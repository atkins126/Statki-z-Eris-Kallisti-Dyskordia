unit Statki;{18.Sty.2017}

  //
  // MIT License
  //
  // Copyright (c) 2017 Jacek Mulawka
  //
  // j.mulawka@interia.pl
  //
  // https://github.com/jacek-mulawka
  //
  //
  // W produkcji.
  //


  // Kierunki współrzędnych układu głównego.
  //
  //     góra y
  //     przód -z
  // lewo -x
  //     tył z
  //

  // Kąty na około statku.
  //
  //   przód
  // lewo
  //
  //     0
  // 90  A -90
  // 180 / -180
  //

  //
  // Hierarchia obiektów (Statki_Form.GLScene1.Objects zmiana na Gra_Obiekty_GLDummyCube)
  //
  // Statki_Form.GLScene1.Objects
  //   Gra_Obiekty_GLDummyCube
  //
  // TStatek.Owner = Gra_Obiekty_GLDummyCube
  //        .Parent = Gra_Obiekty_GLDummyCube
  //   falowanie_dummy, punkty_życia_dummy
  //        .Owner = TStatek
  //        .Parent = TStatek
  //   elementy kadłuba
  //        .Owner = falowanie_dummy
  //        .Parent = falowanie_dummy
  //   TTorpedy_Wyrzutnia.Owner = TStatek
  //                     .Parent = TStatek
  //                     .statek = TStatek
  //                     .elementy_wizualne_dummy.Owner = TTorpedy_Wyrzutnia
  //                     .elementy_wizualne_dummy.Parent = TTorpedy_Wyrzutnia;
  //     TLufa.Owner = TTorpedy_Wyrzutnia
  //          .Parent = TTorpedy_Wyrzutnia.elementy_wizualne_dummy
  //          .działo = TTorpedy_Wyrzutnia
  //          .statek = TStatek
  //          TLufa.Strzał
  //            Amunicja_Wystrzelona_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, TLufa )
  //
  // TAmunicja.Owner = Gra_Obiekty_GLDummyCube - Po uzbrojeniu dla torpedy porusza się w płaszczyźnie poziomej, w pozostałych przypadkach porusza się jak amunicja.
  //          .Parent = TLufa, Gra_Obiekty_GLDummyCube (najpierw jest TLufa a w momencie jej opuszczenia następuje zmiana rodzica na Gra_Obiekty_GLDummyCube)
  //          .statek = TStatek
  //   korpus_opadanie_obrót_dummy.Owner = TAmunicja
  //   korpus_opadanie_obrót_dummy.Parent = TAmunicja
  //   korpus_ustawienie_początkowe_dummy.Owner = korpus_opadanie_obrót_dummy
  //   korpus_ustawienie_początkowe_dummy.Parent = korpus_opadanie_obrót_dummy
  //
  // GLParticleFXRenderer1 - umieszczony na końcu aby elementy gry nie przesłaniały efektów.
  // Informacje_Główne_GLHUDText - umieszczony za GLParticleFXRenderer1 aby efekty nie przesłaniały napisów na ekranie.

  //  Wieloosobowość będzie się opierała chyba na tym, że serwer będzie przeliczał pociski, a klient tylko kopiował obraz.
  //  Serwer otrzyma informację o strzale gracza i ją przetworzy (cel, konfiguracja strzału)
  //  Informacje o ruchu gracza (klawisze ruchu) //???

  // *ślad torpedy na wodzie
  // *falowanie śladu torpedy na wodzie


  // 'Granie' jako obserwator.
  // kolory efektów
  // SI, SI - każde działo osobno celuje
  // tryb obrony twierdzy
  // Jeże głębinowe.
  // lotniskowiec

  // falga, oznaczenie grupy, symbol statku, ukrywnie wskaznika życia dla statku gracza
  // lot pocisków sprawdzić; kilwater, woda
  // ping klientów udp

  // jasna linia na górze amunicaji

  //? kierunek efektu torpedy - chyba działa
  //? współczynnik masy
  //? kulki po bokach do mierzenia kąta obrotu dział
  //? usuwanie elementów z listy efektów wieloosobowych
  //? puchylenie eleentu śrub
  //? wpływ ruchu statku na amunicję
  //? skasowac z listy graczy tcp rozłączonych więcej niż od danego czasu

  // opis do klawiszy (P Alt to jak A + C, czego nie wykrywa)

  // pętle w tworeni definicji lądów, statkó
  // celownik_linia_bez_falowania.Parent := AStatek ma innego rodzica i inaczej kolor wygląda
  // jedna funkcja do zwalnianai statków (wywolania)
  // jedna funkcja do zwalnianai efektów (wywolania)
  // ląd na radarze
  // prędkośc torped rózna, pocisków
  // u klienta - odnowiony statek był przekręcony
  // status statku wyświetlać (wycelowanie)
  // Napis_Odśwież() rysować nie tak często
  // sortowanie listy graczy
  // ląd punkty życia
  // obrót dział - prędkość gry
  // gra_współczynnik_prędkości_c
  // chwilowe psudzie dział steru itp po trafieniu
  // po starcie gry odczekać na od wszystkich graczy Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__udp__klient_połączony_nadal_c, -99, '', true );
  // GLCollisionManager2Collision - usunąć(?)
  // dane z radia o lądzie(?)
  // wysyłanie danych o lądzie i prymitywach przy gotowości serwera (dołączaniu klientów)
  // dźwięki
  // po odłączeniu (wyrzuceniu) gracza usunąć jego statek ?
  // zdarzenia losowe (meteory)

  // Gdyby nie wysyłało upc na sieć to ponoć zamiast Send użyć Brodcast (?).

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, GLObjects, GLScene, GLCoordinates, Vcl.ComCtrls, Vcl.Buttons,
  Vcl.Samples.Spin, Vcl.Grids, Vcl.CheckLst,

  VclTee.TeeGDIPlus, VCLTee.TeEngine, VCLTee.TeeProcs, VCLTee.Chart, VCLTee.Series,

  GLNavigator, GLCadencer, GLCrossPlatform, GLBaseClasses, GLWin32Viewer,
  GLGeomObjects,
  GLKeyboard, GLHUDObjects, GLBitmapFont, GLWindowsFont, GLSkydome, GLVectorGeometry, GLColor, IdContext,

  GLCollision, GLFireFX, GLParticleFX, GLPerlinPFX, GLMaterial, GLSpaceText,

  IdTCPConnection, IdTCPClient, IdBaseComponent, IdComponent, IdCustomTCPServer, IdTCPServer,
  IdSocketHandle, IdUDPClient, IdUDPBase, IdUDPServer,

  System.DateUtils, Math, GLWaterPlane, Vcl.ExtCtrls, IdIOHandler, IdGlobal, Vcl.StdCtrls, Xml.XMLDoc, Xml.XMLIntf,
  pngimage, IdSync, IniFiles;


type
  TAmunicja_Rodzaj = ( ar_Brak, ar_Artyleria, ar_Pocisk, ar_Torpeda, ar_Wszystkie ); // To samo TAmunicja_Rodzaj, Amunicja_Rodzaj_Zbiór_Zwróć().
    TAmunicja_Rodzaj_Zbiór = set of TAmunicja_Rodzaj;
  TCelowanie_Tryb = ( ct_Brak, ct_Linia, ct_Odległość, ct_Punkt );
  TEfekt_Rodzaj = ( er_Brak, er_Trafienie_Ląd, er_Trafienie_Statek, er_Trafienie_Woda );
  TKamera_Tryb = ( kt_Brak, kt_Amunicja, kt_Artyleria, kt_Statek, kt_Swobodna, kt_Statek_Swobodna, kt_Za_Statkiem ); // kt_Statek_Swobodna - jeżeli nie ma statku gracza ustawi kamerę swobodną.
  TStatki_Rozstawianie_Status = ( srs_Brak, srs_Rozstawianie_Kolizja_Sprawdź, srs_Rozstawianie_Kolizja_Wykryta );

  TPokój_Rozmów__Odbiorca_Rodzaj = ( pror_Brak, pror_Gracz_Jeden, pror_Grupa_Jedna, pror_Wszyscy );

  TArtyleria = class;
  TDziało = class;
  TLufa = class;
  TSter = class;
  TŚruba = class;
  TTorpedy_Wyrzutnia = class;


  TWieloosobowe_String = ShortString; //string[ 255 ]; // SizeOf( ShortString ) = 4. // Nie udaje się poprawnie wysyłać i odbierać nieograniczonych napisów (string).

  TTCP_Klient_Dane = class
    // Serwer ma peer_port i identyfikator = -1.
    // Gracze mają identyfikator od 0 narastająco.
    identyfikator, // Nadawany przez serwer gry, rozpoznaje czy to ten sam gracz się podłączył po odłączeniu.
    id_grupa,
    id_statek_schemat,
    peer_port_tcp, // Nadawany przez serwer TCP.
    peer_port_udp // Nadawany przez serwer UDP.
      : integer;
    data_czas__dłączenia,
    data_czas__podłączenia,
    data_czas__podłączenia_ostatniego, // Jeżeli po rozłączeniu znów się połączy.
    data_czas__udp_kontakt
      : TDateTime;
    gotowy,
    odłączony
      : boolean;
    nazwa : TWieloosobowe_String;
  end;//---//TTCP_Klient_Dane

  TTCP_Klienci_Lista = class
  private
    { Private declarations }
    identyfikator_najmniejszy,
    identyfikator_największy
      : integer;
    klienci_lista_list : TList;
  public
    { Public declarations }
    constructor Create();
    destructor Destroy(); override; // Bez override; się nie wywołuje (jedynie tak się wywoła tcp_klienci_lista_g.Destroy()).

    function Dodaj_Aktualizuj( const peer_port_f, identyfikator_f : integer ) : TTCP_Klient_Dane;
    procedure Usuń( const indeks_f : integer );
    procedure Usuń_Identyfikator( const identyfikator_f : integer );
    procedure Usuń_Peer_Port( const peer_port_f : integer );
    procedure Usuń_Wszystkich();

    function Nazwa_Niepowtarzalna( const peer_port_f : integer; const nazwa_f : string ) : boolean; overload;
    function Nazwa_Niepowtarzalna( const nazwa_f : string ) : boolean; overload;
    procedure Odłączony_Peer_Port( const peer_port_f : integer );
    function Znajdź_Identyfikator( const identyfikator_f : integer ) : TTCP_Klient_Dane;
    function Znajdź_Peer_Port( const peer_port_f : integer ) : TTCP_Klient_Dane;
  end;//---//TTCP_Klienci_Lista


  TUDP_Klient_Dane = class
    identyfikator,
    peer_port
      : integer;
    adres_ip
    //komenda //???
      : string;
    data_czas_kontakt_ostatni : TDateTime;
  end;//---//TUDP_Klient_Dane

  TUDP_Klienci_Lista = class
  private
    { Private declarations }
    klienci_lista_list : TList;
  public
    { Public declarations }
    constructor Create();
    destructor Destroy(); override; // Bez override; się nie wywołuje (jedynie tak się wywoła udp_klienci_lista_g.Destroy()).

    procedure Dodaj( const adres_ip_f : string; const peer_port_f : word; const identyfikator_f : integer );
    procedure Usuń( const indeks_f : integer );
    procedure Usuń_Peer_Port( const peer_port_f : integer );
    procedure Usuń_Przeterminowanych();
    procedure Usuń_Wszystkich();
    //procedure Terminy_Sprawdź();
  end;//---//TUDP_Klienci_Lista


  TWieloosobowe_Powiadomienie = class( TIdNotify ) // uses IdSync.
  private
    wyróżnij : boolean; // Czy ma zaznaczyć pojawienie się komunikatu.
    powiadomienie_treść : string;
  protected
    procedure DoNotify(); override;
  end;//---//TWieloosobowe_Powiadomienie


  TWieloosobowe__Wektor_4 = record
    X,
    Y,
    Z,
    W
     : single; // SizeOf( single ) = 4.
    // SizeOf( single ) = 4 * 4 = 16.
  end;//---//TWieloosobowe__Wektor_4


  TObiekty_Wieloosobowe__Lufa_r = record
    lufa_podniesienie_kąt, // Kąt podniesienia lufy.
    lufa_pozycja_z // Dla cofania lufy w wyniku strzału.
      : real; // SizeOf( real ) = 8.

    strzał_gotowość : boolean; // Informacje do wyświetlania dla gracza o jego statku.

    przeładowanie_wskaźnik__kolor,
    przeładowanie_wskaźnik__pozycja
      : TWieloosobowe__Wektor_4; //GLVectorGeometry.TVector
  end;//---//TObiekty_Wieloosobowe__Lufa_r

  TObiekty_Wieloosobowe__Działo_r = record
    obrót_kąt, // Kąt obrotu działa.
    celownik_linia__podniesienie_kąt
      : real; // SizeOf( real ) = 8.

    celownik_linia__szerokość : single;

    celownik_linia__wzór : word; // SizeOf( word ) = 2.

    //lufa_podniesienie_kąt_t__długość_tabeli : integer;

    //lufa_podniesienie_kąt_t // Aktualny kąt podniesienia lufy.
    //  : array of real; // SizeOf( Pointer ) = 4.

    amunicja_ilość, // Informacje do wyświetlania dla gracza o jego statku.
    obiekty_wieloosobowe_lufa_r_t__długość_tabeli
      : integer; // SizeOf( integer ) = 4.

    czy_lot_parabolą : boolean;

    celownik_linia__kolor : TWieloosobowe__Wektor_4; //GLVectorGeometry.TVector

    obiekty_wieloosobowe_lufa_r_t
      : array of TObiekty_Wieloosobowe__Lufa_r; // SizeOf( Pointer ) = 4.
  end;//---//TObiekty_Wieloosobowe__Działo_r

  TObiekty_Wieloosobowe__Amunicja_r = record
    id_statek : integer;
    id_wieloosobowe_amunicja : Int64;

    czy_lot_parabolą,
    czy_poza_lufą,
    przeliczone // Czy dane o tej amunicji zostały już przeliczone.
      : boolean;

    kierunek,
    pozycja,
    pozycja_celu
      : GLVectorGeometry.TVector;

    korpus__Height,
    torpeda_efekt_na_wodzie_stan // Czy widoczny jest już efekt na wodzie ( 0 - efekt jeszcze nie był widoczny, 1 - efekt widoczny, 2 - efektu już nie widać).
      : Single;

    turn_angle,
    pitch_angle,

    korpus__TopRadius,
    korpus__BottomRadius
      : real;

    amunicja_rodzaj : TAmunicja_Rodzaj;
  end;//---//TObiekty_Wieloosobowe__Amunicja_r

  TObiekty_Wieloosobowe__Efekt_r = record
    id_statek : integer;
    wysłane : boolean;
    pozycja : GLVectorGeometry.TVector;
    czas_trwania,
    czas_trwania_efekt_dodatkowy
      : Int64;
    amunicja_rodzaj : TAmunicja_Rodzaj;
    efekt_rodzaj : TEfekt_Rodzaj;
    // siła obrażeń //???
  end;//---//TObiekty_Wieloosobowe__Efekt_r

  TObiekty_Wieloosobowe__Statek_r = record
    id_grupa,
    id_statek,
    id_statek_schemat,
    artyleria_t__długość_tabeli,
    działa_t__długość_tabeli,
    torpedy_wyrzutnie_t__długość_tabeli,
    artyleria_wygląd_t__długość_tabeli,
    działa_wygląd_t__długość_tabeli,
    torpedy_wyrzutnie_wygląd_t__długość_tabeli,
    śruba_obrót_kąt__długość
      : integer; // SizeOf( integer ) = 4.

    falowanie_bok_skręt, // Ilość stopni wychylenia w bok z powodu skręt (aktualnego).
    prędkość_procent, // Informacje do wyświetlania dla gracza o jego statku.
    prędkość_zadana_procent, // Informacje do wyświetlania dla gracza o jego statku.
    punkty_życia,
    punkty_życia_maksymalne,
    punkty_życia_procent_zostało,
    skręt_procent, // Informacje do wyświetlania dla gracza o jego statku.
    skręt_zadany_procent, // Informacje do wyświetlania dla gracza o jego statku.
    ster_kąt, // Kąt wychylenia steru.
    tonięcie__przechylenie__lewo_prawo, // Dla animacji tonięcia statku.
    tonięcie__przechylenie__przód_tył // Dla animacji tonięcia statku.
      : real; // SizeOf( real ) = 8.

    czy_wszystkie_lufy,
    obracaj_działa,
    podnoś_lufy,
    przeliczone // Czy dane o tym statku zostały już przeliczone.
      : boolean; // SizeOf( boolean ) = 1.

    gracz__nazwa : TWieloosobowe_String;

    cel_współrzędne,
    kierunek,
    pozycja
      : TWieloosobowe__Wektor_4; //GLVectorGeometry.TVector

    amunicja_rodzaj : TAmunicja_Rodzaj; // SizeOf( TAmunicja_Rodzaj ) = 1 ale SizeOf( SmallInt ) = 2. // To chyba też się traktuje jako - SizeOf( Pointer ) = 4.

    śruba_obrót_kąt // Aktualny kąt obrotu śruby (daje efekt obracania śrubą).
      : array of real; // SizeOf( Pointer ) = 4.

    artyleria_t,
    działa_t,
    torpedy_wyrzutnie_t,
    artyleria_wygląd_t, // Może tylko wygląd wysyłać.
    działa_wygląd_t,
    torpedy_wyrzutnie_wygląd_t
      : array of TObiekty_Wieloosobowe__Działo_r; // SizeOf( Pointer ) = 4.

    radar_id_statki_w_zasięgu,
    radio_id_statki_w_zasięgu
      : TWieloosobowe_String;
  end;//---//TObiekty_Wieloosobowe__Statek_r

  TObiekty_Wieloosobowe__Statek_Klawisze_Obsługa_r = record
    id_statek
    //cel_współrzędne__x,
    //cel_współrzędne__y,
    //cel_współrzędne__z
      : integer;
    klawisz : Word;
    shift : TShiftState; // Wygląda na to, że poprawnie przesyła ten zbiór wartości.
    mysz_przycisk : SmallInt; // Nie TMouseButton, gdyż w tym zbiorze nie ma stanu ‘brak’ (none).
    ar_artyleria,
    ar_pocisk,
    ar_torpeda,
    ar_wszystkie
      : boolean;
    cel_współrzędne : GLVectorGeometry.TVector;
    polecenie_nazwa : TWieloosobowe_String;
  end;//---//TObiekty_Wieloosobowe__Statek_Klawisze_Obsługa_r


  TPokój_Rozmów_r = record
    id_nadawca,
    id_odbiorca
    //wiadomość__długość
      : integer;
    odbiorca_rodzaj : TPokój_Rozmów__Odbiorca_Rodzaj;
    data_czas_wysłania : TDateTime;
    wiadomość : TWieloosobowe_String; //ShortString
    //wiadomość : string;
    // Nie chce mi to działać.
    // Strumień się zapisuje i odczytuje poprawnie ale podczas odczytu po wysłaniu rekord, do którego wpisywane są dane psuje się
    // (zostaje określony w debugerze jako niedostępna wartość [inaccessible value], a program podczas działania zgłasza błąd [access violation]).
  end;//---//TPokój_Rozmów_r

  TPokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj = class
    id_odbiorca : integer;
    odbiorca_rodzaj : TPokój_Rozmów__Odbiorca_Rodzaj;
  end;//---//TPokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj_

  TPokój_Rozmów_Powiadomienie = class( TIdNotify ) // uses IdSync.
  private
    pokój_rozmów_r : TPokój_Rozmów_r;
  protected
    procedure DoNotify(); override;
  end;//---//TPokój_Rozmów_Powiadomienie


  TKomunikacja_Rekord_Testowy_r = record
    liczba_całkowita : integer;
    liczba_rzeczywista : real;
    data_czas : TDateTime;
    napis_krótki : TWieloosobowe_String; //ShortString
  end;//---//TKomunikacja_Rekord_Testowy_r

  TKomunikacja_Rekord_Testowy_2_r = record
    liczba_całkowita : integer;
    liczba_rzeczywista : real;
    data_czas : TDateTime;
    napis : string;
  end;//---//TKomunikacja_Rekord_Testowy_2_r


  TSchematy_Lista_r = record
    id,
    nazwa,
    opis,
    plik_nazwa,
    treść
      : string; // string TWieloosobowe_String; //ShortString
  end;//---//TSchematy_Lista_r

  TSchematy_Lista_r_t = array of TSchematy_Lista_r;


  TPozycja_Początkowa_Parametry_r = record
    korekta_obrót,
    korekta_x,
    korekta_z,
    odstęp_x,
    z
     : integer;
  end;//---//TPozycja_Początkowa_Parametry_r

  TWygląd_Kolor_Definicja_r = record
    kolor_vector : GLVectorGeometry.TVector;
    kolor_definicja_nazwa : string;
  end;//---//TWygląd_Kolor_Definicja_r

  TKlawiatura_Konfiguracja_r = record
    klawisz : word;
    czy_mysz,
    mysz_niezdefiniowana,
    plus_alt,
    plus_ctrl,
    plus_shift
      : boolean;
    polecenie_nazwa : string;
  end;//---//TKlawiatura_Konfiguracja_r

  TStatek = class( TGLDummyCube )
  private
    { Private declarations }
    falowanie_bok_skręt, // Ilość stopni wychylenia w bok z powodu skrętu (aktualnego).
    falowanie_bok_skręt_zakres, // Zakres maksymalny wychylenia z powodu skrętu (aktualnego).
    falowanie_bok_zakres, // Ilość stopni wychylenia w jeden bok z powodu falowania.
    falowanie_bok_wychylenie_aktualne, // Zakres wychylenia w bok wyrażany w stopniach od 0 do 360 dla funkcji sinus.

    falowanie_góra_dół_zakres, // Wysokość unoszenia (i obniżania) z powodu falowania.
    falowanie_góra_dół_wysokość_aktualna, // Zakres unoszenia (i obniżania) z powodu falowania wyrażany w stopniach od 0 do 360 dla funkcji sinus.

    falowanie_przód_ruch, // Ilość stopni wychylenia w przód z powodu prędkości ruchu (aktualnego).
    falowanie_przód_zakres, // Ilość stopni wychylenia w przód z powodu falowania.
    falowanie_przód_wychylenie_aktualne, // Zakres wychylenia w przód wyrażany w stopniach od 0 do 360 dla funkcji sinus.

    prędkość_aktualna, // Aktualna prędkość statku (wynika z prędkość_współczynnik * prędkość_procent).
    prędkość_maksymalna, // Jak szybko płynie.
    prędkość_obrotu_aktualna, // Aktualna prędkość obrotu statku.
    prędkość_ograniczenie, // Do jakiej wartości procentowej może zmieniać się prędkość statku podczas kolizji (np. tryb gry, w którym elementy otoczenia przyśpieszają statek). Do 2`500.
    prędkość_procent, // Aktualny procent prędkości (od -100 do 100).
    prędkość_przyspieszanie, // Jak szybko silnik modyfikuje prędkość.    
    prędkość_zadana_procent, // Zadany procent prędkości (od -100 do 100).
    prędkość_zwalnianie, // Jak szybko statek (sam) zwalnia.
    prędkość__kolizja_zwalnianie, // Jak szybko statek zwalnia w wyniku kolizji; 1 - neutralna wartość, 0 - 1 spowalnia 1 - 3 odbija (im większa wartość tym mocniej odbija).

    skręt_kąt_maksymalny,
    skręt_procent, // Aktualny procent skrętu (od -100 do 100).
    skręt_szybkość_wychylania_steru, // Jak szybko się zmienia.
    skręt_prędkość, // Jak szybko skręca (zwrotność).
    skręt_współczynnik_do_prędkości, // Do jakiego procentu osiągniętej prędkości spowalnia skręcanie. Jeżeli wolno płynie to słabiej skręca np. dla parametru o wartości 25 dopiero gdy statek osiągnie prędkość 25% będzie skręcał z pełną wydajnością, przy mniejszej prędkości (rozpędzanie się) wydajność skrętu będzie słabsza.
    skręt_zadany_procent, // Zadany procent skrętu (od -100 do 100).

    tonięcie__obrót__lewo_prawo, // Jak szybko unoszą / obniżają się boki statku.
    tonięcie__obrót__przód_tył, // Jak szybko unosi / obniża się dziób / rufa.
    tonięcie__prędkość_w_dół, // Jak szybko statek się zanurza.

    punkty_życia, // Aktualna ilość punktów życia.
    punkty_życia_maksymalne, // Łączna ilość punktów życia (tyle ma punktów jeżeli nie został uszkodzony).
    punkty_życia_procent_zostało // Aktualna procentowa ilość punktów życia.
      : real;

    id_grupa,
    id_statek, // Jest taki sam jak identyfikator gracza.
    id_statek_schemat, // Indeks schematu wyglądu statku.
    artyleria_ostatni_strzał_indeks, // Indeks artylerii, która ostatnio wystrzeliła.
    działo_ostatni_strzał_indeks, // Indeks działa, które ostatnio wystrzeliło.
    torpedy_wyrzutnia_ostatni_strzał_indeks, // Indeks wyrzutni torped, która ostatnio wystrzeliła.

    falowanie_opóźnienie, // Aby falowanie statków było asynchroniczne będzie się rozpoczynać z różnym opóźnieniem.

    kamera_odległość_maksymalna, // Maksymalna odległość kamery od statku.
    luneta_zasięg, // Maksymalny zasięg przybliżenia.
    radar_zasięg, // Maksymalny zasięg radaru.
    radio_zasięg // Maksymalny zasięg radia.
      : integer;

    tonięcie__czas_i // Czas, w którym rozpoczęło się tonięcie.
      : int64;

    broń_indeks_zmieniaj, // Po strzale nie przechodzi na kolejną broń z danej kategorii (rodzaju) tylko ciągle próbuje strzelać tą sama bronią (tym samym działem).
    obracaj_działa,
    obrót_kąt_zablokowany_wskaźnik_widoczne, // Aby przy wywoływaniu funkcji dostosowującej elementy gracza nie przechodził przez pętle broni gdy nic się nie zmieniło w tym zakresie ustawień.
    obrót_kąt_zablokowany_strzał_wskaźnik_widoczne, // Aby przy wywoływaniu funkcji dostosowującej elementy gracza nie przechodził przez pętle broni gdy nic się nie zmieniło w tym zakresie ustawień.
    podnoś_lufy,
    czy_usunąć //???
      : boolean;

    kamera_na_statek_pozycja, // W którym miejscu ma się ustawić kamera po ustawieniu widoku ze statku.
    kamera_za_statkiem_pozycja // Przesunięcie kamery po ustawieniu widoku za statkiem.
      : TWieloosobowe__Wektor_4;

    statki_rozstawianie_status : TStatki_Rozstawianie_Status; // Aby nie wykrywał kolizji ze statkami, które są w trakcie rozstawiania.

    wygląd_elementy_list : TList; // Lista elementów wyglądu statku.

    kolizja_oznaczenie_string_list : TStringList;

    falowanie_dummy, // Dla falowania i przechyłów aby nie zakłócać ruchu statku.
    punkty_życia_dummy, // Kontener na wskaźnik punktów życia.
    punkty_życia_podniesienie // Aby przechylać góra dół wskaźnik życia do kamery. //???
      : TGLDummyCube;

    dziób,
    kadłub,
    punkty_życia__ramka
      : TGLCube;

    punkty_życia__wskaźnik
      : TGLCylinder;

    gracz__nazwa,
    punkty_życia__napis
      : TGLSpaceText; // uses GLSpaceText.

    artyleria_t,
    artyleria_wygląd_t // Falowanie zakłóca algorytm celowania więc działa do strzelania nie będą falować a te nie będą strzelać tylko będą ładnie wyglądać.
      : array of TArtyleria;
    działa_t,
    działa_wygląd_t
      : array of TDziało;
    torpedy_wyrzutnie_t,
    torpedy_wyrzutnie_wygląd_t
      : array of TTorpedy_Wyrzutnia;

    ster_t : array of TSter;
    śruby_t : array of TŚruba;

    celownicza_linia : TGLLines;

    radar_id_statki_w_zasięgu, // Statki w zasięgu radaru. '-99, -99' - gdy brak, '-99, 1, 2, 3, -99'.
    radio_id_statki_w_zasięgu // Statki w zasięgu radia. '-99, -99' - gdy brak, '-99, 1, 2, 3, -99'.
      : TWieloosobowe_String;
  public
    { Public declarations }
    constructor Create( AOwner : TGLBaseSceneObject; gl_collision_mmanager_f : TGLCollisionManager; const id_statek_f : integer; const wygląd_definicja_f : string; const prymitywy_lista_f : TSchematy_Lista_r_t );
    destructor Destroy(); override;

    function Kąt_Obrotu_Statku() : real;

    procedure Prędkość_Zadana_Procent_Zmień( const zmień_o_f : integer );
    procedure Skręt_Zadany_Procent_Zmień( const zmień_o_f : integer );

    procedure Prędkość_Procent_Zmień();
    procedure Skręt_Procent_Zmień();

    procedure Broń_Indeks_Zmieniaj_Ustaw( const amunicja_rodzaj_zbiór_f : TAmunicja_Rodzaj_Zbiór ); overload;
    procedure Broń_Indeks_Zmieniaj_Ustaw( const czy_poprzednia_f : boolean; const amunicja_rodzaj_zbiór_f : TAmunicja_Rodzaj_Zbiór ); overload;

    function Strzał( const amunicja_rodzaj_zbiór_f : TAmunicja_Rodzaj_Zbiór; const czy_wszystkie_bronie_f, czy_wszystkie_lufy_f, obracaj_działa_f, podnoś_lufy_f : boolean; const cel_współrzędne_f : TAffineVector ) : boolean;

    procedure Elementy_Gracza_Dostosuj( const id_grupa_gracza_f : integer; const punkty_życia_wskaźnik_widoczne__gracz_f, punkty_życia_wskaźnik_widoczne__przeciwnik_f, punkty_życia_wskaźnik_widoczne__sojusznik_f, obrót_kąt_zablokowany_wskaźnik_widoczne_f, obrót_kąt_zablokowany_strzał_wskaźnik_widoczne_f : boolean );
    procedure Elementy_Gracza_Widoczność( const id_grupa_gracza_f : integer; const widoczne_f : boolean );

    procedure Punkty_Życia_Zmień( const wartość_f : real );
    procedure Punkty_Życia_Wskaźnik_Rysuj( const gl_camera_f : TGLCamera; const wartość_liczbowa_f : integer );

    function Parametry_Odczytaj( const dane_wszystkie_f : boolean = false ) : string;
  end;//---//TStatek

  TLufa = class( TGLDummyCube )
  private
    { Private declarations }    
    przeładowanie_czas_milisekundy : integer;
    //strzał_czas : TDateTime;
    strzał_czas_i : int64; // Czas wystrzelenia (do liczenia okresu przeładowania).
    amunicja_pobrana,
    strzał_gotowość, // Czy jest przeładowana.
    czy_indeks_do_strzału_lufa, // Oznacza, że ta lufa jest aktualnie ustawione do strzałów pojedynczych.
    czy_wycelowane_podniesienie // Czy osiągnięto zadany kierunek celowania podniesienia.
      : boolean;

    działo : TTorpedy_Wyrzutnia;

    amunicja_rodzaj : TAmunicja_Rodzaj; // Rodzaj amunicji działa.

    statek : TStatek; // Statek, na którym umiejscowiony jest obiekt (może być potomkiem innego obiektu ale w ramach tego statku).

    podniesienie_szybkość_modyfikator, // Aby lufy podnosiły się z różnymi prędkościami.
    przeładowanie_wskaźnik__dystans_do_przesunięcia,
    przeładowanie_wskaźnik__pozycja_wycelowany_Y // Domyślna wysokość wskaźnika przeładowania (jeżeli lufa nie osiągnie wymaganego do strzału kątu to wskaźnik się obniży).
      : real;
    przeładowanie_wskaźnik__pozycja_rozładowany,
    przeładowanie_wskaźnik__pozycja_załadowany
      : TAffineVector;

    korpus : TGLCylinder;

    przeładowanie_wskaźnik,
    wylot_pozycja
      : TGLSphere;
  public
    { Public declarations }
    constructor Create( ATorpedy_Wyrzutnia : TTorpedy_Wyrzutnia; AStatek : TStatek; gl_collision_mmanager_f : TGLCollisionManager ); // TGLSceneObject
    destructor Destroy(); override;

    procedure Dodatkowe_Elementy_Lufy_Pozycja_Ustaw();
    procedure Przeładowanie( delta_czasu_f : double );
    function Strzał( const obracaj_działa_f, podnoś_lufy_f : boolean; const cel_współrzędne_f : TAffineVector ) : boolean; // obracaj_działa_f
  end;//---//TLufa

  TTorpedy_Wyrzutnia = class( TGLDummyCube )
  private
    { Private declarations }
    obrót_kierunek_zadany : GLVectorGeometry.TVector; // uses GLVectorGeometry. //TGLCoordinates;

    obrót_kąt_zadany,
    obrót_kąt_zadany_bezwzględny, // Zadany kąt obrotu z pominięciem wszelkich zablokowanych zakresów.

    // Przez ten kąt nie można obracać.
    // Opis jest analogiczny jak dla obrót_kąt_zablokowany_strzał_do, obrót_kąt_zablokowany_strzał_od.
    // Gdy obie wartości są sobie równe kąt zablokowany jest nieaktywny (nie ma kąta zablokowanego).
    obrót_kąt_zablokowany_do, // 120, -50
    obrót_kąt_zablokowany_od, // 50, -120

    obrót_szybkość, // Jak szybko się zmienia.

    celownik_linia_szerokość_obrót, // Jaka szerokość linii celowania została ustalona na podstawie wycelowania obrotu broni.
    skala, // Wielkość działa.
    obrażenia_zadawane,
    zasięg
      : real;

    //indeks_w_tabeli,
    amunicja_ilość,
    lufa_ostatni_strzał_indeks, // Indeks lufy, która ostatnio wystrzeliła.    
    przeładowanie_czas_milisekundy, // Powinien być większy równy strzał_od_blokada_milisekundy, gdyż po strzale, gdy ma zadany inny kąt obrotu ale nie może się jeszcze obracać, po przeładowaniu strzela i nadal blokuje obrót (obrót jest ciągle zablokowany i strzela w dawnym kierunku).
    strzały_ilość // Ilość oddanych strzałów, zeruje się gdy ilość strzałów równa się ilości luf.
      : integer;

    czy_indeks_do_strzału, // Oznacza, że to działo jest aktualnie ustawione do strzałów pojedynczych.
    //czy_lufa_podnoszona, // Czy lufa rusza się góra dół. // Nie wiem czy dobrze rozpoznaje jakiej klasy jest działo.
    czy_wycelowany_obrót, // Czy osiągnięto zadany kierunek celowania obrótu.
    czy_usunąć //???
      : boolean;

    //strzał_czas : TDateTime;
    strzał_czas_i, // Czas ostatniego wystrzału.
    strzał_od_blokada_milisekundy // Ile milisekund od wystrzału blokuje ruch działa.
      : int64;

    // Wewnątrz tych kątów nie można strzelać.
    // Obie tabela mają taki sam wymiar.
    // Patrząc od tyłu w przód statku kąt (TurnAngle) wynosi 0, po lewej stronie jest dodatni, po prawej stronie jest ujemny, patrząc w tył wynosi 180.
    // Zgodnie z ruchem wskazówek zegara obrót_kąt_zablokowany_strzał_od ma być przed obrót_kąt_zablokowany_strzał_do.
    // Jeżeli zakres zablokowanego kąta przechodzi przez środek rufy obrót_kąt_zablokowany_strzał_od jest ujemny, a obrót_kąt_zablokowany_strzał_do jest dodatni.
    obrót_kąt_zablokowany_strzał_do, // -90, 170
    obrót_kąt_zablokowany_strzał_od // 50, -170
      : array of real;

    amunicja_rodzaj : TAmunicja_Rodzaj; // Rodzaj amunicji działa.

    statek : TStatek; // Statek, na którym umiejscowiony jest obiekt (może być potomkiem innego obiektu ale w ramach tego statku).

    elementy_wizualne_dummy, // Kontener na elementy wizualne działa.
    kąt_test
      : TGLDummyCube;

    korpus_przód,
    podstawa
      : TGLCylinder;
    korpus
      : TGLCube;
    lufy_t : array of TLufa;
    celownik_linia,
    celownik_linia_bez_falowania // Dla dużych zasięgów koniec linii ruchomej w sporym zakresie faluje i może go być nie widać oraz trudno określić zasięg.
      : TGLLines;

    obrót_kąt_zablokowany_GLDisk : TGLDisk; // Wizualizuje obszar zablokowanego kąta obrotu.
    obrót_kąt_zablokowany_strzał_GLDisk_t : array of TGLDisk; // Wizualizuje obszar zablokowanego kąta obrotu.

    działo_strzelające : TTorpedy_Wyrzutnia; // Jeżeli obiekt jest działem ładnie wyglądającym to to wskazuje na działo strzelające, którego wygląd ma odwzorowywać.
  public
    { Public declarations }
    constructor Create( AOwner : TGLBaseSceneObject; AStatek : TStatek; gl_collision_mmanager_f : TGLCollisionManager; const lufy_ilość_f : integer );
    destructor Destroy(); override;

    procedure Dodatkowe_Elementy_Ustaw();
    procedure Parametry_Kopiuj_Dla_Wygląd( const ATorpedy_Wyrzutnia : TTorpedy_Wyrzutnia );
    procedure Parametry_Aktualizuj_Dla_Wyglądu();

    function Obrót_Kąt_Zablokowany_Sprawdź( kąt_f : real ) : boolean;
    procedure Obrót_Zadany_Zmień( const celownik_linia_widoczność_f : boolean = true );
    procedure Obrót_Kierunek_Zmień( const celowanie_precyzja_obrót_f : real; const broń_nie_unosi_luf_f : boolean = false );

    function Strzał( const czy_wszystkie_lufy_f, obracaj_działa_f, podnoś_lufy_f : boolean; var wystrzeliły_wszystkie_f : boolean; const cel_współrzędne_f : TAffineVector  ) : boolean;
    function Obrót_Kąt_Zablokowany_Strzału_Sprawdź() : boolean; overload;
    function Obrót_Kąt_Zablokowany_Strzału_Sprawdź( kąt_f : real; const indeks_f : integer ) : boolean; overload;

    procedure Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( const celownik_linia_widoczność_f : boolean = true );

    function Parametry_Odczytaj( const odstęp_f : string; const dane_wszystkie_f : boolean = false ) : string;
  end;//---//TTorpedy_Wyrzutnia

  TDziało = class( TTorpedy_Wyrzutnia )
  private
    { Private declarations }
    cofanie_wystrzał_odległość,
    cofanie_wystrzał_pozycja_początkowa,

    podniesienie_kąt_maksymalny,
    podniesienie_kąt_minimalny,
    podniesienie_kąt_zadany, // Zadany kąt podniesienia.
    podniesienie_kąt_zadany_bezwzględny, // Zadany kąt podniesienia nie ograniczany zakresem kąta maksymalnym i minimalnym.
    podniesienie_szybkość // Jak szybko się zmienia.
      : real;

    czy_lot_parabolą : boolean; // Pocisk leci po paraboli a nie według swojego kierunku.

    korpus_przód : TGLCube;
  public
    { Public declarations }
    constructor Create( AOwner : TGLBaseSceneObject; AStatek : TStatek; gl_collision_mmanager_f : TGLCollisionManager; const lufy_ilość_f : integer; const lufy_podniesienie_kąt_f : real );
    destructor Destroy(); override;

    procedure Podniesienie_Zadane_Zmień( const celownik_linia_widoczność_f : boolean = true );
    procedure Podniesienie_Kierunek_Zmień( const celowanie_precyzja_podniesienie_f : real );

    procedure Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( const celownik_linia_widoczność_f : boolean = true );

    function Parametry_Odczytaj( const odstęp_f : string; const dane_wszystkie_f : boolean = false ) : string;
  end;//---//TDziało

  TArtyleria = class( TDziało )
  private
    { Private declarations }
    zasięg_od_parabola // Zasięg, od którego celowanie nie odbywa się w punkt tylko poprzez podniesienie lufy.
      : real;
    function Parametry_Odczytaj( const odstęp_f : string; const dane_wszystkie_f : boolean = false ) : string;  
  public
    { Public declarations }
    constructor Create( AOwner : TGLBaseSceneObject; AStatek : TStatek; gl_collision_mmanager_f : TGLCollisionManager; const lufy_ilość_f : integer; const lufy_podniesienie_kąt_f : real );
  end;//---//TArtyleria

  TAmunicja = class( TGLDummyCube )
  private
    { Private declarations }
    id_statek : integer; // Jest taki sam jak identyfikator gracza.
    id_amunicja : cardinal;

    cel_odległość, // Odległość od lufy do celu (przy zablokowanym podnoszeniu luf jest liczony według procentu uniesienia lufy i zasięgu działa).
    //działo_podniesienie_kąt_maksymalny, // Wysokość i obrót dla ruchu parabolą - wersja 2.
    działo_podniesienie_procent_kąta_maksymalnego, // Jaki procent z maksymalnego uniesienia luf miało ustawione działo podczas strzelania.
    obrażenia_zadawane,
    obrażenia_zadawane_współczynnik, // Modyfikuje obrażenia zadawane poza skutecznym zasięgiem (wartość aktualna).
    obrażenia_zadawane_współczynnik_zmodyfikowany, // Modyfikuje obrażenia zadawane poza skutecznym zasięgiem.
    opadanie_obrót_korekta_o_kąt_na_granicy_zasięgu, // Koryguje obracanie amunicji o wartość kąta w momencie wykraczania poza zasięg aby podczas opadania obracała się do pozycji pionowo w dół.
    opadanie_obrót_korekta_o_ustawienie_początkowe, // Koryguje obracanie amunicji o początkowy kąt lotu aby podczas opadania obracała się do pozycji pionowo w dół.
    //parabola_kąt_lotu_początkowy, // Wysokość i obrót dla ruchu parabolą - wersja 1.
    //parabola_kąt_lotu_współczynnik, // Podczas strzału ma kąt lufy i wraz z dystansem będzie się zmieniać o ten współczynnik tak aby przy celu kąt był 80 stopni (w dół są stopnie dodatnie).  // Wysokość i obrót dla ruchu parabolą - wersja 1.
    //parabola_równanie__a, // Parametry równania paraboli w postaci y = a * x^2 + b * x + c
    //parabola_równanie__b,
    //parabola_równanie__c,
    prędkość,
    prędkość_opadania,
    prędkość_opadania_współczynnik, // Jak szybko przyrasta prędkość opadania.
    prędkość_początkowa,
    prędkość_wytracanie_współczynnik, // Jak szybko wytraca prędkość poza zasięgiem skutecznym.
    skala, // Działo może być skalowane. Utworzony pocisk jako potomek działa przejmuje skalowanie działa ale następnie staje się potomkiem sceny i skala działa przestaje dotyczyć pocisku a powinna być zachowana.
    strzał_od_blokada_dystans, // W jakiej odległości od wystrzału (lufy) przesuwa i obraca amunicję razem ze statkiem.
    statek_prędkość, // Prędkość statku w momencie strzału, po opuszczeniu lufy jest zmniejszana do zera.
    zanurzenie_głębokość_po_wpadnięciu_do_wody, // Do jakiej głębokości się zanurzy po wpadnięciu do wody.
    zanurzenie_głębokość_zadana, // Na jakiej głębokości ma płynąć.
    zasięg // Zasięg amunicji (może być trochę dłuższy od wyświetlanej linii gdyż jest liczony od końca lufy a nie od środka działa).
      : real;

    czy_efekt_wpadnięcia_do_wody, // Czy wyświetlono efekt (pierwszego) wpadnięcia do wody.
    czy_lot_parabolą, // Pocisk leci po paraboli a nie według swojego kierunku.
    czy_pod_wodą, // Znajduje się poniżej linii wody (ustawiane na true przy pierwszym wpadnięciu do wody).
    czy_poza_lufą, // Amunicja opuściła lufę (aby detekcja kolizji nie wykrywała kontaktu z lufą).
    czy_poza_zasięgiem, // Jeżeli w wyniku opadania amunicja znajdzie się znów w zasięgu ma być nadal traktowana jako poza zasięgiem.
    //czy_statek_dane, // Czy odczytano dane ze statku, z którego wystrzelono amunicję.
    czy_usunąć,
    czy_uzbrojona,
    czy_wynurzanie // Po odpaleniu zanurzy się pod wodę i wypłynie na powierzchnię.
      : boolean;

    amunicja_rodzaj : TAmunicja_Rodzaj; // Rodzaj amunicji działa.

    działo_pozycja_absolutna_vector : GLVectorGeometry.TVector;

    // TAmunicja TGLDummyCube -  porusza się w linii strzału (tylko w przód, nie obraca się, nie obniża ani nie wznosi; jedynie jeżeli wynika to ze skośnego tor lotu - wznoszącego lub opadającego).
    //                             Dla torped przesuwa się w linii wody.
    korpus_opadanie_obrót_dummy, // Dla obrotu opadania (góra dół).
    korpus_ustawienie_początkowe_dummy, // Zapamiętuje jak początkowo była ustawiona amunicja (wychylenia).
    torpeda_efekt_na_wodzie // Aby torpeda była widoczna na powierzchni wody.
      : TGLDummyCube;

    korpus : TGLCylinder;
    czubek :  TGLCone;

    pozycja_celu, // Istotne dla lotu parabolą, wyliczane na podstawie zasięgu i procentu uniesienia luf względem maksymalnego uniesienia luf.
    pozycja_startowa, // Dla lotu parabolą jest od pozycji działa, dla lotu zwykłego od końca lufy.
    pozycja_woda // Odwzorowanie pozycji amunicji na powierzchni (mniej więcej) wody, wysokości działa.
      : TGLSphere;

    statek : TStatek; // Statek, z którego wystrzelono amunicję.
  public
    { Public declarations }
    constructor Create( AOwner : TGLBaseSceneObject; ALufa : TLufa; const obracaj_działa_f : boolean; cel_współrzędne_f : TAffineVector; gl_collision_mmanager_f : TGLCollisionManager ); overload;
    //constructor Create( AAmunicja : TAmunicja ); overload; //Konstruktor kopiujący klasy TAmunicja.
    constructor Create( AObiekty_Wieloosobowe_Amunicja_r : TObiekty_Wieloosobowe__Amunicja_r; AOwner : TGLBaseSceneObject ); overload;
    destructor Destroy(); override;
  end;//---//TAmunicja

  TSter = class( TGLDummyCube )
  private
    { Private declarations }
    ster : TGLCube;
    ster_mocowanie : TGLCylinder;
  public
    { Public declarations }
    constructor Create( AOwner : TGLBaseSceneObject; gl_collision_mmanager_f : TGLCollisionManager; x_f, y_f, z_f : real );
    destructor Destroy(); override;
  end;//---//TSter

  TŚruba = class( TGLDummyCube )
  private
    { Private declarations }
    prędkość_obrotowa_aktualna_procent,
    prędkość_obrotowa_maksymalna, // Całkiem dobrze wychodzi gdy [śruba] prędkość_obrotowa_maksymalna / prędkość_obrotowa_przyspieszanie = [statek] prędkość_maksymalna / prędkość_przyspieszanie.
    prędkość_obrotowa_przyspieszanie // Jak szybko śruba modyfikuje prędkość obrotów.
      : real;

    czy_obrót_lewo, // Śruba obraca się w lewo (góra śruby patrząc od tyłu statku).
    czy_usunąć //???
      : boolean;

    obrót_dummy : TGLDummyCube;

    wał,
    wał_łożysko, // Łączy podpórkę z wałem.
    wał_mocowanie, // Przez nie wychodzi wał z kadłuba.
    wał_podpórka, // Podpórka przed śrubą.
    wał_do_wirnika // Z łożyska do wirnika.
      : TGLCylinder;

    wirnik_środek : TGLSphere;

    wirnik_łopaty_t : array of TGLCone;

    statek : TStatek; //??? // Statek, z którego wystrzelono amunicję.

  public
    { Public declarations }
    constructor Create( AOwner : TGLBaseSceneObject; AStatek : TStatek; const czy_obrót_lewo_f : boolean; gl_collision_mmanager_f : TGLCollisionManager );
    destructor Destroy(); override;

    procedure Śruba_Obracaj();
  end;//---//TŚruba

  TTrafienia_Efekt = class( TGLDummyCube )
  private
    { Private declarations }
    czas_trwania, // Ile milisekund efekt trwa (widać go).
    czas_utworzenia // Czas utworzenia efektu (od niego odmierza się czas trwania).
      : Int64;
  public
    { Public declarations }
    constructor Create( AOwner : TGLBaseSceneObject; x_f, y_f, z_f : real );
    destructor Destroy(); override;
  end;//---//TTrafienia_Efekt

  TInformacje_Dodatkowe = class
    wyświetlanie_czas_sekund : smallint;
    utworzenie_data_czas : TDateTime;
    napis : string;
  public
    constructor Create( const napis_f : string = '' ); overload;
    constructor Create( const napis_f : string; const wyświetlanie_czas_sekund_f : smallint ); overload;
  end;//---//TInformacje_Dodatkowe

  TKlawisz_Konfiguracja = class( TPanel )
  private
    klawiatura_konfiguracja_r_w : ^TKlawiatura_Konfiguracja_r;
    domyślna_konfiguracja_r : TKlawiatura_Konfiguracja_r;
    Polecenie_Nazwa_Label : TLabel;
    Klawisz_Edit : TEdit;
    Domyślny_Button,
    Niezdefiniowane_Button
      : TButton;
    Czy_Mysz_CheckBox,
    Plus_Alt_CheckBox,
    Plus_Ctrl_CheckBox,
    Plus_Shift_CheckBox
      : TCheckBox;
  public
    constructor Create( AOwner : TComponent; pointer_f : Pointer );
    destructor Destroy(); override; // Bez override; się nie wywołuje (jedynie tak się wywoła wygląd_kolor_definicja.Destroy()).
  private
    function Nazwa_Klawisza() : string;
    procedure Check_Box_Click( Sender : TObject );
    procedure Edit_Exit( Sender : TObject );
    procedure Edit_Key_Down( Sender : TObject; var Key : Word; Shift : TShiftState );
    procedure Edit_Mouse_Down( Sender : TObject; Button : TMouseButton; Shift : TShiftState; X, Y : Integer );
    procedure Domyślny_Button_Click( Sender : TObject );
    procedure Niezdefiniowane_Button_Click( Sender : TObject );
    procedure Panel_Mouse_Enter( Sender : TObject );
    procedure Panel_Mouse_Leave( Sender : TObject );
  end;//---//TKlawiatura_Konfiguracja

  TWygląd_Kolor_Definicja = class
    wygląd_kolor_definicja_t : array of TWygląd_Kolor_Definicja_r;
  public
    { Public declarations }
    constructor Create();
    destructor Destroy(); override; // Bez override; się nie wywołuje (jedynie tak się wywoła wygląd_kolor_definicja.Destroy()).

    function Definicja_Istnieje( const kolor_definicja_nazwa_f : string ) : boolean;
    procedure Dodaj_Definicję( const czerwony_f, zielony_f, niebieski_f, przezroczystość_f : real; const kolor_definicja_nazwa_f : string );
    function Odczytaj_Definicję( const kolor_definicja_nazwa_f : string ) : GLVectorGeometry.TVector;
  end;//---//TWygląd_Kolor_Definicja


  TStatki_Form = class( TForm )
    GLSceneViewer1: TGLSceneViewer;
    GLScene1: TGLScene;
    GLCadencer1: TGLCadencer;
    GLUserInterface1: TGLUserInterface;
    GLNavigator1: TGLNavigator;
    GLLightSource1: TGLLightSource;
    GLCamera1: TGLCamera;
    Zero_GLSphere: TGLSphere;
    X_Lewo_GLCube: TGLCube;
    Z_Tył_GLCone1: TGLCone;
    Woda_GLPlane: TGLPlane;
    Informacje_Główne_GLHUDText: TGLHUDText;
    GLWindowsBitmapFont1: TGLWindowsBitmapFont;
    GLSkyDome1: TGLSkyDome;
    GLLines1: TGLLines;
    GLLines2: TGLLines;
    GLLines3: TGLLines;
    Celownicza_GLSphere: TGLSphere;
    Celowniczy_GLDummyCube: TGLDummyCube;
    GLWaterPlane1: TGLWaterPlane;
    Czas_Bezwzględny_Timer: TTimer;
    IdTCPServer1: TIdTCPServer;
    IdTCPClient1: TIdTCPClient;
    Klient_IdTCP_Czyta_Timer: TTimer;
    Wieloosobowe__Tryb_RadioGroup: TRadioGroup;
    Serwer_Wysyła_Timer: TTimer;
    Log_Memo: TMemo;
    Button1: TButton;
    GLCollisionManager1: TGLCollisionManager;
    GLCollisionManager2: TGLCollisionManager;
    Efekt__Wpadnięcie_Do_Wody_0_GLFireFXManager: TGLFireFXManager;
    Efekt__Wpadnięcie_Do_Wody_GLPolygonPFXManager: TGLPolygonPFXManager;
    GLParticleFXRenderer1: TGLParticleFXRenderer;
    Woda_Kolizje_GLCube: TGLCube;
    Efekt__Ogień_GLFireFXManager: TGLFireFXManager;
    Efekt__Dym_GLPerlinPFXManager: TGLPerlinPFXManager;
    Efekt__Mgła_GLPerlinPFXManager: TGLPerlinPFXManager;
    Efekt__Smuga_GLPerlinPFXManager: TGLPerlinPFXManager;
    IdUDPServer1: TIdUDPServer;
    IdUDPClient1: TIdUDPClient;
    Klient_IdUDP_Czyta_Timer: TTimer;
    Gra_Obiekty_GLDummyCube: TGLDummyCube;
    GLArrowLine_Żółta: TGLArrowLine;
    GLArrowLine_Zielona: TGLArrowLine;
    Dno_GLPlane: TGLPlane;
    Dno_Kolizje_GLCube: TGLCube;
    PageControl1: TPageControl;
    Log_TabSheet: TTabSheet;
    Splitter1: TSplitter;
    Wieloosobowe_TabSheet: TTabSheet;
    Gra_TabSheet: TTabSheet;
    Ląd_GroupBox: TGroupBox;
    Ląd_ComboBox: TComboBox;
    Ląd__Wczytaj_Listę_BitBtn: TBitBtn;
    Ląd_Opis_Memo: TMemo;
    Ląd__Odśwież_Wskazany_BitBtn: TBitBtn;
    Statek_GroupBox: TGroupBox;
    Statek_ComboBox: TComboBox;
    Statek__Wczytaj_Listę_BitBtn: TBitBtn;
    Statek_Opis_Memo: TMemo;
    Statek__Odśwież_Wskazany_BitBtn: TBitBtn;
    Ląd__Utwórz_BitBtn: TBitBtn;
    Statek__Utwórz_BitBtn: TBitBtn;
    Gra_Współczynnik_Prędkości_SpinEdit: TSpinEdit;
    Gra_Współczynnik_Prędkości_Etykieta_Label: TLabel;
    Wieloosobowe__Podłącz_BitBtn: TBitBtn;
    Wieloosobowe__Odłącz_BitBtn: TBitBtn;
    Wieloosobowe_GroupBox: TGroupBox;
    Pokój_Rozmów_GroupBox: TGroupBox;
    Pokój_Rozmów_Memo: TMemo;
    Pokój_Rozmów_Przyciski_Panel: TPanel;
    Pokój_Rozmów_Wiadomość_Edit: TEdit;
    Pokój_Rozmów__Wyślij_Wiadomość_Button: TButton;
    Wieloosobowe_Identyfikator_Etykieta_Label: TLabel;
    Wieloosobowe_Identyfikator_Edit: TEdit;
    Pozostałe_TabSheet: TTabSheet;
    Gracze_Lista_GroupBox: TGroupBox;
    Gracze_Lista_StringGrid: TStringGrid;
    Gracz_Nazwa_Etykieta_Label: TLabel;
    Gracz_Nazwa_Edit: TEdit;
    Gracz_Grupa_Etykieta_Label: TLabel;
    Gracz_Grupa_SpinEdit: TSpinEdit;
    Gracz_Gotowość_Tak_BitBtn: TBitBtn;
    Gracz_Gotowość_Nie_BitBtn: TBitBtn;
    Serwer_Klient_Odłączenie_Timer: TTimer;
    Gracze_Lista_Odśwież_BitBtn: TBitBtn;
    Gracze_Lista_Rozłącz_Gracza_BitBtn: TBitBtn;
    Mapa_Label: TLabel;
    Gracz_Dane_GroupBox: TGroupBox;
    SI_GroupBox: TGroupBox;
    SI__Statek_ComboBox: TComboBox;
    SI__Dodaj_BitBtn: TBitBtn;
    SI__Nazwa_Etykieta_Label: TLabel;
    SI__Grupa_Etykieta_Label: TLabel;
    SI__Nazwa_Edit: TEdit;
    SI__Grupa_SpinEdit: TSpinEdit;
    Serwer_Adres_IP_Etykieta_Label: TLabel;
    Serwer_Adres_IP_Edit: TEdit;
    Serwer_Port_SpinEdit: TSpinEdit;
    Serwer_Port_Etykieta_Label: TLabel;
    Hasło_Edit: TEdit;
    Hasło_Etykieta_Label: TLabel;
    Klient_Wysyła_Timer: TTimer;
    Projektowy_Tryb_CheckBox: TCheckBox;
    Radar_Chart: TChart;
    Series1: TPointSeries;
    Radar_Timer: TTimer;
    Series2: TPointSeries;
    Series3: TPointSeries;
    Radar_Zasięg_Etykieta_Label: TLabel;
    Radar_Zasięg_SpinEdit: TSpinEdit;
    Series4: TPointSeries;
    Series5: TPointSeries;
    Radar_Odwróć_CheckBox: TCheckBox;
    Series6: TPointSeries;
    Radar_Przyciski_Panel: TPanel;
    Radar_Panel: TPanel;
    Radar_Powiększ_Button: TButton;
    Radar_Pomniejsz_Button: TButton;
    Statek__Opis_BitBtn: TBitBtn;
    Radar_Dane_Z_Radia_CheckBox: TCheckBox;
    Ustawienia_TabSheet: TTabSheet;
    Kamera_Odległość_Maksymalna_Etykieta_Label: TLabel;
    Kamera_Odległość_Maksymalna_SpinEdit: TSpinEdit;
    Punkty_Życia_Wskaźnik__Gracz_CheckBox: TCheckBox;
    Statki_Pozycje_Początkowe_GroupBox: TGroupBox;
    Statki_Pozycje_Początkowe_ComboBox: TComboBox;
    Statki_Pozycje_Początkowe__Wczytaj_Listę_BitBtn: TBitBtn;
    Statki_Pozycje_Początkowe_Opis_Memo: TMemo;
    Statki_Pozycje_Początkowe__Odśwież_Wskazany_BitBtn: TBitBtn;
    Statki_Pozycje_Początkowe_Label: TLabel;
    Statki_Pozycje_Początkowe__Brak_BitBtn: TBitBtn;
    Mysz_Czułość_Etykieta_Label: TLabel;
    Mysz_Czułość_Edit: TEdit;
    Mysz_Czułość_Label: TLabel;
    Mysz_Czułość_Luneta_Etykieta_Label: TLabel;
    Mysz_Czułość_Luneta_Edit: TEdit;
    Mysz_Czułość_Luneta_Label: TLabel;
    Dalmierz_CheckBox: TCheckBox;
    Amunicja__Cel_Pozycja_Dla_Lotu_Parabolą_Wyświetl_CheckBox: TCheckBox;
    Amunicja__Zanurzenie_Głębokość_Zadana_Edit: TEdit;
    Amunicja__Zanurzenie_Głębokość_Zadana_Etykieta_Label: TLabel;
    Amunicja__Zanurzenie_Głębokość_Zadana_Label: TLabel;
    Amunicja_Rodzaj_GroupBox: TGroupBox;
    ar_Artyleria_CheckBox: TCheckBox;
    ar_Pocisk_CheckBox: TCheckBox;
    ar_Torpeda_CheckBox: TCheckBox;
    ar_Wszystkie_CheckBox: TCheckBox;
    Ląd__Komunikat_Błędu_Pomiń_CheckBox: TCheckBox;
    Statek__Komunikat_Błędu_Pomiń_CheckBox: TCheckBox;
    Obrót_Kąt_Zablokowany_Wskaźnik_CheckBox: TCheckBox;
    Celowanie_Tryb_RadioGroup: TRadioGroup;
    Statki_Zaprezentuj_GroupBox: TGroupBox;
    Statki_Zaprezentuj__Pozycja_Początkowa__X_SpinEdit: TSpinEdit;
    Statki_Zaprezentuj__Pozycja_Początkowa__Y_SpinEdit: TSpinEdit;
    Statki_Zaprezentuj__Pozycja_Początkowa__Z_SpinEdit: TSpinEdit;
    Statki_Zaprezentuj__Odstępy_Między_Statkami_SpinEdit: TSpinEdit;
    Statki_Zaprezentuj__Pozycja_Początkowa_Etykieta_Label: TLabel;
    Statki_Zaprezentuj__Pozycja_Początkowa__X_Etykieta_Label: TLabel;
    Statki_Zaprezentuj__Pozycja_Początkowa__Y_Etykieta_Label: TLabel;
    Statki_Zaprezentuj__Pozycja_Początkowa__Z_Etykieta_Label: TLabel;
    Statki_Zaprezentuj__Odstępy_Między_Statkami_Etykieta_Label: TLabel;
    Statki_Zaprezentuj__Kolumna_CheckBox: TCheckBox;
    Statki_Zaprezentuj_Button: TButton;
    Statki_Zaprezentuj__Zwolnij_BitBtn: TBitBtn;
    Ustawienia_Wczytaj_Button: TButton;
    Ustawienia_Zapisz_Button: TButton;
    Kamera_Szybkość_Ruchu_Etykieta_Label: TLabel;
    Kamera_Szybkość_Ruchu_Label: TLabel;
    Kamera_Szybkość_Ruchu_Edit: TEdit;
    Punkty_Życia_Wskaźnik__Przeciwnik_CheckBox: TCheckBox;
    Punkty_Życia_Wskaźnik__Sojusznik_CheckBox: TCheckBox;
    Klawiatura_Konfiguracja_TabSheet: TTabSheet;
    Klawiatura_Konfiguracja__Przyciski_Panel: TPanel;
    Klawiatura_Konfiguracja__Zapisz_Button: TButton;
    Klawiatura_Konfiguracja__Wczytaj_Button: TButton;
    Klawiatura_Konfiguracja__Domyślna_Button: TButton;
    Klawiatura_Konfiguracja_ScrollBox: TScrollBox;
    Klawiatura_Konfiguracja__Niepowtarzalność_Sprawdź_Button: TButton;
    Amunicja__Zanurzenie_Głębokość_Zadana__Skok_O_Etykieta_Label: TLabel;
    Amunicja__Zanurzenie_Głębokość_Zadana__Skok_O_Label: TLabel;
    Amunicja__Zanurzenie_Głębokość_Zadana__Skok_O_Edit: TEdit;
    Klawiatura_Konfiguracja__Konfiguracja_Numer_SpinEdit: TSpinEdit;
    Klawiatura_Konfiguracja__Rozmiar_Zakładki_Poszerz_CheckBox: TCheckBox;
    Informacje_Dodatkowe_GLHUDText: TGLHUDText;
    Informacje_Dodatkowe_Timer: TTimer;
    Pokój_Rozmów__Informacja_Dodatkowa_CheckBox: TCheckBox;
    Ustawienia_Panel: TPanel;
    Ustawienia_ScrollBox: TScrollBox;
    Wieloosobowe_Gra_GroupBox: TGroupBox;
    Gra_Uruchamianie_Panel: TPanel;
    Gra_Rozpocznij_BitBtn: TBitBtn;
    Gra_Zakończ_BitBtn: TBitBtn;
    Wieloosobowe_Identyfikator_Gra_Etykieta_Label: TLabel;
    Wieloosobowe_Identyfikator_Gra_Label: TLabel;
    Pokój_Rozmów__Na_Ekranie_CheckBox: TCheckBox;
    Pokój_Rozmów__Ukryj_Button: TButton;
    Celowanie_Precyzja_Obrót_Etykieta_Label: TLabel;
    Celowanie_Precyzja_Obrót_SpinEdit: TSpinEdit;
    Celowanie_Precyzja_Podniesienie_Etykieta_Label: TLabel;
    Celowanie_Precyzja_Podniesienie_SpinEdit: TSpinEdit;
    Pokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj_ComboBox: TComboBox;
    Wieloosobowe_ScrollBox: TScrollBox;
    Gra_ScrollBox: TScrollBox;
    O_Programie_TabSheet: TTabSheet;
    O_Programie_Label: TLabel;
    Celownik_Wielkość_Etykieta_Label: TLabel;
    Celownik_Wielkość_Label: TLabel;
    Celownik_Wielkość_Edit: TEdit;
    Celownik_Widoczność_CheckBox: TCheckBox;
    Celownik_Widoczność_Mouse_Look_Active_CheckBox: TCheckBox;
    Radar_Widoczność_CheckBox: TCheckBox;
    Obrót_Kąt_Zablokowany_Strzał_Wskaźnik_CheckBox: TCheckBox;
    procedure FormShow( Sender: TObject );
    procedure FormClose( Sender: TObject; var Action: TCloseAction );
    procedure FormResize( Sender: TObject );

    procedure GLSceneViewer1Exit( Sender: TObject );
    procedure GLSceneViewer1Click( Sender: TObject );
    procedure GLSceneViewer1MouseDown( Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer );
    procedure GLSceneViewer1MouseWheel( Sender: TObject; Shift: TShiftState; WheelDelta: Integer; MousePos: TPoint; var Handled: Boolean );
    procedure GLSceneViewer1MouseMove( Sender: TObject; Shift: TShiftState; X, Y: Integer );
    procedure GLSceneViewer1KeyDown( Sender: TObject; var Key: Word; Shift: TShiftState );
    procedure GLCadencer1Progress( Sender: TObject; const deltaTime, newTime: Double );
    procedure GLCollisionManager1Collision( Sender: TObject; object1, object2: TGLBaseSceneObject );

    procedure Czas_Bezwzględny_TimerTimer( Sender: TObject );

    procedure PageControl1Change( Sender: TObject );

    procedure Ląd__Wczytaj_Listę_BitBtnClick( Sender: TObject );
    procedure Ląd__Odśwież_Wskazany_BitBtnClick( Sender: TObject );
    procedure Ląd__Utwórz_BitBtnClick( Sender: TObject );
    procedure Ląd_ComboBoxChange( Sender: TObject );

    procedure Statek__Wczytaj_Listę_BitBtnClick( Sender: TObject );
    procedure Statek__Odśwież_Wskazany_BitBtnClick( Sender: TObject );
    procedure Statek__Utwórz_BitBtnClick( Sender: TObject );
    procedure Statek__Opis_BitBtnClick( Sender: TObject );
    procedure Statek_ComboBoxChange( Sender: TObject );
    procedure Statek_ComboBoxKeyDown( Sender: TObject; var Key: Word; Shift: TShiftState );

    procedure Statki_Pozycje_Początkowe__Wczytaj_Listę_BitBtnClick( Sender: TObject );
    procedure Statki_Pozycje_Początkowe__Odśwież_Wskazany_BitBtnClick( Sender: TObject );
    procedure Statki_Pozycje_Początkowe__Brak_BitBtnClick( Sender: TObject );
    procedure Statki_Pozycje_Początkowe_ComboBoxChange( Sender: TObject );

    procedure Gra_Rozpocznij_BitBtnClick( Sender: TObject );
    procedure Gra_Zakończ_BitBtnClick( Sender: TObject );

    procedure Gra_Współczynnik_Prędkości_SpinEditChange( Sender: TObject );

    procedure Wieloosobowe__Tryb_RadioGroupClick( Sender: TObject );
    procedure Wieloosobowe__Podłącz_BitBtnClick( Sender: TObject );
    procedure Wieloosobowe__Odłącz_BitBtnClick( Sender: TObject );

    procedure IdTCPServer1Connect( AContext: TIdContext );
    procedure IdTCPServer1Disconnect( AContext: TIdContext );
    procedure IdTCPServer1Execute( AContext: TIdContext );

    procedure IdUDPServer1UDPRead( AThread: TIdUDPListenerThread; const AData: TIdBytes; ABinding: TIdSocketHandle );

    procedure Serwer_Wysyła_TimerTimer( Sender: TObject );
    procedure Klient_IdTCP_Czyta_TimerTimer( Sender: TObject );
    procedure Klient_IdUDP_Czyta_TimerTimer( Sender: TObject );
    procedure Klient_Wysyła_TimerTimer( Sender: TObject );

    procedure Serwer_Klient_Odłączenie_TimerTimer( Sender: TObject );

    procedure Pokój_Rozmów__Na_Ekranie_CheckBoxClick( Sender: TObject );
    procedure Pokój_Rozmów__Wyślij_Wiadomość_ButtonClick( Sender: TObject );
    procedure Pokój_Rozmów_Wiadomość_EditKeyDown( Sender: TObject; var Key: Word; Shift: TShiftState );
    procedure Pokój_Rozmów__Ukryj_ButtonClick( Sender: TObject );
    procedure Pokój_Rozmów_Przyciski_PanelMouseDown( Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer );
    procedure Pokój_Rozmów_Przyciski_PanelMouseMove( Sender: TObject; Shift: TShiftState; X, Y: Integer );
    procedure Pokój_Rozmów_Przyciski_PanelMouseUp( Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer );

    procedure Gracz_Gotowość_BitBtnClick( Sender: TObject );
    procedure Gracze_Lista_Odśwież_BitBtnClick( Sender: TObject );
    procedure Gracze_Lista_Rozłącz_Gracza_BitBtnClick( Sender: TObject );

    procedure SI__Dodaj_BitBtnClick( Sender: TObject );

    procedure Edit_Jako_Spin_KeyDown( Sender: TObject; var Key: Word; Shift: TShiftState );
    procedure ScrollBoxMouseWheel( Sender: TObject; Shift: TShiftState; WheelDelta: Integer; MousePos: TPoint; var Handled: Boolean );

    procedure Ustawienia_Wczytaj_ButtonClick( Sender: TObject );
    procedure Ustawienia_Zapisz_ButtonClick( Sender: TObject );

    procedure Amunicja__Zanurzenie_Głębokość_Zadana_EditChange( Sender: TObject );
    procedure Celowanie_Tryb_RadioGroupClick( Sender: TObject );
    procedure Celownik_Widoczność_CheckBoxClick( Sender: TObject );
    procedure Celownik_Wielkość_EditChange( Sender: TObject );
    procedure Kamera_Szybkość_Ruchu_EditChange( Sender: TObject );
    procedure Mysz_Czułość_EditChange( Sender: TObject );
    procedure Elementy_Gracza_Dostosuj_CheckBoxClick( Sender: TObject );

    procedure Projektowy_Tryb_CheckBoxClick( Sender: TObject );
    procedure Radar_Widoczność_CheckBoxClick( Sender: TObject );
    procedure Informacje_Dodatkowe_TimerTimer( Sender: TObject );

    procedure Radar_Wielkość_ButtonClick( Sender: TObject );
    procedure Radar_Odwróć_CheckBoxClick( Sender: TObject );
    procedure Radar_TimerTimer( Sender: TObject );

    procedure Statki_Zaprezentuj_ButtonClick( Sender: TObject );
    procedure Statki_Zaprezentuj__Zwolnij_BitBtnClick( Sender: TObject );
    procedure Statki_ZaprezentujKeyDown( Sender: TObject; var Key: Word; Shift: TShiftState );

    procedure Klawiatura_Konfiguracja__Domyślna_ButtonClick( Sender: TObject );
    procedure Klawiatura_Konfiguracja__Wczytaj_ButtonClick( Sender: TObject );
    procedure Klawiatura_Konfiguracja__Zapisz_ButtonClick( Sender: TObject );
    procedure Klawiatura_Konfiguracja__Niepowtarzalność_Sprawdź_ButtonClick( Sender: TObject );

    procedure Button1Click(Sender: TObject);
    procedure GLCollisionManager2Collision(Sender: TObject; object1, object2: TGLBaseSceneObject);
  private
    { Private declarations }
    kamera_indeks_amunicji, // Indeks w liście amunicji, na którym była ustawiona kamera.
    pokój_rozmów__zmiana_szerokości__szerokość_początkowa_g,
    pokój_rozmów__zmiana_szerokości__wysokość_początkowa_g,
    pokój_rozmów__zmiana_szerokości__x_początkowy_g,
    pokój_rozmów__zmiana_szerokości__y_początkowy_g,
    wieloosobowe__statek_przywróć_do_gry__id_statek_g
      : integer;

    gra_współczynnik_prędkości_g, // Modyfikuje prędkość różnych przekształceń. // 1 - prędkość normalna gry.
    kamera_szybkość_ruchu_g,
    mysz_czułość_g, // Czułość myszy (szybkość ruchu myszą).
    mysz_czułość_luneta_g // Czułość myszy przy maksymalnym przybliżeniu lunety.
      : real;
    
    czy_kamera_od_najnowszego_pocisku, // Przełącza kamerę pomiędzy pociskami w kierunku od najnowszego do najstarszego (gdy prawda). // Podpiąć do menu opcji.
    czy_pauza_g,
    //mouse_look_active_przed_pauzą, // Podczas pauzy nie obraca się kamera i po wyłączeniu pauzy występuje skok kamery na nowe współrzędne myszy.

    czy_gra_lokalna_g,
    czy_serwer_g,
    czy_klient_g,
    czy_wyłączanie_serwera_g, // W trybie serwera (oznacza, że serwer jest w procedurze wyłączania się).
    //czy_wysyłanie_trwa_g, //??? To nie pomaga. // Jeżeli serwer TCP zacznie wysyłanie gdy poprzednie się nie zakończyło może dojść do zamrożenia programu (Contexts.LockList() wywoła się za dużo razy, pozakłada wewnętrzne blokady, które się nie pościągają - Contexts.UnlockList()).
    //kamera_obrót_myszą_g,
    klient_pierwsze_ustawienie_kamery_g, // Po rozpoczęciu gry ustawi kamerę gracza klienta na jego statku.
    pokój_rozmów__zmiana_szerokości__aktywność_g // Aktywność trybu zmiany szerokości pokoju rozmów.
      : boolean;

    ląd_definicja_g : string; // Definicja lądu w aktualnej grze (mapa gry).

    //moment_wciśnięcia_klawisza,
    pokój_rozmów_ostatnia_wiadomość_wysłana_data_czas,
    udp_data_czas_sprawdzanie_połączeń_ostatnie_g // Kiedy ostatnio: serwer - usuwał nieaktywne połączenia z listy; klient - przypominał, że jest połączony z serwerem.
      : TDateTime;

    amunicja_wystrzelona_list,
    wieloosobowe_amunicja_wystrzelona_list,

    informacje_dodatkowe_list,
    ląd_list,
    trafienia_efekt_list
      : TList;

    pokój_rozmów_ostatnia_wiadomości_wysłane_treść_string_list : TStringList;

    wieloosobowe_amunicja_efekt_g : TAmunicja; // Aby utworzyć u klientów efekt na podstawie danych z amunicji i aby ciągle w funkcji nie tworzyć i nie zwalniać instancji amunicji.

    statek_gracza,
    projektowy_tryb__statek
      : TStatek;

    lądy_lista_t,
    prymitywy_lista_t, // U klientów jest zerowane przy komendzie gra start.
    statki_lista_t,
    statki_pozycje_początkowe_lista_t
      : TSchematy_Lista_r_t;

    statki_t : array of TStatek;

    gra_pozycja_początkowa_parametry_t,
    ląd_pozycja_początkowa_parametry_t,
    statki_pozycja_początkowa_parametry_t
       : array [ 1..2 ] of TPozycja_Początkowa_Parametry_r;

    tcp_klienci_lista_g : TTCP_Klienci_Lista;
    udp_klienci_lista_g : TUDP_Klienci_Lista;

    wieloosobowe__efekt_r : TObiekty_Wieloosobowe__Efekt_r;

    wieloosobowe__amunicja_t : array of TObiekty_Wieloosobowe__Amunicja_r;
    wieloosobowe__efekt_t : array of TObiekty_Wieloosobowe__Efekt_r;
    wieloosobowe__statki_t : array of TObiekty_Wieloosobowe__Statek_r;
    wieloosobowe__statek_klawisze_obsługa_r : TObiekty_Wieloosobowe__Statek_Klawisze_Obsługa_r;

    pokój_rozmów_r : TPokój_Rozmów_r;
    komunikacja_rekord_testowy_r : TKomunikacja_Rekord_Testowy_r;
    komunikacja_rekord_testowy_2_r : TKomunikacja_Rekord_Testowy_2_r;

    klawisz__amunicja__zanurzenie_głębokość_zadana__plus,
    klawisz__amunicja__zanurzenie_głębokość_zadana__minus,
    klawisz__celowanie_tryb,
    klawisz__celownik_widoczność,
    klawisz__celownik_widoczność_mouse_look_active,
    klawisz__dalmierz,
    klawisz__gra_współczynnik_prędkości__plus,
    klawisz__gra_współczynnik_prędkości__normalna,
    klawisz__gra_współczynnik_prędkości__minus,
    klawisz__kamera__do_tyłu,
    klawisz__kamera__do_przodu,
    klawisz__kamera__w_lewo,
    klawisz__kamera__w_przawo,
    klawisz__kamera__w_górę,
    klawisz__kamera__w_dół,
    klawisz__kamera__w_lewo_obrót,
    klawisz__kamera__w_przawo_obrót,
    klawisz__kamera__w_górę_obrót,
    klawisz__kamera__w_dół_obrót,
    klawisz__kamera__Amunicja,
    klawisz__kamera__Artyleria,
    klawisz__kamera__Statek,
    klawisz__kamera__Swobodna,
    klawisz__kamera__Za_Statkiem,
    klawisz__ląd_odśwież_wskazany,
    klawisz__mouse_look_active,
    klawisz__obracaj_działa,
    klawisz__obrót_kąt_zablokowany_wskaźnik,
    klawisz__obrót_kąt_zablokowany_strzał_wskaźnik,
    klawisz__opcje,
    klawisz__pauza,
    klawisz__podnoś_lufy,
    klawisz__pokój_rozmów__na_ekranie,
    klawisz__pokój_rozmów__informacja_dodatkowa,
    klawisz__prędkość_zadana_procent_zmień__100_plus,
    klawisz__prędkość_zadana_procent_zmień__25_plus,
    klawisz__prędkość_zadana_procent_zmień__1_plus,
    klawisz__prędkość_zadana_procent_zmień__zero,
    klawisz__prędkość_zadana_procent_zmień__1_minus,
    klawisz__prędkość_zadana_procent_zmień__25_minus,
    klawisz__prędkość_zadana_procent_zmień__100_minus,
    klawisz__projektowy_tryb__włącz_wyłącz,
    klawisz__projektowy_tryb__statek__przesunięcie_w_lewo,
    klawisz__projektowy_tryb__statek__przesunięcie_w_prawo,
    klawisz__projektowy_tryb__statek__przesunięcie_w_przód,
    klawisz__projektowy_tryb__statek__przesunięcie_w_tył,
    klawisz__projektowy_tryb__statek__obrót_lewo,
    klawisz__projektowy_tryb__statek__obrót_prawo,
    klawisz__projektowy_tryb__statek__przechylenie_w_lewo,
    klawisz__projektowy_tryb__statek__przechylenie_w_prawo,
    klawisz__projektowy_tryb__statek__uniesienie_przodu,
    klawisz__projektowy_tryb__statek__uniesienie_tyłu,
    klawisz__projektowy_tryb__statek__prędkość_zadana_0_100,
    klawisz__projektowy_tryb__statek___resetuj_obrót,
    klawisz__punkty_życia_wskaźnik__gracz,
    klawisz__punkty_życia_wskaźnik__przeciwnik,
    klawisz__punkty_życia_wskaźnik__sojusznik,
    klawisz__radar_widoczność,
    klawisz__skręt_zadany_procent_zmień__100_lewo,
    klawisz__skręt_zadany_procent_zmień__25_lewo,
    klawisz__skręt_zadany_procent_zmień__1_lewo,
    klawisz__skręt_zadany_procent_zmień__zero,
    klawisz__skręt_zadany_procent_zmień__1_prawo,
    klawisz__skręt_zadany_procent_zmień__25_prawo,
    klawisz__skręt_zadany_procent_zmień__100_prawo,
    klawisz__statek__utwórz,
    klawisz__strzał_1,
    klawisz__strzał_2,
    klawisz__strzał__wszystkie_lufy_1,
    klawisz__strzał__wszystkie_lufy_2,
    klawisz__strzał__wszystkie_wybrane_1,
    klawisz__strzał__wszystkie_wybrane_2,
    klawisz__strzał__broń_indeks_zmieniaj,
    klawisz__strzał__broń_indeks_poprzedni,
    klawisz__strzał__broń_indeks_następny,
    klawisz__strzelaj_z__artyleria,
    klawisz__strzelaj_z__pocisk,
    klawisz__strzelaj_z__torpeda,
    klawisz__strzelaj_z__wszystkie,
    klawisz__zamknij_program
      : TKlawiatura_Konfiguracja_r;

    klawiatura_konfiguracja_r_t : array of ^TKlawiatura_Konfiguracja_r;

    function Wieloosobowe__Wektor_4__Do__Vector( const wieloosobowe__wektor_4_f : TWieloosobowe__Wektor_4 ) : GLVectorGeometry.TVector;
    function Vector__Do__Wieloosobowe__Wektor_4( const vector_f : GLVectorGeometry.TVector ) : TWieloosobowe__Wektor_4;

    function Statek_Znajdź( pointer_f : Pointer ) : Pointer;

    procedure Amunicja_Wystrzelona_Utwórz_Jeden( AOwner : TGLBaseSceneObject; ALufa : TLufa; const obracaj_działa_f : boolean; const cel_współrzędne_f : TAffineVector );
    procedure Amunicja_Wystrzelona_Zwolnij_Jeden( amunicja_f : TAmunicja  );
    procedure Amunicja_Wystrzelona_Zwolnij_Wszystkie();
    procedure Amunicja_Wystrzelona_Efekt_Utwórz( amunicja_f : TAmunicja; const czy_torpeda_efekt_na_wodzie_f : boolean; const czy_wieloosobowa_f : boolean = false );

    function Odczytaj_Liczbę_Z_Napisu( napis_f : string; const wartość_minimalna_f : variant; const przełącz_zakładkę_f : boolean = true ) : real;

    function Wygląd_Elementy__Utwórz_Element( const statek_f : TStatek; const ląd_prymityw_f : string; const właściciel_gl_base_scene_object_f : TGLBaseSceneObject; const rodzic_gl_dummy_cube_f : TGLDummyCube = nil ) : TGLCustomSceneObject;
    function Wygląd_Elementy__Tekstura_Wczytaj( gl_custom_scene_object_f : TGLCustomSceneObject; tekstura_ścieżka_f : string ) : boolean;
    procedure Ląd_Utwórz( const lista_indeks_f : integer; const prymityw_indeks_f : integer = -99; const prymityw_rodzic_gl_dummy_cube_f : TGLDummyCube = nil );
    procedure Ląd_Zwolnij();

    procedure Statki_Zwolnij( const zwolnij_pierwszy_statek_f : boolean = true; zwolnij_statki_za_pierwszym_f : boolean = true );

    function Statek_Odczytaj_Schemat( const lista_indeks_f : integer ) : string;

    procedure Trafienia_Efekt_Utwórz_Jeden( AOwner : TGLBaseSceneObject; efekt_rodzaj_f : TEfekt_Rodzaj; x_f, y_f, z_f : real; amunicja_f : TAmunicja; czas_trwania_f, czas_trwania_efekt_dodatkowy_f : Int64 );
    procedure Trafienia_Efekt_Zwolnij_Jeden( trafienia_efekt_f : TTrafienia_Efekt );
    procedure Trafienia_Efekt_Zwolnij_Wszystkie();

    function Amunicja_Rodzaj_Zbiór_Zwróć() : TAmunicja_Rodzaj_Zbiór; overload;
    function Amunicja_Rodzaj_Zbiór_Zwróć( const ar_brak_f, ar_artyleria_f, ar_pocisk_f, ar_torpeda_f, ar_wszystkie_f : boolean ) : TAmunicja_Rodzaj_Zbiór; overload;

    function Klawisz_Wciśnięto_Sprawdź( const klawiatura_konfiguracja_r_f : TKlawiatura_Konfiguracja_r; const klawisz_f : Word; const mysz_przycisk_f : SmallInt; const shift_f : TShiftState; const czy_z_wieloosobowe__odczytaj_f : boolean = false ) : boolean;
    procedure Statek_Klawisze_Obsługa( const id_statek_f : integer; const klawisz_f : Word; const mysz_przycisk_f : SmallInt; const shift_f : TShiftState; const amunicja_rodzaj_zbiór_f : TAmunicja_Rodzaj_Zbiór; const czy_z_wieloosobowe__odczytaj_f : boolean = false );
    procedure Klawisze_Obsługa_Zachowanie_Ciągłe( delta_czasu_f : double; const shift_f : TShiftState = []; const mysz_przycisk_f : SmallInt = -1 );
    procedure Statek_Klient_Cel_Ustaw( const id_statek_f : integer; const cel_współrzędne_f : GLVectorGeometry.TVector );

    procedure Statki_Ruch( delta_czasu_f : double );
    procedure Amunicja_Ruch( delta_czasu_f : double );
    procedure Lufy_Przeładowanie( delta_czasu_f : double );

    function Statki_Kolizja_Oznaczenie_Sprawdź( string_list_f : TStringList; obiekt_nazwa_f : string ) : boolean;

    procedure Trafienia_Efekt_Czas_Trwania_Sprawdź();

    procedure Kamera_Odległość_Kontroluj_Ustaw( delta_czasu_f : double );
    procedure Kamera_Przełącz( const kamera_tryb_f : TKamera_Tryb );

    procedure Napis_Odśwież();

    procedure Celownicza_Kula_Zmień_Pozycję();
    procedure Pauza( const czy_pauza_f : boolean );

    procedure Elementy_Gry_Przygotuj();
    procedure Elementy_Gry_Zwolnij();
    procedure Statek_Przywróć_Do_Gry( const id_statek_f : integer ); overload;
    procedure Statek_Przywróć_Do_Gry( const statek_f : TStatek ); overload;
    procedure Statki_Rozstaw( const statek_f : TStatek );

    procedure Ustawienia_Plik( const zapisuj_ustawienia_f : boolean = false );
    procedure Wczytaj_Schemat( const katalog_nazwa_f : string; const lista_indeks_f : integer; var schematy_lista_r_t_f : TSchematy_Lista_r_t );
    
    procedure Wieloosobowe_Amunicja_Parametry_Odczytaj();
    procedure Wieloosobowe_Amunicja_Parametry_Ustaw();

    procedure Wieloosobowe__Efekt_Odczytaj_Jeden( AOwner : TGLBaseSceneObject; efekt_rodzaj_f : TEfekt_Rodzaj; x_f, y_f, z_f : real; amunicja_f : TAmunicja; czas_trwania_f, czas_trwania_efekt_dodatkowy_f : Int64 );

    procedure Wieloosobowe_Statki_Rekord_Czyść();
    procedure Wieloosobowe_Statki_Utwórz();
    procedure Wieloosobowe_Statki_Parametry_Odczytaj();
    procedure Wieloosobowe_Statki_Parametry_Ustaw();

    procedure Wieloosobowe__Tekst_Wyślij( const napis_f : string; const peer_port_f : integer = -99 );
    procedure Wieloosobowe__Tekst_Wyślij_UDP( const napis_f : string );
    procedure Wieloosobowe__Strumień_Wyślij( const komenda_f : string; const peer_port_f : integer; const wartość_f : TWieloosobowe_String; const czy_udp_f : boolean = false );
    function Wieloosobowe__Odczytaj( const io_handler_f : TIdIOHandler; const komenda_udp_f : string; const id_context_f : TIdContext; const id_socket_handle_f : TIdSocketHandle ) : string; // uses IdIOHandler.

    procedure Wieloosobowe__Trafienia_Efekt_Utwórz( obiekty_wieloosobowe__efekt_r_f : TObiekty_Wieloosobowe__Efekt_r ); overload;
    procedure Wieloosobowe__Trafienia_Efekt_Utwórz( obiekty_wieloosobowe__efekt_t_f : array of TObiekty_Wieloosobowe__Efekt_r ); overload;

    procedure Wieloosobowe__Log_Wypisz( const napis_f : string; const wyróżnij_f : boolean = false );

    function Gracz_Identyfikator() : integer;
    procedure Gracze_Lista_Odśwież();
    procedure Gracze_Lista_Rozłącz( const peer_port_f : integer );

    procedure Informacja_Dodatkowa_Dodaj( const napis_f : string; const wyświetlanie_czas_sekund_f : smallint = 0 );

    procedure Interfejs_Parametry_Według_Statku_Ustaw();

    procedure Klawisz_Konfiguracja_Zwolnij();

    procedure Log_Wypisz( const napis_f : string; const przełącz_zakładkę_f : boolean = true );

    procedure Pokój_Rozmów__Wyświetl_Wiadomość( pokój_rozmów_r_f : TPokój_Rozmów_r );

    procedure Radar_Ląd_Rysuj();
    procedure Radar_Statki_Rysuj();
    procedure Radar_Wyczyść( const czyść_wszystko_f : boolean = false );

    procedure Radio_Statki_W_Zasięgu();
    function Radio_Dane_Wymień( const zt_statek_f : TStatek; id_statek_f : integer ) : boolean;

    procedure Komunikacja_Rekord_Testowy_Obsługa( const tylko_wyświetl_f : boolean = true );
  public
    { Public declarations }
  end;//---//TStatki_Form

const
  amunicja_prędkość_c : real = 100; //50 //???
  cofanie_wystrzał_powrót_milisekund_c : real = 250; // Po jakim czasie od wystrzału lufa wraca na domyślną pozycję (w milisekundach). Jeżeli ten czas jest większy od czasu przeładowania wskaźnik przeładowania na lufie ustawi się w pozycji 'naładowany' (przesunie się poza lufę) zanim lufa wróci na domyślna pozycje cofania.
  dno_poziom_c : single = -10;
  udp_klient_połączenie_potwierdzanie_sekund_c : single = 10; // Jeżeli po upływie tego czasu klient się nie odezwie uznaje się, że połączenie UDP zostało utracone.
  kolizja_oznaczanie_prędkość_procent_c : real = 10; // Przy jakiej prędkości procentowej oznaczać efekt kolizji.
  kolizja_przesuwanie_siła_c : real = 5; // Z jaką siłą statek przesuwa inny statek podczas kolizji.
  lot_parabolą__kąta_opadania__odległość_od_procent_c : real = 0.6; // Od jakiego procenta dystansu amunicja zaczyna opadać ( lot_parabolą__kąta_opadania__odległość_od_procent_c + lot_parabolą__kąta_opadania__odległość_od_odcinek_zmiany_kąta_procent_c powinno być mniejsze od 1 (100%)).
  lot_parabolą__kąta_opadania__odległość_od_odcinek_zmiany_kąta_procent_c : real = 0.36; //35 // Na jakim procencie dystansu zmienia się płynnie kąt opadania (bez naprowadzania ( lot_parabolą__kąta_opadania__odległość_od_procent_c + lot_parabolą__kąta_opadania__odległość_od_odcinek_zmiany_kąta_procent_c powinno być mniejsze od 1 (100%)).
  lot_parabolą__kąta_opadania__przed_namierzaniem_c : real = 80; //85 // Kąt do jakiego należy pochylić amunicję przed rozpoczęciem nakierowywania na cel.
  oczekiwanie_na_odnowienie_statku_czas_c : int64 = 15; // Sekundy. // 15
  statek_kolizja_oznaczenie_ponowne_czas_c : int64 = 1; // Sekundy. // 7
  woda_współczynnik_tłumienia_c : real = 0.25;

  informacja_dodatkowa__wyświetlanie_czas_sekund__domyślny_c : smallint = 10;
  informacja_dodatkowa__wyświetlanie_czas_sekund__krótki_c : smallint = 1;

  katalog_schematy_lista__lądy_c : string = 'Lądy';
  katalog_schematy_lista__prymitywy_c : string = 'Prymitywy';
  katalog_schematy_lista__statki_c : string = 'Statki';
  katalog_schematy_lista__statki_pozycje_początkowe_c : string = 'Statki pozycje początkowe';

  // Powyżej wartości 7 nie widać różnicy w szerokości linii celowania.
  celownik_linia_szerokość_maksymalna__obrót_c : smallint = 2; // Wpływ precyzji celowania obrotu broni na szerokość linii celowania.
  celownik_linia_szerokość_maksymalna__podniesienie_c : smallint = 2; // Wpływ precyzji celowania podniesienia luf na szerokość linii celowania. Jeżeli broń nie unosi luf wartość ta jest uwzględniana przy obliczaniu wycelowania obrotu broni.

  char_rozmiar_c = SizeOf( char );
  obiekty_wieloosobowe__amunicja_r__rozmiar_c = SizeOf( TObiekty_Wieloosobowe__Amunicja_r );
  obiekty_wieloosobowe__efekt_r__rozmiar_c = SizeOf( TObiekty_Wieloosobowe__Efekt_r );
  //obiekty_wieloosobowe__działo_r__rozmiar_c = SizeOf( TObiekty_Wieloosobowe__Działo_r ) - SizeOf( Pointer );
  //obiekty_wieloosobowe__lufa_r__rozmiar_c = SizeOf( TObiekty_Wieloosobowe__Lufa_r );
  //obiekty_wieloosobowe__statki_r__rozmiar_c = SizeOf( TObiekty_Wieloosobowe__Statek_r ) - SizeOf( Pointer ) * ( 0 + 1 + 6 );
  obiekty_wieloosobowe__statek_klawisze_obsługa_r__rozmiar_c = SizeOf( TObiekty_Wieloosobowe__Statek_Klawisze_Obsługa_r );
  //pokój_rozmów_r__rozmiar_c = SizeOf( TPokój_Rozmów_r ) - SizeOf( string );
  pokój_rozmów_r__rozmiar_c = SizeOf( TPokój_Rozmów_r );
  //schematy_lista__rozmiar_c = SizeOf( TSchematy_Lista_r );
  wieloosobowe_string__rozmiar_c = SizeOf( TWieloosobowe_String );
  komunikacja_rekord_testowy_r__rozmiar_c = SizeOf( TKomunikacja_Rekord_Testowy_r );
  komunikacja_rekord_testowy_2_r__rozmiar_c = SizeOf( TKomunikacja_Rekord_Testowy_2_r ) - SizeOf( string );

  serwer_peer_port_c : integer = -1;
  si_peer_port_c : integer = -2;

  torpeda_dążenie_do_zadanej_głębokości_szybkość_c : real = 7; // Jak szybko torpeda próbuje się ustawić na zadanej głębokości.

  radar__celownik_c = 5;
  radar__ląd_c = 2;
  radar__statki_c = 4;
  radar__statki_kierunek_c = 3;
  radar__statki_ślady_c = 1;
  radar__statek_margines_c = 0;

  wieloosobowe__komenda__gra__rozpocznij_c = '__Gra_Rozpocznij__';
  wieloosobowe__komenda__gra__zakończ_c = '__Gra_Zakończ__';
  wieloosobowe__komenda__gra_współczynnik_prędkości_c = '__Gra_Współczynnik_Prędkości__';

  wieloosobowe__komenda__gracz_gotowość_c = '__Gracz_Gotowość__';
  wieloosobowe__komenda__gracz_lista_odśwież_c = '__Gracz_Lista_Odśwież__';

  wieloosobowe__komenda__hasło__sprawdź_c = '__Hasło__Sprawdź__';

  wieloosobowe__komenda__identyfikator__nadaj_c = '__Identyfikator__Nadaj__';
  wieloosobowe__komenda__identyfikator__przypomnij_c = '__Identyfikator_Przypomnij__'; // Gdy ponownie łączy się rozłączony klient.
  wieloosobowe__komenda__identyfikator__zapamiętaj_c = '__Identyfikator_Zapamiętaj__';

  wieloosobowe__komenda__pauza_c = '__Pauza__';

  wieloosobowe__komenda__odbierz__ląd_definicja_c = '__Ląd_Definicja__';
  wieloosobowe__komenda__odbierz__prymitywy_definicja_c = '__Prymitywy_Definicja__';
  wieloosobowe__komenda__odbierz__rekord_amunicja_c = '__Rekord_Amunicja__';
  wieloosobowe__komenda__odbierz__rekord_efekt_c = '__Rekord_Efekt__';
  wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c = '__Rekord_Pokój_Rozmów__';
  wieloosobowe__komenda__odbierz__rekord_statki_c = '__Rekord_Statki__';
  wieloosobowe__komenda__odbierz__statki_definicje_c = '__Statki_Definicje__';

  wieloosobowe__komenda__serwer_wyłącza_się_c = '__Serwer_Wyłącza_Się__';

  wieloosobowe__komenda__statek__klawisze_obsługa_c = '__Rekord_Statek_Klawisze_Obsługa__';
  wieloosobowe__komenda__statek__przywróć_do_gry_c = '__Statek_Przywróć_Do_Gry__';

  wieloosobowe__komenda__udp__klient_połączony_nadal_c = '__udp__połączony__'; // Klient informuje, że nadal jest podłączony (nadal nasłuchuje serwer).


  wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_r_c = '__Komunikacja_Rekord_Testowy__';
  wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_2_r_c = '__Komunikacja_Rekord_Testowy_2__';


  wygląd_prymityw_c : string = 'prymityw';
  wygląd_prymityw__kula_c : string = 'kula';
  wygląd_prymityw__ostrosłup_c : string = 'ostrosłup';
  wygląd_prymityw__prostopadłościan_c : string = 'prostopadłościan';
  wygląd_prymityw__stożek_c : string = 'stożek';
  wygląd_prymityw__walec_c : string = 'walec';

var
  Statki_Form: TStatki_Form;

  celowanie_tryb_g : TCelowanie_Tryb;
  czas_bezwzględny_g, // Czas upływający w grze (zatrzymuje się podczas pauzy).
  czas_bezwzględny_skok_milisekundy_g // Ile milisekund stanowi jedność czas_bezwzględny_g (1 sekunda: przy 1 [skok] - 1000 [czas_bezwzględny_g], 10 - 100, 50 - 20, 100 - 10, 1000 - 1).
    : int64;
  id_amunicja_g : cardinal;

  function Czas_Między_W_Sekundach( const czas_poprzedni_f : int64 ) : int64;
  function Czas_Między_W_Milisekundach( const czas_poprzedni_f : int64 ) : int64;
  function Czas_Teraz() : int64;
  function Czas_Teraz_W_Milisekundach() : int64;

implementation

{$R *.dfm}

{$region 'TStatek.'}
//Konstruktor klasy TStatek.
constructor TStatek.Create( AOwner : TGLBaseSceneObject; gl_collision_mmanager_f : TGLCollisionManager; const id_statek_f : integer; const wygląd_definicja_f : string; const prymitywy_lista_f : TSchematy_Lista_r_t );
var
  zt_gl_base_scene_object : TGLBaseSceneObject;

  //Funkcja Wygląd_Elementy_Utwórz() w Konstruktor klasy TStatek.
  procedure Wygląd_Elementy_Utwórz( const prymityw_indeks_f : integer = -99; const prymityw_rodzic_gl_dummy_cube_f : TGLDummyCube = nil );
  var
    i,
    j,
    jj
      : integer;
    ztr_1,
    ztr_2,
    ztr_3,
    ztr_4
      : real;
    zts : string;
    zt_xml_document : TXMLDocument; //uses XMLDoc
    zt_gl_custom_scene_object : TGLCustomSceneObject;
    kolor_vector : GLVectorGeometry.TVector;
    wygląd_kolor_definicja : TWygląd_Kolor_Definicja;
  begin

    // Parametry:
    //   prymityw_indeks_f:
    //     = -99 - tworzy statek.
    //     <> -99 - tworzy prymityw.
    //   prymityw_rodzic_gl_dummy_cube_f
    //     = nil - tworzy statek.
    //     <> nil - tworzy prymityw (rodzicem tworzonych obiektów jest utworzony wcześniej kontener TGLDummyCube).
    //

    if   ( Self.wygląd_elementy_list = nil )
      or (  not Assigned( Self.wygląd_elementy_list )  ) then
      Exit;


    if prymityw_indeks_f = -99 then
      begin

        // Tworzy statek.

        if Trim( wygląd_definicja_f ) = '' then
          begin

            Statki_Form.Log_Wypisz( 'Brak definicji elementów statku.', not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked );
            Exit;

          end;
        //---//if Trim( wygląd_definicja_f ) = '' then

        zts := wygląd_definicja_f;

      end
    else//if prymityw_indeks_f = -99 then
      begin

        // Tworzy prymityw.

        if prymityw_indeks_f <> -99 then
          begin

            if   ( prymityw_indeks_f < 0 )
              or (  prymityw_indeks_f > Length( prymitywy_lista_f ) - 1  ) then
              begin

                Statki_Form.Log_Wypisz( 'Brak definicji prymitywu.', not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked );
                Exit;

              end;
            //---//if   ( prymityw_indeks_f < 0 ) (...)

            zts := prymitywy_lista_f[ prymityw_indeks_f ].treść;

          end;
        //---//if prymityw_indeks_f <> -99 then

      end;
    //---//if prymityw_indeks_f = -99 then


    zt_xml_document := TXMLDocument.Create( Application );

    zt_xml_document.Options := zt_xml_document.Options + [ doNodeAutoIndent ]; // Domyślnie ma: doNodeAutoCreate, doAttrNull, doAutoPrefix, doNamespaceDecl.

    try
      // Serwer zgłasza błąd podczas odczytu danych o lądzie od klienta
      //   MSXML is not installed
      //   Assertion failure GLContext.pas
      // W Ląd_Zwolnij() chyba też takie coś się dzieje (inne błędy) ale z podobnego powodu.
      //
      // Udało się uniknąć błędów tak:
      //   w zdarzeniu odczytania danych o lądzie tylko włączyć Timer;
      //   w Timer.OnTimet wyłączyć Timer i wywołać zwalnianie i wczytywanie lądu.
      //
      zt_xml_document.LoadFromXML( zts );
    except
      on E : Exception do
        Statki_Form.Log_Wypisz(  'Nieprawidłowa definicja elementów statku. ' + #13 + #10 + E.Message + ' ' + IntToStr( E.HelpContext ), not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked  );
    end;
    //---//try

    {$region 'Odczyt danych xml.'}
    if zt_xml_document.Active then
      begin

        wygląd_kolor_definicja := TWygląd_Kolor_Definicja.Create();


        for i := 0 to zt_xml_document.DocumentElement.ChildNodes.Count - 1 do
          begin

            if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' )
              or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'działo' )
              or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' )
              or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = wygląd_prymityw_c )
              or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'ster' )
              or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'śruba' )
              or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'torpedy_wyrzutnia' ) then
              begin

                zt_gl_custom_scene_object := nil;

                if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' then
                  begin

                    try
                      jj := zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'lufy_ilość' ];
                    except
                      jj := 1;
                    end;
                    //---//try

                    j := Length( Self.artyleria_t );
                    SetLength( Self.artyleria_t, j + 1 );
                    Self.artyleria_t[ j ] := TArtyleria.Create( zt_gl_base_scene_object, Self, gl_collision_mmanager_f, jj, 0 );
                    zt_gl_custom_scene_object := Self.artyleria_t[ j ];

                  end
                else//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' then
                if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'działo' then
                  begin

                    try
                      jj := zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'lufy_ilość' ];
                    except
                      jj := 1;
                    end;
                    //---//try                  

                    j := Length( Self.działa_t );
                    SetLength( Self.działa_t, j + 1 );
                    Self.działa_t[ j ] := TDziało.Create( zt_gl_base_scene_object, Self, gl_collision_mmanager_f, jj, 0 );
                    zt_gl_custom_scene_object := Self.działa_t[ j ];

                  end
                else//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'działo' then
                if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' )
                  or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = wygląd_prymityw_c ) then
                  begin

                    if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' then
                      zt_gl_custom_scene_object := Statki_Form.Wygląd_Elementy__Utwórz_Element(  Self, VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'typ' ] ), zt_gl_base_scene_object, prymityw_rodzic_gl_dummy_cube_f  )
                    else//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' then
                    if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = wygląd_prymityw_c then
                      zt_gl_custom_scene_object := Statki_Form.Wygląd_Elementy__Utwórz_Element( Self, wygląd_prymityw_c, zt_gl_base_scene_object );

                  end
                else//if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' ) (...)
                if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'ster' then
                  begin

                    j := Length( Self.ster_t );
                    SetLength( Self.ster_t, j + 1 );
                    Self.ster_t[ j ] := TSter.Create( zt_gl_base_scene_object, gl_collision_mmanager_f, 0, 0, 0 );
                    zt_gl_custom_scene_object := Self.ster_t[ j ];

                  end
                else//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'ster' then
                if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'śruba' then
                  begin

                    j := Length( Self.śruby_t );
                    SetLength( Self.śruby_t, j + 1 );
                    Self.śruby_t[ j ] := TŚruba.Create( zt_gl_base_scene_object, Self, i = 1, gl_collision_mmanager_f );
                    zt_gl_custom_scene_object := Self.śruby_t[ j ];

                  end
                else//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'śruba' then
                if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'torpedy_wyrzutnia' then
                  begin
                  
                    try
                      jj := zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'lufy_ilość' ];
                    except
                      jj := 1;
                    end;
                    //---//try
                    
                    j := Length( Self.torpedy_wyrzutnie_t );
                    SetLength( Self.torpedy_wyrzutnie_t, j + 1 );
                    Self.torpedy_wyrzutnie_t[ j ] := TTorpedy_Wyrzutnia.Create( zt_gl_base_scene_object, Self, gl_collision_mmanager_f, jj );
                    zt_gl_custom_scene_object := Self.torpedy_wyrzutnie_t[ j ];

                  end;
                //---//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'torpedy_wyrzutnia' then

                if zt_gl_custom_scene_object <> nil then
                  begin

                    if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' )
                      or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = wygląd_prymityw_c ) then
                      Self.wygląd_elementy_list.Add( zt_gl_custom_scene_object );


                    if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = wygląd_prymityw_c then
                      for j := 0 to Length( prymitywy_lista_f ) - 1 do
                        if prymitywy_lista_f[ j ].plik_nazwa = VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'nazwa' ] ) then
                          begin

                            Wygląd_Elementy_Utwórz( j, TGLDummyCube(zt_gl_custom_scene_object) );
                            Break;

                          end;
                        //---//if prymitywy_lista_f[ j ].plik_nazwa = VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'nazwa' ] ) then


                    for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do
                      begin

                        if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' )
                          or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'działo' )
                          or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'torpedy_wyrzutnia' ) then
                          begin

                            if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' )
                              or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'działo' ) then
                              begin

                                if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'podniesienie_kąt_maksymalny' then
                                  TDziało(zt_gl_custom_scene_object).podniesienie_kąt_maksymalny := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                                else
                                if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'podniesienie_kąt_minimalny' then
                                  TDziało(zt_gl_custom_scene_object).podniesienie_kąt_minimalny := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                                else
                                if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'podniesienie_szybkość' then
                                  TDziało(zt_gl_custom_scene_object).podniesienie_szybkość := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0.0001, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                              end;
                            //---//if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' ) (...)

                            if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'amunicja_ilość' then
                              TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).amunicja_ilość := Round(  Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )  )
                            else
                            if    ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' )
                              and ( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'zasięg_od_parabola' ) then
                                TArtyleria(zt_gl_custom_scene_object).zasięg_od_parabola := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                            else
                            if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'obrażenia_zadawane' then
                              TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).obrażenia_zadawane := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                            else
                            if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'obrót_kąt_zablokowany_do' then
                              TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).obrót_kąt_zablokowany_do := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                            else
                            if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'obrót_kąt_zablokowany_od' then
                              TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).obrót_kąt_zablokowany_od := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                            else
                            if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'obrót_kąt_zablokowany_strzał_do' then
                              begin

                                jj := Length( TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).obrót_kąt_zablokowany_strzał_do );
                                SetLength( TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).obrót_kąt_zablokowany_strzał_do, jj + 1 );

                                TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).obrót_kąt_zablokowany_strzał_do[ jj ] := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                              end
                            else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'obrót_kąt_zablokowany_strzał_do' then
                            if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'obrót_szybkość' then
                              TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).obrót_szybkość := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0.0001, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                            else
                            if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'obrót_kąt_zablokowany_strzał_od' then
                              begin

                                jj := Length( TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).obrót_kąt_zablokowany_strzał_od );
                                SetLength( TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).obrót_kąt_zablokowany_strzał_od, jj + 1 );

                                TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).obrót_kąt_zablokowany_strzał_od[ jj ] := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                              end
                            else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'obrót_kąt_zablokowany_strzał_od' then
                            if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'przeładowanie_czas_milisekundy' then
                              begin

                                TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).przeładowanie_czas_milisekundy := Round(  Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 1, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )  );

                                if TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).przeładowanie_czas_milisekundy <= 0 then
                                  TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).przeładowanie_czas_milisekundy := 1;

                              end
                            else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'przeładowanie_czas_milisekundy' then
                            //if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'skala' then
                            //  TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).skala := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 1, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                            //else
                            if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'strzał_od_blokada_milisekundy' then
                              TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).strzał_od_blokada_milisekundy := Round(  Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 1, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )  )
                            else
                            if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'zasięg' then
                              TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).zasięg := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0.0001, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                          end;
                        //---//if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' ) (...)

                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'czy_obrót_lewo' then
                          begin

                            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'śruba' then
                              if AnsiLowerCase( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text ) = 'tak' then
                                TŚruba(zt_gl_custom_scene_object).czy_obrót_lewo := true;

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'czy_obrót_lewo' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'dziób' then
                          begin

                            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' then
                              if AnsiLowerCase( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text ) = 'tak' then
                                zt_gl_custom_scene_object.Tag := 1; // Oznacza, że jest to dziób (część taranująca - wzmocniona).

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'dziób' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'kolor' then
                          begin

                            if    (   Trim(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Attributes[ 'nazwa' ] )  ) <> ''   )
                              and (   wygląd_kolor_definicja.Definicja_Istnieje(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Attributes[ 'nazwa' ] )  )   ) then
                              begin

                                kolor_vector := wygląd_kolor_definicja.Odczytaj_Definicję(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Attributes[ 'nazwa' ] )  );

                              end
                            else//if    (   Trim(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Attributes[ 'nazwa' ] )  ) <> ''   ) (...)
                              begin

                                for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do
                                  begin

                                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'r' then
                                      ztr_1 := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                                    else
                                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'g' then
                                      ztr_2 := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                                    else
                                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'b' then
                                      ztr_3 := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                                    else
                                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'a' then
                                      ztr_4 := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                                  end;
                                //---//for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do

                                if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count > 0 then
                                  GLVectorGeometry.SetVector( kolor_vector, ztr_1, ztr_2, ztr_3, ztr_4 )
                                else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count > 0 then
                                  kolor_vector := clrGray20;

                              end;
                            //---//if    (   Trim(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Attributes[ 'nazwa' ] )  ) <> ''   ) (...)


                            if   ( zt_gl_custom_scene_object is TDziało )
                              or ( zt_gl_custom_scene_object is TTorpedy_Wyrzutnia ) then
                              begin

                                TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).korpus.Material.FrontProperties.Emission.Color := kolor_vector;
                                TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).korpus_przód.Material.FrontProperties.Emission.Color := kolor_vector;
                                TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).obrót_kąt_zablokowany_GLDisk.Material.FrontProperties.Emission.Color := kolor_vector;
                                TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).podstawa.Material.FrontProperties.Emission.Color := kolor_vector;

                                for jj := 0 to Length( TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).lufy_t ) - 1 do
                                  begin

                                    TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).lufy_t[ jj ].korpus.Material.FrontProperties.Emission.Color := kolor_vector;
                                    TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).lufy_t[ jj ].wylot_pozycja.Material.FrontProperties.Emission.Color := kolor_vector;

                                  end;
                                //---//for jj := 0 to Length( TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).lufy_t ) - 1 do

                                if zt_gl_custom_scene_object is TDziało then
                                  begin

                                    TDziało(zt_gl_custom_scene_object).korpus_przód.Material.FrontProperties.Emission.Color := kolor_vector;

                                  end
                                else//if zt_gl_custom_scene_object is TTorpedy_Wyrzutnia then

                              end
                            else//if   ( zt_gl_custom_scene_object is TDziało ) (...)
                            if zt_gl_custom_scene_object is TŚruba then
                              begin

                                TŚruba(zt_gl_custom_scene_object).wał.Material.FrontProperties.Emission.Color := kolor_vector;
                                TŚruba(zt_gl_custom_scene_object).wał_łożysko.Material.FrontProperties.Emission.Color := kolor_vector;
                                TŚruba(zt_gl_custom_scene_object).wał_mocowanie.Material.FrontProperties.Emission.Color := kolor_vector;
                                TŚruba(zt_gl_custom_scene_object).wał_podpórka.Material.FrontProperties.Emission.Color := kolor_vector;
                                TŚruba(zt_gl_custom_scene_object).wał_do_wirnika.Material.FrontProperties.Emission.Color := kolor_vector;
                                TŚruba(zt_gl_custom_scene_object).wirnik_środek.Material.FrontProperties.Emission.Color := kolor_vector;

                                for jj := 0 to Length( TŚruba(zt_gl_custom_scene_object).wirnik_łopaty_t ) - 1 do
                                  TŚruba(zt_gl_custom_scene_object).wirnik_łopaty_t[ jj ].Material.FrontProperties.Emission.Color := kolor_vector;

                              end
                            else//if zt_gl_custom_scene_object is TŚruba then
                            if zt_gl_custom_scene_object is TSter then
                              begin

                                TSter(zt_gl_custom_scene_object).ster.Material.FrontProperties.Emission.Color := kolor_vector;
                                TSter(zt_gl_custom_scene_object).ster_mocowanie.Material.FrontProperties.Emission.Color := kolor_vector;

                              end
                            else//if zt_gl_custom_scene_object is TSter then
                              zt_gl_custom_scene_object.Material.FrontProperties.Emission.Color := kolor_vector;

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'kolor' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'kolor_nazwa' then
                          begin

                            zt_gl_custom_scene_object.Material.FrontProperties.Emission.Color := GLColor.ColorManager.GetColor( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text ); // Robi wyciek pamięci. // clrGreen clrYellowGreen clrBronze2 clrGray40

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'kolor_nazwa' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'obrót__lewo_prawo' then
                          begin

                            if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' )
                              or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'działo' )
                              or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'torpedy_wyrzutnia' ) then
                              TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).obrót_kąt_zadany := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                            else//if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' ) (...)
                              zt_gl_custom_scene_object.TurnAngle := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'obrót__lewo_prawo' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'prędkość_obrotowa_maksymalna' then
                          begin

                            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'śruba' then
                              TŚruba(zt_gl_custom_scene_object).prędkość_obrotowa_maksymalna := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0.0001, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'prędkość_obrotowa_maksymalna' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'prędkość_obrotowa_przyspieszanie' then
                          begin

                            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'śruba' then
                              TŚruba(zt_gl_custom_scene_object).prędkość_obrotowa_przyspieszanie := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0.0001, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'prędkość_obrotowa_przyspieszanie' then
                        //if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'siła_wpływu_kolizji' then
                        //    zt_gl_custom_scene_object.TagFloat := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0.0001, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                        //else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'siła_wpływu_kolizji' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'skala' then
                          begin

                            if    ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName <> 'artyleria' )
                              and ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName <> 'działo' )
                              and ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName <> 'torpedy_wyrzutnia' ) then                          
                              for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do
                                begin

                                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'x' then
                                    zt_gl_custom_scene_object.Scale.X := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0.0001, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                                  else
                                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'y' then
                                    zt_gl_custom_scene_object.Scale.Y := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0.0001, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                                  else
                                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'z' then
                                    zt_gl_custom_scene_object.Scale.Z := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0.0001, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                                end;
                              //---//for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'skala' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'skala_proporcjonalna' then
                          begin

                            if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' )
                              or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'działo' )
                              or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'torpedy_wyrzutnia' ) then
                              TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).skala := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0.0001, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                            else
                              zt_gl_custom_scene_object.Scale.Scale(  Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0.0001, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )  );

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'skala_proporcjonalna' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'tekstura' then
                          begin

                            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' then
                              if not Statki_Form.Wygląd_Elementy__Tekstura_Wczytaj( zt_gl_custom_scene_object, zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text ) then
                                Statki_Form.Log_Wypisz( 'Tworzenie elementów statku - błąd wczytania tekstury: ' + zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text + '.', not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'tekstura' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wartość_dodatkowa_01' then
                          begin

                            if    ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' )
                              and ( zt_gl_custom_scene_object is TGLFrustrum ) then
                              TGLFrustrum(zt_gl_custom_scene_object).Height := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wartość_dodatkowa_01' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'współrzędne' then
                          begin

                            for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do
                              begin

                                if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'x' then
                                  zt_gl_custom_scene_object.Position.X := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                                else
                                if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'y' then
                                  zt_gl_custom_scene_object.Position.Y := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                                else
                                if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'z' then
                                  zt_gl_custom_scene_object.Position.Z := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                              end;
                            //---//for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'współrzędne' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wychylenie__lewo_prawo' then
                          begin

                            zt_gl_custom_scene_object.RollAngle := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wychylenie__lewo_prawo' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wychylenie__przód_tył' then
                          begin
                          
                            if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' )
                              or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'działo' ) then
                              begin

                                TDziało(zt_gl_custom_scene_object).podniesienie_kąt_zadany := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked );
                                TDziało(zt_gl_custom_scene_object).podniesienie_kąt_zadany_bezwzględny := TDziało(zt_gl_custom_scene_object).podniesienie_kąt_zadany;

                              end
                            else//if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' ) (...)
                              //if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName <> 'torpedy_wyrzutnia' then
                                zt_gl_custom_scene_object.PitchAngle := -Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                          end;
                        //---//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wychylenie__przód_tył' then
                        
                      end;
                    //---//for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do

                  end;
                //---//if zt_gl_custom_scene_object <> nil then

              end
            else//if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' ) (...)
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'falowanie_bok_skręt_zakres' then
              Self.falowanie_bok_skręt_zakres := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, null, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'falowanie_bok_zakres' then
              Self.falowanie_bok_zakres := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, null, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'falowanie_góra_dół_zakres' then
              Self.falowanie_góra_dół_zakres := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, null, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'falowanie_przód_zakres' then
              Self.falowanie_przód_zakres := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, null, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'kamera_na_statek_pozycja' then
              begin

                for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do
                  begin

                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'x' then
                      Self.kamera_na_statek_pozycja.X := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                    else
                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'y' then
                      Self.kamera_na_statek_pozycja.Y := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0.1, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                    else
                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'z' then
                      Self.kamera_na_statek_pozycja.Z := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                  end;
                //---//for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do

              end
            else//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'kamera_na_statek_pozycja' then
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'kamera_za_statkiem_pozycja' then
              begin

                for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do
                  begin

                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'x' then
                      Self.kamera_za_statkiem_pozycja.X := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                    else
                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'y' then
                      Self.kamera_za_statkiem_pozycja.Y := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0.1, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                    else
                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'z' then
                      Self.kamera_za_statkiem_pozycja.Z := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                  end;
                //---//for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do

              end
            else//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'kamera_za_statkiem_pozycja' then
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'kamera_odległość_maksymalna' then
              Self.kamera_odległość_maksymalna := Round(  Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )  )
            else
            if    ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'kolor_definicja' )
              and (   Trim(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'nazwa' ] )  ) <> ''   )
              and (   not wygląd_kolor_definicja.Definicja_Istnieje(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'nazwa' ] )  )   ) then
              begin

                for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do
                  begin

                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].LocalName = 'r' then
                      ztr_1 := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].Text, 0, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                    else
                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].LocalName = 'g' then
                      ztr_2 := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].Text, 0, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                    else
                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].LocalName = 'b' then
                      ztr_3 := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].Text, 0, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                    else
                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].LocalName = 'a' then
                      ztr_4 := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].Text, 0, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                  end;
                //---//for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do


                wygląd_kolor_definicja.Dodaj_Definicję(  ztr_1, ztr_2, ztr_3, ztr_4, VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'nazwa' ] )  );

              end
            else//if    ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'kolor_definicja' ) (...)
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'luneta_zasięg' then
              Self.luneta_zasięg := Round(  Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )  )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'prędkość__kolizja_zwalnianie' then
              Self.prędkość__kolizja_zwalnianie := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0.0001, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'prędkość_maksymalna' then
              Self.prędkość_maksymalna := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0.0001, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'prędkość_ograniczenie' then
              Self.prędkość_ograniczenie := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0.0001, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'prędkość_przyspieszanie' then
              Self.prędkość_przyspieszanie := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0.0001, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'prędkość_zwalnianie' then
              Self.prędkość_zwalnianie := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0.0001, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'punkty_życia_maksymalne' then
              begin

                Self.punkty_życia_maksymalne := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0.0001, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked );
                Self.punkty_życia := Self.punkty_życia_maksymalne;

              end
            else//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'punkty_życia_maksymalne' then
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'punkty_życia_wskaźnik_wysokość' then
              Self.punkty_życia_dummy.Position.Y := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0.0001, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'radar_zasięg' then
              Self.radar_zasięg := Round(  Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )  )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'radio_zasięg' then
              Self.radio_zasięg := Round(  Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )  )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'skręt_kąt_maksymalny' then
              Self.skręt_kąt_maksymalny := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0.0001, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'skręt_prędkość' then
              Self.skręt_prędkość := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0.0001, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'skręt_szybkość_wychylania_steru' then
              Self.skręt_szybkość_wychylania_steru := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0.0001, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'skręt_współczynnik_do_prędkości' then
              Self.skręt_współczynnik_do_prędkości := Statki_Form.Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0.0001, not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked );

          end;
        //---//for i := 0 to zt_xml_document.DocumentElement.ChildNodes.Count - 1 do


        FreeAndNil( wygląd_kolor_definicja );

      end;
    //---//if zt_xml_document.Active then
    {$endregion 'Odczyt danych xml.'}


    zt_xml_document.Free();


    {$region 'Przykład xml.'}
  {
  <statek>
      <!-- Wymiar wynosi 1 we wszystkich głównych kierunkach. -->

    <nazwa>Nazwa abc</nazwa>
    <opis><![CDATA[Opis abc.#13#10Nowa linia.]]></opis>


    <kolor_definicja nazwa="kolor nazwa abc">
      <r>0,0</r>
      <g>0,5</g>
      <b>0,0</b>
      <a>0</a>
    </kolor_definicja>


    <falowanie_bok_skręt_zakres>123,456</falowanie_bok_skręt_zakres>
    <falowanie_bok_zakres>123,456</falowanie_bok_zakres>
    <falowanie_góra_dół_zakres>123,456</falowanie_góra_dół_zakres>
    <falowanie_przód_zakres>123,456</falowanie_przód_zakres>

    <kamera_odległość_maksymalna>5</kamera_odległość_maksymalna>

    <kamera_na_statek_pozycja>
      <x>0</x>
      <y>1</y>
      <z>0</z>
    </kamera_na_statek_pozycja>

    <kamera_za_statkiem_pozycja>
      <x>0</x>
      <y>5</y>
      <z>0</z>
    </kamera_za_statkiem_pozycja>

    <luneta_zasięg>600</luneta_zasięg>

    <punkty_życia_maksymalne>10</punkty_życia_maksymalne>
    <punkty_życia_wskaźnik_wysokość>2,5</punkty_życia_wskaźnik_wysokość>

    <prędkość__kolizja_zwalnianie>0</prędkość__kolizja_zwalnianie>
    <prędkość_maksymalna>2,01</prędkość_maksymalna>
    <prędkość_ograniczenie>100</prędkość_ograniczenie>
    <prędkość_przyspieszanie>1,05</prędkość_przyspieszanie>
    <prędkość_zwalnianie>0,3</prędkość_zwalnianie>

    <radar_zasięg>100</radar_zasięg>
    <radio_zasięg>100</radio_zasięg>

    <skręt_kąt_maksymalny>75</skręt_kąt_maksymalny>
    <skręt_prędkość>20</skręt_prędkość>
    <skręt_szybkość_wychylania_steru>0,4</skręt_szybkość_wychylania_steru>
    <skręt_współczynnik_do_prędkości>25</skręt_współczynnik_do_prędkości>


    <obiekt typ="kula">
      <kolor>
        <r>0</r>
        <g>1</g>
        <b>0,5</b>
        <a>0</a>
      </kolor>
        <!-- Od 0 (czarny) do 1 (biały), ujemne działają jakoś odwrotnie, a - nie wiem. -->
      <kolor nazwa="kolor nazwa abc"/>
      <kolor_nazwa>clrGreen</kolor_nazwa> <!-- Robi wyciek pamięci. -->

      <skala>
        <x>1</x>
        <y>123,456</y>
        <z>123,456</z>
      </skala>
        <!-- 0 - w danym wymiarze jest jak płaszczyzna, ujemne działają jak dodatnie. -->

      <skala_proporcjonalna>2</skala_proporcjonalna>
        <!-- 0, ujemne działają jak dodatnie. -->

      <współrzędne>
        <x>123,456</x>
        <y>123,456</y>
        <z>123,456</z>
      </współrzędne>

      <wychylenie__lewo_prawo>123,456</wychylenie__lewo_prawo>
      <obrót__lewo_prawo>123,456</obrót__lewo_prawo>
        <!-- Dodatnie w lewo (lewa burta). -->
      <wychylenie__przód_tył>123,456</wychylenie__przód_tył>
        <!-- -(minus) w dół, +(plus) w górę. -->
        <!-- 0, ujemne działają, większe wartości obniżane są poprzez wielokrotność 180. -->

      <tekstura>K1\P_1.png</tekstura>
        <!-- Pliki 'png'. Domyślnie ścieżka w katalogu 'Tekstury' w folderze z grą. -->

      <dziób>Tak</dziób>

    <wartość_dodatkowa_01>123,456 abc</wartość_dodatkowa_01>
      <!-- Dla wybranych prymitywów (brył) dodatkowe parametry, których wartość i typ wartości zależy od danego prymitywu. -->
        <!-- Dla prymitywu: ostrosłup - Height - 123,456 - w zakresie od 0 do 1 - ( 0, 1 >. -->
    </obiekt>

    <śruba>
      <kolor>
        <r>0</r>
        <g>1</g>
        <b>0,5</b>
        <a>0</a>
      </kolor>
        <!-- Od 0 (czarny) do 1 (biały), ujemne działają jakoś odwrotnie, a - nie wiem. -->
      <kolor_nazwa>clrGreen</kolor_nazwa> <!-- Robi wyciek pamięci. -->

      <skala>
        <x>1</x>
        <y>123,456</y>
        <z>123,456</z>
      </skala>
        <!-- 0 - w danym wymiarze jest jak płaszczyzna, ujemne działają jak dodatnie. -->

      <skala_proporcjonalna>2</skala_proporcjonalna>
        <!-- 0, ujemne działają jak dodatnie. -->

      <współrzędne>
        <x>123,456</x>
        <y>123,456</y>
        <z>123,456</z>
      </współrzędne>

      <wychylenie__lewo_prawo>123,456</wychylenie__lewo_prawo>
      <obrót__lewo_prawo>123,456</obrót__lewo_prawo>
        <!-- Dodatnie w lewo (lewa burta). -->            
      <wychylenie__przód_tył>123,456</wychylenie__przód_tył>
        <!-- -(minus) w dół, +(plus) w górę. -->
        <!-- 0, ujemne działają, większe wartości obniżane są poprzez wielokrotność 180. -->

      <czy_obrót_lewo>Tak</czy_obrót_lewo>
      <prędkość_obrotowa_maksymalna>8</prędkość_obrotowa_maksymalna>
      <prędkość_obrotowa_przyspieszanie>0,1</prędkość_obrotowa_przyspieszanie>
        <!-- Całkiem dobrze wychodzi gdy [śruba] prędkość_obrotowa_maksymalna / prędkość_obrotowa_przyspieszanie = [statek] prędkość_maksymalna / prędkość_przyspieszanie -->
    </śruba>

    <ster>
      <kolor>
        <r>0</r>
        <g>1</g>
        <b>0,5</b>
        <a>0</a>
      </kolor>
        <!-- Od 0 (czarny) do 1 (biały), ujemne działają jakoś odwrotnie, a - nie wiem. -->
      <kolor_nazwa>clrGreen</kolor_nazwa> <!-- Robi wyciek pamięci. -->

      <skala>
        <x>1</x>
        <y>123,456</y>
        <z>123,456</z>
      </skala>
        <!-- 0 - w danym wymiarze jest jak płaszczyzna, ujemne działają jak dodatnie. -->

      <skala_proporcjonalna>2</skala_proporcjonalna>
        <!-- 0, ujemne działają jak dodatnie. -->

      <współrzędne>
        <x>123,456</x>
        <y>123,456</y>
        <z>123,456</z>
      </współrzędne>

      <wychylenie__lewo_prawo>123,456</wychylenie__lewo_prawo>
      <obrót__lewo_prawo>123,456</obrót__lewo_prawo>
        <!-- Dodatnie w lewo (lewa burta). -->
      <wychylenie__przód_tył>123,456</wychylenie__przód_tył>
        <!-- -(minus) w dół, +(plus) w górę. -->
        <!-- 0, ujemne działają, większe wartości obniżane są poprzez wielokrotność 180. -->
    </ster>

    <torpedy_wyrzutnia lufy_ilość="3">
      <kolor>
        <r>0</r>
        <g>1</g>
        <b>0,5</b>
        <a>0</a>
      </kolor>

      <skala_proporcjonalna>1</skala_proporcjonalna>

      <współrzędne>
        <x>-0,5</x>
        <y>0</y>
        <z>-2</z>
      </współrzędne>

      <obrót__lewo_prawo>123,456</obrót__lewo_prawo>
        <!-- Dodatnie w lewo (lewa burta). -->      
      
      <obrót_kąt_zablokowany_do>1,1</obrót_kąt_zablokowany_do>
      <obrót_kąt_zablokowany_od>2,2</obrót_kąt_zablokowany_od>

      <obrót_szybkość>1,1</obrót_szybkość>

      <obrażenia_zadawane>11,3</obrażenia_zadawane>
      <zasięg>10,5</zasięg>

      <amunicja_ilość>12</amunicja_ilość>
      <przeładowanie_czas_milisekundy>3</przeładowanie_czas_milisekundy>
      <strzał_od_blokada_milisekundy>100</strzał_od_blokada_milisekundy>

      <obrót_kąt_zablokowany_strzał_do>1,1</obrót_kąt_zablokowany_strzał_do>
      <obrót_kąt_zablokowany_strzał_od>2,2</obrót_kąt_zablokowany_strzał_od>
    </torpedy_wyrzutnia>

    <działo lufy_ilość="2">
      <kolor>
        <r>0</r>
        <g>1</g>
        <b>0,5</b>
        <a>0</a>
      </kolor>

      <skala_proporcjonalna>0,5</skala_proporcjonalna>

      <współrzędne>
        <x>-0,5</x>
        <y>0</y>
        <z>-2</z>
      </współrzędne>

      <obrót__lewo_prawo>123,456</obrót__lewo_prawo>
        <!-- Dodatnie w lewo (lewa burta). -->      
      <wychylenie__przód_tył>123,456</wychylenie__przód_tył>
        <!-- -(minus) w dół, +(plus) w górę. -->
        
      <obrót_kąt_zablokowany_do>1,1</obrót_kąt_zablokowany_do>
      <obrót_kąt_zablokowany_od>2,2</obrót_kąt_zablokowany_od>

      <obrót_szybkość>1,1</obrót_szybkość>

      <obrażenia_zadawane>11,3</obrażenia_zadawane>
      <zasięg>10,5</zasięg>

      <amunicja_ilość>12</amunicja_ilość>
      <przeładowanie_czas_milisekundy>3</przeładowanie_czas_milisekundy>
      <strzał_od_blokada_milisekundy>100</strzał_od_blokada_milisekundy>

      <obrót_kąt_zablokowany_strzał_do>1,1</obrót_kąt_zablokowany_strzał_do>
      <obrót_kąt_zablokowany_strzał_od>2,2</obrót_kąt_zablokowany_strzał_od>

      <podniesienie_kąt_maksymalny>45,5</podniesienie_kąt_maksymalny>
        <!-- -(minus) w dół, +(plus) w górę. -->      
      <podniesienie_kąt_minimalny>5,5</podniesienie_kąt_minimalny>
        <!-- -(minus) w dół, +(plus) w górę. -->      
      <podniesienie_szybkość>1,1</podniesienie_szybkość>
    </działo>

    <artyleria lufy_ilość="1">
      <kolor>
        <r>0</r>
        <g>1</g>
        <b>0,5</b>
        <a>0</a>
      </kolor>

      <skala_proporcjonalna>2,5</skala_proporcjonalna>

      <współrzędne>
        <x>-0,5</x>
        <y>0</y>
        <z>-2</z>
      </współrzędne>

      <obrót__lewo_prawo>123,456</obrót__lewo_prawo>
        <!-- Dodatnie w lewo (lewa burta). -->      
      <wychylenie__przód_tył>123,456</wychylenie__przód_tył>
        <!-- -(minus) w dół, +(plus) w górę. -->
        
      <obrót_kąt_zablokowany_do>1,1</obrót_kąt_zablokowany_do>
      <obrót_kąt_zablokowany_od>2,2</obrót_kąt_zablokowany_od>

      <obrót_szybkość>1,1</obrót_szybkość>

      <obrażenia_zadawane>11,3</obrażenia_zadawane>
      <zasięg>10,5</zasięg>

      <amunicja_ilość>12</amunicja_ilość>
      <przeładowanie_czas_milisekundy>3</przeładowanie_czas_milisekundy>
      <strzał_od_blokada_milisekundy>100</strzał_od_blokada_milisekundy>

      <obrót_kąt_zablokowany_strzał_do>1,1</obrót_kąt_zablokowany_strzał_do>
      <obrót_kąt_zablokowany_strzał_od>2,2</obrót_kąt_zablokowany_strzał_od>

      <podniesienie_kąt_maksymalny>60,5</podniesienie_kąt_maksymalny><!--- Dla kąta innego niż 60 maksymalny zasięg pocisk osiąga na dnie -->
      <podniesienie_kąt_minimalny>5,5</podniesienie_kąt_minimalny>
      <podniesienie_szybkość>1,1</podniesienie_szybkość>

      <zasięg_od_parabola>10,5</zasięg_od_parabola>
    </artyleria>

  </statek>
  }
    {$endregion 'Przykład xml.'}

  end;//---//Funkcja Wygląd_Elementy_Utwórz() w Konstruktor klasy TStatek.

var
  i,
  j
    : integer;
begin//Konstruktor klasy TStatek.

  inherited Create( AOwner );


  Self.id_grupa := 0;
  Self.id_statek := id_statek_f;
  Self.id_statek_schemat := -1;

  Self.falowanie_bok_skręt := 0;
  Self.falowanie_bok_skręt_zakres := 10;
  Self.falowanie_bok_zakres := 2;
  Self.falowanie_bok_wychylenie_aktualne := 0;

  Self.falowanie_góra_dół_zakres := 0.025;
  Self.falowanie_góra_dół_wysokość_aktualna := 0;

  Self.falowanie_przód_ruch := 0;
  Self.falowanie_przód_zakres := 1;
  Self.falowanie_przód_wychylenie_aktualne := 0;

  Self.falowanie_opóźnienie := Random( 3000 );

  Self.wygląd_elementy_list := TList.Create();
  Self.kolizja_oznaczenie_string_list := TStringList.Create();

  Self.punkty_życia_maksymalne := 10;
  Self.punkty_życia := Self.punkty_życia_maksymalne;
  Self.punkty_życia_procent_zostało := 100;

  Self.prędkość_aktualna := 0;
  Self.prędkość_maksymalna := 2;  
  Self.prędkość_obrotu_aktualna := 0;
  Self.prędkość_ograniczenie := 100; // 100 2550
  Self.prędkość_procent := 0;
  Self.prędkość_przyspieszanie := 1.05; // Dobrać tak aby ruch śrub odpowiadał przyśpieszeniu statku (statek zmienia kierunek ruchu, a śruby jeszcze nie wyhamowały).  
  Self.prędkość_zadana_procent := 0;
  Self.prędkość_zwalnianie := Self.prędkość_przyspieszanie * 0.3;
  Self.prędkość__kolizja_zwalnianie := 0;

  Self.skręt_kąt_maksymalny := 75;
  Self.skręt_procent := 0;
  Self.skręt_szybkość_wychylania_steru := 0.4;
  Self.skręt_prędkość := 20;
  Self.skręt_współczynnik_do_prędkości := 25;
  Self.skręt_zadany_procent := 0;

  Self.tonięcie__czas_i := 0;
  Self.tonięcie__obrót__lewo_prawo := 0;
  Self.tonięcie__obrót__przód_tył := 0;
  Self.tonięcie__prędkość_w_dół := 0;

  Self.kamera_odległość_maksymalna := 5;

  Self.luneta_zasięg := 600;

  Self.radar_zasięg := 100;
  Self.radio_zasięg := 100;

  Self.radar_id_statki_w_zasięgu := '-99, -99';
  Self.radio_id_statki_w_zasięgu := '-99, -99';

  Self.artyleria_ostatni_strzał_indeks := -1;
  Self.działo_ostatni_strzał_indeks := -1;
  Self.torpedy_wyrzutnia_ostatni_strzał_indeks := -1;

  Self.broń_indeks_zmieniaj := true;

  Self.obrót_kąt_zablokowany_wskaźnik_widoczne := true;
  Self.obrót_kąt_zablokowany_strzał_wskaźnik_widoczne := true;
  Self.obracaj_działa := true;
  Self.podnoś_lufy := true;
  Self.czy_usunąć := false;

  Self.kamera_na_statek_pozycja.X := 0;
  Self.kamera_na_statek_pozycja.Y := 1;
  Self.kamera_na_statek_pozycja.Z := 0;

  Self.kamera_za_statkiem_pozycja.X := 0;
  Self.kamera_za_statkiem_pozycja.Y := 5;
  Self.kamera_za_statkiem_pozycja.Z := 0;

  //Self.obracaj_działa := false; //???
  //Self.podnoś_lufy := false; //???

  Self.statki_rozstawianie_status := srs_Brak;

  Self.Parent := AOwner; //Gra_Obiekty_GLDummyCube
  //Self.MoveUp(); //???
  //Self.TurnAngle := 90;
  Self.Direction.SetVector( 0, 0, -1 );
  //Self.VisibleAtRunTime := true; //???
  //Self.ShowAxes := true; //???

  Self.falowanie_dummy := TGLDummyCube.Create( Self );
  Self.falowanie_dummy.Parent := Self;
  //Self.falowanie_dummy.VisibleAtRunTime := true; //???


  //zt_gl_base_scene_object := Self;
  zt_gl_base_scene_object := Self.falowanie_dummy; //???


  Self.punkty_życia_dummy := TGLDummyCube.Create( Self );
  Self.punkty_życia_dummy.Parent := Self;
  Self.punkty_życia_dummy.Pickable := false;
  Self.punkty_życia_dummy.Position.Y := 2;

  Self.punkty_życia_podniesienie := TGLDummyCube.Create( Self );
  Self.punkty_życia_podniesienie.Parent := punkty_życia_dummy;
  Self.punkty_życia_podniesienie.Pickable := false;

  Self.punkty_życia__wskaźnik := TGLCylinder.Create( Self );
  Self.punkty_życia__wskaźnik.Parent := Self.punkty_życia_podniesienie; // punkty_życia_dummy
  Self.punkty_życia__wskaźnik.Pickable := false;
  Self.punkty_życia__wskaźnik.RollAngle := 90;
  Self.punkty_życia__wskaźnik.BottomRadius := 0.15;
  Self.punkty_życia__wskaźnik.TopRadius := Self.punkty_życia__wskaźnik.BottomRadius;
  Self.punkty_życia__wskaźnik.Height := 1.5;
  Self.punkty_życia__wskaźnik.Material.MaterialOptions := [ GLMaterial.moNoLighting ]; // uses GLMaterial.
  Self.punkty_życia__wskaźnik.Material.FrontProperties.Diffuse.Color := clrGreen;
  Self.punkty_życia__wskaźnik.TagFloat := Self.punkty_życia__wskaźnik.Height; // Wielkość z pełnym życiem.
  Self.punkty_życia__wskaźnik.Scale.Z := 0.075; // 0.075 0.3

  Self.punkty_życia__ramka := TGLCube.Create( Self );
  Self.punkty_życia__ramka.Parent := Self.punkty_życia_podniesienie; // punkty_życia_dummy
  Self.punkty_życia__ramka.Pickable := false;
  Self.punkty_życia__ramka.CubeHeight := Self.punkty_życia__wskaźnik.TopRadius * 2 + Self.punkty_życia__wskaźnik.TopRadius * 0.4; // Wysokość. Promień * 2 + średnica + 2 * 10% z każdej strony (promień * 40%).
  Self.punkty_życia__ramka.CubeWidth := Self.punkty_życia__wskaźnik.Height + Self.punkty_życia__wskaźnik.TopRadius * 2 * 0.4; // Szerokość. Taki sam margines jak wyżej.
  Self.punkty_życia__ramka.CubeDepth := 0.01; // Grubość. // 0.01 0.03
  Self.punkty_życia__ramka.Material.MaterialOptions := [ GLMaterial.moNoLighting ]; // uses GLMaterial.
  Self.punkty_życia__ramka.Material.FrontProperties.Diffuse.Color := clrBlack;

  Self.punkty_życia__napis := TGLSpaceText.Create( Self );
  Self.punkty_życia__napis.Parent := Self.punkty_życia_podniesienie; // punkty_życia_dummy
  Self.punkty_życia__napis.Pickable := false;
  Self.punkty_życia__napis.TurnAngle := 180;
  Self.punkty_życia__napis.Position.X := Self.punkty_życia__ramka.CubeWidth * 0.475;
  Self.punkty_życia__napis.Position.Y := -Self.punkty_życia__ramka.CubeHeight * 0.2;
  Self.punkty_życia__napis.Position.Z := -Self.punkty_życia__ramka.CubeDepth * 2;
  //Self.punkty_życia__napis.Scale.Scale( 0.25 );
  Self.punkty_życia__napis.TextHeight := 0.2;
  Self.punkty_życia__napis.Material.MaterialOptions := [ GLMaterial.moNoLighting ]; // uses GLMaterial.
  Self.punkty_życia__napis.Text := 'pż';

  Self.gracz__nazwa := TGLSpaceText.Create( Self );
  Self.gracz__nazwa.Parent := Self.punkty_życia_podniesienie;
  Self.gracz__nazwa.Pickable := false;
  Self.gracz__nazwa.TurnAngle := 180;
  Self.gracz__nazwa.Position.X := Self.punkty_życia__ramka.CubeWidth * 0.475;
  Self.gracz__nazwa.Position.Y := -Self.punkty_życia__ramka.CubeHeight * 0.2 + Self.punkty_życia__ramka.CubeHeight;
  Self.gracz__nazwa.Position.Z := -Self.punkty_życia__ramka.CubeDepth * 2;
  Self.gracz__nazwa.TextHeight := 0.2;
  Self.gracz__nazwa.Material.MaterialOptions := [ GLMaterial.moNoLighting ]; // uses GLMaterial.
  Self.gracz__nazwa.Text := 'gn';
  Self.gracz__nazwa.Font.Style := [ fsBold ];
  //Self.gracz__nazwa.Extrusion := Self.gracz__nazwa.TextHeight;
  Self.gracz__nazwa.Material.BlendingMode := bmAdditive;


  Self.celownicza_linia := TGLLines.Create( Self );
  Self.celownicza_linia.Parent := Self;
  Self.celownicza_linia.Visible := false; //???
  //Self.celownicza_linia.Position.SetPoint( 0, 0, 0 );
  Self.celownicza_linia.Up.SetVector( 0, 1, 0 );
  Self.celownicza_linia.Direction.SetVector( 0, 0, -1 );
  Self.celownicza_linia.AddNode( 0, 1, 0 );
  Self.celownicza_linia.AddNode( 0, 0, 0 );
  //Self.celownicza_linia.Position.SetPoint( Self.celownicza_linia.Nodes[ 0 ].AsVector );


  if Trim( wygląd_definicja_f ) <> '' then
    begin

      Self.kadłub := nil;
      Self.dziób := nil;

      SetLength( Self.artyleria_t, 0 ); // Ilość artylerii.
      SetLength( Self.działa_t, 0 ); // Ilość dział.
      SetLength( Self.torpedy_wyrzutnie_t, 0 ); // Ilość wyrzutni torped.
      SetLength( Self.śruby_t, 0 ); // Ilość śrub.
      SetLength( Self.ster_t, 0 ); // Ilość sterów.

      Wygląd_Elementy_Utwórz();


      for i := 0 to Length( Self.artyleria_t ) - 1 do
        begin

          Self.artyleria_t[ i ].Dodatkowe_Elementy_Ustaw();

          if i = 0 then
            Self.artyleria_t[ i ].czy_indeks_do_strzału := true;

          for j := 0 to Length( Self.artyleria_t[ i ].lufy_t ) - 1 do
            Self.artyleria_t[ i ].lufy_t[ j ].Dodatkowe_Elementy_Lufy_Pozycja_Ustaw();

        end;
      //---//for i := 0 to Length( Self.artyleria_t ) - 1 do

      for i := 0 to Length( Self.działa_t ) - 1 do
        begin

          Self.działa_t[ i ].Dodatkowe_Elementy_Ustaw();

          if i = 0 then
            Self.działa_t[ i ].czy_indeks_do_strzału := true;

          for j := 0 to Length( Self.działa_t[ i ].lufy_t ) - 1 do
            Self.działa_t[ i ].lufy_t[ j ].Dodatkowe_Elementy_Lufy_Pozycja_Ustaw();

        end;
      //---//for i := 0 to Length( Self.działa_t ) - 1 do

      for i := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do
        begin

          if i = 0 then
            Self.torpedy_wyrzutnie_t[ i ].czy_indeks_do_strzału := true;

          Self.torpedy_wyrzutnie_t[ i ].Dodatkowe_Elementy_Ustaw();

        end;
      //---//for i := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do

    end
  else//if Trim( wygląd_definicja_f ) <> '' then
    begin

      // Jeżeli nie podano definicji wyglądu statku utworzy domyślny wygląd.

      Self.kadłub := TGLCube.Create( zt_gl_base_scene_object );
      Self.kadłub.Parent := zt_gl_base_scene_object;
      Self.kadłub.CubeHeight := 1;
      Self.kadłub.CubeWidth := 3;
      Self.kadłub.CubeDepth := 2;
      Self.kadłub.TurnAngle := 90;


      Self.dziób := TGLCube.Create( zt_gl_base_scene_object );
      Self.dziób.Parent := zt_gl_base_scene_object;
      Self.dziób.TurnAngle := 45;
      Self.dziób.Position.Z := 1.5;
      Self.dziób.Tag := 1; // Oznacza, że jest to dziób (część taranująca - wzmocniona).


      SetLength( Self.artyleria_t, 1 ); // Ilość artylerii.

      for i := 0 to Length( Self.artyleria_t ) - 1 do
        begin

          Self.artyleria_t[ i ] := TArtyleria.Create( zt_gl_base_scene_object, Self, gl_collision_mmanager_f, 3, 0 );
          //Self.artyleria_t[ i ].indeks_w_tabeli := i;
          Self.artyleria_t[ i ].Position.SetPoint( 0, 0.5, 1 );
          Self.artyleria_t[ i ].TurnAngle := 0; // Plus - lewo.
          Self.artyleria_t[ i ].skala := 2;
          Self.artyleria_t[ i ].Dodatkowe_Elementy_Ustaw();

          if i = 0 then
            Self.artyleria_t[ i ].czy_indeks_do_strzału := true;

        end;
      //---//for i := 0 to Length( Self.artyleria_t ) - 1 do


      SetLength( Self.działa_t, 1 ); // Ilość dział.

      for i := 0 to Length( Self.działa_t ) - 1 do
        begin

          Self.działa_t[ i ] := TDziało.Create( zt_gl_base_scene_object, Self, gl_collision_mmanager_f, 3, 0 );
          //Self.działa_t[ i ].indeks_w_tabeli := i;
          Self.działa_t[ i ].Position.SetPoint( 0, 1.25, 0.75 ); // 0, 1, 0 //???
          Self.działa_t[ i ].TurnAngle := 0; // Plus - lewo.
          Self.działa_t[ i ].skala := 0.5;
          Self.działa_t[ i ].Dodatkowe_Elementy_Ustaw();

          if i = 0 then
            Self.działa_t[ i ].czy_indeks_do_strzału := true;

        end;
      //---//for i := 0 to Length( Self.działa_t ) - 1 do


      SetLength( Self.torpedy_wyrzutnie_t, 1 ); // Ilość wyrzutni torped.

      for i := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do
        begin

          Self.torpedy_wyrzutnie_t[ i ] := TTorpedy_Wyrzutnia.Create( zt_gl_base_scene_object, Self, gl_collision_mmanager_f, 3 );
          //Self.torpedy_wyrzutnie_t[ i ].indeks_w_tabeli := i;
          Self.torpedy_wyrzutnie_t[ i ].Position.SetPoint( 0, 0.5, -1 ); // 0, 1, 0 //???
          Self.torpedy_wyrzutnie_t[ i ].TurnAngle := 180; // Plus - lewo.
          Self.torpedy_wyrzutnie_t[ i ].skala := 1;
          Self.torpedy_wyrzutnie_t[ i ].Dodatkowe_Elementy_Ustaw();

          if i = 0 then
            Self.torpedy_wyrzutnie_t[ i ].czy_indeks_do_strzału := true;


          if i = 0 then //???
            begin

              SetLength( Self.torpedy_wyrzutnie_t[ i ].obrót_kąt_zablokowany_strzał_do, 2 );
              SetLength(  Self.torpedy_wyrzutnie_t[ i ].obrót_kąt_zablokowany_strzał_od, Length( Self.torpedy_wyrzutnie_t[ i ].obrót_kąt_zablokowany_strzał_do )  );

              Self.torpedy_wyrzutnie_t[ i ].obrót_kąt_zablokowany_strzał_od[ 0 ] := 50;
              Self.torpedy_wyrzutnie_t[ i ].obrót_kąt_zablokowany_strzał_do[ 0 ] := -90;

              Self.torpedy_wyrzutnie_t[ i ].obrót_kąt_zablokowany_strzał_od[ 1 ] := -170;
              Self.torpedy_wyrzutnie_t[ i ].obrót_kąt_zablokowany_strzał_do[ 1 ] := 170;


              Self.torpedy_wyrzutnie_t[ i ].obrót_kąt_zablokowany_od := 50; // 180  -90  50 -150
              Self.torpedy_wyrzutnie_t[ i ].obrót_kąt_zablokowany_do := -50; //   90 -180 -50  150

            end;
          //---//if i = 0 then

          //Self.torpedy_wyrzutnie_t[ i ].obrót_szybkość := 1; //???

        end;
      //---//for i := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do


      {$region 'Działa ładnie wyglądające.'}
//      SetLength(  Self.artyleria_wygląd_t, Length( Self.artyleria_t )  );
//
//      for i := 0 to Length( Self.artyleria_wygląd_t ) - 1 do
//        begin
//
//          Self.artyleria_wygląd_t[ i ] := TArtyleria.Create( zt_gl_base_scene_object, Self, gl_collision_mmanager_f );
//          Self.artyleria_wygląd_t[ i ].Parametry_Kopiuj_Dla_Wygląd( Self.artyleria_t[ i ] );
//
//        end;
//      //---//for i := 0 to Length( Self.artyleria_wygląd_t ) - 1 do
//
//
//      SetLength(  Self.działa_wygląd_t, Length( Self.działa_t )  );
//
//      for i := 0 to Length( Self.działa_wygląd_t ) - 1 do
//        begin
//
//          Self.działa_wygląd_t[ i ] := TDziało.Create( zt_gl_base_scene_object, Self, gl_collision_mmanager_f );
//          Self.działa_wygląd_t[ i ].Parametry_Kopiuj_Dla_Wygląd( Self.działa_t[ i ] );
//          //Self.działa_wygląd_t[ i ].Position := Self.działa_t[ i ].Position;
//          //Self.działa_wygląd_t[ i ].skala := Self.działa_t[ i ].skala;
//          //Self.działa_wygląd_t[ i ].celownik_linia.Visible := false;
//          //Self.działa_wygląd_t[ i ].Dodatkowe_Elementy_Ustaw();
//
//        end;
//      //---//for i := 0 to Length( Self.działa_wygląd_t ) - 1 do
//
//
//      SetLength(  Self.torpedy_wyrzutnie_wygląd_t, Length( Self.torpedy_wyrzutnie_t )  );
//
//      for i := 0 to Length( Self.torpedy_wyrzutnie_wygląd_t ) - 1 do
//        begin
//
//          Self.torpedy_wyrzutnie_wygląd_t[ i ] := TTorpedy_Wyrzutnia.Create( zt_gl_base_scene_object, Self, gl_collision_mmanager_f );
//          Self.torpedy_wyrzutnie_wygląd_t[ i ].Parametry_Kopiuj_Dla_Wygląd( Self.torpedy_wyrzutnie_t[ i ] );
//
//        end;
//      //---//for i := 0 to Length( Self.torpedy_wyrzutnie_wygląd_t ) - 1 do
      {$endregion 'Działa ładnie wyglądające.'}


      SetLength( Self.śruby_t, 2 ); // Ilość śrub.

      for i := 0 to Length( Self.śruby_t ) - 1 do
        begin

          Self.śruby_t[ i ] := TŚruba.Create( zt_gl_base_scene_object, Self, i = 1, gl_collision_mmanager_f );
          Self.śruby_t[ i ].Position.SetPoint( 0, 0, 0 ); // 0, 1, 0 //???
          //Self.śruby_t[ i ].TurnAngle := 20 * i + 15; // Plus - lewo.
          //Self.śruby_t[ i ].TurnAngle := 90; // Plus - lewo.
          Self.śruby_t[ i ].Position.Y := -Self.kadłub.CubeHeight;
          //Self.śruby_t[ i ].Position.Y := 2; //???

          //???
          if i = 0 then
            begin

              Self.śruby_t[ i ].Position.X := Self.kadłub.CubeDepth * 0.3;

            end
          else//if i = 0 then
          if i = 1 then
            begin

              Self.śruby_t[ i ].Position.X := -Self.kadłub.CubeDepth * 0.3;

            end;
          //---//if i = 1 then


          //Self.śruby_t[ i ].Position.Z := -4 + 2 * i; //???

        end;
      //---//for i := 0 to Length( Self.śruby_t ) - 1 do


      SetLength( Self.ster_t, 3 ); // Ilość sterów.

      for i := 0 to Length( Self.ster_t ) - 1 do
        begin

          Self.ster_t[ i ] := TSter.Create( zt_gl_base_scene_object, gl_collision_mmanager_f, 0, 0, 0 );
          Self.ster_t[ i ].Position.SetPoint( 0, 0, 0 ); // 0, 1, 0 //???
          Self.ster_t[ i ].Position.Z := -Self.kadłub.CubeWidth * 0.5;

          //Self.ster_t[ i ].Position.Y := -Self.kadłub.CubeHeight;
          //Self.ster_t[ i ].Position.Y := 2; //???

          //???
          if i = 0 then
            begin

              Self.ster_t[ i ].Position.X := Self.kadłub.CubeDepth * 0.3;

            end
          else//if i = 0 then
          if i = 1 then
            begin

              Self.ster_t[ i ].Position.X := -Self.kadłub.CubeDepth * 0.3;

            end;
          //---//if i = 1 then


          //Self.ster_t[ i ].Position.Z := -4 + 2 * i; //???

        end;
      //---//for i := 0 to Length( Self.ster_t ) - 1 do

    end;
  //---//if Trim( wygląd_definicja_f ) <> '' then


//  if Length( Self.artyleria_t ) > 0 then
//    Self.artyleria_ostatni_strzał_indeks := 0;
//
//  if Length( Self.działa_t ) > 0 then
//    Self.działo_ostatni_strzał_indeks := 0;
//
//  if Length( Self.torpedy_wyrzutnie_t ) > 0 then
//    Self.torpedy_wyrzutnia_ostatni_strzał_indeks := 0;


  if gl_collision_mmanager_f <> nil then
    begin

      if Self.dziób <> nil then
        with TGLBCollision.Create( Self.dziób.Behaviours ) do
          begin

            GroupIndex := 0;
            BoundingMode := cbmCube;
            Manager := gl_collision_mmanager_f;

          end;
        //---//with TGLBCollision.Create( Self.dziób.Behaviours ) do

      if Self.kadłub <> nil then
        with TGLBCollision.Create( Self.kadłub.Behaviours ) do
          begin

            GroupIndex := 0;
            BoundingMode := cbmCube;
            Manager := gl_collision_mmanager_f;

          end;
        //---//with TGLBCollision.Create( Self.kadłub.Behaviours ) do

    end;
  //---//if gl_collision_mmanager_f <> nil then

end;//---//Konstruktor klasy TStatek.

//Destruktor klasy TStatek.
destructor TStatek.Destroy();
var
  i : integer;
begin

  Self.kolizja_oznaczenie_string_list.Clear();
  FreeAndNil( Self.kolizja_oznaczenie_string_list );


  if    ( Self.wygląd_elementy_list <> nil )
    and (  Assigned( Self.wygląd_elementy_list )  ) then
    for i := Self.wygląd_elementy_list.Count - 1 downto 0 do
      begin

        TGLCustomSceneObject(Self.wygląd_elementy_list[ i ]).Free();
        Self.wygląd_elementy_list.Delete( i );

      end;
    //---//for i := Self.wygląd_elementy_list.Count - 1 downto 0 do

  FreeAndNil( Self.wygląd_elementy_list );


  FreeAndNil( Self.dziób );
  FreeAndNil( Self.kadłub );

  FreeAndNil( Self.gracz__nazwa );
  FreeAndNil( Self.punkty_życia__wskaźnik );
  FreeAndNil( Self.punkty_życia__ramka );
  FreeAndNil( Self.punkty_życia__napis );
  FreeAndNil( Self.punkty_życia_podniesienie );
  FreeAndNil( Self.punkty_życia_dummy );

  FreeAndNil( Self.celownicza_linia );


  for i := 0 to Length( Self.artyleria_t ) - 1 do
    FreeAndNil( Self.artyleria_t[ i ] );

  SetLength( Self.artyleria_t, 0 );

  for i := 0 to Length( Self.artyleria_wygląd_t ) - 1 do
    FreeAndNil( Self.artyleria_wygląd_t[ i ] );

  SetLength( Self.artyleria_wygląd_t, 0 );


  for i := 0 to Length( Self.działa_t ) - 1 do
    FreeAndNil( Self.działa_t[ i ] );

  SetLength( Self.działa_t, 0 );

  for i := 0 to Length( Self.działa_wygląd_t ) - 1 do
    FreeAndNil( Self.działa_wygląd_t[ i ] );

  SetLength( Self.działa_wygląd_t, 0 );


  for i := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do
    FreeAndNil( Self.torpedy_wyrzutnie_t[ i ] );

  SetLength( Self.torpedy_wyrzutnie_t, 0 );

  for i := 0 to Length( Self.torpedy_wyrzutnie_wygląd_t ) - 1 do
    FreeAndNil( Self.torpedy_wyrzutnie_wygląd_t[ i ] );

  SetLength( Self.torpedy_wyrzutnie_wygląd_t, 0 );


  for i := 0 to Length( Self.śruby_t ) - 1 do
    FreeAndNil( Self.śruby_t[ i ] );

  SetLength( Self.śruby_t, 0 );


  for i := 0 to Length( Self.ster_t ) - 1 do
    FreeAndNil( Self.ster_t[ i ] );

  SetLength( Self.ster_t, 0 );


  FreeAndNil( Self.falowanie_dummy );

  inherited;

end;//---//Destruktor klasy TStatek.

//Funkcja Prędkość_Zadana_Procent_Zmień().
function TStatek.Kąt_Obrotu_Statku() : real; //???
var
  zt_vector : GLVectorGeometry.TVector; // uses GLVectorGeometry.
begin

  //
  // Funkcja określa kąt obrotu statku względem osi z w kierunku -1 (pozycja startowa kamery spogląda w przód = w głąb mapy).
  //
  //         0
  //     -45 | 45
  // -90     |     90
  //    -135 | 135
  //         |
  //        180
  //

  Result := 0;

  // Góra Prawo.
  if    ( Self.AbsoluteDirection.X >= 0 )
    and ( Self.AbsoluteDirection.Z <= 0 ) then
    Result := -Self.TurnAngle
  else
  // Góra Lewo.
  if    ( Self.AbsoluteDirection.X < 0 )
    and ( Self.AbsoluteDirection.Z <= 0 ) then
    Result := 180 + Self.TurnAngle;
  // Dół Prawo.
  if    ( Self.AbsoluteDirection.X >= 0 )
    and ( Self.AbsoluteDirection.Z > 0 ) then
    Result := 180 + Self.TurnAngle
  else
  // Dół Lewo.
  if    ( Self.AbsoluteDirection.X < 0 )
    and ( Self.AbsoluteDirection.Z > 0 ) then
    Result := -( 360 + Self.TurnAngle ); // 270 + 90

  //Statki_Form.Caption := FloatToStr( Result );

end;//---//Funkcja Prędkość_Zadana_Procent_Zmień().

//Funkcja Prędkość_Zadana_Procent_Zmień().
procedure TStatek.Prędkość_Zadana_Procent_Zmień( const zmień_o_f : integer );
begin

  //
  // Funkcja modyfikuje o podaną wartość prędkość zadaną w procentach.
  //// -100 -75 -50 -25 0 25 50 75 100
  //
  // Parametry:
  //   zmień_o_f:
  //     < 0 - zwalnia / cofa.
  //     0 - zeruje.
  //     > 0 - przyśpiesza.
  //

  if zmień_o_f = 0 then
    Self.prędkość_zadana_procent := 0
  else//if zmień_o_f = 0 then
    Self.prędkość_zadana_procent := Self.prędkość_zadana_procent + zmień_o_f;

  if Self.prędkość_zadana_procent > 100 then
    Self.prędkość_zadana_procent := 100
  else
  if Self.prędkość_zadana_procent < -100 then
    Self.prędkość_zadana_procent := -100;

  //if zmień_o_f = 0 then
  //  Self.prędkość_zadana_procent := 0
  //else//if zmień_o_f = 0 then
  //if zmień_o_f > 0 then
  //  begin
  //
  //    // Przyśpieszanie.
  //
  //    if Self.prędkość_zadana_procent <= 75 then
  //      begin
  //
  //        if Self.prędkość_zadana_procent >= 0 then
  //          Self.prędkość_zadana_procent := Self.prędkość_zadana_procent + 25
  //        else//if Self.prędkość_zadana_procent >= 0 then
  //          Self.prędkość_zadana_procent := Self.prędkość_zadana_procent + 25; // 50 dla wariantu -100 -50 0.
  //
  //      end;
  //    //---//if Self.prędkość_zadana_procent <= 75 then
  //
  //
  //    if Self.prędkość_zadana_procent > 100 then
  //      Self.prędkość_zadana_procent := 100;
  //
  //  end
  //else//if zmień_o_f > 0 then
  //if zmień_o_f < 0 then
  //  begin
  //
  //    // Zwalnianie / cofanie.
  //
  //    if Self.prędkość_zadana_procent >= -75 then
  //      begin
  //
  //        if Self.prędkość_zadana_procent > 0 then
  //          Self.prędkość_zadana_procent := Self.prędkość_zadana_procent - 25
  //        else//if Self.prędkość_zadana_procent > 0 then
  //          Self.prędkość_zadana_procent := Self.prędkość_zadana_procent - 25; // -50 dla wariantu -100 -50 0.
  //
  //      end;
  //    //---//if Self.prędkość_zadana_procent >= -50 then
  //
  //
  //    if Self.prędkość_zadana_procent < -100 then
  //      Self.prędkość_zadana_procent := -100;
  //
  //  end;
  ////---//if zmień_o_f < 0 then

end;//---//Funkcja Prędkość_Zadana_Procent_Zmień().

//Funkcja Skręt_Zadany_Procent_Zmień().
procedure TStatek.Skręt_Zadany_Procent_Zmień( const zmień_o_f : integer );
begin

  //
  // Funkcja modyfikuje o podaną wartość skręt zadany w procentach.
  //// -100 -75 -50 -20 0 25 50 75 100
  //
  // Parametry:
  //   zmień_o_f:
  //     < 0 - lewo.
  //     0 - zeruje.
  //     > 0 - w prawo
  //

  if zmień_o_f = 0 then
    Self.skręt_zadany_procent := 0
  else//if zmień_o_f = 0 then
    Self.skręt_zadany_procent := Self.skręt_zadany_procent + zmień_o_f;

  if Self.skręt_zadany_procent < -100 then
    Self.skręt_zadany_procent := -100
  else
  if Self.skręt_zadany_procent > 100 then
    Self.skręt_zadany_procent := 100;

  //if zmień_o_f = 0 then
  //  Self.skręt_zadany_procent := 0
  //else//if zmień_o_f = 0 then
  //if zmień_o_f < 0 then
  //  begin
  //
  //    // W lewo.
  //
  //    if Self.skręt_zadany_procent >= -75 then
  //      begin
  //
  //        Self.skręt_zadany_procent := Self.skręt_zadany_procent - 25;
  //
  //      end;
  //    //---//if Self.skręt_zadany_procent >= -75 then
  //
  //
  //    if Self.skręt_zadany_procent < -100 then
  //      Self.skręt_zadany_procent := -100;
  //
  //  end
  //else//if zmień_o_f < 0 then
  //if zmień_o_f > 0 then
  //  begin
  //
  //    // W prawo.
  //
  //    if Self.skręt_zadany_procent <= 75 then
  //      begin
  //
  //        Self.skręt_zadany_procent := Self.skręt_zadany_procent + 25;
  //
  //      end;
  //    //---//if Self.skręt_zadany_procent <= 75 then
  //
  //
  //    if Self.skręt_zadany_procent > 100 then
  //      Self.skręt_zadany_procent := 100;
  //
  //  end;
  ////---//if zmień_o_f > 0 then

end;//---//Funkcja Skręt_Zadany_Procent_Zmień().

//Funkcja Prędkość_Procent_Zmień().
procedure TStatek.Prędkość_Procent_Zmień();
begin

  //
  // Funkcja modyfikuje prędkość w procentach.
  //
  //  Zmiana prędkości odbywa się zawsze pełną mocą i liniowo.
  //  Moc silników wpływa na zmianę prędkości tylko gdy zadana prędkość jest bezwzględnie większa lub ma znak przeciwny od obecnej prędkości.
  //

  if Self.punkty_życia <= 0 then
    begin

      if Self.prędkość_zadana_procent <> 0 then
        Self.prędkość_zadana_procent := 0;

    end;
  //---//if Self.punkty_życia <= 0 then


  // Wyhamowywanie.
  if Abs( Self.prędkość_procent ) > Self.prędkość_zwalnianie * Statki_Form.gra_współczynnik_prędkości_g then
    begin

      if Self.prędkość_procent > 0 then
        Self.prędkość_procent := Self.prędkość_procent - Self.prędkość_zwalnianie * Statki_Form.gra_współczynnik_prędkości_g
      else//if Self.prędkość_procent > 0 then
      if Self.prędkość_procent < 0 then
        Self.prędkość_procent := Self.prędkość_procent + Self.prędkość_zwalnianie * Statki_Form.gra_współczynnik_prędkości_g;

    end
  else//if Abs( Self.prędkość_procent ) > Self.prędkość_zwalnianie * Statki_Form.gra_współczynnik_prędkości_g then
    Self.prędkość_procent := 0; // Prędkość mniejsza od współczynnika wyhamowywania jest zerowana.


  //if Self.prędkość_zadana_procent <> 0 then
    if Self.prędkość_procent < Self.prędkość_zadana_procent then
      begin

        // Przyśpieszanie.

        if Self.prędkość_zadana_procent > 0 then
          Self.prędkość_procent := Self.prędkość_procent + Self.prędkość_przyspieszanie * Statki_Form.gra_współczynnik_prędkości_g;

        if Self.prędkość_procent > Self.prędkość_zadana_procent then
         Self.prędkość_procent := Self.prędkość_zadana_procent;

      end
    else//if Self.prędkość_procent < Self.prędkość_zadana_procent then
    if Self.prędkość_procent > Self.prędkość_zadana_procent then
      begin

        // Cofanie.

        if Self.prędkość_zadana_procent < 0 then
          Self.prędkość_procent := Self.prędkość_procent - Self.prędkość_przyspieszanie * Statki_Form.gra_współczynnik_prędkości_g;

        if Self.prędkość_procent < Self.prędkość_zadana_procent then
         Self.prędkość_procent := Self.prędkość_zadana_procent;

      end;
    //---//if Self.prędkość_procent > Self.prędkość_zadana_procent then



  // Wyhamowywanie wynikające z kolizji.
  if    (  Abs( Self.prędkość_procent ) > 0  )
    and ( Self.prędkość__kolizja_zwalnianie <> 0 ) then
    begin

      //Self.prędkość_procent := Self.prędkość_procent * (  100 - Abs( Self.prędkość_procent ) * Self.prędkość__kolizja_zwalnianie  ) * 0.01;
      Self.prędkość_procent :=
          Self.prędkość_procent
        * (
              (
                  100 - Abs( Self.prędkość_procent ) // Im większa prędkość tym mniejsza wartość (tym bardziej zmniejsza prędkość im prędkość jest większa).
                * Self.prędkość__kolizja_zwalnianie
              )
            * 0.01 // Wyliczanie wartości procentowej (x / 100 = x%).
          ) // Prędkość jest pomniejszana o tyle procent.
        * 0.85 // Modyfikuje siłę wpływu kolizji na prędkość.
        * Statki_Form.gra_współczynnik_prędkości_g;


      if Self.prędkość_procent > Self.prędkość_ograniczenie then
        Self.prędkość_procent := Self.prędkość_ograniczenie
      else
      if Self.prędkość_procent < -Self.prędkość_ograniczenie then
        Self.prędkość_procent := -Self.prędkość_ograniczenie;


      Self.prędkość__kolizja_zwalnianie := 0;

    end;
  //---//if Abs( Self.prędkość_procent ) > Self.prędkość_zwalnianie then

end;//---//Funkcja Prędkość_Procent_Zmień().

//Funkcja Skręt_Procent_Zmień().
procedure TStatek.Skręt_Procent_Zmień();
var
  i : integer;
begin

  //
  // Funkcja modyfikuje skręt w procentach.
  //
  //  Zmiana skrętu odbywa się zawsze pełną mocą i liniowo.
  //

  if Self.skręt_procent > Self.skręt_zadany_procent then
    begin

      // Lewo.

      Self.skręt_procent := Self.skręt_procent - Self.skręt_szybkość_wychylania_steru * Statki_Form.gra_współczynnik_prędkości_g;

      if Self.skręt_procent < Self.skręt_zadany_procent then
       Self.skręt_procent := Self.skręt_zadany_procent;

    end
  else//if Self.skręt_procent > Self.skręt_zadany_procent then
  if Self.skręt_procent < Self.skręt_zadany_procent then
    begin

      // Prawo.

      Self.skręt_procent := Self.skręt_procent + Self.skręt_szybkość_wychylania_steru * Statki_Form.gra_współczynnik_prędkości_g;

      if Self.skręt_procent > Self.skręt_zadany_procent then
       Self.skręt_procent := Self.skręt_zadany_procent;

    end;
  //---//if Self.skręt_procent < Self.skręt_zadany_procent then


  for i := 0 to Length( Self.ster_t ) - 1 do
    begin

      if i = 0 then
        Self.ster_t[ i ].TurnAngle := Self.skręt_kąt_maksymalny * Self.skręt_procent * 0.01
      else//if i = 0 then
        Self.ster_t[ i ].TurnAngle := Self.ster_t[ 0 ].TurnAngle;

    end;
  //---//for i := 0 to Length( Self.ster_t ) - 1 do

end;//---//Funkcja Skręt_Procent_Zmień().

//Funkcja Broń_Indeks_Zmieniaj_Ustaw().
procedure TStatek.Broń_Indeks_Zmieniaj_Ustaw( const amunicja_rodzaj_zbiór_f : TAmunicja_Rodzaj_Zbiór );
begin

  //
  // Funkcja ustawia czy po strzale ustawić się na następną broń tego samego rodzaju czy nie.
  //


  Self.broń_indeks_zmieniaj := not Self.broń_indeks_zmieniaj;


  if    (
             ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
          or ( ar_Artyleria in amunicja_rodzaj_zbiór_f )
        )
    and ( Self.artyleria_ostatni_strzał_indeks < 0 )
    and (  Length( Self.artyleria_t ) > 0  ) then
    Self.artyleria_ostatni_strzał_indeks := Length( Self.artyleria_t ) - 1;


  if    (
             ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
          or ( ar_Pocisk in amunicja_rodzaj_zbiór_f )
        )
    and ( Self.działo_ostatni_strzał_indeks < 0 )
    and (  Length( Self.działa_t ) > 0  ) then
    Self.działo_ostatni_strzał_indeks := Length( Self.działa_t ) - 1;


  if    (
             ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
          or ( ar_Torpeda in amunicja_rodzaj_zbiór_f )
        )
    and ( Self.torpedy_wyrzutnia_ostatni_strzał_indeks < 0 )
    and (  Length( Self.torpedy_wyrzutnie_t ) > 0  ) then
    Self.torpedy_wyrzutnia_ostatni_strzał_indeks := Length( Self.torpedy_wyrzutnie_t ) - 1;

end;//---//Funkcja Broń_Indeks_Zmieniaj_Ustaw().

//Funkcja Broń_Indeks_Zmieniaj_Ustaw().
procedure TStatek.Broń_Indeks_Zmieniaj_Ustaw( const czy_poprzednia_f : boolean; const amunicja_rodzaj_zbiór_f : TAmunicja_Rodzaj_Zbiór );

  //Funkcja Broń_Indeks_Ustaw() w Broń_Indeks_Zmieniaj_Ustaw().
  procedure Broń_Indeks_Ustaw( broń_t_f : array of TTorpedy_Wyrzutnia; var broń_ostatni_strzał_indeks_f : integer );
  var
    i,
    zti
      : integer;
  begin

    if czy_poprzednia_f then
      begin

        dec( broń_ostatni_strzał_indeks_f );

      end
    else//if czy_poprzednia_f then
      begin

        inc( broń_ostatni_strzał_indeks_f );

      end;
    //---//if czy_poprzednia_f then


    if broń_ostatni_strzał_indeks_f < 0 then
      broń_ostatni_strzał_indeks_f := Length( broń_t_f ) - 1;

    if broń_ostatni_strzał_indeks_f > Length( broń_t_f ) - 1 then
      broń_ostatni_strzał_indeks_f := 0;


    zti := broń_ostatni_strzał_indeks_f + 1;

    if zti > Length( broń_t_f ) - 1 then
      zti := 0;


    for i := 0 to Length( broń_t_f ) - 1 do
      broń_t_f[ i ].czy_indeks_do_strzału := i = zti;

  end;//Funkcja Broń_Indeks_Ustaw() w Broń_Indeks_Zmieniaj_Ustaw().

type
  TTorpedy_Wyrzutnia_t_l = array of TTorpedy_Wyrzutnia; // Tylko aby wywołać funkcję.

var
  i : integer;
begin//Funkcja Broń_Indeks_Zmieniaj_Ustaw().

  //
  // Funkcja przestawia na kolejną lub poprzednią broń tego samego rodzaju.
  //
  // Parametry:
  //   czy_poprzednia_f:
  //     false - przestawia na następną.
  //     true - przestawia na poprzednią.
  //

  if    (
             ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
          or ( ar_Artyleria in amunicja_rodzaj_zbiór_f )
        )
    and ( Self.artyleria_ostatni_strzał_indeks < 0 )
    and (  Length( Self.artyleria_t ) > 0  ) then
    Self.artyleria_ostatni_strzał_indeks := Length( Self.artyleria_t ) - 1;


  if    (
             ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
          or ( ar_Pocisk in amunicja_rodzaj_zbiór_f )
        )
    and ( Self.działo_ostatni_strzał_indeks < 0 )
    and (  Length( Self.działa_t ) > 0  ) then
    Self.działo_ostatni_strzał_indeks := Length( Self.działa_t ) - 1;


  if    (
             ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
          or ( ar_Torpeda in amunicja_rodzaj_zbiór_f )
        )
    and ( Self.torpedy_wyrzutnia_ostatni_strzał_indeks < 0 )
    and (  Length( Self.torpedy_wyrzutnie_t ) > 0  ) then
    Self.torpedy_wyrzutnia_ostatni_strzał_indeks := Length( Self.torpedy_wyrzutnie_t ) - 1;



  if
       ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
    or ( ar_Artyleria in amunicja_rodzaj_zbiór_f )
    and (  Length( Self.artyleria_t ) > 0  ) then
    Broń_Indeks_Ustaw( TTorpedy_Wyrzutnia_t_l(Self.artyleria_t), Self.artyleria_ostatni_strzał_indeks );

  if
       ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
    or ( ar_Pocisk in amunicja_rodzaj_zbiór_f )
    and (  Length( Self.działa_t ) > 0  ) then
    Broń_Indeks_Ustaw( TTorpedy_Wyrzutnia_t_l(Self.działa_t), Self.działo_ostatni_strzał_indeks );

  if
       ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
    or ( ar_Torpeda in amunicja_rodzaj_zbiór_f )
    and (  Length( Self.torpedy_wyrzutnie_t ) > 0  ) then
    Broń_Indeks_Ustaw( Self.torpedy_wyrzutnie_t, Self.torpedy_wyrzutnia_ostatni_strzał_indeks );

end;//---//Funkcja Broń_Indeks_Zmieniaj_Ustaw().

//Funkcja Strzał().
function TStatek.Strzał( const amunicja_rodzaj_zbiór_f : TAmunicja_Rodzaj_Zbiór; const czy_wszystkie_bronie_f, czy_wszystkie_lufy_f, obracaj_działa_f, podnoś_lufy_f : boolean; const cel_współrzędne_f : TAffineVector ) : boolean;
var
  wystrzeliły_wszystkie_l : boolean;

  //Funkcja Strzał_Jedną_Lufą() w Strzał().
  function Strzał_Jedną_Lufą( broń_t_f : array of TTorpedy_Wyrzutnia; var broń_ostatni_strzał_indeks_f : integer; const czy_indeks_do_strzału_f : boolean = true ) : boolean;
  var
    i,
    próby_strzału_ilość
      : integer;

    //Funkcja Broń_Kolejny_Egzemplarz_Do_Próby_Strzału_Wyznacz() w Strzał_Jedną_Lufą() w Strzał().
    function Broń_Kolejny_Egzemplarz_Do_Próby_Strzału_Wyznacz() : boolean;
    begin

      //
      // Funkcja wyznacza kolejny egzemplarz broni do próby strzału.
      // Jeżeli do pojedynczego strzału jest wyznaczone działo, które jeszcze nie wycelowało (albo np. nie może wycelować z powodu blokad obrotu) spróbuje strzelić innym działem.
      //
      // Zwraca prawdę gdy należy podjąć próbę strzału z innego egzemplarza broni.
      //

      if not Self.broń_indeks_zmieniaj then
        begin

          Result := false;
          Exit;

        end
      else//if not Self.broń_indeks_zmieniaj then
        Result := true;


      inc( i );

      if i > Length( broń_t_f ) - 1 then
        i := 0;

    end;//---//Funkcja Broń_Kolejny_Egzemplarz_Do_Próby_Strzału_Wyznacz() w Strzał_Jedną_Lufą() w Strzał().

  begin//Funkcja Strzał_Jedną_Lufą() w Strzał().

    // czy_indeks_do_strzału_f
    //   false - próbuje strzelać którąkolwiek bronią danego rodzaju.
    //   true - próbuje strzelać tylko bronią wyznaczoną do strzału.

    Result := false;


    próby_strzału_ilość := 1;

    i := broń_ostatni_strzał_indeks_f;

    inc( i );

    if i > Length( broń_t_f ) - 1 then
      i := 0;


    while próby_strzału_ilość <= Length( broń_t_f ) do
      begin

        inc( próby_strzału_ilość );


        if   ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
          or ( broń_t_f[ i ].amunicja_rodzaj in amunicja_rodzaj_zbiór_f ) then
          begin

            if    (
                       ( not czy_indeks_do_strzału_f )
                    or (
                             ( czy_indeks_do_strzału_f )
                         and ( broń_t_f[ i ].czy_indeks_do_strzału )
                       )
                  )
              and (  broń_t_f[ i ].Strzał( czy_wszystkie_lufy_f, obracaj_działa_f, podnoś_lufy_f, wystrzeliły_wszystkie_l, cel_współrzędne_f )  ) then
              begin

                //broń_ostatni_strzał_indeks_f := i;


                if Self.broń_indeks_zmieniaj then
                  if wystrzeliły_wszystkie_l then
                    begin

                      broń_ostatni_strzał_indeks_f := i;

                      if broń_t_f[ i ].czy_indeks_do_strzału then
                        begin

                          broń_t_f[ i ].czy_indeks_do_strzału := false;


                          // Oznacza, które działo będzie strzelać pojedynczo jako kolejne.
                          inc( i );

                          if i > Length( broń_t_f ) - 1 then
                            i := 0;

                          broń_t_f[ i ].czy_indeks_do_strzału := true;
                          //---// Oznacza, które działo będzie strzelać pojedynczo jako kolejne.

                        end;
                      //---//broń_t_f[ i ].czy_indeks_do_strzału

                    end;
                  //---//if wystrzeliły_wszystkie_l then


                Result := true;

                Exit;

              end
            else//if    ( (...)
              if not Broń_Kolejny_Egzemplarz_Do_Próby_Strzału_Wyznacz() then
                Exit;

          end
        else//if   ( ar_Wszystkie in amunicja_rodzaj_zbiór_f ) (...)
          if not Broń_Kolejny_Egzemplarz_Do_Próby_Strzału_Wyznacz() then
            Exit;

      end;
    //---//while próby_strzału_ilość <= Length( broń_t_f ) do


    if    ( not Result )
      and ( czy_indeks_do_strzału_f ) then
      Result := Strzał_Jedną_Lufą( broń_t_f, broń_ostatni_strzał_indeks_f, false );

  end;//Funkcja Strzał_Jedną_Lufą() w Strzał().

  //Funkcja Strzał_Wszystkie_Bronie_Jednego_Rodzaju() w Strzał().
  function Strzał_Wszystkie_Bronie_Jednego_Rodzaju( broń_t_f : array of TTorpedy_Wyrzutnia; var broń_ostatni_strzał_indeks_f : integer ) : boolean;
  var
    i : integer;
  begin

    Result := false;

    for i := 0 to Length( broń_t_f ) - 1 do
      if    (
                 ( czy_wszystkie_bronie_f )
              or ( broń_t_f[ i ].czy_indeks_do_strzału )
            )
        and (
                 ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
              or ( broń_t_f[ i ].amunicja_rodzaj in amunicja_rodzaj_zbiór_f )
            ) then
        begin

          broń_t_f[ i ].Strzał( czy_wszystkie_lufy_f, obracaj_działa_f, podnoś_lufy_f, wystrzeliły_wszystkie_l, cel_współrzędne_f );

          if not Result then
            Result := true;


          if    ( Self.broń_indeks_zmieniaj )
            and ( not czy_wszystkie_bronie_f )
            and ( czy_wszystkie_lufy_f ) then
            begin

              if broń_ostatni_strzał_indeks_f < 0 then
                broń_ostatni_strzał_indeks_f := 0;

              inc( broń_ostatni_strzał_indeks_f );

              if broń_ostatni_strzał_indeks_f > Length( broń_t_f ) - 1 then
                broń_ostatni_strzał_indeks_f := 0;

              broń_t_f[ i ].czy_indeks_do_strzału := false;
              broń_t_f[ broń_ostatni_strzał_indeks_f ].czy_indeks_do_strzału := true;

              Break;

            end;
          //---//if    ( Self.broń_indeks_zmieniaj ) (...)

        end;
      //---//if    ( (...)

  end;//Funkcja Strzał_Wszystkie_Bronie_Jednego_Rodzaju() w Strzał().

type
  TTorpedy_Wyrzutnia_t_l = array of TTorpedy_Wyrzutnia; // Tylko aby wywołać funkcję.

var
  ztb : boolean;
begin//Funkcja Strzał().

  //
  // Funkcja strzela wszystkimi lufami lub ustala kolejną (następną po poprzednim strzale) gotową lufę i strzela jedną lufą.
  //
  // Zwraca prawdę gdy wystrzeli.
  //
  // Parametry:
  //   czy_wszystkie_bronie_f
  //     true - strzał wszystkimi broniami wybranego rodzaju.
  //     false - strzał jedną bronią (egzemplarz) wybranego rodzaju.
  //   czy_wszystkie_lufy_f:
  //     true - strzał wszystkimi lufami jednej (egzemplarz) broni.
  //     false - strzał jedną lufą jednej (egzemplarz) broni.
  //   obracaj_działa_f
  //     true - strzela tylko gdy działo jest wycelowane.
  //     false - jeżeli działa są zablokowane można strzelić mimo nie wycelowania.
  //

  Result := false;


  if Self.punkty_życia <= 0 then
    Exit;


  if    (
             ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
          or ( ar_Artyleria in amunicja_rodzaj_zbiór_f )
        )
    and (  Length( Self.artyleria_t ) > 0  ) then
    begin

      if czy_wszystkie_bronie_f then
        ztb := Strzał_Wszystkie_Bronie_Jednego_Rodzaju( TTorpedy_Wyrzutnia_t_l(Self.artyleria_t), Self.artyleria_ostatni_strzał_indeks )
      else//if czy_wszystkie_bronie_f then
        ztb := Strzał_Jedną_Lufą( TTorpedy_Wyrzutnia_t_l(Self.artyleria_t), Self.artyleria_ostatni_strzał_indeks );

      if    ( not Result )
        and ( ztb ) then
        Result := true;

    end;
  //---//if    ( (...)


  if   (
             ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
          or ( ar_Pocisk in amunicja_rodzaj_zbiór_f )
        )
    and (  Length( Self.działa_t ) > 0  ) then
    begin

      if czy_wszystkie_bronie_f then
        ztb := Strzał_Wszystkie_Bronie_Jednego_Rodzaju( TTorpedy_Wyrzutnia_t_l(Self.działa_t), Self.działo_ostatni_strzał_indeks )
      else//if czy_wszystkie_bronie_f then
        ztb := Strzał_Jedną_Lufą( TTorpedy_Wyrzutnia_t_l(Self.działa_t), Self.działo_ostatni_strzał_indeks );

      if    ( not Result )
        and ( ztb ) then
        Result := true;

    end;
  //---//if    ( (...)


  if   (
             ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
          or ( ar_Torpeda in amunicja_rodzaj_zbiór_f )
        )
    and (  Length( Self.torpedy_wyrzutnie_t ) > 0  ) then
    begin

      if czy_wszystkie_bronie_f then
        ztb := Strzał_Wszystkie_Bronie_Jednego_Rodzaju( Self.torpedy_wyrzutnie_t, Self.torpedy_wyrzutnia_ostatni_strzał_indeks )
      else//if czy_wszystkie_bronie_f then
        ztb := Strzał_Jedną_Lufą( Self.torpedy_wyrzutnie_t, Self.torpedy_wyrzutnia_ostatni_strzał_indeks );

      if    ( not Result )
        and ( ztb ) then
        Result := true;

    end;
  //---//if    ( (...)

end;//---//Funkcja Strzał().

//Funkcja Elementy_Gracza_Dostosuj().
procedure TStatek.Elementy_Gracza_Dostosuj( const id_grupa_gracza_f : integer; const punkty_życia_wskaźnik_widoczne__gracz_f, punkty_życia_wskaźnik_widoczne__przeciwnik_f, punkty_życia_wskaźnik_widoczne__sojusznik_f, obrót_kąt_zablokowany_wskaźnik_widoczne_f, obrót_kąt_zablokowany_strzał_wskaźnik_widoczne_f : boolean );
var
  i,
  j
    : integer;
begin

  //
  // Funkcja ukrywa lub wyświetla elementy statku, które na swoim statku gracz.
  //
  // Parametry:
  //   id_grupa_gracza_f - id grupy, do której należy gracz.
  //     -99 - modyfikacje dotyczą statku gracza.
  //     różne od -99 - modyfikacje dotyczą statków innych graczy.
  //   punkty_życia_wskaźnik_widoczne__gracz_f
  //   punkty_życia_wskaźnik_widoczne__przeciwnik_f
  //   punkty_życia_wskaźnik_widoczne__sojusznik_f
  //   obrót_kąt_zablokowany_wskaźnik_widoczne_f
  //   obrót_kąt_zablokowany_strzał_wskaźnik_widoczne_f
  //

  if id_grupa_gracza_f = -99 then
    begin

      // Modyfikacje dotyczą statku gracza.

      Self.punkty_życia_dummy.Visible := punkty_życia_wskaźnik_widoczne__gracz_f;


      if   ( Self.obrót_kąt_zablokowany_wskaźnik_widoczne <> obrót_kąt_zablokowany_wskaźnik_widoczne_f )
        or ( Self.obrót_kąt_zablokowany_strzał_wskaźnik_widoczne <> obrót_kąt_zablokowany_strzał_wskaźnik_widoczne_f )  then
        begin

          Self.obrót_kąt_zablokowany_wskaźnik_widoczne := obrót_kąt_zablokowany_wskaźnik_widoczne_f;
          Self.obrót_kąt_zablokowany_strzał_wskaźnik_widoczne := obrót_kąt_zablokowany_strzał_wskaźnik_widoczne_f;

          {$region 'Działa normalne.'}
          // Jeżeli są działa ładnie wyglądające to tych strzelających nie pokazuje się. //??? Niesprawdzone.
          if   ( not obrót_kąt_zablokowany_wskaźnik_widoczne_f )
            or (  Length( Self.artyleria_wygląd_t ) <= 0  )then
            for i := 0 to Length( Self.artyleria_t ) - 1 do
              begin

                Self.artyleria_t[ i ].obrót_kąt_zablokowany_GLDisk.Visible := obrót_kąt_zablokowany_wskaźnik_widoczne_f;

                for j := 0 to Length( Self.artyleria_t[ i ].obrót_kąt_zablokowany_strzał_do ) - 1 do
                  Self.artyleria_t[ i ].obrót_kąt_zablokowany_strzał_GLDisk_t[ j ].Visible := obrót_kąt_zablokowany_strzał_wskaźnik_widoczne_f;

              end;
            //---//for i := 0 to Length( Self.artyleria_t ) - 1 do


          if   ( not obrót_kąt_zablokowany_wskaźnik_widoczne_f )
            or (  Length( Self.działa_wygląd_t ) <= 0  )then
            for i := 0 to Length( Self.działa_t ) - 1 do
              begin

                Self.działa_t[ i ].obrót_kąt_zablokowany_GLDisk.Visible := obrót_kąt_zablokowany_wskaźnik_widoczne_f;

                for j := 0 to Length( Self.działa_t[ i ].obrót_kąt_zablokowany_strzał_do ) - 1 do
                  Self.działa_t[ i ].obrót_kąt_zablokowany_strzał_GLDisk_t[ j ].Visible := obrót_kąt_zablokowany_strzał_wskaźnik_widoczne_f;

              end;
            //---//for i := 0 to Length( Self.działa_t ) - 1 do


          if   ( not obrót_kąt_zablokowany_wskaźnik_widoczne_f )
            or (  Length( Self.torpedy_wyrzutnie_wygląd_t ) <= 0  )then
            for i := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do
              begin

                Self.torpedy_wyrzutnie_t[ i ].obrót_kąt_zablokowany_GLDisk.Visible := obrót_kąt_zablokowany_wskaźnik_widoczne_f;

                for j := 0 to Length( Self.torpedy_wyrzutnie_t[ i ].obrót_kąt_zablokowany_strzał_do ) - 1 do
                  Self.torpedy_wyrzutnie_t[ i ].obrót_kąt_zablokowany_strzał_GLDisk_t[ j ].Visible := obrót_kąt_zablokowany_strzał_wskaźnik_widoczne_f;

              end;
            //---//for i := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do
          {$endregion 'Działa normalne.'}


          {$region 'Działa wygląd.'}
          for i := 0 to Length( Self.artyleria_wygląd_t ) - 1 do
            begin

              Self.artyleria_wygląd_t[ i ].obrót_kąt_zablokowany_GLDisk.Visible := obrót_kąt_zablokowany_wskaźnik_widoczne_f;

              for j := 0 to Length( Self.artyleria_wygląd_t[ i ].obrót_kąt_zablokowany_strzał_do ) - 1 do
                Self.artyleria_wygląd_t[ i ].obrót_kąt_zablokowany_strzał_GLDisk_t[ j ].Visible := obrót_kąt_zablokowany_strzał_wskaźnik_widoczne_f;

            end;
          //---//for i := 0 to Length( Self.artyleria_wygląd_t ) - 1 do


          for i := 0 to Length( Self.działa_wygląd_t ) - 1 do
            begin

              Self.działa_wygląd_t[ i ].obrót_kąt_zablokowany_GLDisk.Visible := obrót_kąt_zablokowany_wskaźnik_widoczne_f;

              for j := 0 to Length( Self.działa_wygląd_t[ i ].obrót_kąt_zablokowany_strzał_do ) - 1 do
                Self.działa_wygląd_t[ i ].obrót_kąt_zablokowany_strzał_GLDisk_t[ j ].Visible := obrót_kąt_zablokowany_strzał_wskaźnik_widoczne_f;

            end;
          //---//for i := 0 to Length( Self.działa_wygląd_t ) - 1 do


          for i := 0 to Length( Self.torpedy_wyrzutnie_wygląd_t ) - 1 do
            begin

              Self.torpedy_wyrzutnie_wygląd_t[ i ].obrót_kąt_zablokowany_GLDisk.Visible := obrót_kąt_zablokowany_wskaźnik_widoczne_f;

              for j := 0 to Length( Self.torpedy_wyrzutnie_wygląd_t[ i ].obrót_kąt_zablokowany_strzał_do ) - 1 do
                Self.torpedy_wyrzutnie_wygląd_t[ i ].obrót_kąt_zablokowany_strzał_GLDisk_t[ j ].Visible := obrót_kąt_zablokowany_strzał_wskaźnik_widoczne_f;

            end;
          //---//for i := 0 to Length( Self.torpedy_wyrzutnie_wygląd_t ) - 1 do
          {$endregion 'Działa wygląd.'}

        end;
      //---//if   ( Self.obrót_kąt_zablokowany_wskaźnik_widoczne <> obrót_kąt_zablokowany_wskaźnik_widoczne_f ) (...)

    end
  else//if id_grupa_gracza_f = -99 then
    begin

      // Modyfikacje dotyczą statków innych graczy.

      if Self.id_grupa = id_grupa_gracza_f then
        begin

          Self.punkty_życia_dummy.Visible := punkty_życia_wskaźnik_widoczne__sojusznik_f;

        end
      else//if Self.id_grupa = id_grupa_gracza_f then
        begin

          Self.punkty_życia_dummy.Visible := punkty_życia_wskaźnik_widoczne__przeciwnik_f;

        end;
      //---//if Self.id_grupa = id_grupa_gracza_f then

    end;
  //---//if id_grupa_gracza_f = -99 then

end;//---//Funkcja Elementy_Gracza_Dostosuj().

//Funkcja Elementy_Gracza_Widoczność().
procedure TStatek.Elementy_Gracza_Widoczność( const id_grupa_gracza_f : integer; const widoczne_f : boolean );

  //Funkcja Tag_Widoczność_Wpisz() w Elementy_Gracza_Widoczność().
  function Tag_Widoczność_Wpisz() : integer;
  begin

    //
    // Funkcja zamienia boolean na integer.
    //
    // Zwraca integer.
    //

    if widoczne_f then
      Result := 1
    else//if widoczne_f then
      Result := 0;

  end;//---//Funkcja Tag_Widoczność_Wpisz() w Elementy_Gracza_Widoczność().

var
  i,
  j
    : integer;
begin//Funkcja Elementy_Gracza_Widoczność().

  //
  // Funkcja ukrywa lub wyświetla elementy statku, które widzi tylko gracz tego statku.
  //
  // Parametry:
  //   id_grupa_gracza_f - id grupy, do której należy gracz.
  //   widoczne_f:
  //     true - elementy są widoczne.
  //     false - elementy nie są widoczne.
  //

  Self.celownicza_linia.Visible := widoczne_f;


  if Self.id_grupa <> id_grupa_gracza_f then
    Self.punkty_życia__wskaźnik.Material.FrontProperties.Diffuse.Color := clrRed;


  {$region 'Działa normalne.'}
  // Jeżeli są działa ładnie wyglądające to tych strzelających nie pokazuje się. //??? Niesprawdzone.
  if   ( not widoczne_f )
    or (  Length( Self.artyleria_wygląd_t ) <= 0  )then
    for i := 0 to Length( Self.artyleria_t ) - 1 do
      begin

        Self.artyleria_t[ i ].celownik_linia.Visible := widoczne_f;
        Self.artyleria_t[ i ].celownik_linia_bez_falowania.Visible := Self.artyleria_t[ i ].celownik_linia.Visible;
        Self.artyleria_t[ i ].celownik_linia.Tag := Tag_Widoczność_Wpisz();

        for j := 0 to Length( Self.artyleria_t[ i ].lufy_t ) - 1 do
          Self.artyleria_t[ i ].lufy_t[ j ].przeładowanie_wskaźnik.Visible := widoczne_f;

      end;
    //---//for i := 0 to Length( Self.artyleria_t ) - 1 do


  if   ( not widoczne_f )
    or (  Length( Self.działa_wygląd_t ) <= 0  )then
    for i := 0 to Length( Self.działa_t ) - 1 do
      begin

        Self.działa_t[ i ].celownik_linia.Visible := widoczne_f;
        Self.działa_t[ i ].celownik_linia_bez_falowania.Visible := Self.działa_t[ i ].celownik_linia.Visible;
        Self.działa_t[ i ].celownik_linia.Tag := Tag_Widoczność_Wpisz();

        for j := 0 to Length( Self.działa_t[ i ].lufy_t ) - 1 do
          Self.działa_t[ i ].lufy_t[ j ].przeładowanie_wskaźnik.Visible := widoczne_f;

      end;
    //---//for i := 0 to Length( Self.działa_t ) - 1 do


  if   ( not widoczne_f )
    or (  Length( Self.torpedy_wyrzutnie_wygląd_t ) <= 0  )then
    for i := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do
      begin

        Self.torpedy_wyrzutnie_t[ i ].celownik_linia.Visible := widoczne_f;
        Self.torpedy_wyrzutnie_t[ i ].celownik_linia_bez_falowania.Visible := Self.torpedy_wyrzutnie_t[ i ].celownik_linia.Visible;
        Self.torpedy_wyrzutnie_t[ i ].celownik_linia.Tag := Tag_Widoczność_Wpisz();

        for j := 0 to Length( Self.torpedy_wyrzutnie_t[ i ].lufy_t ) - 1 do
          Self.torpedy_wyrzutnie_t[ i ].lufy_t[ j ].przeładowanie_wskaźnik.Visible := widoczne_f;

      end;
    //---//for i := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do
  {$endregion 'Działa normalne.'}


  {$region 'Działa wygląd.'}
  for i := 0 to Length( Self.artyleria_wygląd_t ) - 1 do
    begin

      Self.artyleria_wygląd_t[ i ].celownik_linia.Visible := widoczne_f;

      for j := 0 to Length( Self.artyleria_wygląd_t[ i ].lufy_t ) - 1 do
        Self.artyleria_wygląd_t[ i ].lufy_t[ j ].przeładowanie_wskaźnik.Visible := widoczne_f;

    end;
  //---//for i := 0 to Length( Self.artyleria_wygląd_t ) - 1 do


  for i := 0 to Length( Self.działa_wygląd_t ) - 1 do
    begin

      Self.działa_wygląd_t[ i ].celownik_linia.Visible := widoczne_f;

      for j := 0 to Length( Self.działa_wygląd_t[ i ].lufy_t ) - 1 do
        Self.działa_wygląd_t[ i ].lufy_t[ j ].przeładowanie_wskaźnik.Visible := widoczne_f;

    end;
  //---//for i := 0 to Length( Self.działa_wygląd_t ) - 1 do


  for i := 0 to Length( Self.torpedy_wyrzutnie_wygląd_t ) - 1 do
    begin

      Self.torpedy_wyrzutnie_wygląd_t[ i ].celownik_linia.Visible := widoczne_f;

      for j := 0 to Length( Self.torpedy_wyrzutnie_wygląd_t[ i ].lufy_t ) - 1 do
        Self.torpedy_wyrzutnie_wygląd_t[ i ].lufy_t[ j ].przeładowanie_wskaźnik.Visible := widoczne_f;

    end;
  //---//for i := 0 to Length( Self.torpedy_wyrzutnie_wygląd_t ) - 1 do
  {$endregion 'Działa wygląd.'}

end;//---//Funkcja Elementy_Gracza_Widoczność().

//Funkcja Punkty_Życia_Zmień().
procedure TStatek.Punkty_Życia_Zmień( const wartość_f : real );
begin

  //
  // Funkcja modyfikuje wartość punktów życia.
  //

  if Self.punkty_życia > 0 then // Gdy punkty życia są zerowe nie nalicza obrażeń.
    Self.punkty_życia := Self.punkty_życia + wartość_f;

  if Self.punkty_życia < 0 then
    Self.punkty_życia := 0;

  if Self.punkty_życia > Self.punkty_życia_maksymalne then //???
    Self.punkty_życia := Self.punkty_życia_maksymalne;

  if Self.punkty_życia_maksymalne <> 0 then
    Self.punkty_życia_procent_zostało := 100 * Self.punkty_życia / Self.punkty_życia_maksymalne
  else//if Self.punkty_życia_maksymalne <> 0 then
    Self.punkty_życia_procent_zostało := 0;

  //if Self.punkty_życia <= 0 then
  //  Self.czy_usunąć := true;

end;//---//Funkcja Punkty_Życia_Zmień().

//Funkcja Punkty_Życia_Wskaźnik_Rysuj().
procedure TStatek.Punkty_Życia_Wskaźnik_Rysuj( const gl_camera_f : TGLCamera; const wartość_liczbowa_f : integer );
begin

  //
  // Funkcja rysuje wskaźnik punktów życia.
  //
  // Parametry:
  //   gl_camera_f - kamera do której obracać wskaźnik
  //   wartość_liczbowa_f:
  //     0 - brak.
  //     1 - punkty życia.
  //     2 - punkty życia %.
  //     3 - punkty życia i punkty życia %.
  //


  if   ( gl_camera_f = nil )
    or (  not Assigned( gl_camera_f )  ) then
    Exit;

  //Self.punkty_życia_dummy.VisibleAtRunTime := true; //???
  //Self.punkty_życia_podniesienie.VisibleAtRunTime := true; //???

  // Obraca (lewo prawo) aby czoło było równolegle do ekranu.
  Self.punkty_życia_dummy.AbsoluteDirection := GLVectorGeometry.VectorMake
    (
        gl_camera_f.AbsoluteDirection.X - Self.punkty_życia_dummy.Position.X
      , 0 //gl_camera_f.AbsoluteDirection.Y - Self.punkty_życia_dummy.Position.Y
      , gl_camera_f.AbsoluteDirection.Z - Self.punkty_życia_dummy.Position.Z
    );

  if gl_camera_f.Up.Y < 0 then // Jeżeli kamera patrząc w górę lub w dół przekręci się do góry nogami to wskaźnik życia również obracał się do góry nogami.
    Self.punkty_życia_dummy.AbsoluteDirection := GLVectorGeometry.VectorNegate( Self.punkty_życia_dummy.AbsoluteDirection );
  //---// Obraca (lewo prawo) aby czoło było równolegle do ekranu.

  // Obraca (góra dół) aby czoło było równolegle do ekranu.
  Self.punkty_życia_podniesienie.PitchAngle :=
    RadToDeg( // uses Math.
        AngleBetweenVectors( // uses GLVectorGeometry.
           GLVectorGeometry.VectorMake(  gl_camera_f.AbsoluteDirection.X, Abs( gl_camera_f.AbsoluteDirection.Y ), gl_camera_f.AbsoluteDirection.Z  ),
           GLVectorGeometry.VectorMake( gl_camera_f.AbsoluteDirection.X, 0, gl_camera_f.AbsoluteDirection.Z ),
           GLVectorGeometry.VectorMake( 0, 0, 0 )
         )
      );

  if gl_camera_f.AbsoluteDirection.Y < 0 then
    Self.punkty_życia_podniesienie.PitchAngle := -Self.punkty_życia_podniesienie.PitchAngle;
  //---// Obraca (góra dół) aby czoło było równolegle do ekranu.



  // Wersja B.
  // Wylicza dobrze ale jeżeli statek odpłynie w bok ekranu to kąt między kamerą a wskaźnikiem zycia maleje.
  //
  // Oblicza odległość od wskaźnika życia do kamery w płaszczyźnie poziomej (kierunku wskaźnika życia).
  //GLVectorGeometry.SetVector( zt_vector, gl_camera_f.AbsolutePosition.X, 0, gl_camera_f.AbsolutePosition.Z ); // zt_vector : GLVectorGeometry.TVector;
  ////GLVectorGeometry.SetVector( zt_vector, gl_camera_f.AbsolutePosition.X, Self.punkty_życia_dummy.AbsoluteDirection.Y, gl_camera_f.AbsolutePosition.Z );
  //punkty_życia_procent_zostało_l := Self.punkty_życia_dummy.DistanceTo( zt_vector ); // Tutaj tymczasowo jako odległość.
  //
  //// Liczy kąt w osi X -
  ////  ze współrzędnych X, Z kamery wylicza odległość i używa tego jako współrzędnej x;
  ////  z różnicy między wysokością kamery a wysokością wskaźnika życia wylicza współrzędną y;
  ////  kąt liczony w punkcie (0, 0) miedzy osią x i wyliczonym punktem x, y.
  //Self.punkty_życia_podniesienie.PitchAngle :=
  //  -RadToDeg( // uses Math.
  //      AngleBetweenVectors( // uses GLVectorGeometry.
  //         GLVectorGeometry.VectorMake( punkty_życia_procent_zostało_l, gl_camera_f.AbsolutePosition.Y - Self.punkty_życia_dummy.AbsolutePosition.Y, 0 ),
  //         GLVectorGeometry.VectorMake( 1, 0, 0 ),
  //         GLVectorGeometry.VectorMake( 0, 0, 0 )
  //       )
  //    );
  //
  //if gl_camera_f.AbsolutePosition.Y < Self.punkty_życia_dummy.AbsolutePosition.Y then
  //  Self.punkty_życia_podniesienie.PitchAngle := -Self.punkty_życia_podniesienie.PitchAngle;
  //---// Wersja B.


  Self.punkty_życia__wskaźnik.Height := Self.punkty_życia__wskaźnik.TagFloat * Self.punkty_życia_procent_zostało * 0.01;

  case wartość_liczbowa_f of
      1 : Self.punkty_życia__napis.Text := Trim(  FormatFloat( '### ### ##0', Self.punkty_życia )  );
      2 : Self.punkty_życia__napis.Text := Trim(  FormatFloat( '### ### ##0', Self.punkty_życia_procent_zostało )  ) + '%';
      3 : Self.punkty_życia__napis.Text := Trim(  FormatFloat( '### ### ##0', Self.punkty_życia )  ) + ' (' + Trim(  FormatFloat( '### ### ##0', Self.punkty_życia_procent_zostało )  ) + '%)';
      else//case wartość_liczbowa_f of
        Self.punkty_życia__napis.Text := '';
    end;
  //---//case wartość_liczbowa_f of

end;//---//Funkcja Punkty_Życia_Wskaźnik_Rysuj().

//Funkcja Parametry_Odczytaj().
function TStatek.Parametry_Odczytaj( const dane_wszystkie_f : boolean = false ) : string;
var
  i : integer;
const
  odstęp_l_c : string = '   ';    
begin

  //
  // Funkcja wypisuje dane (parametry) statku.
  //
  // Zwraca napis z danymi (parametrami) statku.
  //
  // Parametry:
  //   dane_wszystkie_f:
  //     false - wypisuje tylko dane podstawowe.
  //     true - wypisujewszystkie dane.
  //

  Result := '';

  Result := Result + 
                'punkty_życia_maksymalne: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.punkty_życia_maksymalne )  ) +
    #13 + #10 + 'prędkość_maksymalna: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.prędkość_maksymalna )  ) +
    #13 + #10 + 'prędkość_przyspieszanie: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.prędkość_przyspieszanie )  ) +
    #13 + #10 + 'prędkość_zwalnianie: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.prędkość_zwalnianie )  ) +
    #13 + #10 + 'skręt_kąt_maksymalny: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.skręt_kąt_maksymalny )  ) +
    #13 + #10 + 'skręt_szybkość_wychylania_steru: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.skręt_szybkość_wychylania_steru )  ) +
    #13 + #10 + 'skręt_prędkość: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.skręt_prędkość )  ) +
    #13 + #10 + 'skręt_współczynnik_do_prędkości: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.skręt_współczynnik_do_prędkości )  ) +
    #13 + #10 + 'luneta_zasięg: ' + Trim(  FormatFloat( '### ### ##0', Self.luneta_zasięg )  ) +
    #13 + #10 + 'radar_zasięg: ' + Trim(  FormatFloat( '### ### ##0', Self.radar_zasięg )  ) +
    #13 + #10 + 'radio_zasięg: ' + Trim(  FormatFloat( '### ### ##0', Self.radio_zasięg )  );

  if dane_wszystkie_f then
    begin

      Result := Result +
        #13 + #10 + 'kamera_odległość_maksymalna: ' + Trim(  FormatFloat( '### ### ##0', Self.kamera_odległość_maksymalna )  ) +
        #13 + #10 + 'falowanie_bok_skręt_zakres: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.falowanie_bok_skręt_zakres )  ) +
        #13 + #10 + 'falowanie_bok_zakres: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.falowanie_bok_zakres )  ) +
        #13 + #10 + 'falowanie_góra_dół_zakres: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.falowanie_góra_dół_zakres )  ) +
        #13 + #10 + 'falowanie_przód_zakres: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.falowanie_przód_zakres )  ) +
        #13 + #10 + 'prędkość_ograniczenie: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.prędkość_ograniczenie )  ) +
        #13 + #10 + 'prędkość__kolizja_zwalnianie: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.prędkość__kolizja_zwalnianie )  ) +
        //#13 + #10 + 'siła_wpływu_kolizji: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.TagFloat )  ) +
        #13 + #10 + 'śruby ilość: ' + Trim(   FormatFloat(  '### ### ##0', Length( Self.śruby_t )  )   );
    
      for i := 0 to Length( Self.śruby_t ) - 1 do
        begin

          Result := Result +
            #13 + #10 + odstęp_l_c + Trim(  FormatFloat( '### ### ##0', i + 1 )  ) +
            #13 + #10 + odstęp_l_c + 'prędkość_obrotowa_maksymalna: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.śruby_t[ i ].prędkość_obrotowa_maksymalna )  ) +
            #13 + #10 + odstęp_l_c + 'prędkość_obrotowa_przyspieszanie: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.śruby_t[ i ].prędkość_obrotowa_przyspieszanie )  ) +
            #13 + #10 + odstęp_l_c + 'czy_obrót_lewo: ';

          if Self.śruby_t[ i ].czy_obrót_lewo then
            Result := Result +
              'tak'
          else//if Self.śruby_t[ i ].czy_obrót_lewo then
            Result := Result +
              'nie';

        end;
      //---//for i := 0 to Length( Self.śruby_t ) - 1 do
  
    end;
  //---//if dane_wszystkie_f then
  
  
  Result := Result +
    #13 + #10 + 'artyleria ilość: ' + Trim(   FormatFloat(  '### ### ##0', Length( Self.artyleria_t )  )   );  

  for i := 0 to Length( Self.artyleria_t ) - 1 do
    begin

      Result := Result +
        #13 + #10 + odstęp_l_c + Trim(  FormatFloat( '### ### ##0', i + 1 )  ) +
        Self.artyleria_t[ i ].Parametry_Odczytaj( odstęp_l_c + odstęp_l_c, dane_wszystkie_f );

    end;
  //---//for i := 0 to Length( Self.artyleria_t ) - 1 do

  
  Result := Result +
    #13 + #10 + 'działa ilość: ' + Trim(   FormatFloat(  '### ### ##0', Length( Self.działa_t )  )   );  

  for i := 0 to Length( Self.działa_t ) - 1 do
    begin

      Result := Result +
        #13 + #10 + odstęp_l_c + Trim(  FormatFloat( '### ### ##0', i + 1 )  ) +
        Self.działa_t[ i ].Parametry_Odczytaj( odstęp_l_c + odstęp_l_c, dane_wszystkie_f );

    end;
  //---//for i := 0 to Length( Self.działa_t ) - 1 do

  
  Result := Result +
    #13 + #10 + 'torpedy wyrzutnie ilość: ' + Trim(   FormatFloat(  '### ### ##0', Length( Self.torpedy_wyrzutnie_t )  )   );  

  for i := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do
    begin

      Result := Result +
        #13 + #10 + odstęp_l_c + Trim(  FormatFloat( '### ### ##0', i + 1 )  ) +
        Self.torpedy_wyrzutnie_t[ i ].Parametry_Odczytaj( odstęp_l_c + odstęp_l_c, dane_wszystkie_f );

    end;
  //---//for i := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do    

end;//---//Funkcja Parametry_Odczytaj().
{$endregion 'TStatek.'}


{$region 'TLufa.'}
//Konstruktor klasy TLufa.
constructor TLufa.Create( ATorpedy_Wyrzutnia : TTorpedy_Wyrzutnia; AStatek : TStatek; gl_collision_mmanager_f : TGLCollisionManager );
begin

  //
  // Podniesienie lufy (PitchAngle) -(minus) w górę, +(plus) w dół.
  //

  inherited Create( ATorpedy_Wyrzutnia );

  Self.statek := AStatek;

  Self.Parent := ATorpedy_Wyrzutnia.elementy_wizualne_dummy;

  Self.działo := ATorpedy_Wyrzutnia;

  Self.przeładowanie_czas_milisekundy := ATorpedy_Wyrzutnia.przeładowanie_czas_milisekundy;
  //Self.strzał_czas := Now();
  Self.strzał_czas_i := Czas_Teraz(); // Dla pierwszego załadowania.
  Self.amunicja_pobrana := false;
  Self.czy_indeks_do_strzału_lufa := false;
  Self.strzał_gotowość := false;

  Self.amunicja_rodzaj := ATorpedy_Wyrzutnia.amunicja_rodzaj;

  //Self.VisibleAtRunTime := true; //???

  Self.korpus := TGLCylinder.Create( Self );
  Self.korpus.Parent := Self;
  Self.korpus.TopRadius := 0.05;
  Self.korpus.BottomRadius := Self.korpus.TopRadius;
  Self.korpus.Height := 1.25;
  //Self.korpus.Position.Y := Self.korpus_przód.Position.Y + Self.korpus.TopRadius * 2;
  Self.korpus.PitchAngle := 90;


  Self.wylot_pozycja := TGLSphere.Create( Self );
  Self.wylot_pozycja.Parent := Self.korpus;

  Self.przeładowanie_wskaźnik := TGLSphere.Create( Self );
  Self.przeładowanie_wskaźnik.Parent := Self;

  //Self.ShowAxes := true;


  if gl_collision_mmanager_f <> nil then
    with TGLBCollision.Create( Self.korpus.Behaviours ) do
      begin

        GroupIndex := 0;
        BoundingMode := cbmCube;
        Manager := gl_collision_mmanager_f;

      end;
    //---//with TGLBCollision.Create( Self.korpus.Behaviours ) do

end;//---//Konstruktor klasy TLufa.

//Destruktor klasy TLufa.
destructor TLufa.Destroy();
var
  i : integer;
begin

  for i := 0 to Self.Count - 1 do // Razem z niewizualnymi.
    if Self.Children[ i ] is TAmunicja then
      begin

        // Jeżeli amunicja jest w lufie to zwalnia ją razem z lufa i pojawiają się błędy dostępu do pamięci.
        TAmunicja(Self.Children[ i ]).pozycja_celu := nil;
        TAmunicja(Self.Children[ i ]).pozycja_startowa.Parent := nil; // Nie zmieniać tej kolejności.
        TAmunicja(Self.Children[ i ]).Parent := nil; // Nie zmieniać tej kolejności.

        TAmunicja(Self.Children[ i ]).czy_usunąć := true;

      end;
    //---//if Self.Children[ i ] is TAmunicja then


  FreeAndNil( Self.przeładowanie_wskaźnik );
  FreeAndNil( Self.wylot_pozycja );
  FreeAndNil( Self.korpus );

  inherited;

end;//---//Destruktor klasy TLufa.

//Funkcja Dodatkowe_Elementy_Lufy_Pozycja_Ustaw().
procedure TLufa.Dodatkowe_Elementy_Lufy_Pozycja_Ustaw();
begin

  //
  // Funkcja ustawia dodatkowe elementy lufy we właściwych miejscach.
  //
  // Parametry:
  //   czy_lufa_podniesienie_kąt_ustaw_f:
  //     true - ustawi początkowy kąt podniesienia lufy.
  //     false - nie ustawi początkowego kąta podniesienia lufy (dla wyrzutni torped).
  //

  if Self.wylot_pozycja.Parent <> nil then
    begin

      //Self.wylot_pozycja.Radius := 0.05;
      Self.wylot_pozycja.Radius := TGLCylinder(Self.wylot_pozycja.Parent).TopRadius;
      Self.wylot_pozycja.Position.Y := Self.korpus.Height * 0.5 {+ Self.wylot_pozycja.Radius * 2};

    end;
  //---//if Self.wylot_pozycja.Parent <> nil then


  if Self.przeładowanie_wskaźnik.Parent <> nil then
    begin

      Self.przeładowanie_wskaźnik.Radius := TGLCylinder(Self.wylot_pozycja.Parent).TopRadius * 0.5;
      //Self.przeładowanie_wskaźnik.Position.AsVector := Self.przeładowanie_wskaźnik.AbsoluteToLocal( Self.wylot_pozycja.AbsolutePosition );

      if Self.przeładowanie_wskaźnik.Parent <> nil then
        Self.przeładowanie_wskaźnik.Position.AsVector := Self.przeładowanie_wskaźnik.Parent.AbsoluteToLocal( Self.wylot_pozycja.AbsolutePosition );

      Self.przeładowanie_wskaźnik.Position.Y := Self.przeładowanie_wskaźnik.Position.Y + Self.korpus.TopRadius + Self.przeładowanie_wskaźnik.Radius * 0.75;

      Self.przeładowanie_wskaźnik__pozycja_załadowany := Self.przeładowanie_wskaźnik.Position.AsAffineVector;
      Self.przeładowanie_wskaźnik.Move( Self.korpus.Height * 0.5 ); // Zmienia Z z minus na mniejszy minus (dodaje).
      Self.przeładowanie_wskaźnik__pozycja_rozładowany := Self.przeładowanie_wskaźnik.Position.AsAffineVector;

    end;
  //---//if Self.przeładowanie_wskaźnik.Parent <> nil then


  przeładowanie_wskaźnik__dystans_do_przesunięcia := Abs( Self.przeładowanie_wskaźnik__pozycja_załadowany.Z ) - Abs( Self.przeładowanie_wskaźnik__pozycja_rozładowany.Z );
  //przeładowanie_wskaźnik__dystans_do_przesunięcia := przeładowanie_wskaźnik__dystans_do_przesunięcia - przeładowanie_wskaźnik__dystans_do_przesunięcia * 0.01; // Lekka korekta pomniejszająca zakres aby wskaźnik za daleko się nie przesunął.


  if    ( Self.działo <> nil )
    and ( Self.działo is TDziało ) then
    begin

      // TDziało.

      Self.czy_wycelowane_podniesienie := false;

      if Self.działo is TArtyleria then
        Self.podniesienie_szybkość_modyfikator := TDziało(Self.działo).podniesienie_szybkość * 2 * Random() // Do 20% standardowej szybkości - artyleria wolno się porusza.
      else//if Self.działo is TArtyleria then
        Self.podniesienie_szybkość_modyfikator := TDziało(Self.działo).podniesienie_szybkość * Random( 3 ); // Do 30% standardowej szybkości.

    end
  else//if    ( Self.działo <> nil ) (...)
    begin

      // TTorpedy_Wyrzutnia.

      Self.czy_wycelowane_podniesienie := true;

      Self.podniesienie_szybkość_modyfikator := 0;

    end;
  //---//if    ( Self.działo <> nil ) (...)


  Self.przeładowanie_wskaźnik__pozycja_wycelowany_Y := Self.przeładowanie_wskaźnik.Position.Y;


  if    ( Self.działo <> nil )
    and ( Self.działo is TDziało ) then
    //and ( TDziało(Self.działo).czy_lufa_podnoszona ) then
    begin

      // TArtyleria, TDziało.

      // Jeżeli w schemacie wczytanym z pliku zadany kąt podniesienia jest poza zakresem unoszenia lufy.
      if TDziało(Self.działo).podniesienie_kąt_zadany > TDziało(Self.działo).podniesienie_kąt_maksymalny then
        TDziało(Self.działo).podniesienie_kąt_zadany := TDziało(Self.działo).podniesienie_kąt_maksymalny;

      if TDziało(Self.działo).podniesienie_kąt_zadany < TDziało(Self.działo).podniesienie_kąt_minimalny then
        TDziało(Self.działo).podniesienie_kąt_zadany := TDziało(Self.działo).podniesienie_kąt_minimalny;

      // Z przeciwnym znakiem gdyż -(minus) w górę, +(plus) w dół.
      Self.PitchAngle := -TDziało(Self.działo).podniesienie_kąt_zadany; // Potem zostanie nadpisany wartością ustawioną przez 'gracza'.

      TDziało(Self.działo).podniesienie_kąt_zadany_bezwzględny := TDziało(Self.działo).podniesienie_kąt_zadany;

    end;
  //---//if    ( Self.działo <> nil ) (...)

end;//---//Funkcja Dodatkowe_Elementy_Lufy_Pozycja_Ustaw().

//Funkcja Przeładowanie().
procedure TLufa.Przeładowanie( delta_czasu_f : double );
var
  milisekund_przeładowania_l : int64;
  ztr : real;
begin

  //
  // Funkcja ładuje lufę w odpowiednim czasie i ustawia jej gotowość.
  //

  if Self.działo <> nil then
    begin

      // Oznacza lufę wybraną do strzału tylko na dziale, które też jest wybrane do strzału.

      if    ( Self.czy_indeks_do_strzału_lufa )
        and ( TTorpedy_Wyrzutnia(Self.działo).czy_indeks_do_strzału ) then
        Self.przeładowanie_wskaźnik.Material.FrontProperties.Ambient.Color := clrGreenYellow //clrBlue clrGreenYellow
      else//if    ( Self.czy_indeks_do_strzału_lufa ) (...)
        Self.przeładowanie_wskaźnik.Material.FrontProperties.Ambient.Color := clrGreen;

    end;
  //---//if Self.działo <> nil then


  // Lufa osiągnęła wymagany do strzału kąt.
  if Self.czy_wycelowane_podniesienie then
    Self.przeładowanie_wskaźnik.Position.Y := Self.przeładowanie_wskaźnik__pozycja_wycelowany_Y
  else//if Self.czy_wycelowane_podniesienie then
    Self.przeładowanie_wskaźnik.Position.Y := Self.przeładowanie_wskaźnik__pozycja_wycelowany_Y - Self.przeładowanie_wskaźnik.Radius;


  //sekund_przeładowania_l := SecondsBetween( Now(), Self.strzał_czas );
  milisekund_przeładowania_l := Round(  Czas_Między_W_Milisekundach( Self.strzał_czas_i ) * Statki_Form.gra_współczynnik_prędkości_g  );


  if    ( Self.działo <> nil )
    and ( Self.działo is TDziało ) then // TArtyleria, TDziało.
    if milisekund_przeładowania_l < cofanie_wystrzał_powrót_milisekund_c then
      begin

        //ztr := ( milisekund_przeładowania_l * 100 / cofanie_wystrzał_powrót_milisekund_c * 0.01 ); // Wariant z przesuwaniem według dystansu proporcjonalnie do czasu przeładowania.
        ztr :=  ( milisekund_przeładowania_l / cofanie_wystrzał_powrót_milisekund_c ); // Wariant z przesuwaniem według dystansu proporcjonalnie do czasu przeładowania (uproszczone obliczenia).

        Self.korpus.Position.Z := TDziało(Self.działo).cofanie_wystrzał_pozycja_początkowa + TDziało(Self.działo).cofanie_wystrzał_odległość * ( 1 - ztr );

      end
    else//if milisekund_przeładowania_l < cofanie_wystrzał_powrót_milisekund_c then
      begin

        Self.korpus.Position.Z := TDziało(Self.działo).cofanie_wystrzał_pozycja_początkowa;

      end;
    //---//if milisekund_przeładowania_l < cofanie_wystrzał_powrót_milisekund_c then


  if Self.strzał_gotowość then
    Exit;


  if not Self.amunicja_pobrana then
    if    ( Self.działo <> nil )
      and ( TTorpedy_Wyrzutnia(Self.działo).amunicja_ilość > 0 ) then
      begin

        Dec( TTorpedy_Wyrzutnia(Self.działo).amunicja_ilość );
        Self.amunicja_pobrana := true;

      end
    else//if    ( Self.działo <> nil ) (...)
      begin

        // Wskazuje brak amunicji.

        Self.przeładowanie_wskaźnik.Material.FrontProperties.Ambient.Color := clrRed;
        Exit;

      end;
    //---//if    ( Self.działo <> nil ) (...)


  //if SecondsBetween( Now(), Self.strzał_czas ) >= przeładowanie_czas_milisekundy then
  if milisekund_przeładowania_l >= Self.przeładowanie_czas_milisekundy then
    begin

      strzał_gotowość := true;
      Self.przeładowanie_wskaźnik.Position.Z := Self.przeładowanie_wskaźnik__pozycja_załadowany.Z;
      Self.przeładowanie_wskaźnik.Material.FrontProperties.Ambient.Color := clrGreen;

      Exit;

    end;
  //---//if milisekund_przeładowania_l >= Self.przeładowanie_czas_milisekundy then

  //ztr := Abs( Self.przeładowanie_wskaźnik__pozycja_załadowany.Z ) - Abs( Self.przeładowanie_wskaźnik__pozycja_rozładowany.Z );
  //ztr := ztr - ztr * 0.025; // Lekka korekta pomniejszająca zakres aby wskaźnik za daleko się nie przesunął


  // Przesuwa wskaźnik załadowania od pozycji rozładowany do pozycji załadowany.
  if Self.przeładowanie_wskaźnik.Position.Z > Self.przeładowanie_wskaźnik__pozycja_załadowany.Z then
    begin

      //Self.przeładowanie_wskaźnik.Move( -ztr * delta_czasu_f / przeładowanie_czas_milisekundy );
      //Self.przeładowanie_wskaźnik.Move( -Self.przeładowanie_wskaźnik__dystans_do_przesunięcia * 1000 * delta_czasu_f / Self.przeładowanie_czas_milisekundy ); // Wariant z przesuwaniem funkcją Move().

      //ztr := ( milisekund_przeładowania_l * 100 / Self.przeładowanie_czas_milisekundy * 0.01 ); // Wariant z przesuwaniem według dystansu proporcjonalnie do czasu przeładowania.
      ztr :=  ( milisekund_przeładowania_l / Self.przeładowanie_czas_milisekundy ); // Wariant z przesuwaniem według dystansu proporcjonalnie do czasu przeładowania (uproszczone obliczenia).

      Self.przeładowanie_wskaźnik.Position.Z := Self.przeładowanie_wskaźnik__pozycja_rozładowany.Z - Self.przeładowanie_wskaźnik__dystans_do_przesunięcia * ztr;

    end;
  //---//if Self.przeładowanie_wskaźnik.Position.Z > Self.przeładowanie_wskaźnik__pozycja_załadowany.Z then

  //Statki_Form.Caption := FloatToStr( delta_czasu_f ) + ' ' + FloatToStr( sekund_przeładowania_l ) + ' ' + FloatToStr( ztr ) + ' ' + FloatToStr( Self.wylot_pozycja.Position.Z );

end;//---//Funkcja Przeładowanie().

//Funkcja Strzał().
function TLufa.Strzał( const obracaj_działa_f, podnoś_lufy_f : boolean; const cel_współrzędne_f : TAffineVector ) : boolean;
var
  rodzic_l : TGLBaseSceneObject;
begin

  //
  // Funkcja strzela z lufy i ustawia amunicję do lotu.
  //
  // Zwraca prawdę gdy wystrzeli.
  //

  Result := false;

  if   ( not Self.strzał_gotowość )
    {or ( not Self.czy_wycelowane_podniesienie )} then
    Exit;


  if podnoś_lufy_f then // Jeżeli lufy są zablokowane można strzelić mimo nie wycelowania.
    if not Self.czy_wycelowane_podniesienie then
      Exit;


  Self.amunicja_pobrana := false;
  Self.strzał_gotowość := false;
  //Self.strzał_czas := Now();
  Self.strzał_czas_i := Czas_Teraz();

  //Self.przeładowanie_wskaźnik.Move( Self.korpus.Height * 0.5 );
  Self.przeładowanie_wskaźnik.Position.Z := Self.przeładowanie_wskaźnik__pozycja_rozładowany.Z;
  Self.przeładowanie_wskaźnik.Material.FrontProperties.Ambient.Color := clrYellow;

  rodzic_l := Self;

  //while rodzic_l.HasParent do // Aby rodzicem była scena.
  //  rodzic_l := rodzic_l.Parent;

  while ( rodzic_l.HasParent ) // Aby rodzicem był Gra_Obiekty_GLDummyCube.
    and ( rodzic_l.Parent.HasParent ) do
    rodzic_l := rodzic_l.Parent;

  Statki_Form.Amunicja_Wystrzelona_Utwórz_Jeden( rodzic_l, Self, obracaj_działa_f, cel_współrzędne_f );
  //Statki_Form.Amunicja_Wystrzelona_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, Self );


  if    ( Self.działo <> nil )
    and ( Self.działo is TDziało ) then
    begin

      // TArtyleria, TDziało.

      Self.korpus.Position.Z := TDziało(Self.działo).cofanie_wystrzał_pozycja_początkowa + TDziało(Self.działo).cofanie_wystrzał_odległość;

    end;
  //---//if    ( Self.działo <> nil ) (...)


  Result := true;

end;//---//Funkcja Strzał().
{$endregion 'TLufa.'}


{$region 'TTorpedy_Wyrzutnia.'}
//Konstruktor klasy TTorpedy_Wyrzutnia.
constructor TTorpedy_Wyrzutnia.Create( AOwner : TGLBaseSceneObject; AStatek : TStatek; gl_collision_mmanager_f : TGLCollisionManager; const lufy_ilość_f : integer );
var
  i : integer;
  ztr : real;
begin

  inherited Create( AOwner );

  Self.statek := AStatek;


  //Self.indeks_w_tabeli := -1;

  Self.obrót_kierunek_zadany.Y := 0;

  Self.obrót_kąt_zadany := 0;

  Self.obrót_kąt_zablokowany_do := 0;
  Self.obrót_kąt_zablokowany_od := 0;
  Self.obrót_szybkość := 0.5;

  Self.amunicja_ilość := 1500;
  Self.celownik_linia_szerokość_obrót := 0;
  Self.lufa_ostatni_strzał_indeks := -1;
  Self.obrażenia_zadawane := 1;
  Self.przeładowanie_czas_milisekundy := 1000; // 7000 //???
  Self.skala := 1;
  Self.strzał_od_blokada_milisekundy := 750;
  Self.strzały_ilość := 0;
  Self.zasięg := 35; // 35 15 25 5

  Self.czy_indeks_do_strzału := false;
  //Self.czy_lufa_podnoszona := false;
  Self.czy_usunąć := false;
  Self.czy_wycelowany_obrót := false;

  SetLength( Self.obrót_kąt_zablokowany_strzał_do, 0 );
  SetLength( Self.obrót_kąt_zablokowany_strzał_od, 0 );

  Self.amunicja_rodzaj := ar_Torpeda;
  //Self.strzał_czas := Now();
  Self.strzał_czas_i := Czas_Teraz();

  Self.działo_strzelające := nil;

  Self.Parent := AOwner;
  Self.TurnAngle := 0;
  Self.Direction.SetVector( 0, 0, -1 );
  Self.Position.SetPoint( 0, 1, 0 );
  //Self.VisibleAtRunTime := true; //???

  Self.elementy_wizualne_dummy := TGLDummyCube.Create( Self );
  Self.elementy_wizualne_dummy.Parent := Self;
  //Self.elementy_wizualne_dummy.VisibleAtRunTime := true; //???
  //Self.elementy_wizualne_dummy.ShowAxes := true; //???

  Self.podstawa := TGLCylinder.Create( Self );
  Self.podstawa.Parent := Self.elementy_wizualne_dummy;
  Self.podstawa.TopRadius := 0.25;
  Self.podstawa.BottomRadius := Self.podstawa.TopRadius;
  Self.podstawa.Height := 0.1;
  //Self.podstawa.Position.Y := -( Self.CubeSize * 0.5 ) + Self.podstawa.Height * 0.5;
  Self.podstawa.Position.Y := Self.podstawa.Height * 0.5;

  Self.kąt_test := TGLDummyCube.Create( Self );
  Self.kąt_test.Parent := Self.elementy_wizualne_dummy;
  Self.kąt_test.Position := Self.podstawa.Position;
  Self.kąt_test.Up.SetVector( 0, 1, 0 ); //???
  //Self.kąt_test.VisibleAtRunTime := true; //???
  //Self.kąt_test.ShowAxes := true; //???


  Self.korpus := TGLCube.Create( Self );
  Self.korpus.Parent := Self.elementy_wizualne_dummy;
  Self.korpus.CubeDepth := Self.podstawa.TopRadius * 2;
  Self.korpus.CubeHeight := 0.1;
  Self.korpus.CubeWidth := Self.podstawa.TopRadius * 3;
  //Self.korpus.Position.Y := -( Self.CubeSize * 0.5 ) + Self.podstawa.Height * 2 - Self.korpus.CubeHeight * 0.5;
  Self.korpus.Position.Y := Self.podstawa.Position.Y + Self.podstawa.Height * 0.5 + Self.korpus.CubeHeight * 0.5;
  Self.korpus.TurnAngle := 0;

  Self.korpus_przód := TGLCylinder.Create( Self );
  Self.korpus_przód.Parent := Self.elementy_wizualne_dummy;
  Self.korpus_przód.TopRadius := 0.05;
  Self.korpus_przód.BottomRadius := Self.korpus_przód.TopRadius;
  Self.korpus_przód.Height := Self.korpus.CubeWidth + Self.korpus_przód.TopRadius * 2;
  Self.korpus_przód.PitchAngle := 90;
  Self.korpus_przód.RollAngle := 90;
  Self.korpus_przód.Position.Y := Self.korpus.Position.Y;
  Self.korpus_przód.Position.Z := -Self.korpus.CubeDepth * 0.5 - Self.korpus_przód.TopRadius * 0.5;


  i := lufy_ilość_f;

  if i < 1 then
    i := 1; // Ilość luf.

  SetLength( Self.lufy_t, i );

  if Length( Self.lufy_t ) > 0 then
    ztr := Self.korpus.CubeWidth / Length( lufy_t ) // Ilość miejsca na lufę.
  else//if Length( lufy_t ) > 0 then
    ztr := 0;

  for i := 0 to Length( Self.lufy_t ) - 1 do
    begin

      Self.lufy_t[ i ] := TLufa.Create( Self, Self.statek, gl_collision_mmanager_f );
      Self.lufy_t[ i ].Position.Y := Self.korpus_przód.Position.Y + Self.lufy_t[ i ].korpus.TopRadius * 2;
      Self.lufy_t[ i ].Position.X := i * ztr - Self.korpus.CubeWidth * 0.5 + ztr * 0.5 ; // Przesunięcie o pół szerokości korpusu, wyśrodkowanie na obszarze dla lufy.
      Self.lufy_t[ i ].korpus.TopRadius := 0.05;
      Self.lufy_t[ i ].korpus.BottomRadius := Self.lufy_t[ i ].korpus.TopRadius;
      Self.lufy_t[ i ].korpus.Height := 1.25;
      Self.lufy_t[ i ].Dodatkowe_Elementy_Lufy_Pozycja_Ustaw();

      if i = 0 then
        Self.lufy_t[ i ].czy_indeks_do_strzału_lufa := true;

    end;
  //---//for i := 0 to Length( Self.lufy_t ) - 1 do


  Self.celownik_linia := TGLLines.Create( Self );
  Self.celownik_linia.Parent := Self;
  Self.celownik_linia.Pickable := false;
  Self.celownik_linia.Tag := 1; // Oznacza, że element jest widoczny (1; 0 - niewidoczny).
  Self.celownik_linia.LineWidth := 0;
  Self.celownik_linia.LineColor.Color := GLColor.clrYellow;
  Self.celownik_linia.Position := Self.elementy_wizualne_dummy.Position; //Self.podstawa.Position elementy_wizualne_dummy
  Self.celownik_linia.Position.Y := Self.podstawa.Height * 0.5; // Y - w połowie wysokości podstawy.
  //Self.celownik_linia.ShowAxes := true; //???
  //Self.celownik_linia.Up.SetVector( 0, 1, 0 );
  //Self.celownik_linia.Visible := false; //???
  Self.celownik_linia.AddNode( 0, 0, 0 );
  Self.celownik_linia.AddNode( 0, 0, -Self.zasięg ); // Zasięg torpedy.

  if Length( Self.lufy_t ) > 0 then
    begin

      // Określa odległość w jakiej uzbraja się torpeda.
      Self.celownik_linia.Nodes[ 0 ].Z := Self.lufy_t[ 0 ].korpus.Height + Self.lufy_t[ 0 ].korpus.Height * 0.1;
      Self.celownik_linia.Nodes[ 0 ].Z := -( Self.celownik_linia.Nodes[ 0 ].Z + Self.celownik_linia.Nodes[ 0 ].Z * 0.3 ) * 2; // Tak samo wyliczyć wskaźnik uzbrojenia amunicji.

    end;
  //---//if Length( Self.lufy_t ) > 0 then

  Self.celownik_linia_bez_falowania := TGLLines.Create( Self );
  Self.celownik_linia_bez_falowania.Parent := AStatek;
  Self.celownik_linia_bez_falowania.Pickable := false;
  Self.celownik_linia_bez_falowania.LineWidth := Self.celownik_linia.LineWidth;
  Self.celownik_linia_bez_falowania.LineColor.Color := GLColor.clrRichBlue; //Self.celownik_linia.LineColor.Color;
  Self.celownik_linia_bez_falowania.Position := Self.elementy_wizualne_dummy.Position; //Self.podstawa.Position elementy_wizualne_dummy
  Self.celownik_linia_bez_falowania.Position.Y := Self.podstawa.Height * 0.5; // Y - w połowie wysokości podstawy.
  Self.celownik_linia_bez_falowania.AddNode( 0, 0, Self.celownik_linia.Nodes[ 0 ].Z );
  Self.celownik_linia_bez_falowania.AddNode( 0, 0, -Self.zasięg ); // Zasięg torpedy.


  Self.obrót_kąt_zablokowany_GLDisk := TGLDisk.Create( Self );
  Self.obrót_kąt_zablokowany_GLDisk.Parent := AOwner;
  Self.obrót_kąt_zablokowany_GLDisk.Pickable := false;
  Self.obrót_kąt_zablokowany_GLDisk.Direction.SetVector( 0, 1, 0 );
  Self.obrót_kąt_zablokowany_GLDisk.RollAngle := 180;
  Self.obrót_kąt_zablokowany_GLDisk.OuterRadius := 0.75;
  Self.obrót_kąt_zablokowany_GLDisk.Visible := AStatek.obrót_kąt_zablokowany_wskaźnik_widoczne;
  Self.obrót_kąt_zablokowany_GLDisk.Material.BlendingMode := bmModulate;


  if gl_collision_mmanager_f <> nil then
    begin

      with TGLBCollision.Create( Self.korpus.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.korpus.Behaviours ) do

      with TGLBCollision.Create( Self.korpus_przód.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.korpus_przód.Behaviours ) do

      with TGLBCollision.Create( Self.podstawa.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.podstawa.Behaviours ) do

    end;
  //---//if gl_collision_mmanager_f <> nil then

end;//---//Konstruktor klasy TTorpedy_Wyrzutnia.

//Destruktor klasy TTorpedy_Wyrzutnia.
destructor TTorpedy_Wyrzutnia.Destroy();
var
  i : integer;
begin

  SetLength( Self.obrót_kąt_zablokowany_strzał_do, 0 );
  SetLength( Self.obrót_kąt_zablokowany_strzał_od, 0 );


  FreeAndNil( Self.kąt_test );

  FreeAndNil( Self.podstawa );
  FreeAndNil( Self.korpus );
  FreeAndNil( Self.korpus_przód );


  for i := 0 to Length( Self.lufy_t ) - 1 do
    FreeAndNil( Self.lufy_t[ i ] );

  SetLength( Self.lufy_t, 0 );


  FreeAndNil( Self.elementy_wizualne_dummy );

  FreeAndNil( Self.celownik_linia );
  FreeAndNil( Self.celownik_linia_bez_falowania );

  FreeAndNil( Self.obrót_kąt_zablokowany_GLDisk );


  for i := 0 to Length( Self.obrót_kąt_zablokowany_strzał_GLDisk_t ) - 1 do
    FreeAndNil( Self.obrót_kąt_zablokowany_strzał_GLDisk_t[ i ] );

  SetLength( Self.obrót_kąt_zablokowany_strzał_GLDisk_t, 0 );


  inherited;

end;//---//Destruktor klasy TTorpedy_Wyrzutnia.

//Funkcja Dodatkowe_Elementy_Ustaw().
procedure TTorpedy_Wyrzutnia.Dodatkowe_Elementy_Ustaw();

  //Funkcja Kąt_Zablokowany_Obszar_Rysuj() w Dodatkowe_Elementy_Ustaw().
  function Kąt_Zablokowany_Obszar_Rysuj( gl_disk_f : TGLDisk; const kąt_do_f, kąt_od_f : real; const indeks_f : integer; const czy_obrót_kąt_zablokowany_strzał_f : boolean ) : integer;
  var
    i : integer;
    zt_gl_sphere : TGLSphere;
  begin

    gl_disk_f.Position := Self.Position;
    gl_disk_f.Position.Y := gl_disk_f.Position.Y + Self.podstawa.Height * 0.5;

    gl_disk_f.StartAngle := kąt_od_f;
    gl_disk_f.SweepAngle := 0;

    zt_gl_sphere := TGLSphere.Create( Self.Parent );

    zt_gl_sphere.TurnAngle := gl_disk_f.StartAngle;
    zt_gl_sphere.TurnAngle := zt_gl_sphere.TurnAngle + 1;


    if czy_obrót_kąt_zablokowany_strzał_f then
      begin

        // Kąt zablokowany strzał.

        gl_disk_f.Position.Y := gl_disk_f.Position.Y + 0.002 + indeks_f * 0.0001 + Random( 100 ) * 0.00001; // Jeżeli jest na tym samym poziomie co inny element to migocze.


        // Sprawdza czy kąt zablokowany strzału rozciąga się w kierunku rosnącym czy malejącym względem kąta obrót_kąt_zablokowany_od.
        if Self.Obrót_Kąt_Zablokowany_Strzału_Sprawdź( zt_gl_sphere.TurnAngle, indeks_f ) then
          Result := 1
        else//if Self.Obrót_Kąt_Zablokowany_Strzału_Sprawdź( zt_gl_sphere.TurnAngle, indeks_f ) then
          Result := -1;
        //---// Sprawdza czy kąt zablokowany strzału rozciąga się w kierunku rosnącym czy malejącym względem kąta obrót_kąt_zablokowany_od.

      end
    else//if czy_obrót_kąt_zablokowany_strzał_f then
      begin

        // Kąt zablokowany.

        gl_disk_f.Position.Y := gl_disk_f.Position.Y + 0.001 + Random( 100 ) * 0.00001; // Jeżeli jest na tym samym poziomie co inny element to migocze.


        // Sprawdza czy kąt zablokowany rozciąga się w kierunku rosnącym czy malejącym względem kąta obrót_kąt_zablokowany_od.
        if Self.Obrót_Kąt_Zablokowany_Sprawdź( zt_gl_sphere.TurnAngle ) then
          Result := 1
        else//if Self.Obrót_Kąt_Zablokowany_Sprawdź( zt_gl_sphere.TurnAngle ) then
          Result := -1;
        //---// Sprawdza czy kąt zablokowany rozciąga się w kierunku rosnącym czy malejącym względem kąta obrót_kąt_zablokowany_od.

      end;
    //---//if czy_obrót_kąt_zablokowany_strzał_f then


    zt_gl_sphere.TurnAngle := gl_disk_f.StartAngle;

    for i := -179 to 180 do
      begin

        zt_gl_sphere.TurnAngle := zt_gl_sphere.TurnAngle + Result;


        if czy_obrót_kąt_zablokowany_strzał_f then
          begin

            // Kąt zablokowany strzał.

            if Self.Obrót_Kąt_Zablokowany_Strzału_Sprawdź( zt_gl_sphere.TurnAngle, indeks_f ) then
              gl_disk_f.SweepAngle := gl_disk_f.SweepAngle + Result
            else//if Self.Obrót_Kąt_Zablokowany_Strzału_Sprawdź( zt_gl_sphere.TurnAngle, indeks_f ) then
              Break;

          end
        else//if czy_obrót_kąt_zablokowany_strzał_f then
          begin

            // Kąt zablokowany.

            if Self.Obrót_Kąt_Zablokowany_Sprawdź( zt_gl_sphere.TurnAngle ) then
              gl_disk_f.SweepAngle := gl_disk_f.SweepAngle + Result
            else//if Self.Obrót_Kąt_Zablokowany_Sprawdź( zt_gl_sphere.TurnAngle ) then
              Break;

          end;
        //---//if czy_obrót_kąt_zablokowany_strzał_f then

      end;
    //---//for i := -179 to 180 do


    FreeAndNil( zt_gl_sphere );


    // Zamiana znaków, gdyż tak się rysuje GLDisk.
    gl_disk_f.StartAngle := -gl_disk_f.StartAngle;
    gl_disk_f.SweepAngle := -gl_disk_f.SweepAngle;

  end;//---//Funkcja Kąt_Zablokowany_Obszar_Rysuj() w Dodatkowe_Elementy_Ustaw().

var
  i,
  zti
    : integer;
  //zt_gl_sphere : TGLSphere;
begin//Funkcja Dodatkowe_Elementy_Ustaw().

  //
  // Funkcja po utworzeniu i ustawieniu parametrów dostosowuje elementy działa.
  //

  // Aktualizuje dane z pliku schematu.
  Self.celownik_linia.Nodes[ 1 ].Z := -Self.zasięg;

  for i := 0 to Length( Self.lufy_t ) - 1 do
    Self.lufy_t[ i ].przeładowanie_czas_milisekundy := Self.przeładowanie_czas_milisekundy;
  //---// Aktualizuje dane z pliku schematu.


  SetLength(  Self.obrót_kąt_zablokowany_strzał_GLDisk_t, Length( Self.obrót_kąt_zablokowany_strzał_do )  );

  for i := 0 to Length( Self.obrót_kąt_zablokowany_strzał_do ) - 1 do
    begin

      Self.obrót_kąt_zablokowany_strzał_GLDisk_t[ i ] := TGLDisk.Create( Self );
      Self.obrót_kąt_zablokowany_strzał_GLDisk_t[ i ].Parent := Self.Parent;
      Self.obrót_kąt_zablokowany_strzał_GLDisk_t[ i ].Pickable := false;
      Self.obrót_kąt_zablokowany_strzał_GLDisk_t[ i ].Direction.SetVector( 0, 1, 0 );
      Self.obrót_kąt_zablokowany_strzał_GLDisk_t[ i ].RollAngle := 180;
      Self.obrót_kąt_zablokowany_strzał_GLDisk_t[ i ].OuterRadius := 0.75;
      Self.obrót_kąt_zablokowany_strzał_GLDisk_t[ i ].Visible := Self.statek.obrót_kąt_zablokowany_strzał_wskaźnik_widoczne;
      Self.obrót_kąt_zablokowany_strzał_GLDisk_t[ i ].Material.FrontProperties.Emission.Color := Self.obrót_kąt_zablokowany_GLDisk.Material.FrontProperties.Emission.Color;
      Self.obrót_kąt_zablokowany_strzał_GLDisk_t[ i ].Material.BlendingMode := bmModulate;

      if    ( Self.skala <> 1 )
        and ( Self.skala <> 0 ) then
        Self.obrót_kąt_zablokowany_strzał_GLDisk_t[ i ].Scale.Scale( Self.skala );

      Kąt_Zablokowany_Obszar_Rysuj( Self.obrót_kąt_zablokowany_strzał_GLDisk_t[ i ], Self.obrót_kąt_zablokowany_strzał_do[ i ], Self.obrót_kąt_zablokowany_strzał_od[ i ], i, true );

    end;
  //---//for i := 0 to Length( Self.obrót_kąt_zablokowany_strzał_do ) - 1 do


  if    ( Self.skala <> 1 )
    and ( Self.skala <> 0 ) then
    begin

      //Self.Scale.Scale( Self.skala );
      Self.elementy_wizualne_dummy.Scale.Scale( Self.skala );
      //Self.elementy_wizualne_dummy.Position.Y := Self.elementy_wizualne_dummy.CubeSize * 0.5;

      Self.obrót_kąt_zablokowany_GLDisk.Scale.Scale( Self.skala );

      // Zmiana hierarchii elementów nie jest już potrzebne.
      //Self.celownik_linia.Nodes[ 1 ].Z := -Self.zasięg * ( 1 / Self.skala ); // Zasięg torpedy - po przeskalowaniu linia zmieni swoją długość a zasięg nie jest skalowany.

      Self.celownik_linia.Position.Y := Self.celownik_linia.Position.Y * Self.skala;
      Self.celownik_linia.Position.Z := Self.celownik_linia.Position.Z * Self.skala;
      Self.celownik_linia.Nodes[ 0 ].Z := Self.celownik_linia.Nodes[ 0 ].Z * Self.skala;

    end;
  //---//if    ( Self.skala <> 1 ) (...)


  Self.celownik_linia_bez_falowania.Nodes[ 1 ].Z := Self.celownik_linia.Nodes[ 1 ].Z;
  //Self.celownik_linia_bez_falowania.Position.AsVector := Self.celownik_linia_bez_falowania.AbsoluteToLocal( Self.celownik_linia.AbsolutePosition );
  Self.celownik_linia_bez_falowania.Position.AsVector := Self.celownik_linia_bez_falowania.AbsoluteToLocal( Self.AbsolutePosition );


  zti := Kąt_Zablokowany_Obszar_Rysuj( Self.obrót_kąt_zablokowany_GLDisk, Self.obrót_kąt_zablokowany_do, Self.obrót_kąt_zablokowany_od, -99, false );

  {$region 'Rysuje obszar zablokowanego kąta obrotu.'}
//  zt_gl_sphere := TGLSphere.Create( Self.Parent );
//
//  Self.obrót_kąt_zablokowany_GLDisk.Position := Self.Position;
//  Self.obrót_kąt_zablokowany_GLDisk.Position.Y := Self.obrót_kąt_zablokowany_GLDisk.Position.Y + Self.podstawa.Height * 0.5;
//  Self.obrót_kąt_zablokowany_GLDisk.Position.Y := Self.obrót_kąt_zablokowany_GLDisk.Position.Y + 0.001; // Jeżeli jest na tym samym poziomie co inny element to migocze.
//
//  Self.obrót_kąt_zablokowany_GLDisk.StartAngle := Self.obrót_kąt_zablokowany_od;
//  Self.obrót_kąt_zablokowany_GLDisk.SweepAngle := 0;
//
//
//  // Sprawdza czy kąt zablokowany rozciąga się w kierunku rosnącym czy malejącym względem kąta obrót_kąt_zablokowany_od.
//  zt_gl_sphere.TurnAngle := Self.obrót_kąt_zablokowany_GLDisk.StartAngle;
//  zt_gl_sphere.TurnAngle := zt_gl_sphere.TurnAngle + 1;
//
//  if Self.Obrót_Kąt_Zablokowany_Sprawdź( zt_gl_sphere.TurnAngle ) then
//    zti := 1
//  else//if Self.Obrót_Kąt_Zablokowany_Sprawdź( zt_gl_sphere.TurnAngle ) then
//    zti := -1;
//
//  zt_gl_sphere.TurnAngle := Self.obrót_kąt_zablokowany_GLDisk.StartAngle;
//  //---// Sprawdza czy kąt zablokowany rozciąga się w kierunku rosnącym czy malejącym względem kąta obrót_kąt_zablokowany_od.
//
//  for i := -179 to 180 do
//    begin
//
//      zt_gl_sphere.TurnAngle := zt_gl_sphere.TurnAngle + zti;
//
//      if Self.Obrót_Kąt_Zablokowany_Sprawdź( zt_gl_sphere.TurnAngle ) then
//        Self.obrót_kąt_zablokowany_GLDisk.SweepAngle := Self.obrót_kąt_zablokowany_GLDisk.SweepAngle + zti
//      else
//        Break;
//
//    end;
//  //---//for i := -179 to 180 do
//
//  FreeAndNil( zt_gl_sphere );
//
//  // Zamiana znaków, gdyż tak się rysuje GLDisk.
//  Self.obrót_kąt_zablokowany_GLDisk.StartAngle := -Self.obrót_kąt_zablokowany_GLDisk.StartAngle;
//  Self.obrót_kąt_zablokowany_GLDisk.SweepAngle := -Self.obrót_kąt_zablokowany_GLDisk.SweepAngle;
  {$endregion 'Rysuje obszar zablokowanego kąta obrotu.'}

    
  // Jeżeli w schemacie wczytanym z pliku zadany kąt obrotu jest w zablokowanym zakresie.
  if Self.Obrót_Kąt_Zablokowany_Sprawdź( Self.obrót_kąt_zadany ) then
    if Abs( Self.obrót_kąt_zadany - Self.obrót_kąt_zablokowany_do ) < Abs( Self.obrót_kąt_zadany - Self.obrót_kąt_zablokowany_od ) then
      Self.obrót_kąt_zadany := Self.obrót_kąt_zablokowany_do + zti
    else//if Abs( Self.obrót_kąt_zadany - Self.obrót_kąt_zablokowany_do ) < Abs( Self.obrót_kąt_zadany - Self.obrót_kąt_zablokowany_od ) then
      Self.obrót_kąt_zadany := Self.obrót_kąt_zablokowany_od - zti;
      
  Self.TurnAngle := Self.obrót_kąt_zadany;



  
//  Self.kąt_test_obrót.Position.AsVector := Self.statek.AbsoluteToLocal( Self.podstawa.AbsolutePosition );
//
//  Self.kąt_test_podniesienie.Position.AsVector := Self.statek.AbsoluteToLocal( Self.podstawa.AbsolutePosition );
//  Self.kąt_test_podniesienie.Position.Y := Self.statek.AbsoluteToLocal( Self.korpus_przód.AbsolutePosition ).Y; // Dokładniej celuje w punkt.

end;//---//Funkcja Dodatkowe_Elementy_Ustaw().

//Funkcja Parametry_Kopiuj_Dla_Wygląd().
procedure TTorpedy_Wyrzutnia.Parametry_Kopiuj_Dla_Wygląd( const ATorpedy_Wyrzutnia : TTorpedy_Wyrzutnia );
begin

  //
  // Funkcja kopiuje parametry działa strzelającego do tego ładnie wyglądającego i dopasowuje jego wygląd.
  //

  if ATorpedy_Wyrzutnia = nil then
    Exit;


  Self.działo_strzelające := ATorpedy_Wyrzutnia;

  Self.Position := ATorpedy_Wyrzutnia.Position;
  //Self.Position.Y := Self.Position.Y + 1; //???

  //Self.AbsoluteDirection := ATorpedy_Wyrzutnia.AbsoluteDirection; // Z tym nieprawidłowo ustawia się na początku.

  Self.TurnAngle := ATorpedy_Wyrzutnia.TurnAngle;
  Self.PitchAngle := ATorpedy_Wyrzutnia.PitchAngle;
  Self.RollAngle := ATorpedy_Wyrzutnia.RollAngle;


  Self.skala := ATorpedy_Wyrzutnia.skala;

  Self.celownik_linia.Visible := false;
  Self.celownik_linia_bez_falowania.Visible := Self.celownik_linia.Visible;

  Self.Dodatkowe_Elementy_Ustaw();


  // Ukrywa działo strzelające.
  Self.działo_strzelające.elementy_wizualne_dummy.Visible := false;

//  Self.działo_strzelające.korpus.Visible := false;
//  Self.działo_strzelające.korpus_przód.Visible := false;
//  Self.działo_strzelające.podstawa.Visible := false;
//
//  for i := 0 to Length( Self.działo_strzelające.lufy_t ) - 1 do
//    Self.działo_strzelające.lufy_t[ i ].Visible := false;

end;//---//Funkcja Parametry_Kopiuj_Dla_Wygląd().

//Funkcja Parametry_Aktualizuj_Dla_Wyglądu().
procedure TTorpedy_Wyrzutnia.Parametry_Aktualizuj_Dla_Wyglądu();
var
  i : integer;
begin

  //
  // Funkcja aktualizuje parametry działa ładnie wyglądającego na podstawie tego strzelającego.
  //

  if Self.działo_strzelające = nil then
    Exit;


  Self.TurnAngle := Self.działo_strzelające.TurnAngle;

  for i := 0 to Length( Self.działo_strzelające.lufy_t ) - 1 do
    begin

      Self.lufy_t[ i ].PitchAngle := Self.działo_strzelające.lufy_t[ i ].PitchAngle;

      Self.lufy_t[ i ].przeładowanie_wskaźnik.Material.FrontProperties.Ambient.Color := Self.działo_strzelające.lufy_t[ i ].przeładowanie_wskaźnik.Material.FrontProperties.Ambient.Color;
      Self.lufy_t[ i ].przeładowanie_wskaźnik.Position.Y := Self.działo_strzelające.lufy_t[ i ].przeładowanie_wskaźnik.Position.Y;
      Self.lufy_t[ i ].przeładowanie_wskaźnik.Position.Z := Self.działo_strzelające.lufy_t[ i ].przeładowanie_wskaźnik.Position.Z;

    end;
  //---//for i := 0 to Length( Self.działo_strzelające.lufy_t ) - 1 do

end;//---//Funkcja Parametry_Aktualizuj_Dla_Wyglądu().

//Funkcja Obrót_Kąt_Zablokowany_Sprawdź().
function TTorpedy_Wyrzutnia.Obrót_Kąt_Zablokowany_Sprawdź( kąt_f : real ) : boolean;
begin

  //
  // Funkcja sprawdza czy zadana wartość kąta znajduje się w zablokowanym obszarze kąta obrotu.
  //
  // Zwraca prawdę gdy zadana wartość kąta znajduje się w zablokowanym obszarze kąta obrotu.
  //
  // Parametry:
  //   kąt_f - sprawdzana wartość kąta.
  //

  // Opis jest analogiczny jak w TTorpedy_Wyrzutnia.Obrót_Kąt_Zablokowany_Strzału_Sprawdź().


  Result := false;

  if Self.obrót_kąt_zablokowany_od = Self.obrót_kąt_zablokowany_do then
    Exit;


  // Wartości powyżej 180 przechodzą na -180, a wartości poniżej -180 przechodzą na 180.
  if kąt_f > 180 then
    kąt_f := 180
  else//if kąt_f > 180 then
    if kąt_f < -180 then
      kąt_f := -180;


  // Wartości 180 i -180 są sobie równe.
  if    (  Abs( kąt_f ) = 180  )
    and (
             (  Abs( Self.obrót_kąt_zablokowany_do ) = 180  )
          or (  Abs( Self.obrót_kąt_zablokowany_od ) = 180  )
        ) then
    begin

      Result := true;
      Exit;

    end;
  //---//if    (  Abs( kąt_f ) = 180  ) (...)


  if Self.obrót_kąt_zablokowany_od >= Self.obrót_kąt_zablokowany_do then
    begin

      // Zakres kąta obrotu 'od do' nie przechodzi przez środek rufy.

      if    ( kąt_f <= Self.obrót_kąt_zablokowany_od )
        and ( kąt_f >= Self.obrót_kąt_zablokowany_do ) then
        begin

          Result := true;

        end;
      //---//if    ( kąt_f <= Self.obrót_kąt_zablokowany_od ) (...)

    end
  else//if Self.obrót_kąt_od >= Self.obrót_kąt_do then
    begin

      // Zakres kąta obrotu 'od do' przechodzi przez środek rufy.

      if   ( kąt_f <= Self.obrót_kąt_zablokowany_od )
        or ( kąt_f >= Self.obrót_kąt_zablokowany_do ) then
        begin

          Result := true;

        end;
      //---//if    ( kąt_f <= Self.obrót_kąt_zablokowany_od ) (...)

    end;
  //---//if Self.obrót_kąt_od >= Self.obrót_kąt_do then

  //if not Result then //???
  //  Statki_Form.Caption := 'OK'
  //else
  //  Statki_Form.Caption := 'x';

end;//---//Funkcja Obrót_Kąt_Zablokowany_Sprawdź() w Obrót_Kierunek_Zmień().

//Funkcja Obrót_Zadany_Zmień().
procedure TTorpedy_Wyrzutnia.Obrót_Zadany_Zmień( const celownik_linia_widoczność_f : boolean = true );

  //Funkcja Obrót_Kąt_Zadany_Wyznacz() w Obrót_Zadany_Zmień().
  function Obrót_Kąt_Zadany_Wyznacz() : real;
  var
    //statek_obrót_kąt_l : real; // Kąt obrotu statku w poziomie (lewo prawo).
    zt_vector
    //zt_vector1
      : GLVectorGeometry.TVector; // uses GLVectorGeometry.
  begin

    //
    // Funkcja wyznacza zadany kąt obrotu względem statku.
    //
    // Zwraca zadany kąt obrotu względem statku.
    //

    GLVectorGeometry.SetVector( zt_vector, 0, 0, 0 ); // Najlepiej sprawdzać kąt w punkcie zero.
    //GLVectorGeometry.SetVector( zt_vector1, 0, 0, -1 ); // Kierunek w przód.

    //statek_obrót_kąt_l := RadToDeg(  AngleBetweenVectors( Self.statek.AbsoluteDirection, zt_vector1, zt_vector )  );

    //if Self.statek.AbsoluteDirection.X > 0 then
    //  statek_obrót_kąt_l := -statek_obrót_kąt_l;


    Result := RadToDeg(  AngleBetweenVectors( Self.statek.AbsoluteDirection, Self.obrót_kierunek_zadany, zt_vector )  );

    if Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector.X > 0 then
      Result := -Result;

    //Statki_Form.Caption := FloatToStr( Result ); //???
    //Statki_Form.Caption := FloatToStr( Self.statek.AbsoluteDirection.X ) + ' ' + FloatToStr( Self.statek.AbsoluteDirection.Z ); //???
    //Statki_Form.Caption := FloatToStr( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector.X ) + ' ' + FloatToStr( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector.Z ); //???
    //Statki_Form.Caption := FloatToStr( statek_obrót_kąt_l );
    //Statki_Form.Caption := FloatToStr( Self.statek.TurnAngle );

  end;//---//Funkcja Obrót_Kąt_Zadany_Wyznacz() w Obrót_Zadany_Zmień().

var
  odległość_kąt_zablokowany_do_l,
  odległość_kąt_zablokowany_od_l
    : real;
  //zt_vector : GLVectorGeometry.TVector; // uses GLVectorGeometry.
begin//Funkcja Obrót_Zadany_Zmień().

  //
  // Funkcja ustawia zadany kierunek obrotu na kierunek, w którym patrzy kamera (w płaszczyźnie poziomej).
  //

  //Self.obrót_kierunek_zadany.Y := 0;
  //// Wartości absolutne mają X i Z o przeciwnych znakach niż kamera.
  //Self.obrót_kierunek_zadany.X := Statki_Form.GLCamera1.AbsoluteDirection.X; //???
  //Self.obrót_kierunek_zadany.Z := Statki_Form.GLCamera1.AbsoluteDirection.Z; //???

  if Self.Parent = nil then
    Exit;

  // Namierzanie według linii celowniczej statku.

  case celowanie_tryb_g of
      ct_Linia :
        begin

          // Namierzanie równoległe do linii celowania.

          Self.obrót_kierunek_zadany.X := Self.statek.celownicza_linia.Nodes[ 1 ].X; // TStatek(Self.Parent).celownicza_linia.Nodes[ 1 ].X.
          Self.obrót_kierunek_zadany.Z := Self.statek.celownicza_linia.Nodes[ 1 ].Z;

        end;
      //---//ct_Linia :

      else//case celowanie_tryb_g of
        begin

          // Namierzanie zbieżne do punktu celowania.

          //Self.kąt_test.Direction.SetVector
          //  (   // Cel                 Obiekt celujący
          //      Statki_Form.Celowniczy_GLDummyCube.Position.X - Self.kąt_test.AbsolutePosition.X
          //    , 0
          //    , Statki_Form.Celowniczy_GLDummyCube.Position.Z - Self.kąt_test.AbsolutePosition.Z
          //  );
          // Lub.
          Self.kąt_test.Direction.SetVector
            (   // Cel                 Obiekt celujący
                Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector ).X - Self.kąt_test.AbsolutePosition.X
              , 0
              , Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Z - Self.kąt_test.AbsolutePosition.Z
            );

          Self.obrót_kierunek_zadany.X := Self.kąt_test.Direction.X;
          Self.obrót_kierunek_zadany.Z := Self.kąt_test.Direction.Z;

        end;
      //---//case celowanie_tryb_g of
    end;
  //---//case celowanie_tryb_g of


  Self.obrót_kąt_zadany := Obrót_Kąt_Zadany_Wyznacz();
  Self.obrót_kąt_zadany_bezwzględny := Self.obrót_kąt_zadany;


  // Jeżeli kąt zadany jest w zakresie zablokowanego kąta obrotu ustali wartość kąta zadanego na najbliższą mu wartość granicy zakresu zablokowanego kąta obrotu.
  if    ( Self.obrót_kąt_zablokowany_od <> Self.obrót_kąt_zablokowany_do )
    and (  Self.Obrót_Kąt_Zablokowany_Sprawdź( Self.obrót_kąt_zadany )  ) then
    begin

      odległość_kąt_zablokowany_od_l := Abs( Self.obrót_kąt_zadany - Self.obrót_kąt_zablokowany_od );
      odległość_kąt_zablokowany_do_l := Abs( Self.obrót_kąt_zadany - Self.obrót_kąt_zablokowany_do );

      // Wartość kąta obrotu nie może być równa wartości zablokowanego zakresu ( +/- Self.obrót_szybkość).
      if odległość_kąt_zablokowany_od_l < odległość_kąt_zablokowany_do_l then
        Self.obrót_kąt_zadany := Self.obrót_kąt_zablokowany_od + Self.obrót_szybkość
      else//if odległość_kąt_zablokowany_od_l < odległość_kąt_zablokowany_do_l then
        Self.obrót_kąt_zadany := Self.obrót_kąt_zablokowany_do - Self.obrót_szybkość;


      // Wartość kąta obrotu nie może przekroczyć zakresu od -180 do 180.
      if Self.obrót_kąt_zadany > 180 then
        Self.obrót_kąt_zadany := Self.obrót_kąt_zadany - 360
      else//if Self.obrót_kąt_zadany > 180 then
        if Self.obrót_kąt_zadany < -180 then
          Self.obrót_kąt_zadany := Self.obrót_kąt_zadany + 360;


      //Statki_Form.Caption := FloatToStr(  Round( odległość_kąt_zablokowany_od_l )  ) + ' ' + FloatToStr(  Round( odległość_kąt_zablokowany_do_l )  ) + ' ' + FloatToStr( Self.obrót_kąt_zadany ); //???

    end;
  //---//if    ( Self.obrót_kąt_zablokowany_od <> Self.obrót_kąt_zablokowany_do ) (...)


  //if Self.Parent <> nil then
  //  begin
  //
  //    GLVectorGeometry.SetVector( zt_vector, 0, 1, 0 );
  //    //RotateVector(  Self.obrót_kierunek_zadany, zt_vector, DegToRad( Self.statek.Kąt_Obrotu_Statku() )  );
  //    //RotateVector(  Self.obrót_kierunek_zadany, zt_vector, DegToRad( Self.statek.TurnAngle )  );
  //    //RotateVectorAroundY( Self.obrót_kierunek_zadany, Self.statek.Kąt_Obrotu_Statku() );
  //
  //  end;
  ////---//if Self.Parent <> nil then


  Self.Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( celownik_linia_widoczność_f );

end;//---//Funkcja Obrót_Zadany_Zmień().

//Funkcja Obrót_Kierunek_Zmień().
procedure TTorpedy_Wyrzutnia.Obrót_Kierunek_Zmień( const celowanie_precyzja_obrót_f : real; const broń_nie_unosi_luf_f : boolean = false );

  //Funkcja Obrót_Kierunek_Ustal() w Obrót_Kierunek_Zmień().
  function Obrót_Kierunek_Ustal() : real;

    //Funkcja Znak_Sprawdź() w Obrót_Kierunek_Ustal() w Obrót_Kierunek_Zmień().
    function Znak_Sprawdź( const liczba_f : real ) : SmallInt;
    begin

      //
      // Funkcja sprawdza znak liczby.
      //
      // Zwraca
      //  1 dla liczb dodatnich i zera oraz
      //  -1 dla liczb ujemnych.
      //

      if liczba_f >= 0 then
        Result := 1
      else//if liczba_f >= 0 then
        Result := -1;

    end;//---//Funkcja Znak_Sprawdź() w Obrót_Kierunek_Ustal() w Obrót_Kierunek_Zmień().

  var
    odległość_przez_0_l,
    odległość_przez_180_l,
    do_1,
    do_2,
    od_1,
    od_2,
    ztr_l
      : real;
  begin//Funkcja Obrót_Kierunek_Ustal() w Obrót_Kierunek_Zmień().

    //
    // Funkcja ustala, w którą stronę obracać aby najszybciej osiągnąć zadany kąt obrotu
    // uwzględnia zablokowany obszar obrotu.
    //
    // Tutaj jest mniej kodu ale chyba trudniej go zrozumieć.
    //
    // Zwraca
    //  1 obrotu w lewo
    //  -1 obrotu w prawo.
    //


    Result := 1;

    //Statki_Form.Caption := ''; //???

    if Znak_Sprawdź( Self.TurnAngle ) = Znak_Sprawdź( Self.obrót_kąt_zadany ) then
      begin

        // Znaki są takie same.

        if Self.obrót_kąt_zadany < Self.TurnAngle then
          Result := -1;

      end
    else//if Znak_Sprawdź( Self.TurnAngle ) = Znak_Sprawdź( Self.obrót_kąt_zadany ) then
      begin

        // Znaki są różne.

        odległość_przez_0_l := Abs( Self.obrót_kąt_zadany ) + Abs( Self.TurnAngle );
        odległość_przez_180_l := 180 - Abs( Self.obrót_kąt_zadany ) + 180 - Abs( Self.TurnAngle );


        // Analogiczny warunek.
        if odległość_przez_0_l <= odległość_przez_180_l then
          Result := -1;
        
        // Korygowanie dla przeciwnej strony statku.
        if Self.obrót_kąt_zadany >= 0 then
          Result := -Result;


        //// Analogiczny, skrócony warunek. // To skrócenie jest błędne.
        //if    ( odległość_przez_0_l <= odległość_przez_180_l )
        //  and ( Self.obrót_kąt_zadany < 0 ) then
        //  Result := -1;

        //Statki_Form.Caption := FloatToStr( odległość_przez_0_l ) + ' ' + FloatToStr( odległość_przez_180_l ); //???
        //Statki_Form.Caption := 'R'; //???

      end;
    //---//if Znak_Sprawdź( Self.TurnAngle ) = Znak_Sprawdź( Self.obrót_kąt_zadany ) then


    // Jeżeli ustalony kierunek obrotu przechodzi przez zablokowany zakres kąta obrotu zmieni kierunek obrotu.
    if Self.obrót_kąt_zablokowany_od = Self.obrót_kąt_zablokowany_do then
      Exit;


    //Statki_Form.Caption := ''; //???

    {$region 'Ustala zakres kątów przez który odbywa się obrót.'}
    // od_1 i do_1 określają zakres kątów z tym samym znakiem.
    // od_2 i do_2 określają zakres kątów z przeciwnym znakiem względem od_1 i do_1,
    //   są dokończeniem ruchu od 0 do zakres ruchu lub zakres ruchu do 180,
    //   gdy obie wartości są równe 0 zakres nie jest aktywny.

    if    ( Self.TurnAngle >= 0 )
      and ( Result = 1 ) then
      begin

        od_1 := Self.TurnAngle;

        if Self.obrót_kąt_zadany >= 0 then
          begin

            do_1 := Self.obrót_kąt_zadany;

            do_2 := 0;
            od_2 := 0;

          end
        else//if Self.obrót_kąt_zadany >= 0 then
          begin

            do_1 := 180;

            do_2 := Self.obrót_kąt_zadany;
            od_2 := -180;

          end;
        //---//if Self.obrót_kąt_zadany >= 0 then

      end
    else//if    ( Self.TurnAngle >= 0 ) (...)
    if    ( Self.TurnAngle >= 0 )
      and ( Result = -1 ) then
      begin

        od_1 := Self.TurnAngle;

        if Self.obrót_kąt_zadany >= 0 then
          begin

            do_1 := Self.obrót_kąt_zadany;

            do_2 := 0;
            od_2 := 0;

          end
        else//if Self.obrót_kąt_zadany >= 0 then
          begin

            do_1 := 0;

            do_2 := Self.obrót_kąt_zadany;
            od_2 := 0;

          end;
        //---//if Self.obrót_kąt_zadany >= 0 then

      end
    else//if    ( Self.TurnAngle >= 0 ) (...)
    if    ( Self.TurnAngle < 0 )
      and ( Result = 1 ) then
      begin

        od_1 := Self.TurnAngle;

        if Self.obrót_kąt_zadany < 0 then
          begin

            do_1 := Self.obrót_kąt_zadany;

            do_2 := 0;
            od_2 := 0;

          end
        else//if Self.obrót_kąt_zadany < 0 then
          begin

            do_1 := 0;

            do_2 := Self.obrót_kąt_zadany;
            od_2 := 0;

          end;
        //---//if Self.obrót_kąt_zadany < 0 then

      end
    else//if    ( Self.TurnAngle < 0 ) (...)
    if    ( Self.TurnAngle < 0 )
      and ( Result = -1 ) then
      begin

        od_1 := Self.TurnAngle;

        if Self.obrót_kąt_zadany < 0 then
          begin

            do_1 := Self.obrót_kąt_zadany;

            do_2 := 0;
            od_2 := 0;

          end
        else//if Self.obrót_kąt_zadany < 0 then
          begin

            do_1 := -180;

            do_2 := Self.obrót_kąt_zadany;
            od_2 := 180;

          end;
        //---//if Self.obrót_kąt_zadany < 0 then

      end;
    //---//if    ( Self.TurnAngle < 0 ) (...)


    // Sprawdza kolejność wartości brzegowych odcinków aby była rosnąca.
    if od_1 > do_1 then
      begin

        ztr_l := od_1;
        od_1 := do_1;
        do_1 := ztr_l;

      end;
    //---//if od_1 > do_1 then

    if od_2 > do_2 then
      begin

        ztr_l := od_2;
        od_2 := do_2;
        do_2 := ztr_l;

      end;
    //---//if od_2 > do_2 then
    {$endregion 'Ustala zakres kątów przez który odbywa się obrót.'}


    //Statki_Form.Caption := FloatToStr( Result ) + ' | ' + FloatToStr(  Round( od_1 )  ) + ' ' + FloatToStr(  Round( do_1 )  ) + ' ' + FloatToStr(  Round( od_2 )  ) + ' ' + FloatToStr(  Round( do_2 )  ); //???


    // Jeżeli obrót odbywa się przez zablokowany zakres kątów odwraca kierunek obrotu.
    if   (
               ( Self.obrót_kąt_zablokowany_do >= od_1 )
           and ( Self.obrót_kąt_zablokowany_do <= do_1 )
         )
      or (
               ( Self.obrót_kąt_zablokowany_od >= od_1 )
           and ( Self.obrót_kąt_zablokowany_od <= do_1 )
         )
      or (
               ( do_2 <> od_2 )
           and (
                    (
                          ( Self.obrót_kąt_zablokowany_do >= od_2 )
                      and ( Self.obrót_kąt_zablokowany_do <= do_2 )
                    )
                 or (
                          ( Self.obrót_kąt_zablokowany_od >= od_2 )
                      and ( Self.obrót_kąt_zablokowany_od <= do_2 )
                    )
               )
         )
    then
      begin

        Result := -Result;
        //Statki_Form.Caption := 'O ' + Statki_Form.Caption; //???

      end;
    //---//if   ( (...)

  end;//---//Funkcja Obrót_Kierunek_Ustal() w Obrót_Kierunek_Zmień().

  //Funkcja Obrót_Kierunek_Ustal_2() w Obrót_Kierunek_Zmień().
  function Obrót_Kierunek_Ustal_2() : real;

    //Funkcja Znak_Sprawdź() w Obrót_Kierunek_Ustal_2() w Obrót_Kierunek_Zmień().
    function Znak_Sprawdź( const liczba_f : real ) : SmallInt;
    begin

      //
      // Funkcja sprawdza znak liczby.
      //
      // Zwraca
      //  1 dla liczb dodatnich i zera oraz
      //  -1 dla liczb ujemnych.
      //

      if liczba_f >= 0 then
        Result := 1
      else//if liczba_f >= 0 then
        Result := -1;

    end;//---//Funkcja Znak_Sprawdź() w Obrót_Kierunek_Ustal_2() w Obrót_Kierunek_Zmień().

    //Funkcja Posortuj_Wartości() w Obrót_Kierunek_Ustal_2() w Obrót_Kierunek_Zmień().
    procedure Posortuj_Wartości( var liczba_od_f, liczba_do_f : real );
    var
      ztr_l
        : real;
    begin

      //
      // Funkcja ustawia podane liczby w kolejności rosnącej (liczba_od_f <= liczba_do_f).
      //
      // Parametry:
      //   liczba_od_f
      //   liczba_do_f
      //

      if liczba_od_f > liczba_do_f then
        begin

          ztr_l := liczba_od_f;
          liczba_od_f := liczba_do_f;
          liczba_do_f := ztr_l;

        end;
      //---//if liczba_od_f > liczba_do_f then

    end;//---//Funkcja Posortuj_Wartości() w Obrót_Kierunek_Ustal_2() w Obrót_Kierunek_Zmień().

  var
    odległość_przez_0_l,
    odległość_przez_180_l,
    do_1,
    do_2,
    do_3,
    od_1,
    od_2,
    od_3
      : real;
    czy_obrót_przez_0_l, //???
    czy_obrót_przez_zablokowany_zakres_l //???
      : boolean;
  begin//Funkcja Obrót_Kierunek_Ustal_2() w Obrót_Kierunek_Zmień().

    //
    // Funkcja ustala, w którą stronę obracać aby najszybciej osiągnąć zadany kąt obrotu,
    // uwzględnia zablokowany obszar obrotu.
    //
    // Tutaj jest więcej kodu ale chyba łatwiej go zrozumieć.
    //
    // Zwraca
    //  1 obrotu w lewo
    //  -1 obrotu w prawo.
    //

    {$region 'Określa cechy wariantów obrotów.'}
    if Znak_Sprawdź( Self.TurnAngle ) = Znak_Sprawdź( Self.obrót_kąt_zadany ) then
      begin

        // Znaki są takie same.

        if Abs( Self.TurnAngle ) >= Abs( Self.obrót_kąt_zadany ) then
          begin

            // Kąt zadany obrotu jest między kątem aktualnym a 0.

            odległość_przez_0_l := Abs( Self.TurnAngle ) - Abs( Self.obrót_kąt_zadany );
            odległość_przez_180_l := 360 - odległość_przez_0_l;


            if odległość_przez_0_l <= odległość_przez_180_l then
              begin

                // Zakresy przez 0.

                od_1 := Self.TurnAngle;
                do_1 := Self.obrót_kąt_zadany;

                do_2 := 0;
                od_2 := 0;

                od_3 := 0;
                do_3 := 0;

              end
            else//if odległość_przez_0_l <= odległość_przez_180_l then
              begin

                // Zakresy przez 180.

                od_1 := 180;

                if Self.TurnAngle < 0 then
                  od_1 := -od_1;

                do_1 := Self.TurnAngle;


                od_2 := 0;
                do_2 := 180;

                if Self.TurnAngle >= 0 then
                  do_2 := -do_2;


                od_3 := Self.obrót_kąt_zadany;
                do_3 := 0;

              end;
            //---//if odległość_przez_0_l <= odległość_przez_180_l then

          end
        else//if Abs( Self.TurnAngle ) >= Abs( Self.obrót_kąt_zadany ) then
          begin

            // Kąt zadany obrotu jest między kątem aktualnym a 180 (też -180).

            odległość_przez_180_l := Abs( Self.obrót_kąt_zadany ) - Abs( Self.TurnAngle );
            odległość_przez_0_l := 360 - odległość_przez_180_l;


            if odległość_przez_0_l <= odległość_przez_180_l then
              begin

                // Zakresy przez 0.

                od_1 := Self.TurnAngle;
                do_1 := 0;


                od_2 := 0;
                do_2 := 180;

                if Self.obrót_kąt_zadany >= 0 then
                  do_2 := -do_2;


                od_3 := 180;

                if Self.obrót_kąt_zadany < 0 then
                  od_3 := -od_3;

                do_3 := Self.obrót_kąt_zadany;

              end
            else//if odległość_przez_0_l <= odległość_przez_180_l then
              begin

                // Zakresy przez 180.

                od_1 := Self.obrót_kąt_zadany;
                do_1 := Self.TurnAngle;

                do_2 := 0;
                od_2 := 0;

                od_3 := 0;
                do_3 := 0;

              end;
            //---//if odległość_przez_0_l <= odległość_przez_180_l then

          end;
        //---//if Abs( Self.TurnAngle ) >= Abs( Self.obrót_kąt_zadany ) then

      end
    else//if Znak_Sprawdź( Self.TurnAngle ) = Znak_Sprawdź( Self.obrót_kąt_zadany ) then
      begin

        // Znaki są różne.

        if Abs( Self.TurnAngle ) >= Abs( Self.obrót_kąt_zadany ) then
          begin

            // 0 jest między kątem aktualnym a zadanym kątem obrotu.

            odległość_przez_0_l := Abs( Self.TurnAngle ) + Abs( Self.obrót_kąt_zadany );
            odległość_przez_180_l := 360 - odległość_przez_0_l;


            if odległość_przez_0_l <= odległość_przez_180_l then
              begin

                // Zakresy przez 0.

                od_1 := Self.TurnAngle;
                do_1 := 0;

                do_2 := 0;
                od_2 := Self.obrót_kąt_zadany;

                od_3 := 0;
                do_3 := 0;

              end
            else//if odległość_przez_0_l <= odległość_przez_180_l then
              begin

                // Zakresy przez 180.

                od_1 := 180;

                if Self.TurnAngle < 0 then
                  od_1 := -od_1;

                do_1 := Self.TurnAngle;


                od_2 := 180;

                if Self.obrót_kąt_zadany < 0 then
                  od_2 := -od_2;

                do_2 := Self.obrót_kąt_zadany;


                od_3 := 0;
                do_3 := 0;

              end;
            //---//if odległość_przez_0_l <= odległość_przez_180_l then

          end
        else//if Abs( Self.TurnAngle ) >= Abs( Self.obrót_kąt_zadany ) then
          begin

            // 180 (też -180) jest między kątem aktualnym a zadanym kątem obrotu.

            odległość_przez_0_l := Abs( Self.obrót_kąt_zadany ) + Abs( Self.TurnAngle );
            odległość_przez_180_l := 360 - odległość_przez_0_l;


            if odległość_przez_0_l <= odległość_przez_180_l then
              begin

                // Zakresy przez 0.

                od_1 := Self.TurnAngle;
                do_1 := 0;

                do_2 := 0;
                od_2 := Self.obrót_kąt_zadany;

                od_3 := 0;
                do_3 := 0;

              end
            else//if odległość_przez_0_l <= odległość_przez_180_l then
              begin

                // Zakresy przez 180.

                od_1 := 180;

                if Self.TurnAngle < 0 then
                  od_1 := -od_1;

                do_1 := Self.TurnAngle;


                od_2 := 180;

                if Self.obrót_kąt_zadany < 0 then
                  od_2 := -od_2;

                do_2 := Self.obrót_kąt_zadany;


                od_3 := 0;
                do_3 := 0;

              end;
            //---//if odległość_przez_0_l <= odległość_przez_180_l then

          end;
        //---//if Abs( Self.TurnAngle ) >= Abs( Self.obrót_kąt_zadany ) then

      end;
    //---//if Znak_Sprawdź( Self.TurnAngle ) = Znak_Sprawdź( Self.obrót_kąt_zadany ) then


    Posortuj_Wartości( od_1, do_1 );
    Posortuj_Wartości( od_2, do_2 );
    Posortuj_Wartości( od_3, do_3 );
    {$endregion 'Określa cechy wariantów obrotów.'}


    if odległość_przez_0_l <= odległość_przez_180_l then
      czy_obrót_przez_0_l := true
    else//if odległość_przez_0_l <= odległość_przez_180_l then
      czy_obrót_przez_0_l := false;


    // Jeżeli obrót odbywa się przez zablokowany zakres kątów odwraca kierunek obrotu.
    if    ( Self.obrót_kąt_zablokowany_od <> Self.obrót_kąt_zablokowany_do )
      and (
               (
                     ( Self.obrót_kąt_zablokowany_do >= od_1 )
                 and ( Self.obrót_kąt_zablokowany_do <= do_1 )
               )
            or (
                     ( Self.obrót_kąt_zablokowany_od >= od_1 )
                 and ( Self.obrót_kąt_zablokowany_od <= do_1 )
               )
            or (
                     ( do_2 <> od_2 )
                 and (
                          (
                                ( Self.obrót_kąt_zablokowany_do >= od_2 )
                            and ( Self.obrót_kąt_zablokowany_do <= do_2 )
                          )
                       or (
                                ( Self.obrót_kąt_zablokowany_od >= od_2 )
                            and ( Self.obrót_kąt_zablokowany_od <= do_2 )
                          )
                     )
               )
            or (
                     ( do_3 <> od_3 )
                 and (
                          (
                                ( Self.obrót_kąt_zablokowany_do >= od_3 )
                            and ( Self.obrót_kąt_zablokowany_do <= do_3 )
                          )
                       or (
                                ( Self.obrót_kąt_zablokowany_od >= od_3 )
                            and ( Self.obrót_kąt_zablokowany_od <= do_3 )
                          )
                     )
               )
          )
    then
      czy_obrót_przez_zablokowany_zakres_l := true
    else//if    ( Self.obrót_kąt_zablokowany_od <> Self.obrót_kąt_zablokowany_do ) (...)
      czy_obrót_przez_zablokowany_zakres_l  := false;


    if Self.TurnAngle >= 0 then
      begin

        //if odległość_przez_0_l <= odległość_przez_180_l then
        if czy_obrót_przez_0_l then
          Result := -1
        else//if czy_obrót_przez_0_l then
          Result := 1;

      end
    else//if Self.TurnAngle >= 0 then
      begin

        //if odległość_przez_0_l <= odległość_przez_180_l then
        if czy_obrót_przez_0_l then
          Result := 1
        else//if czy_obrót_przez_0_l then
          Result := -1;

      end;
    //---//if Self.TurnAngle >= 0 then

    if czy_obrót_przez_zablokowany_zakres_l then
      Result := -Result;


    //if czy_obrót_przez_0_l then
    //  Statki_Form.Caption := 'P_0'
    //else//if czy_obrót_przez_0_l then
    //  Statki_Form.Caption := 'P_180';


    //if czy_obrót_przez_zablokowany_zakres_l then
    //  Statki_Form.Caption := Statki_Form.Caption + ' O ';


    //Statki_Form.Caption := Statki_Form.Caption +
    //  //FloatToStr( Result ) +
    //  ' I ' + FloatToStr(  Round( od_1 )  ) + ' ' + FloatToStr(  Round( do_1 )  ) +
    //  ' II ' + FloatToStr(  Round( od_2 )  ) + ' ' + FloatToStr(  Round( do_2 )  ) +
    //  ' III ' + FloatToStr(  Round( od_3 )  ) + ' ' + FloatToStr(  Round( do_3 )  ) +
    //  //' | ' + FloatToStr(  Round( odległość_1_l )  ) + ' ' + FloatToStr(  Round( odległość_2_l )  ) +
    //  ' | ' + FloatToStr(  Round( odległość_przez_0_l )  ) + ' ' + FloatToStr(  Round( odległość_przez_180_l )  ); //???

  end;//---//Funkcja Obrót_Kierunek_Ustal_2() w Obrót_Kierunek_Zmień().

var
  ztr,
  //kąt_1,
  //kąt_2,
  kąt_do_kąt_obrócenia_l,
  kąt_do_kąt_obrócenia_bezwzględny_l,
  kąt_do_kąt_obrócenia_odległość_procent_l, // Określa jaki procent precyzji celowania stanowi aktualna różnica kąta zadanego względem kąta wycelowania (wartość ograniczana do zakresu 0 - 100).
  obrót_kierunek_l,
  obrót_szybkość_l
    : real;
  //zt_vector : GLVectorGeometry.TVector; // uses GLVectorGeometry.
begin//Funkcja Obrót_Kierunek_Zmień().

  //
  // Funkcja modyfikuje obrót.
  //
  //  Zmiana obrótu odbywa się zawsze pełną mocą i liniowo.
  //

  //if MilliSecondsBetween( Now(), Self.strzał_czas ) <= Self.strzał_od_blokada_milisekundy then
  if Czas_Między_W_Milisekundach( Self.strzał_czas_i ) <= Self.strzał_od_blokada_milisekundy then
    begin

      // Sygnalizuje, że działo jest w trakcie strzału i nie obraca się.

      if Self.czy_indeks_do_strzału then
        Self.celownik_linia.LineColor.Color := GLColor.clrLightGray // Jasny szary.
      else//if Self.czy_indeks_do_strzału then
        Self.celownik_linia.LineColor.Color := GLColor.clrBlack; // Ciemny czarny.

      Self.celownik_linia_bez_falowania.LineColor.Color := Self.celownik_linia.LineColor.Color;
      Exit;

    end;
  //---//if Czas_Między_W_Milisekundach( Self.strzał_czas_i ) <= Self.strzał_od_blokada_milisekundy then

  {$region 'Wersja 1.'}
  //GLVectorGeometry.SetVector( zt_vector, 0, 0, 0 ); // Najlepiej sprawdzać kąt w punkcie zero.
  //
  //Self.kąt_test.Up.SetVector( 0, 1, 0 ); // Jeżeli kąt testowy jest używany do wyliczania podniesienia może go obrócić.
  //
  //// Ustawia kąt bryły testowej na taki jak ma aktualnie działo.
  //Self.kąt_test.AbsoluteDirection := Self.AbsoluteDirection;
  //
  //// Sprawdza kąt między kierunkiem zadanym a kierunkiem działa.
  //kąt_1 := 180 - RadToDeg(  AngleBetweenVectors( Self.kąt_test.AbsoluteDirection, Self.obrót_kierunek_zadany, zt_vector )  );
  //
  ////Statki_Form.Caption := FloatToStr( kąt_1 );
  //
  //
  //// Obraca bryłę testową i ponownie wylicza kąt.
  ////Self.kąt_test.Turn( Self.obrót_szybkość );
  //Self.kąt_test.TurnAngle := Self.kąt_test.TurnAngle - Self.obrót_szybkość;
  //kąt_2 := 180 - RadToDeg(  AngleBetweenVectors( Self.kąt_test.AbsoluteDirection, Self.obrót_kierunek_zadany, zt_vector )  );
  //
  ////Statki_Form.Caption := Statki_Form.Caption + ' ' + FloatToStr( kąt_2 );
  //
  //// Jeżeli po obrocie kąt się zmniejsza obraca działo w tym samym kierunki, w przeciwnym wypadku obraca w przeciwną stronę.

  //if kąt_1 < Self.obrót_szybkość then // Coś jest nie tak z ustawianiem kierunków ale obrót o same kąty działa.
  //  Self.Direction.AsVector := Self.obrót_kierunek_zadany
  //else//if kąt_1 < Self.obrót_szybkość then
  {$endregion 'Wersja 1.'}


  kąt_do_kąt_obrócenia_l := Abs( Self.TurnAngle - Self.obrót_kąt_zadany );
  kąt_do_kąt_obrócenia_bezwzględny_l := Abs( Self.TurnAngle - Self.obrót_kąt_zadany_bezwzględny );


  if celowanie_precyzja_obrót_f <> 0 then
    kąt_do_kąt_obrócenia_odległość_procent_l := kąt_do_kąt_obrócenia_l * 100 / celowanie_precyzja_obrót_f
  else//if celowanie_precyzja_obrót_f <> 0 then
    kąt_do_kąt_obrócenia_odległość_procent_l := 100;


  if kąt_do_kąt_obrócenia_odległość_procent_l > 100 then
    kąt_do_kąt_obrócenia_odległość_procent_l := 100
  else//if kąt_do_kąt_obrócenia_odległość_procent_l > 100 then
  if kąt_do_kąt_obrócenia_odległość_procent_l < 0 then
    kąt_do_kąt_obrócenia_odległość_procent_l := 0;

  obrót_szybkość_l := Self.obrót_szybkość * kąt_do_kąt_obrócenia_odległość_procent_l * 0.01; // Im bliżej zadanego kąta wycelowana tym wolniej obraca bronie ale z większą precyzją.


  if kąt_do_kąt_obrócenia_l > obrót_szybkość_l * Statki_Form.gra_współczynnik_prędkości_g then
    begin

      obrót_kierunek_l := Obrót_Kierunek_Ustal();


      // Powyżej pewnej prędkości gry nie może ustawić właściwego kąta (za szybko zmienia kąt i broń drży na boki).
      ztr := obrót_szybkość_l * Statki_Form.gra_współczynnik_prędkości_g;

      if ztr > 20 then
        ztr := 20;

      ztr := ztr * obrót_kierunek_l;


      if not Obrót_Kąt_Zablokowany_Sprawdź( Self.TurnAngle + ztr ) then // Dodatkowe zabezpieczenie. //// Jeżeli obrót wykonuje się po Self.obrót_kąt_zadany_bezwzględny.
        Self.TurnAngle := Self.TurnAngle + ztr;


      {$region 'Wersja 1.'}
      //if kąt_2 < kąt_1 then
      // begin
      //
      //    //Statki_Form.Caption := Statki_Form.Caption + ' Prawo';
      //    //Self.Turn( Self.obrót_szybkość ); // Prawo.
      //
      //    if not Obrót_Kąt_Zablokowany_Sprawdź( Self.TurnAngle - Self.obrót_szybkość ) then
      //      Self.TurnAngle := Self.TurnAngle - Self.obrót_szybkość;
      //
      //  end
      //else//if kąt_2 < kąt_1 then
      //  begin
      //
      //    //Statki_Form.Caption := Statki_Form.Caption + ' Lewo';
      //    //Self.Turn( -Self.obrót_szybkość ); // Lewo.
      //
      //    if not Obrót_Kąt_Zablokowany_Sprawdź( Self.TurnAngle + Self.obrót_szybkość ) then
      //      Self.TurnAngle := Self.TurnAngle + Self.obrót_szybkość;
      //
      //  end;
      ////---//if kąt_2 < kąt_1 then
      {$endregion 'Wersja 1.'}

    end;
  //---//if kąt_do_kąt_obrócenia_l > obrót_szybkość_l * Statki_Form.gra_współczynnik_prędkości_g then


  if kąt_do_kąt_obrócenia_bezwzględny_l < obrót_szybkość_l + celowanie_precyzja_obrót_f then // Jeżeli wycelowano w obrębie zablokowanego obszaru obrotu oznacza jako nie wycelowane.
    Self.czy_wycelowany_obrót := true
  else//if kąt_do_kąt_obrócenia_bezwzględny_l < obrót_szybkość_l then
    Self.czy_wycelowany_obrót := false;


  if    ( Self.czy_wycelowany_obrót )
    and ( Self.Obrót_Kąt_Zablokowany_Strzału_Sprawdź() ) then // W martwym kącie nie oznacza jako wycelowane.
    Self.czy_wycelowany_obrót := false;


  if Self.czy_wycelowany_obrót then
    begin

      if Self.czy_indeks_do_strzału then
        Self.celownik_linia.LineColor.Color := GLColor.clrGreenYellow // Jasny zielony.
      else//if Self.czy_indeks_do_strzału then
        Self.celownik_linia.LineColor.Color := GLColor.clrGreen; // Ciemny zielony.


      if celowanie_precyzja_obrót_f <> 0 then
        begin

          // Określa jaki procent precyzji celowania stanowi aktualna różnica kąta zadanego względem kąta wycelowania (wartość ograniczana do zakresu 0 - 100).
          ztr := kąt_do_kąt_obrócenia_bezwzględny_l * 100 / celowanie_precyzja_obrót_f;

          if ztr > 100 then
            ztr := 100
          else//if ztr > 100 then
          if ztr < 0 then
            ztr := 0;
          //---// Określa jaki procent precyzji celowania stanowi aktualna różnica kąta zadanego względem kąta wycelowania (wartość ograniczana do zakresu 0 - 100).

        end
      else//if celowanie_precyzja_obrót_f <> 0 then
        ztr := 0;

      // Grubość linii jest odwrotna do procenta (im mniejszy procent tym linia grubsza).
      if broń_nie_unosi_luf_f then
        ztr := ( celownik_linia_szerokość_maksymalna__obrót_c + celownik_linia_szerokość_maksymalna__podniesienie_c ) * ( 100 - ztr ) * 0.01
      else//if broń_nie_unosi_luf_f then
        ztr := celownik_linia_szerokość_maksymalna__obrót_c * ( 100 - ztr ) * 0.01;


      Self.celownik_linia_szerokość_obrót := ztr;

    end
  else//if Self.czy_wycelowany_obrót then
    begin

      if Self.czy_indeks_do_strzału then
        Self.celownik_linia.LineColor.Color := GLColor.clrRed // Jasny czerwony.
      else//if Self.czy_indeks_do_strzału then
        Self.celownik_linia.LineColor.Color := GLColor.clrDarkPurple; // Ciemny czerwony.

      Self.celownik_linia_szerokość_obrót := ztr;

    end;
  //---//if Self.czy_wycelowany_obrót then


  Self.celownik_linia.LineWidth := Self.celownik_linia_szerokość_obrót;

  Self.celownik_linia_bez_falowania.LineColor.Color := Self.celownik_linia.LineColor.Color;
  Self.celownik_linia_bez_falowania.LineWidth := Self.celownik_linia.LineWidth;

end;//---//Funkcja Obrót_Kierunek_Zmień().

//Funkcja Strzał().
function TTorpedy_Wyrzutnia.Strzał( const czy_wszystkie_lufy_f, obracaj_działa_f, podnoś_lufy_f : boolean; var wystrzeliły_wszystkie_f : boolean; const cel_współrzędne_f : TAffineVector  ) : boolean;

  //Funkcja Strzały_Ilość_Sprawdź() w Strzał().
  procedure Strzały_Ilość_Sprawdź();
  begin

    //
    // Funkcja gdy ilość oddanych strzałów równa się ilości luf zeruje licznik ilości strzałów i oznacza, że wszystkie lufy mogły strzelać.
    //

    inc( Self.strzały_ilość );

    if Self.strzały_ilość >= Length( Self.lufy_t ) then
      begin

        wystrzeliły_wszystkie_f := true;
        Self.strzały_ilość := 0;

      end;
    //---//if Self.strzały_ilość >= Length( Self.lufy_t ) then

  end;//---//Funkcja Strzały_Ilość_Sprawdź() w Strzał().

var
  i,
  próby_strzału_ilość
    : integer;
begin//Funkcja Strzał().

  //
  // Funkcja strzela wszystkimi lufami lub ustala kolejną (następną po poprzednim strzale) gotową lufę i strzela jedną lufą.
  //
  // Zwraca prawdę gdy wystrzeli.
  //
  // Parametry:
  //   czy_wszystkie_lufy_f:
  //     true - strzał wszystkimi lufami.
  //     false - strzał jedną lufą.
  //   obracaj_działa_f
  //     true - strzela tylko gdy działo jest wycelowane.
  //     false - jeżeli działa są zablokowane można strzelić mimo nie wycelowania.
  //  wystrzeliły_wszystkie_f
  //     true - z działa wystrzelono tyle razy ile jest luf (w strzelaniu pojedynczym oznacza żeby przełączyć strzelanie na inne działo).
  //     false.
  //

  Result := false;
  wystrzeliły_wszystkie_f := false;

//  if    ( not Self.czy_wycelowany_obrót )
//    and ( not obracaj_działa_f ) then
//    Exit;

  if obracaj_działa_f then // Jeżeli działa są zablokowane można strzelić mimo nie wycelowania.
    if not Self.czy_wycelowany_obrót then
      Exit;


  if Self.Obrót_Kąt_Zablokowany_Strzału_Sprawdź() then // Nie strzela w martwym kącie.
    Exit;


  if czy_wszystkie_lufy_f then
    begin

      // Strzał wszystkimi lufami.

      for i := 0 to Length( Self.lufy_t ) - 1 do
        if    ( Self.lufy_t[ i ] <> nil )
          and ( Self.lufy_t[ i ].strzał_gotowość )
          //and ( Self.lufy_t[ i ].czy_wycelowane_podniesienie )
          and (
                   ( not obracaj_działa_f )
                or ( Self.lufy_t[ i ].czy_wycelowane_podniesienie )
              ) then
          if Self.lufy_t[ i ].Strzał( obracaj_działa_f, podnoś_lufy_f, cel_współrzędne_f ) then
            begin

              //Self.strzał_czas := Now();
              Self.strzał_czas_i := Czas_Teraz();

              Strzały_Ilość_Sprawdź();

              if not Result then
                Result := true;

            end;
          //---//if Self.lufy_t[ i ].Strzał( obracaj_działa_f, podnoś_lufy_f, cel_współrzędne_f ) then

      Self.strzały_ilość := 0;

    end
  else//if czy_wszystkie_lufy_f then
    begin

      // Strzał jedną lufą.

      próby_strzału_ilość := 1;

      i := Self.lufa_ostatni_strzał_indeks;

      inc( i );

      if i > Length( Self.lufy_t ) - 1 then
        i := 0;


      while próby_strzału_ilość <= Length( Self.lufy_t ) do
        begin

          inc( próby_strzału_ilość );


          if    ( Self.lufy_t[ i ] <> nil )
            and ( Self.lufy_t[ i ].strzał_gotowość )
            //and ( Self.lufy_t[ i ].czy_wycelowane_podniesienie )
            and (
                     ( not obracaj_działa_f )
                  or ( Self.lufy_t[ i ].czy_wycelowane_podniesienie )
                ) then
            begin

              if Self.lufy_t[ i ].Strzał( obracaj_działa_f, podnoś_lufy_f, cel_współrzędne_f ) then
                begin

                  //Self.strzał_czas := Now();
                  Self.strzał_czas_i := Czas_Teraz();
                  Self.lufa_ostatni_strzał_indeks := i;

                  Result := true;

                  Strzały_Ilość_Sprawdź();

                  // Oznacza, która lufa będzie strzelać pojedynczo jako kolejna.
                  //Self.lufy_t[ i ].czy_indeks_do_strzału_lufa := false;
                  for próby_strzału_ilość := 0 to Length( Self.lufy_t ) - 1 do
                    if    ( Self.lufy_t[ próby_strzału_ilość ] <> nil )
                      and ( Self.lufy_t[ próby_strzału_ilość ].czy_indeks_do_strzału_lufa ) then
                      begin

                        // Mogła strzelić inna lufa niż wybrana (jeżeli ta nie była gotowa).

                        Self.lufy_t[ próby_strzału_ilość ].czy_indeks_do_strzału_lufa := false;
                        Break;

                      end;
                    //---//if    ( Self.lufy_t[ próby_strzału_ilość ] <> nil ) (...)

                  inc( i );

                  if i > Length( Self.lufy_t ) - 1 then
                    i := 0;

                  Self.lufy_t[ i ].czy_indeks_do_strzału_lufa := true;
                  //---// Oznacza, która lufa będzie strzelać pojedynczo jako kolejna.

                  Exit;

                end;
              //---//if Self.lufy_t[ i ].Strzał( obracaj_działa_f, podnoś_lufy_f, cel_współrzędne_f ) then

            end
          else//if    ( Self.lufy_t[ i ] <> nil ) (...)
            begin

              inc( i );

              if i > Length( Self.lufy_t ) - 1 then
                i := 0;

            end;
          //---//if    ( Self.lufy_t[ i ] <> nil ) (...)

        end;
      //---//while próby_strzału_ilość <= Length( Self.lufy_t ) do

    end;
  //---//if czy_wszystkie_lufy_f then

end;//---//Funkcja Strzał().

//Funkcja Obrót_Kąt_Zablokowany_Strzału_Sprawdź().
function TTorpedy_Wyrzutnia.Obrót_Kąt_Zablokowany_Strzału_Sprawdź() : boolean;
var
  i : integer;
begin

  //
  // Funkcja sprawdza czy aktualny obrót znajduje się w zablokowanym kącie strzału.
  //
  // Zwraca prawdę gdy aktualny obrót znajduje się w zablokowanym kącie strzału.
  //

  Result := false;

  if   (  Length( Self.obrót_kąt_zablokowany_strzał_do ) <= 0  )
    or (  (  Length( Self.obrót_kąt_zablokowany_strzał_do ) <> Length( Self.obrót_kąt_zablokowany_strzał_od )  )  ) then
    Exit;


  for i := 0 to Length( Self.obrót_kąt_zablokowany_strzał_do ) - 1 do
    if Obrót_Kąt_Zablokowany_Strzału_Sprawdź( Self.TurnAngle, i ) then
      begin

        Result := true;
        Exit;

      end;
    //---//if Obrót_Kąt_Zablokowany_Strzału_Sprawdź( Self.TurnAngle, i ) then

end;//---//Funkcja Obrót_Kąt_Zablokowany_Strzału_Sprawdź().

//Funkcja Obrót_Kąt_Zablokowany_Strzału_Sprawdź().
function TTorpedy_Wyrzutnia.Obrót_Kąt_Zablokowany_Strzału_Sprawdź( kąt_f : real; const indeks_f : integer ) : boolean;
begin

  //
  // Funkcja sprawdza czy aktualny obrót znajduje się w zablokowanym kącie strzału.
  //
  // Zwraca prawdę gdy aktualny obrót znajduje się w zablokowanym kącie strzału.
  //

  // Kąty na około statku.
  //
  //     0
  // 90  A -90
  // 180 / -180
  //

  // Można traktować jak: czy aktualna wartość (kąt) należy do przedziału (zablokowany zakres kąta strzału).
  // 180 ___ -180
  // Wtedy 'kąt od' musi być większy od 'kąta do'.

  // W przypadku przedziału (zablokowany zakres kąta strzału) przechodzącego przez tył (rufę)
  // 0 ___ 180 | -0 ___ -180
  // można traktować jak: czy aktualna wartość (kąt) jest mniejsza od 'wartości od' (zablokowany zakres kąta strzału od)
  // lub czy aktualna wartość (kąt) jest większa od 'wartości do' (zablokowany zakres kąta strzału do).
  //
  // Aby zachować regułę, że 'wartość od' (zablokowany zakres kąta strzału od) jest pierwsza względem 'wartości do' (zablokowany zakres kąta strzału do)
  // zgodnie z kierunkiem ruchu wskazówek zegara 'wartość od' (zablokowany zakres kąta strzału od) jest ujemna, a 'wartość do' (zablokowany zakres kąta strzału do) jest dodatnia
  // i zakres przedziału (zablokowany zakres kąta strzału) przechodzi przez środek tyłu (rufy) [180 / -180].


  Result := false;

  if   (  Length( Self.obrót_kąt_zablokowany_strzał_do ) <= 0  )
    or ( indeks_f < 0 )
    or (  indeks_f > Length( Self.obrót_kąt_zablokowany_strzał_do ) - 1  )
    or (  (  Length( Self.obrót_kąt_zablokowany_strzał_do ) <> Length( Self.obrót_kąt_zablokowany_strzał_od )  )  ) then
    Exit;


  // Wartości powyżej 180 przechodzą na -180, a wartości poniżej -180 przechodzą na 180.
  if kąt_f > 180 then
    kąt_f := 180
  else//if kąt_f > 180 then
    if kąt_f < -180 then
      kąt_f := -180;


  if Self.obrót_kąt_zablokowany_strzał_od[ indeks_f ] >= Self.obrót_kąt_zablokowany_strzał_do[ indeks_f ] then
    begin

      // Zablokowany zakres kąta strzału nie przechodzi przez środek rufy.

      if    ( kąt_f <= Self.obrót_kąt_zablokowany_strzał_od[ indeks_f ] )
        and ( kąt_f >= Self.obrót_kąt_zablokowany_strzał_do[ indeks_f ] ) then
        Result := true;

    end
  else//if Self.obrót_kąt_zablokowany_strzał_od[ indeks_f ] >= Self.obrót_kąt_zablokowany_strzał_do[ indeks_f ] then
    begin

      // Zablokowany zakres kąta strzału przechodzi przez środek rufy.

      if   ( kąt_f <= Self.obrót_kąt_zablokowany_strzał_od[ indeks_f ] )
        or ( kąt_f >= Self.obrót_kąt_zablokowany_strzał_do[ indeks_f ] ) then
        Result := true;

    end;
  //---//if Self.obrót_kąt_zablokowany_strzał_od[ indeks_f ] >= Self.obrót_kąt_zablokowany_strzał_do[ i ] then

end;//---//Funkcja Obrót_Kąt_Zablokowany_Strzału_Sprawdź().

//Funkcja Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj().
procedure TTorpedy_Wyrzutnia.Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( const celownik_linia_widoczność_f : boolean = true );
begin

  //
  // Funkcja ustawia obrót linii celowniczej nieruchomej na podstawie linii celowniczej falującej.
  //

  // Pomija współrzędna uniesienia kierunku (tylko obrót).
  //Self.celownik_linia_bez_falowania.AbsoluteDirection := Self.celownik_linia.AbsoluteDirection;
  //Self.celownik_linia_bez_falowania.Direction.Y := 0;
  Self.celownik_linia_bez_falowania.AbsoluteDirection := GLVectorGeometry.VectorMake( Self.celownik_linia.AbsoluteDirection.X, 0, Self.celownik_linia.AbsoluteDirection.Z );


  if    ( Self.amunicja_rodzaj = ar_Torpeda )
    and ( Self.celownik_linia.Tag = 1 ) then
    begin

      Self.celownik_linia.Visible := false;
      Self.celownik_linia_bez_falowania.Visible := ( not Self.celownik_linia.Visible ) and celownik_linia_widoczność_f;

    end;
  //---//if    ( Self.amunicja_rodzaj = ar_Torpeda ) (...)

end;//---//Funkcja Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj().

//Funkcja Parametry_Odczytaj().
function TTorpedy_Wyrzutnia.Parametry_Odczytaj( const odstęp_f : string; const dane_wszystkie_f : boolean = false ) : string;
var
  i : integer;
begin

  //
  // Funkcja wypisuje dane (parametry).
  //
  // Zwraca napis z danymi (parametrami).
  //
  // Parametry:
  //   odstęp_f
  //   dane_wszystkie_f:
  //     false - wypisuje tylko dane podstawowe.
  //     true - wypisujewszystkie dane.
  //

  Result :=
    #13 + #10 + odstęp_f + 'lufy ilość: ' + Trim(   FormatFloat(  '### ### ##0', Length( Self.lufy_t )  )   ) +
    #13 + #10 + odstęp_f + 'obrót_kąt_zablokowany_do: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.obrót_kąt_zablokowany_do )  ) +
    #13 + #10 + odstęp_f + 'obrót_kąt_zablokowany_od: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.obrót_kąt_zablokowany_od )  ) +
    #13 + #10 + odstęp_f + 'obrót_szybkość: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.obrót_szybkość )  ) +
    #13 + #10 + odstęp_f + 'obrażenia_zadawane: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.obrażenia_zadawane )  ) +
    #13 + #10 + odstęp_f + 'zasięg: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.zasięg )  ) +
    #13 + #10 + odstęp_f + 'amunicja_ilość: ' + Trim(  FormatFloat( '### ### ##0', Self.amunicja_ilość )  ) +
    #13 + #10 + odstęp_f + 'przeładowanie_czas_milisekundy: ' + Trim(  FormatFloat( '### ### ##0', Self.przeładowanie_czas_milisekundy )  );


  for i := 0 to Length( Self.obrót_kąt_zablokowany_strzał_do ) - 1 do
    Result := Result +
      #13 + #10 + odstęp_f + odstęp_f + 'obrót_kąt_zablokowany_strzał_do ' + Trim(  FormatFloat( '### ### ##0', i + 1 )  ) + ': ' + Trim(  FormatFloat( '### ### ##0.0000', Self.obrót_kąt_zablokowany_strzał_do[ i ] )  );
            
  for i := 0 to Length( Self.obrót_kąt_zablokowany_strzał_od ) - 1 do
    Result := Result +
      #13 + #10 + odstęp_f + odstęp_f + 'obrót_kąt_zablokowany_strzał_od ' + Trim(  FormatFloat( '### ### ##0', i + 1 )  ) + ': ' + Trim(  FormatFloat( '### ### ##0.0000', Self.obrót_kąt_zablokowany_strzał_od[ i ] )  );

      
  if dane_wszystkie_f then  
    for i := 0 to Length( Self.lufy_t ) - 1 do
      Result := Result +
        #13 + #10 + odstęp_f + odstęp_f + 'przeładowanie_czas_milisekundy lufa ' + Trim(  FormatFloat( '### ### ##0', i + 1 )  ) + ': ' + Trim(  FormatFloat( '### ### ##0', Self.lufy_t[ i ].przeładowanie_czas_milisekundy )  );
      
end;//---//Funkcja Parametry_Odczytaj().
{$endregion 'TTorpedy_Wyrzutnia.'}


{$region 'TDziało.'}
//Konstruktor klasy TDziało.
constructor TDziało.Create( AOwner : TGLBaseSceneObject; AStatek : TStatek; gl_collision_mmanager_f : TGLCollisionManager; const lufy_ilość_f : integer; const lufy_podniesienie_kąt_f : real );
var
  i : integer;
  ztr : real;
begin

  inherited Create( AOwner, AStatek, gl_collision_mmanager_f, lufy_ilość_f );

  //Self.czy_lufa_podnoszona := true;

//  Self.obrót_kąt_maksymalny := 0;
//  Self.obrót_kąt_minimalny := 0;
//  Self.obrót_procent := 0;
  Self.obrót_szybkość := 0.75;
//  Self.obrót_zadany_procent := 0;

  Self.cofanie_wystrzał_odległość := 0;
  Self.cofanie_wystrzał_pozycja_początkowa := 0;

  Self.podniesienie_kąt_maksymalny := 20; // 20
  Self.podniesienie_kąt_minimalny := -10; // -10 //???
  Self.podniesienie_kąt_zadany := 0; // -(minus) w dół, +(plus) w górę.
  Self.podniesienie_kąt_zadany_bezwzględny := 0;
  Self.podniesienie_szybkość := 0.1; // 0.1 //???

  Self.amunicja_ilość := 1500;
  Self.obrażenia_zadawane := 1;
  Self.przeładowanie_czas_milisekundy := 1000; // 7000 //???
  Self.strzał_od_blokada_milisekundy := 250;
  Self.zasięg := 4; // 12 20

  Self.amunicja_rodzaj := ar_Pocisk;

  Self.czy_lot_parabolą := false;

//  Self.Parent := AStatek;
//  Self.MoveUp();
//  Self.TurnAngle := 0;
//  Self.Direction.SetVector( 0, 0, -1 );
//  Self.Position.SetPoint( 0, 1, 1 );

  //Self.VisibleAtRunTime := true;

//  Self.podstawa := TGLCylinder.Create( Self );
//  Self.podstawa.Parent := Self;
//  Self.podstawa.TopRadius := 0.25;
//  Self.podstawa.BottomRadius := Self.podstawa.TopRadius;
//  Self.podstawa.Height := 0.1;
//  Self.podstawa.Position.Y := -( Self.CubeSize / 2 ) + Self.podstawa.Height / 2;


  Self.korpus.CubeHeight := Self.podstawa.TopRadius;
  //Self.korpus.Position.Y := -( Self.CubeSize * 0.5 ) + Self.podstawa.Height * 2;
  Self.korpus.Position.Y := Self.podstawa.Position.Y + Self.podstawa.Height * 0.5 + Self.korpus.CubeHeight * 0.5;
  //Self.korpus.Visible := false; //???

  TTorpedy_Wyrzutnia(Self).korpus_przód.Visible := false;

  Self.korpus_przód := TGLCube.Create( Self );
  Self.korpus_przód.Parent := Self.elementy_wizualne_dummy;
  Self.korpus_przód.CubeDepth := Self.podstawa.TopRadius;
  Self.korpus_przód.CubeHeight := Self.podstawa.TopRadius;
  Self.korpus_przód.CubeWidth := Self.korpus.CubeWidth;
  Self.korpus_przód.PitchAngle := 45;
  Self.korpus_przód.Position.Y := Self.korpus.Position.Y;
  Self.korpus_przód.Position.Z := -Self.korpus.CubeDepth + Self.korpus_przód.CubeDepth;
  //Self.korpus_przód.Visible := false; //???

  Self.kąt_test.Position.Y := Self.korpus_przód.Position.Y; // Dokładniej celuje w punkt.


  //if Length( Self.lufy_t ) > 0 then
  //  ztr := Self.korpus.CubeWidth / Length( lufy_t ) // Ilość miejsca na lufę.
  //else//if Length( Self.lufy_t ) > 0 then
  //  ztr := 0;

  for i := 0 to Length( Self.lufy_t ) - 1 do
    begin

      Self.lufy_t[ i ].Position.Y := Self.korpus_przód.Position.Y;
      //Self.lufy_t[ i ].Position.X := i * ztr - Self.korpus.CubeWidth * 0.5 + ztr * 0.5 ; // Przesunięcie o pół szerokości korpusu, wyśrodkowanie na obszarze dla lufy.
      Self.lufy_t[ i ].Position.Z := Self.korpus_przód.Position.Z;
      Self.lufy_t[ i ].korpus.TopRadius := 0.05;
      Self.lufy_t[ i ].korpus.BottomRadius := Self.lufy_t[ i ].korpus.TopRadius;

      if Self is TArtyleria then
        Self.lufy_t[ i ].korpus.Height := 1.2
      else//if Self is TArtyleria then
        Self.lufy_t[ i ].korpus.Height := 0.6;

      Self.lufy_t[ i ].korpus.Position.Z := -Self.lufy_t[ i ].korpus.Height * 0.5;
      Self.lufy_t[ i ].Dodatkowe_Elementy_Lufy_Pozycja_Ustaw();

      ztr := lufy_podniesienie_kąt_f

    end;
  //---//for i := 0 to Length( Self.lufy_t ) - 1 do


  if Length( Self.lufy_t ) > 0 then
    begin

      Self.cofanie_wystrzał_odległość := Self.lufy_t[ 0 ].korpus.Height * 0.25;
      Self.cofanie_wystrzał_pozycja_początkowa := Self.lufy_t[ 0 ].korpus.Position.Z;

    end;
  //---//if Length( Self.lufy_t ) > 0 then


  Self.celownik_linia.Nodes[ 1 ].Z := -Self.zasięg; // Zasięg działa. Aktualizacja wartości.


  // Linia celownicza z wysokości luf.
  Self.celownik_linia.Position.Y := Self.podstawa.Height + Self.korpus.CubeHeight * 0.5; // Y - w połowie wysokości korpusu.
  Self.celownik_linia.Position.Z := Self.korpus_przód.Position.Z; // Z - przesunięte na środek przodu korpusu.
  Self.celownik_linia.Nodes[ 0 ].Z := 0; // Zawsze zaczyna się od korpusu działa.
  Self.celownik_linia_bez_falowania.Nodes[ 0 ].Z := Self.celownik_linia.Nodes[ 0 ].Z;


  if gl_collision_mmanager_f <> nil then
    with TGLBCollision.Create( Self.korpus_przód.Behaviours ) do
      begin

        GroupIndex := 0;
        BoundingMode := cbmCube;
        Manager := gl_collision_mmanager_f;

      end;
    //---//with TGLBCollision.Create( Self.korpus_przód.Behaviours ) do

end;//---//Konstruktor klasy TDziało.

//Destruktor klasy TDziało.
destructor TDziało.Destroy();
begin

  FreeAndNil( Self.podstawa );
  FreeAndNil( Self.korpus );
  FreeAndNil( Self.korpus_przód );

  inherited;

end;//---//Destruktor klasy TDziało.

//Funkcja Podniesienie_Zadane_Zmień().
procedure TDziało.Podniesienie_Zadane_Zmień( const celownik_linia_widoczność_f : boolean = true );
var
  kąt_zakres_l,
  podniesienie_procent_l,
  odległość_do_celu_l,
  ztr
    : real;
  zt_vector : GLVectorGeometry.TVector; // uses GLVectorGeometry.
  celowanie_tryb_l : TCelowanie_Tryb;
begin

  //
  // Funkcja ustawia zadany kąt podniesienia na kąt, w którym parzy kamera (w płaszczyźnie pionowej).
  // Od -90 (dół) 0 (poziomo) 90 (góra).
  //

  // Self.podniesienie_kąt_zadany; -(minus) w dół, +(plus) w górę

  // Statki_Form.GLCamera1.AbsoluteDirection.Y: -(minus) w dół, +(plus) w górę

  //Self.podniesienie_kąt_zadany := Statki_Form.GLCamera1.AbsoluteDirection.Y * 90;

  if Self.Parent = nil then
    Exit;

  // Namierzanie według linii celowniczej statku.

  Self.kąt_test.Up.SetVector( 0, 1, 0 ); // Jeżeli kąt testowy jest używany do wyliczania podniesienia może go obrócić.
  //Self.kąt_test.Position := TTorpedy_Wyrzutnia(Self).celownik_linia.Position;


  odległość_do_celu_l := Self.DistanceTo(  Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector )  );


  if Self.amunicja_rodzaj = ar_Artyleria then
    begin

      if odległość_do_celu_l > TArtyleria(Self).zasięg_od_parabola then
        celowanie_tryb_l := ct_Odległość
      else//if odległość_do_celu_l > TArtyleria(Self).zasięg_od_parabola then
        celowanie_tryb_l := celowanie_tryb_g;

    end
  else//if Self.amunicja_rodzaj = ar_Artyleria then
    celowanie_tryb_l := celowanie_tryb_g;


  case celowanie_tryb_l of
      ct_Linia :
        begin

          // Namierzanie równoległe do linii celowania.

                         // Cel                 Obiekt celujący
          zt_vector.X := Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector ).X - Self.kąt_test.AbsolutePosition.X;
          zt_vector.Y := Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Y - Self.kąt_test.AbsolutePosition.Y;
          zt_vector.Z := Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Z - Self.kąt_test.AbsolutePosition.Z;
          Self.kąt_test.AbsoluteDirection := zt_vector;

          Self.podniesienie_kąt_zadany := Self.kąt_test.AbsoluteDirection.Y * 90;

        end;
      //---//ct_Linia :

      ct_Odległość :
        begin

          // Wyznaczanie zadanego kąta według zasięgu odległości namiaru.

          kąt_zakres_l := Self.podniesienie_kąt_maksymalny - Self.podniesienie_kąt_minimalny; // Gdy kąt maksymalny jest dodatni a minimalny może być ujemny.

          if kąt_zakres_l = 0 then
            Exit;

          //odległość_do_celu_l := Self.DistanceTo(  Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector )  );

          if odległość_do_celu_l > Self.zasięg then
            odległość_do_celu_l := Self.zasięg
          else
          if odległość_do_celu_l < 0 then
            odległość_do_celu_l := 0;


          podniesienie_procent_l := 100 * odległość_do_celu_l / Self.zasięg;

          Self.podniesienie_kąt_zadany := kąt_zakres_l * podniesienie_procent_l * 0.01 + Self.podniesienie_kąt_minimalny;

          //Statki_Form.Caption := FloatToStr( Self.podniesienie_kąt_zadany );
          //Statki_Form.Caption := FloatToStr( odległość_do_celu_l ) + ' ' + FloatToStr( Self.podniesienie_kąt_zadany );

          //Self.obrót_kierunek_zadany.X := Self.statek.celownicza_linia.Nodes[ 1 ].X;
          //Self.obrót_kierunek_zadany.Z := Self.statek.celownicza_linia.Nodes[ 1 ].Z;

        end;
      //---//ct_Odległość :

      else//case celowanie_tryb_l of
        begin

          // Namierzanie zbieżne do punktu celowania.

          zt_vector.X := Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector ).X - Self.kąt_test.AbsolutePosition.X;
          zt_vector.Y := Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Y - Self.kąt_test.AbsolutePosition.Y;
          zt_vector.Z := Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Z - Self.kąt_test.AbsolutePosition.Z;
          Self.kąt_test.AbsoluteDirection := zt_vector;

          GLVectorGeometry.SetVector( zt_vector, 0, 0, 0 ); // Najlepiej sprawdzać kąt w punkcie zero.

          // Sprawdza kąt między kierunkiem zadanym a kierunkiem działa.
          ztr := 180 -
            RadToDeg(
                AngleBetweenVectors(
                   Self.kąt_test.AbsoluteDirection,
                   Self.AbsoluteDirection,
                   zt_vector
                 )
              );

          if Self.kąt_test.AbsolutePosition.Y >= Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Y then
            Self.podniesienie_kąt_zadany := -ztr
          else//if Self.kąt_test.AbsolutePosition.Y >= Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Y then
            Self.podniesienie_kąt_zadany := ztr;

        end;
      //---//case celowanie_tryb_l of
    end;
  //---//case celowanie_tryb_l of

  Self.podniesienie_kąt_zadany_bezwzględny := Self.podniesienie_kąt_zadany;

  if Self.podniesienie_kąt_zadany > Self.podniesienie_kąt_maksymalny then
    Self.podniesienie_kąt_zadany := Self.podniesienie_kąt_maksymalny
  else//if Self.podniesienie_kąt_zadany > Self.podniesienie_kąt_maksymalny then
  if Self.podniesienie_kąt_zadany < Self.podniesienie_kąt_minimalny then
    Self.podniesienie_kąt_zadany := Self.podniesienie_kąt_minimalny;


  Self.Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( celownik_linia_widoczność_f );

  //Statki_Form.Caption := FloatToStr( podniesienie_kąt_zadany );

end;//---//Funkcja Podniesienie_Zadane_Zmień().

//Funkcja Podniesienie_Kierunek_Zmień().
procedure TDziało.Podniesienie_Kierunek_Zmień( const celowanie_precyzja_podniesienie_f : real );

  //Funkcja Podniesienie_Kierunek_Zmień_Lufa() w Podniesienie_Kierunek_Zmień().
  function Podniesienie_Kierunek_Zmień_Lufa( lufa_f : TLufa ) : real;
  var
    ztr_l,
    kąt_1,
    kąt_podniesienia_aktualny_l,
    podniesienie_kąt_zadany_odległość_procent_l, // Określa jaki procent precyzji celowania stanowi aktualna różnica kąta zadanego względem kąta wycelowania (wartość ograniczana do zakresu 0 - 100).
    podniesienie_szybkość_l
      : real;
  begin

    //
    // Funkcja modyfikuje podniesienie.
    //
    //  Zmiana podniesienia odbywa się zawsze pełną mocą i liniowo.
    //
    // Zwraca wartość szerokości linii celowania odzwierciedlającą precyzję wycelowania podniesienia lufy.
    //
    //

    //lufa_f.PitchAngle  -(minus) w górę, +(plus) w dół.

    //lufa_f.AbsoluteDirection.Z: -(minus) w dół, +(plus) w górę

    ////if lufa_f.AbsoluteDirection.Z >= 0 then
    //if lufa_f.Direction.Z >= 0 then // Wariant, w którym lufa była samodzielnym cylindrem (bez obiektu dummy).
    //  kąt_podniesienia_aktualny_l := -Abs( lufa_f.PitchAngle )
    //else//if lufa_f.AbsoluteDirection.Z >= 0 then
    //  kąt_podniesienia_aktualny_l := Abs( lufa_f.PitchAngle );

    kąt_podniesienia_aktualny_l := -lufa_f.PitchAngle;
    kąt_1 := Abs( kąt_podniesienia_aktualny_l - Self.podniesienie_kąt_zadany );


    if celowanie_precyzja_podniesienie_f <> 0 then
      podniesienie_kąt_zadany_odległość_procent_l := Abs( kąt_podniesienia_aktualny_l - Self.podniesienie_kąt_zadany_bezwzględny ) * 100 / celowanie_precyzja_podniesienie_f
    else//if celowanie_precyzja_podniesienie_f <> 0 then
      podniesienie_kąt_zadany_odległość_procent_l := 100;


    if podniesienie_kąt_zadany_odległość_procent_l > 100 then
      podniesienie_kąt_zadany_odległość_procent_l := 100
    else//if podniesienie_kąt_zadany_odległość_procent_l > 100 then
    if podniesienie_kąt_zadany_odległość_procent_l < 0 then
      podniesienie_kąt_zadany_odległość_procent_l := 0;

    podniesienie_szybkość_l := Self.podniesienie_szybkość * podniesienie_kąt_zadany_odległość_procent_l * 0.01; // Im bliżej zadanego kąta wycelowana tym wolniej zmienia podniesienie luf ale z większą precyzją.


    //Statki_Form.Caption := FloatToStr( lufa_f.PitchAngle ) + ' ' + FloatToStr( lufa_f.AbsoluteDirection.Z ) + ' ' + FloatToStr( kąt_podniesienia_aktualny_l );
    //Statki_Form.Caption := FloatToStr( kąt_podniesienia_aktualny_l );
    //Statki_Form.Caption := FloatToStr( kąt_podniesienia_aktualny_l ) + ' ' + FloatToStr( Abs( kąt_podniesienia_aktualny_l - Self.podniesienie_kąt_zadany ) );


    //if kąt_1 < podniesienie_szybkość_l then // Coś jest nie tak z ustawianiem kątów ale podnoszenie działa.
    //    begin
    //
    //      lufa_f.PitchAngle := -Self.podniesienie_kąt_zadany;
    //
    //    end
    //else//if kąt_1 > podniesienie_szybkość_l then
    //if Abs( kąt_podniesienia_aktualny_l - Self.podniesienie_kąt_zadany ) > podniesienie_szybkość_l then
    if kąt_1 > podniesienie_szybkość_l * Statki_Form.gra_współczynnik_prędkości_g then
      begin

        //lufa_f.czy_wycelowane_podniesienie := false;

        // Jeżeli kąt jest mniejszy niż zadana precyzja celowania, przyjmuje się, że lufa jest podniesiona w kierunku celu.
        if kąt_1 < celowanie_precyzja_podniesienie_f then
          lufa_f.czy_wycelowane_podniesienie := true
        else//if kąt_1 < celowanie_precyzja_podniesienie_f then
          lufa_f.czy_wycelowane_podniesienie := false;


        // Powyżej pewnej prędkości gry nie może ustawić właściwego kąta (za szybko zmienia kąt i obraca lufami dookoła).
        ztr_l := ( podniesienie_szybkość_l * Statki_Form.gra_współczynnik_prędkości_g + lufa_f.podniesienie_szybkość_modyfikator * Statki_Form.gra_współczynnik_prędkości_g );

        if ztr_l > 10 then
          ztr_l := 10;


        if kąt_podniesienia_aktualny_l < Self.podniesienie_kąt_zadany then
          begin

            // Góra.
            //lufa_f.Pitch(  -( podniesienie_szybkość_l + lufa_f.podniesienie_szybkość_modyfikator )  );
            lufa_f.PitchAngle := lufa_f.PitchAngle - ztr_l;

          end
        else//if kąt_podniesienia_aktualny_l < Self.podniesienie_kąt_zadany then
          begin

            // Dół.
            //lufa_f.Pitch(  podniesienie_szybkość_l + lufa_f.podniesienie_szybkość_modyfikator );
            lufa_f.PitchAngle := lufa_f.PitchAngle + ztr_l;

          end;
        //---//if kąt_podniesienia_aktualny_l < Self.podniesienie_kąt_zadany then

      end
    else//if kąt_1 > podniesienie_szybkość_l * Statki_Form.gra_współczynnik_prędkości_g then
      lufa_f.czy_wycelowane_podniesienie := true;


    if lufa_f.czy_wycelowane_podniesienie then
      begin

        if celowanie_precyzja_podniesienie_f <> 0 then
          Result := podniesienie_kąt_zadany_odległość_procent_l
        else//if celowanie_precyzja_podniesienie_f <> 0 then
          Result := 0;

        // Grubość linii jest odwrotna do procenta (im mniejszy procent tym linia grubsza).
        Result := celownik_linia_szerokość_maksymalna__podniesienie_c * ( 100 - Result ) * 0.01;

      end
    else//if lufa_f.czy_wycelowane_podniesienie then
      Result := 0;

  end;//---//Funkcja Podniesienie_Kierunek_Zmień_Lufa() w Podniesienie_Kierunek_Zmień().

var
  i : integer;
  ztr : real;
  przynajmniej_jedna_lufa_wycelowała : boolean;
begin//Funkcja Podniesienie_Kierunek_Zmień().

  //
  // Funkcja modyfikuje podniesienie.
  //
  //  Zmiana podniesienia odbywa się zawsze pełną mocą i liniowo.
  //

  //if MilliSecondsBetween( Now(), Self.strzał_czas ) <= Self.strzał_od_blokada_milisekundy then
  if Czas_Między_W_Milisekundach( Self.strzał_czas_i ) <= Self.strzał_od_blokada_milisekundy then
      begin

      // Sygnalizuje, że działo jest w trakcie strzału i nie obraca się.

      Self.celownik_linia.LineColor.Color := GLColor.clrGray50;
      Self.celownik_linia_bez_falowania.LineColor.Color := Self.celownik_linia.LineColor.Color;
      Exit;

    end;
  //---//if Czas_Między_W_Milisekundach( Self.strzał_czas_i ) <= Self.strzał_od_blokada_milisekundy then


  ztr := 0;
  przynajmniej_jedna_lufa_wycelowała := false;

  for i := 0 to Length( Self.lufy_t ) - 1 do
    begin

      ztr := ztr +
        Podniesienie_Kierunek_Zmień_Lufa( Self.lufy_t[ i ] );

      if    ( not przynajmniej_jedna_lufa_wycelowała )
        and ( Self.lufy_t[ i ].czy_wycelowane_podniesienie ) then
        przynajmniej_jedna_lufa_wycelowała := true;

    end;
  //---//for i := 0 to Length( lufy_t ) - 1 do


  // Średnia arytmetyczna z wycelowania podniesienia wszystkich luf broni.
  if Length( Self.lufy_t ) > 0 then
    ztr := ztr / Length( Self.lufy_t );

  Self.celownik_linia.LineWidth := Self.celownik_linia_szerokość_obrót + ztr;


  // Jeżeli przynajmniej jedna lufa osiągnęła wymagany do strzału kąt to linia jest ciągła.
  if not przynajmniej_jedna_lufa_wycelowała then
    Self.celownik_linia.LinePattern := $CCCC // Punktowana.
  else//if not przynajmniej_jedna_lufa_wycelowała then
    Self.celownik_linia.LinePattern := $FFFF; // Ciągła.

  Self.celownik_linia_bez_falowania.LinePattern := Self.celownik_linia.LinePattern;
  Self.celownik_linia_bez_falowania.LineWidth := Self.celownik_linia.LineWidth;


  //if    ( Self.amunicja_rodzaj in [ ar_Pocisk ] )
  //  and ( Length( Self.lufy_t ) > 0 ) then
  //  Self.celownik_linia.PitchAngle := -Self.lufy_t[ 0 ].PitchAngle;

  if    ( Self.amunicja_rodzaj in [ ar_Artyleria, ar_Pocisk ] )
    and ( Length( Self.lufy_t ) > 0 ) then
    begin

      if Self.amunicja_rodzaj in [ ar_Pocisk ] then
        Self.celownik_linia.PitchAngle := Self.lufy_t[ 0 ].PitchAngle
      else//if Self.amunicja_rodzaj in [ ar_Pocisk ] then
        begin

          // Gdy lot pocisku jest liniowy lina celownicza wskazuje cel, gdy jest paraboliczny linia celownicza jest pozioma i wskazuje zasięg.

          if Self.DistanceTo(  Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector )  ) > TArtyleria(Self).zasięg_od_parabola then
            begin

              Self.celownik_linia.PitchAngle := 0;
              Self.czy_lot_parabolą := true;

            end
          else//if Self.DistanceTo(  Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector )  ) > TArtyleria(Self).zasięg_od_parabola then
            begin

              Self.celownik_linia.PitchAngle := Self.lufy_t[ 0 ].PitchAngle;
              Self.czy_lot_parabolą := false;

            end
          //---//if Self.DistanceTo(  Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector )  ) > TArtyleria(Self).zasięg_od_parabola then

        end;
      //---//if Self.amunicja_rodzaj in [ ar_Pocisk ] then

    end;
  //---//if    ( Self.amunicja_rodzaj in [ ar_Artyleria, ar_Pocisk ] ) (..)

end;//---//Funkcja Podniesienie_Kierunek_Zmień().

//Funkcja Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj().
procedure TDziało.Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( const celownik_linia_widoczność_f : boolean = true );
begin

  //
  // Funkcja ustawia kąt podniesienia linii celowniczej nieruchomej na podstawie linii celowniczej falującej.
  //

  if not Self.czy_lot_parabolą then
    Self.celownik_linia_bez_falowania.Direction.Y := Self.celownik_linia.AbsoluteDirection.Y
    //Self.celownik_linia_bez_falowania.AbsoluteDirection := Self.celownik_linia.AbsoluteDirection
  else//if not Self.czy_lot_parabolą then
    Self.celownik_linia_bez_falowania.Direction.Y := 0; // Jeżeli nie obraca dział linia się nie wypoziomuje.


  if Self.celownik_linia.Tag = 1 then
    begin

      Self.celownik_linia.Visible := ( not Self.czy_lot_parabolą ) and celownik_linia_widoczność_f;
      Self.celownik_linia_bez_falowania.Visible := ( not Self.celownik_linia.Visible ) and celownik_linia_widoczność_f;

    end;
  //---//if Self.celownik_linia.Tag = 1 then

end;//---//Funkcja Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj().

//Funkcja Parametry_Odczytaj().
function TDziało.Parametry_Odczytaj( const odstęp_f : string; const dane_wszystkie_f : boolean = false ) : string;
begin

  //
  // Funkcja wypisuje dane (parametry).
  //
  // Zwraca napis z danymi (parametrami).
  //
  // Parametry:
  //   odstęp_f
  //   dane_wszystkie_f:
  //     false - wypisuje tylko dane podstawowe.
  //     true - wypisujewszystkie dane.
  //

  Result :=
    TTorpedy_Wyrzutnia(Self).Parametry_Odczytaj( odstęp_f ) +
    #13 + #10 + odstęp_f + 'podniesienie_kąt_maksymalny: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.podniesienie_kąt_maksymalny )  ) +
    #13 + #10 + odstęp_f + 'podniesienie_kąt_minimalny: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.podniesienie_kąt_minimalny )  ) +
    #13 + #10 + odstęp_f + 'podniesienie_szybkość: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.podniesienie_szybkość )  );
    
end;//---//Funkcja Parametry_Odczytaj().
{$endregion 'TDziało.'}


{$region 'TArtyleria.'}
//Konstruktor klasy TArtyleria.
constructor TArtyleria.Create( AOwner : TGLBaseSceneObject; AStatek : TStatek; gl_collision_mmanager_f : TGLCollisionManager; const lufy_ilość_f : integer; const lufy_podniesienie_kąt_f : real );
begin

  inherited Create( AOwner, AStatek, gl_collision_mmanager_f, lufy_ilość_f, lufy_podniesienie_kąt_f );


//  Self.obrót_kąt_maksymalny := 0;
//  Self.obrót_kąt_minimalny := 0;
//  Self.obrót_procent := 0;
  Self.obrót_szybkość := 0.05; // 0.05
//  Self.obrót_zadany_procent := 0;

  Self.podniesienie_kąt_maksymalny := 60; // 60 // Dla kąta innego niż 60 maksymalny zasięg pocisk osiąga na dnie.
  Self.podniesienie_kąt_minimalny := -10;
  Self.podniesienie_kąt_zadany := 0;
  Self.podniesienie_kąt_zadany_bezwzględny := 0;
  Self.podniesienie_szybkość := 0.01; // 0.01 //???

  Self.amunicja_ilość := 1500;
  Self.obrażenia_zadawane := 1;
  Self.przeładowanie_czas_milisekundy := 3000; // 7000 //???
  Self.strzał_od_blokada_milisekundy := 500;
  Self.zasięg := 32; // 12 20
  Self.zasięg_od_parabola := Self.zasięg * 0.3; // 30 procent całkowitego zasięgu.

  Self.amunicja_rodzaj := ar_Artyleria;

  Self.celownik_linia.Nodes[ 1 ].Z := -Self.zasięg; // Zasięg działa. Aktualizacja wartości.
  Self.celownik_linia_bez_falowania.Nodes[ 1 ].Z := Self.celownik_linia.Nodes[ 1 ].Z;

end;//---//Konstruktor klasy TArtyleria.

//Funkcja Parametry_Odczytaj().
function TArtyleria.Parametry_Odczytaj( const odstęp_f : string; const dane_wszystkie_f : boolean = false ) : string;
begin

  //
  // Funkcja wypisuje dane (parametry).
  //
  // Zwraca napis z danymi (parametrami).
  //
  // Parametry:
  //   odstęp_f
  //   dane_wszystkie_f:
  //     false - wypisuje tylko dane podstawowe.
  //     true - wypisujewszystkie dane.
  //

  Result :=
    TDziało(Self).Parametry_Odczytaj( odstęp_f ) +
        #13 + #10 + odstęp_f + 'zasięg_od_parabola: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.zasięg_od_parabola )  );
    
end;//---//Funkcja Parametry_Odczytaj().
{$endregion 'TArtyleria.'}


{$region 'TAmunicja.'}
//Konstruktor klasy TAmunicja.
constructor TAmunicja.Create( AOwner : TGLBaseSceneObject; ALufa : TLufa; const obracaj_działa_f : boolean; cel_współrzędne_f : TAffineVector; gl_collision_mmanager_f : TGLCollisionManager );

  //Funkcja Równanie_Paraboli_3_Punkty() w Konstruktor klasy TAmunicja.
  function Równanie_Paraboli_3_Punkty( x1, y1, x2, y2, x3, y3 : real; var a, b, c : real ) : boolean;
  var
    sx1,
    sx2,
    sx3
      : real;
  begin

    Exit; // Obliczenia dla lotu parabolą - wersja 1. Nieużywane.

    //
    // Funkcja wylicza parametry równania paraboli przechodzącej przez 3 punkty.
    //
    // Zwraca prawdę gdy nie napotkano błędów podczas wyliczania parametrów równania paraboli przechodzącej przez 3 punkty.
    //
    // y = a * x^2 + b * x + c
    //
    // P1( -4, 1 ), P2( -3, -2 ), P3( 1, -2 ) // P( x, y )
    //
    // 16a - 4b + c = 1 // x1^2 * a + x1 * b + c = y1
    // 9a - 3b + c = 2 // x2^2 * a + x2 * b + c = y2
    // a + b + c = -2 // x3^2 * a + x3 * b + c = y3
    //
    // y = 3/5*x^2 + 6/5*x - 19/5
    // y = 0.6 * x^2 + 1.2 * x - 3.8
    //

    Result := false;

    sx1 := Sqr( x1 );
    sx2 := Sqr( x2 );
    sx3 := Sqr( x3 );

    if   (  ( x2 - x1 ) * ( x1 - x3 ) = 0  ) // Z równania na a.
      or (  ( x2 - x1 ) * ( x1 - x3 ) = 0  )
      or (  ( sx3 - sx1 ) - ( sx1 - sx2 ) / ( x2 - x1 ) * ( x1 - x3 ) = 0  )
      or (  x2 - x1 = 0  ) then // Z równania na b.
      Exit;

    //if    (  ( x2 - x1 ) * ( x1 - x3 ) <> 0  )
    //  and (  ( x2 - x1 ) * ( x1 - x3 )  <> 0  )
    //  and (  ( sx3 - sx1 ) - ( sx1 - sx2 ) / ( x2 - x1 ) * ( x1 - x3 ) <> 0  ) then
      a := (  ( y2 - y1  ) / ( x2 - x1 ) * ( x1 - x3 ) - y1 + y3  ) / (  ( sx3 - sx1 ) - ( sx1 - sx2 ) / ( x2 - x1 ) * ( x1 - x3 )  );

    //if x2 - x1 <> 0 then
      b := (  a * ( sx1 - sx2 ) + y2 - y1  ) / ( x2 - x1 );

    c := y1 - a * sx1 - b * x1;


    Result := true;

    //Statki_Form.Caption := FloatToStr( a ) + ' ' + FloatToStr( b ) + ' ' + FloatToStr( c );

    {
    c := y1 - Sqr( x1 ) * a - x1 * b;
    b := ( y2 - Sqr( x2 ) * a - c ) / x2;
    a := ( y3 - x3 * b - c ) / Sqr( x3 );

    sx1 := Sqr( x1 );
    sx2 := Sqr( x2 );
    sx3 := Sqr( x3 );

    c := y1 - a * sx1 - b * x1;
    b := ( y2 - a * sx2 - c ) / x2;
    a := ( y3 - b * x3 - c ) / sx3;

    // Z c do b.
    b * x2 := y2 - a * sx2 - c;
    b * x2 := y2 - a * sx2 - y1 + a * sx1 + b * x1;
    b * x2 - b * x1 := a * sx1 - a * sx2 + y2 - y1;
    b * ( x2 - x1 ) := a * ( sx1 - sx2 ) + y2 - y1;
    b := (  a * ( sx1 - sx2 ) + y2 - y1  ) / ( x2 - x1 );

    // Z c do a
    a * sx3 := y3 - b * x3 - c;
    a * sx3 := y3 - b * x3 - y1 + a * sx1 + b * x1;
    a * sx3 - a * sx1 := b * x1 - b * x3 - y1 + y3;
    a * ( sx3 - sx1 ) := b * ( x1 - x3 ) - y1 + y3;

    // Z b do a (po c)
    a * ( sx3 - sx1 ) := b * ( x1 - x3 ) - y1 + y3;
    a * ( sx3 - sx1 ) := (  a * ( sx1 - sx2 ) + y2 - y1  ) / ( x2 - x1 ) * ( x1 - x3 ) - y1 + y3;

    a * ( sx3 - sx1 ) := a * ( sx1 - sx2 ) / ( x2 - x1 ) * ( x1 - x3 ) + ( y2 - y1  ) / ( x2 - x1 ) * ( x1 - x3 ) - y1 + y3;
    a * ( sx3 - sx1 ) - a * ( sx1 - sx2 ) / ( x2 - x1 ) * ( x1 - x3 ) := ( y2 - y1  ) / ( x2 - x1 ) * ( x1 - x3 ) - y1 + y3;
    a * (  ( sx3 - sx1 ) - ( sx1 - sx2 ) / ( x2 - x1 ) * ( x1 - x3 )  ) := ( y2 - y1  ) / ( x2 - x1 ) * ( x1 - x3 ) - y1 + y3;
    a := (  ( y2 - y1  ) / ( x2 - x1 ) * ( x1 - x3 ) - y1 + y3  ) / (  ( sx3 - sx1 ) - ( sx1 - sx2 ) / ( x2 - x1 ) * ( x1 - x3 )  );
    }

  end;//---//Funkcja Równanie_Paraboli_3_Punkty() w Konstruktor klasy TAmunicja.

var
  ztr,
  cel_oddalenie_l
    : real;
  //czy_lot_parabolą_l : boolean;
begin//Konstruktor klasy TAmunicja.

  inherited Create( AOwner ); // Nie może być ALufa gdyż po zwolnieniu statku pojawiają się błędy dostępu jeżeli amunicja wystrzelona z tego statku nadal jest na scenie.


  Self.id_statek := ALufa.statek.id_statek;
  Self.statek := ALufa.statek;

  inc( id_amunicja_g ); // Po osiągnięciu maksymalnej wartości powinno ustawić się na wartość minimalną (bez błędów).
  Self.id_amunicja := id_amunicja_g; //DateTimeToUnix( Now() );

  Self.cel_odległość := ALufa.wylot_pozycja.DistanceTo( cel_współrzędne_f ); //ALufa.DistanceTo( cel_współrzędne_f )
  //Self.działo_podniesienie_kąt_maksymalny := TDziało(ALufa.działo).podniesienie_kąt_maksymalny;

  if TDziało(ALufa.działo).podniesienie_kąt_maksymalny <> TDziało(ALufa.działo).podniesienie_kąt_minimalny then
    Self.działo_podniesienie_procent_kąta_maksymalnego := ( TDziało(ALufa.działo).podniesienie_kąt_zadany - TDziało(ALufa.działo).podniesienie_kąt_minimalny ) * 100 / ( TDziało(ALufa.działo).podniesienie_kąt_maksymalny - TDziało(ALufa.działo).podniesienie_kąt_minimalny )
  else//if TDziało(ALufa.działo).podniesienie_kąt_maksymalny <> TDziało(ALufa.działo).podniesienie_kąt_minimalny then
    Self.działo_podniesienie_procent_kąta_maksymalnego := 100;

  //Statki_Form.Caption := FloatToStr( Self.działo_podniesienie_procent_kąta_maksymalnego ); //???

  Self.obrażenia_zadawane_współczynnik := 1;
  Self.obrażenia_zadawane_współczynnik_zmodyfikowany := Self.obrażenia_zadawane_współczynnik;
  //Self.parabola_kąt_lotu_początkowy := 0;
  //Self.parabola_kąt_lotu_współczynnik := 0;
  Self.prędkość := amunicja_prędkość_c;
  Self.prędkość_opadania := 0; // 0.0035
  Self.prędkość_opadania_współczynnik := 0.0003;
  Self.strzał_od_blokada_dystans := 250;
  Self.statek_prędkość := 0;
  //Self.zanurzenie_głębokość_po_wpadnięciu_do_wody := -5;
  Self.zanurzenie_głębokość_zadana := -0.3; // -0.25

  Self.czy_efekt_wpadnięcia_do_wody := false;
  Self.czy_lot_parabolą := false;
  Self.czy_poza_lufą := false;
  Self.czy_uzbrojona := false;

  Self.pozycja_celu := TGLSphere.Create( Self );
  Self.pozycja_celu.Parent := AOwner; // Aby pozycja startowa się nie przesuwała.
  Self.pozycja_celu.Pickable := false;
  Self.pozycja_celu.Radius := 0.15;
  Self.pozycja_celu.Visible := false;
  Self.pozycja_celu.AbsolutePosition := ALufa.wylot_pozycja.AbsolutePosition;

  Self.pozycja_woda := TGLSphere.Create( Self );
  Self.pozycja_woda.Parent := AOwner; // Aby pozycja startowa się nie przesuwała.
  Self.pozycja_woda.Pickable := false;
  Self.pozycja_woda.Radius := 0.15;
  Self.pozycja_woda.Visible := false; //???
  Self.pozycja_woda.AbsolutePosition := ALufa.wylot_pozycja.AbsolutePosition;

  Self.Tag := 0;


  if ALufa.HasParent then
    begin

      Self.skala := TTorpedy_Wyrzutnia(ALufa.działo.elementy_wizualne_dummy).Scale.X; // Przy założeniu, że skalowanie jest proporcjonalne.

      Self.amunicja_rodzaj := TTorpedy_Wyrzutnia(ALufa.działo).amunicja_rodzaj;
      Self.obrażenia_zadawane := TTorpedy_Wyrzutnia(ALufa.działo).obrażenia_zadawane;
      Self.zasięg := TTorpedy_Wyrzutnia(ALufa.działo).zasięg;

      if ALufa.działo is TArtyleria then
        begin

          Self.czy_lot_parabolą := TDziało(ALufa.działo).czy_lot_parabolą;

          if Self.czy_lot_parabolą then
            begin

              // Przy aktualnym podniesieniu lufy strzał będzie oddany na procent zasięgu.
              if    ( TDziało(ALufa.działo).podniesienie_kąt_maksymalny <> TDziało(ALufa.działo).podniesienie_kąt_minimalny )
                and (  Abs( TDziało(ALufa.działo).podniesienie_kąt_maksymalny - TDziało(ALufa.działo).podniesienie_kąt_minimalny ) <> 0  ) then
                ztr := // Procent uniesienia lufy.
                    100
                  //* ( -TDziało(ALufa.działo).podniesienie_kąt_minimalny + ALufa.PitchAngle )
                  * ( -TDziało(ALufa.działo).podniesienie_kąt_minimalny - ALufa.PitchAngle ) // Aktualny kąt uniesienia lufy przesunięty aby kąt minimalny wynosił 0 (minus, gdyż tutaj podniesienie w górę ma wartości ujemne).
                  / (  Abs( TDziało(ALufa.działo).podniesienie_kąt_maksymalny - TDziało(ALufa.działo).podniesienie_kąt_minimalny )  ) // Zakres podnoszenia lufy.
              else//if    ( TDziało(ALufa.działo).podniesienie_kąt_maksymalny <> TDziało(ALufa.działo).podniesienie_kąt_minimalny ) (...)
                ztr := 100;

              Self.cel_odległość := Self.zasięg * ztr * 0.01;


              // Inicjuje początkową pozycję wskaźnika celu do wyliczenia pozycji celu przy opuszczaniu lufy przez amunicję.
              //Self.pozycja_celu.Visible := true; //???
              Self.pozycja_celu.Material.FrontProperties.Emission.Color := clrGreen;
              //Self.pozycja_celu.AbsolutePosition := TDziało(ALufa.działo).AbsolutePosition;

              Self.pozycja_celu.Parent := ALufa.działo;
              Self.pozycja_celu.Position := ALufa.Position;
              Self.pozycja_celu.Position.Z := 0;

              Self.działo_pozycja_absolutna_vector := Self.pozycja_celu.AbsolutePosition; // Lepiej chyba tak.

              Self.pozycja_celu.Parent := AOwner;
              Self.pozycja_celu.AbsolutePosition := Self.działo_pozycja_absolutna_vector;
              //---// Inicjuje początkową pozycję wskaźnika celu do wyliczenia pozycji celu przy opuszczaniu lufy przez amunicję.


              //Self.działo_pozycja_absolutna_vector := TDziało(ALufa.działo).AbsolutePosition;

              Self.pozycja_woda.Position.Y := Self.działo_pozycja_absolutna_vector.Y;

            end;
          //---//if Self.czy_lot_parabolą then

          {$region 'Obliczenia dla lotu parabolą - wersja 1.'}
          //Self.zasięg_od_parabola := TArtyleria(ALufa.działo).zasięg_od_parabola;
          //
          //czy_lot_parabolą_l := false;
          //
          //if obracaj_działa_f then // Przy zablokowanym obrocie dział wyliczanie paraboli odbywało się zawsze do aktualnej pozycji celu.
          //  begin
          //
          //    //cel_oddalenie_l := TDziało(ALufa.działo).korpus.DistanceTo( cel_współrzędne_f )
          //    //cel_oddalenie_l := ALufa.DistanceTo( cel_współrzędne_f );
          //
          //    if ALufa.DistanceTo( cel_współrzędne_f ) > Self.zasięg_od_parabola then
          //      czy_lot_parabolą_l := true;
          //
          //  end
          //else//if obracaj_działa_f then
          //  begin
          //
          //    czy_lot_parabolą_l := true;
          //
          //    //// Przy aktualnym podniesieniu lufy strzał będzie oddany na procent zasięgu.
          //    //if TDziało(ALufa.działo).podniesienie_kąt_maksymalny <> TDziało(ALufa.działo).podniesienie_kąt_minimalny then
          //    //  cel_oddalenie_l := 100 * ALufa.PitchAngle / Abs( TDziało(ALufa.działo).podniesienie_kąt_maksymalny - TDziało(ALufa.działo).podniesienie_kąt_minimalny )
          //    //else//if TDziało(ALufa.działo).podniesienie_kąt_maksymalny <> TDziało(ALufa.działo).podniesienie_kąt_minimalny then
          //    //  cel_oddalenie_l := 0;
          //    //
          //    //cel_oddalenie_l := Self.zasięg * cel_oddalenie_l / 100;
          //
          //    cel_współrzędne_f.Y := 0; // Aby pozycja celu nie zmieniała parametrów.
          //
          //  end;
          ////---//if obracaj_działa_f then
          //
          //// Trafia trochę za daleko.
          ////if cel_oddalenie_l > 1 then
          ////  cel_oddalenie_l := cel_oddalenie_l - 1;
          ////cel_oddalenie_l := cel_oddalenie_l - cel_oddalenie_l * 0.025;
          ////cel_współrzędne_f.Y := cel_współrzędne_f.Y - cel_współrzędne_f.Y * 0.1;
          //////w miarę dobrze //???
          //////      cel_oddalenie_l := cel_oddalenie_l - Self.zasięg * 0.03; //0.05
          //////
          //////      if cel_oddalenie_l < 0 then
          //////        cel_oddalenie_l := 0;
          //
          //
          //
          ////if cel_oddalenie_l > Self.zasięg_od_parabola then
          //if czy_lot_parabolą_l then
          //  begin
          //
          //    // Ze względu na precyzję kąta podniesienia dystans jest liczony według kąta lufy (inaczej od razu strzela na wskazany celem dystans).
          //    // Przy aktualnym podniesieniu lufy strzał będzie oddany na procent zasięgu.
          //    // Pociski mogą zalecieć dalej niż zasięg w linii prostej gdy cel jest ponad wodą (y dodatni).
          //    // cel_oddalenie_l - tutaj tymczasowo jako procent wychylenia lufy.
          //    if TDziało(ALufa.działo).podniesienie_kąt_maksymalny <> 0 then
          //      //cel_oddalenie_l := 100 * ( -ALufa.PitchAngle ) / Abs( TDziało(ALufa.działo).podniesienie_kąt_maksymalny )
          //      cel_oddalenie_l := 100 * ( -ALufa.PitchAngle - TDziało(ALufa.działo).podniesienie_kąt_minimalny ) / Abs( TDziało(ALufa.działo).podniesienie_kąt_maksymalny - TDziało(ALufa.działo).podniesienie_kąt_minimalny ) // 100 * (kąt aktualny - kąt minimalny) / zakres kąt
          //    else//if TDziało(ALufa.działo).podniesienie_kąt_maksymalny <> TDziało(ALufa.działo).podniesienie_kąt_minimalny then
          //      cel_oddalenie_l := 0;
          //
          //    //Statki_Form.Caption := FloatToStr( cel_oddalenie_l );
          //    cel_oddalenie_l := Self.zasięg * cel_oddalenie_l * 0.01;
          //
          //
          //    Self.czy_lot_parabolą := true;
          //
          //
          //    if cel_oddalenie_l > Self.zasięg then
          //      cel_oddalenie_l := Self.zasięg;
          //
          //
          //    Self.parabola_kąt_lotu_początkowy := ALufa.PitchAngle;
          //
          //    if cel_oddalenie_l <> 0 then
          //      Self.parabola_kąt_lotu_współczynnik := Abs( 80 - ALufa.PitchAngle ) / cel_oddalenie_l; // 80 - kąt do jakiego ma się odchylić podczas opadania (w dół są stopnie dodatnie).
          //    //Statki_Form.GLLines2.Nodes[ 1 ].Y := ALufa.wylot_pozycja.AbsolutePosition.Y;
          //
          //    ztr := ALufa.wylot_pozycja.AbsolutePosition.Y + cel_oddalenie_l * 0.4;
          //
          //    if ztr < cel_współrzędne_f.Y then // Gdy cel był wysoko parabola była wygięta w dół.
          //      ztr := ztr + cel_współrzędne_f.Y;
          //
          //    //Statki_Form.Caption := FloatToStr( cel_oddalenie_l );
          //
          //    if not Równanie_Paraboli_3_Punkty(
          //               0, ALufa.wylot_pozycja.AbsolutePosition.Y, // Punkt wylotu - ważna jest wysokość (x dla paraboli to będzie przebyty dystans od działa).
          //               cel_oddalenie_l * 0.5, ztr, // Punkt w trakcie lotu. //???
          //               cel_oddalenie_l, cel_współrzędne_f.Y, // Punkt celu (x dla paraboli to będzie dystans do celu).
          //               Self.parabola_równanie__a, Self.parabola_równanie__b, Self.parabola_równanie__c
          //             ) then
          //      begin
          //
          //        Self.parabola_kąt_lotu_współczynnik := 0;
          //        Self.czy_lot_parabolą := false;
          //        Self.parabola_równanie__a := 0;
          //        Self.parabola_równanie__b := 0;
          //        Self.parabola_równanie__c := 0;
          //
          //      end;
          //    //---//if not Równanie_Paraboli_3_Punkty( (...)
          //
          //  end;
          ////---//if czy_lot_parabolą_l then
          {$endregion 'Obliczenia dla lotu parabolą - wersja 1.'}

        end;
      //---//if ALufa.działo is TArtyleria then

    end
  else//if ALufa.HasParent then
    begin

      Self.amunicja_rodzaj := ar_Brak;
      Self.skala := 1;

    end;
  //---//if ALufa.HasParent then


  Self.prędkość := Self.prędkość / Self.skala; // Działo może być skalowane. Koryguje wartość o skalę działa.


  //Self.statek_kierunek := 0;

  {$region 'Obliczenia dla lotu parabolą - wersja 1.'}
  //if not Self.czy_lot_parabolą then
  //  Self.prędkość_opadania_współczynnik := 0.00003
  //else//if not Self.czy_lot_parabolą then
  //  Self.prędkość_opadania_współczynnik := 0.003; // 0.003
  {$endregion 'Obliczenia dla lotu parabolą - wersja 1.'}

  Self.czy_pod_wodą := false;
  Self.czy_poza_zasięgiem := false;
  //Self.czy_statek_dane := false;
  Self.czy_usunąć := false;
  Self.czy_wynurzanie := false;


  Self.Parent := ALufa; //AOwner; // Rodzicem jest Gra_Obiekty_GLDummyCube aby kontener obiektu poruszał się po współrzędnych absolutnych sceny (nie lokalnych).
  //Self.Direction.AsAffineVector := TTorpedy_Wyrzutnia(ALufa.działo).Direction.AsAffineVector;
  //Self.VisibleAtRunTime := true; //???
  //Self.ShowAxes := true; //???


  Self.korpus_opadanie_obrót_dummy := TGLDummyCube.Create( Self );
  Self.korpus_opadanie_obrót_dummy.Parent := Self;
  Self.korpus_opadanie_obrót_dummy.EdgeColor.Color := clrGreen;
  //Self.korpus_opadanie_obrót_dummy.VisibleAtRunTime := true; //???
  //Self.korpus_opadanie_obrót_dummy.ShowAxes := true; //???
  Self.korpus_opadanie_obrót_dummy.TagFloat := 1360;


  Self.korpus_ustawienie_początkowe_dummy := TGLDummyCube.Create( Self );
  Self.korpus_ustawienie_początkowe_dummy.Parent := Self.korpus_opadanie_obrót_dummy;
  Self.korpus_ustawienie_początkowe_dummy.EdgeColor.Color := clrYellow;
  //Self.korpus_ustawienie_początkowe_dummy.VisibleAtRunTime := true; //???
  //Self.korpus_ustawienie_początkowe_dummy.ShowAxes := true; //???


  Self.torpeda_efekt_na_wodzie := TGLDummyCube.Create( Self );
  Self.torpeda_efekt_na_wodzie.Parent := nil;
  Self.torpeda_efekt_na_wodzie.EdgeColor.Color := clrRed;
  //Self.torpeda_efekt_na_wodzie.VisibleAtRunTime := true; //???
  //Self.torpeda_efekt_na_wodzie.ShowAxes := true; //???


  Self.korpus := TGLCylinder.Create( Self );
  Self.korpus.Parent := Self.korpus_ustawienie_początkowe_dummy;


  if Self.amunicja_rodzaj in [ ar_Torpeda ] then
    begin

      Self.prędkość := Self.prędkość * 0.05; //???
      Self.prędkość_wytracanie_współczynnik := Self.prędkość * 0.0005; //???


      Self.AbsolutePosition := ALufa.AbsolutePosition;
      Self.Position.Y := 0;

      //Self.strzał_od_blokada_dystans := Self.korpus.Height + Self.korpus.Height * 0.3; // Na początku wykrywa dystans większy od długości korpusu.
      Self.zanurzenie_głębokość_po_wpadnięciu_do_wody := Self.korpus_opadanie_obrót_dummy.Position.Y * 0.5; // 0.25

      Self.korpus.Height := ALufa.korpus.Height - ALufa.korpus.Height * 0.1; // Tak samo wyliczyć wskaźnik uzbrojenia amunicji.


      Self.strzał_od_blokada_dystans := Self.korpus.Height - Self.korpus.Height * 0.3; // Na początku wykrywa dystans większy od długości korpusu.

    end
  else//if Self.amunicja_rodzaj in [ ar_Torpeda ] then
    if Self.amunicja_rodzaj in [ ar_Artyleria, ar_Pocisk ] then
      begin

        Self.prędkość_wytracanie_współczynnik := Self.prędkość * 0.001; // 0.001

        Self.AbsolutePosition := ALufa.wylot_pozycja.AbsolutePosition;

        {$region 'Obliczenia dla lotu parabolą - wersja 1.'}
        //if Self.czy_lot_parabolą then // Jeżeli lot odbywa się po paraboli to wysokość modyfikuje się ze wzoru (a nie z kierunku lotu).
        //  begin
        //
        //    Self.Direction.Y := 0;
        //    Self.korpus_opadanie_obrót_dummy.PitchAngle := -ALufa.PitchAngle;
        //
        //  end;
        ////---//if Self.czy_lot_parabolą then
        {$endregion 'Obliczenia dla lotu parabolą - wersja 1.'}


        if Self.amunicja_rodzaj in [ ar_Pocisk ] then
          begin

            Self.korpus.Height := ALufa.korpus.Height * 0.3;

          end
        else//if Self.amunicja_rodzaj in [ ar_Pocisk ] then
          Self.korpus.Height := ALufa.korpus.Height * 0.3;


        Self.strzał_od_blokada_dystans := Self.korpus.Height - Self.korpus.Height * 0.4;

      end;
    //---//if Self.amunicja_rodzaj in [ ar_Artyleria, ar_Pocisk ] then


  Self.prędkość_początkowa := Self.prędkość;


  Self.strzał_od_blokada_dystans := Self.strzał_od_blokada_dystans * Self.skala; // Działo może być skalowane. Koryguje wartość o skalę działa.


  Self.AbsoluteDirection := ALufa.AbsoluteDirection;
  Self.Direction.AsVector := GLVectorGeometry.VectorNegate( Self.Direction.AsVector ); // Lepiej działa.
  Self.opadanie_obrót_korekta_o_kąt_na_granicy_zasięgu := 0;
  Self.opadanie_obrót_korekta_o_ustawienie_początkowe := 0;

  Self.korpus.PitchAngle := 90; // 90


  //Self.korpus.TopRadius := ( ALufa.korpus.TopRadius - ALufa.korpus.TopRadius * 0.2 ) * skala_l;
  Self.korpus.TopRadius := ( ALufa.korpus.TopRadius - ALufa.korpus.TopRadius * 0.2 );
  Self.korpus.BottomRadius := Self.korpus.TopRadius;
  //Self.korpus.Height := 1.25;

//  Self.korpus.TopRadius := 0.05;
//  Self.korpus.BottomRadius := Self.korpus.TopRadius;
//  Self.korpus.Height := 1.25;

  Self.czubek := TGLCone.Create( Self );
  Self.czubek.Parent := Self.korpus.Parent;
  Self.czubek.BottomRadius := Self.korpus.TopRadius;
  Self.czubek.PitchAngle := -Self.korpus.PitchAngle;
  Self.czubek.Height := Self.czubek.BottomRadius;
  Self.czubek.Position.Z := ( Self.korpus.Height + Self.czubek.Height ) * 0.5;
  //Self.czubek.Position.Y := ( Self.korpus.Height + Self.czubek.Height ) * 0.5; //???


  Self.pozycja_startowa := TGLSphere.Create( Self ); //???
  Self.pozycja_startowa.Parent := Self.Parent; //Self.Parent AOwner; // Aby pozycja startowa się nie przesuwała.
  Self.pozycja_startowa.Pickable := false;
  Self.pozycja_startowa.Radius := 0.15;
  Self.pozycja_startowa.Visible := false;
  Self.pozycja_startowa.AbsolutePosition := ALufa.wylot_pozycja.AbsolutePosition;
  //Self.pozycja_startowa.ShowAxes := true; //???


  // Dynamiczne dodanie zdarzenia kolizji.
  if gl_collision_mmanager_f <> nil then
    begin

      with TGLBCollision.Create( Self.korpus.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.korpus.Behaviours ) do

      with TGLBCollision.Create( Self.czubek.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.korpus.Behaviours ) do

    end;
  //---//if gl_collision_mmanager_f <> nil then

  //Self.pozycja_startowa.Position.Y := 0; // Zawsze poziom wody. // Zostanie zmodyfikowana po opuszczeniu amunicji z lufy.

  //Self.korpus.Position.Y := Self.korpus_przód.Position.Y + Self.korpus.TopRadius * 2;
  //Self.korpus.Position.AsAffineVector := Self.korpus.AbsoluteToLocal( ALufa.Position.AsAffineVector );
  //Self.korpus.AbsolutePosition := ALufa.AbsolutePosition;
  //Self.korpus.Position.Y := ALufa.AbsolutePosition.Y;


//  Self.pozycja_startowa.Position.X := 0;
//  Self.pozycja_startowa.Position.Z := 0;
//  //Self.pozycja_startowa.Position.Y := Self.pozycja_startowa.LocalToAbsolute( Self.pozycja_startowa.Position.AsAffineVector ).Y;
//  Self.pozycja_startowa.Position.Y := Self.pozycja_startowa.AbsoluteToLocal( Self.pozycja_startowa.Position.AsAffineVector ).Y;


  //Self.ShowAxes := true;
  //Self.korpus_opadanie_obrót_dummy.ShowAxes := true;
  //Self.korpus_ustawienie_początkowe_dummy.ShowAxes := true;
  //Self.korpus.ShowAxes := true;

end;//---//Konstruktor klasy TAmunicja.

//Konstruktor klasy TAmunicja - tylko do wyświetlenia.
constructor TAmunicja.Create( AObiekty_Wieloosobowe_Amunicja_r : TObiekty_Wieloosobowe__Amunicja_r; AOwner : TGLBaseSceneObject );
//constructor TAmunicja.Create( AAmunicja : TAmunicja );
begin

  //
  // Konstruktor utworzy kopię obiektu amunicja w zakresie wystarczającym tylko do wyświetlenia.
  //

  inherited Create( AOwner );


  Self.id_amunicja := AObiekty_Wieloosobowe_Amunicja_r.id_wieloosobowe_amunicja;
  Self.id_statek := AObiekty_Wieloosobowe_Amunicja_r.id_statek;
  Self.statek := nil;

  Self.cel_odległość := 0;
  //Self.działo_podniesienie_kąt_maksymalny := 0;
  Self.działo_podniesienie_procent_kąta_maksymalnego := 100;
  Self.obrażenia_zadawane_współczynnik := 1;
  Self.obrażenia_zadawane_współczynnik_zmodyfikowany := Self.obrażenia_zadawane_współczynnik;
  Self.opadanie_obrót_korekta_o_kąt_na_granicy_zasięgu := 0;
  Self.opadanie_obrót_korekta_o_ustawienie_początkowe := 0;
  //Self.parabola_kąt_lotu_początkowy := 0;
  //Self.parabola_kąt_lotu_współczynnik := 0;
  Self.prędkość := 0.01;
  Self.prędkość_opadania := 0;
  Self.prędkość_opadania_współczynnik := 0;
  Self.prędkość_początkowa := Self.prędkość;
  Self.prędkość_wytracanie_współczynnik := 0;
  Self.skala := 1;
  Self.statek_prędkość := 0;
  Self.zanurzenie_głębokość_po_wpadnięciu_do_wody := -5;
  Self.zanurzenie_głębokość_zadana := 0;

  Self.czy_efekt_wpadnięcia_do_wody := false;
  Self.czy_lot_parabolą := false;

  Self.amunicja_rodzaj := AObiekty_Wieloosobowe_Amunicja_r.amunicja_rodzaj;

  Self.czy_pod_wodą := false;
  Self.czy_poza_lufą := false;
  Self.czy_poza_zasięgiem := false;
  //Self.czy_statek_dane := false;
  Self.czy_usunąć := false;
  Self.czy_uzbrojona := false;
  Self.czy_wynurzanie := false;

  Self.strzał_od_blokada_dystans := 0;


  Self.Parent := AOwner; // Rodzicem jest scena aby kontener obiektu poruszał się po współrzędnych absolutnych sceny (nie lokalnych).
  //Self.Direction.AsAffineVector := TTorpedy_Wyrzutnia(ALufa.działo).Direction.AsAffineVector;
  //Self.VisibleAtRunTime := true; //???
  Self.AbsolutePosition := AObiekty_Wieloosobowe_Amunicja_r.pozycja; //???AAmunicja.AbsolutePosition;
  Self.Direction.AsVector := AObiekty_Wieloosobowe_Amunicja_r.kierunek; //???AAmunicja.AbsoluteDirection;


  Self.korpus_opadanie_obrót_dummy := TGLDummyCube.Create( Self );
  Self.korpus_opadanie_obrót_dummy.Parent := Self;
  Self.korpus_opadanie_obrót_dummy.EdgeColor.Color := clrGreen;
  //Self.korpus_opadanie_obrót_dummy.VisibleAtRunTime := true; //???


  Self.korpus_ustawienie_początkowe_dummy := TGLDummyCube.Create( Self );
  Self.korpus_ustawienie_początkowe_dummy.Parent := AOwner;
  Self.korpus_ustawienie_początkowe_dummy.EdgeColor.Color := clrYellow;
  //Self.korpus_ustawienie_początkowe_dummy.VisibleAtRunTime := true; //???


  Self.torpeda_efekt_na_wodzie := TGLDummyCube.Create( Self );
  Self.torpeda_efekt_na_wodzie.Parent := nil;
  Self.torpeda_efekt_na_wodzie.EdgeColor.Color := clrRed;
  //Self.torpeda_efekt_na_wodzie.VisibleAtRunTime := true; //???
  //Self.torpeda_efekt_na_wodzie.ShowAxes := true; //???


  // Elementy wizualne są potomkami Self.korpus_ustawienie_początkowe_dummy i ustawiane są według jego pozycji i kierunku.
  Self.korpus := TGLCylinder.Create( Self );
  Self.korpus.Parent := Self.korpus_ustawienie_początkowe_dummy;
  Self.korpus.Height := AObiekty_Wieloosobowe_Amunicja_r.korpus__Height;

  Self.korpus.PitchAngle := 90;

  Self.korpus.TopRadius := AObiekty_Wieloosobowe_Amunicja_r.korpus__TopRadius; //???AAmunicja.korpus.TopRadius;
  Self.korpus.BottomRadius := AObiekty_Wieloosobowe_Amunicja_r.korpus__BottomRadius; //???AAmunicja.korpus.BottomRadius;

  Self.czubek := TGLCone.Create( Self );
  Self.czubek.Parent := Self.korpus.Parent;
  Self.czubek.BottomRadius := Self.korpus.TopRadius;
  Self.czubek.PitchAngle := -Self.korpus.PitchAngle;
  Self.czubek.Height := Self.czubek.BottomRadius;
  Self.czubek.Position.Z := ( Self.korpus.Height + Self.czubek.Height ) * 0.5 ;

  Self.pozycja_celu := TGLSphere.Create( Self );
  Self.pozycja_celu.Parent := AOwner; // Aby pozycja startowa się nie przesuwała.
  Self.pozycja_celu.Pickable := false;
  Self.pozycja_celu.Radius := 0.15;
  Self.pozycja_celu.Visible := false;
  Self.pozycja_celu.Position.SetPoint( 0, 0, 0 );

  if AObiekty_Wieloosobowe_Amunicja_r.czy_lot_parabolą then
    Self.pozycja_celu.Material.FrontProperties.Emission.Color := clrGreen;


  Self.pozycja_startowa := TGLSphere.Create( Self );
  Self.pozycja_startowa.Parent := AOwner; // Aby pozycja startowa się nie przesuwała.
  Self.pozycja_startowa.Pickable := false;
  Self.pozycja_startowa.Radius := 0.15;
  Self.pozycja_startowa.Visible := false;
  Self.pozycja_startowa.Position.SetPoint( 0, 0, 0 ); //???AAmunicja.pozycja_startowa.Position.AsVector;

  Self.pozycja_woda := TGLSphere.Create( Self );
  Self.pozycja_woda.Parent := AOwner; // Aby pozycja startowa się nie przesuwała.
  Self.pozycja_woda.Pickable := false;
  Self.pozycja_woda.Radius := 0.15;
  Self.pozycja_woda.Visible := false;
  Self.pozycja_woda.Position.SetPoint( 0, 0, 0 );

end;//---//Konstruktor klasy TAmunicja - tylko do wyświetlenia.

//Destruktor klasy TAmunicja.
destructor TAmunicja.Destroy();
begin

  FreeAndNil( Self.czubek );
  FreeAndNil( Self.korpus );
  FreeAndNil( Self.korpus_ustawienie_początkowe_dummy );
  FreeAndNil( Self.korpus_opadanie_obrót_dummy );
  FreeAndNil( Self.torpeda_efekt_na_wodzie );
  FreeAndNil( Self.pozycja_celu );
  FreeAndNil( Self.pozycja_startowa );
  FreeAndNil( Self.pozycja_woda );

  inherited;

end;//---//Destruktor klasy TAmunicja.
{$endregion 'TAmunicja.'}


{$region 'TSter.'}
//Konstruktor klasy TSter.
constructor TSter.Create( AOwner : TGLBaseSceneObject; gl_collision_mmanager_f : TGLCollisionManager; x_f, y_f, z_f : real );
begin

  inherited Create( AOwner );

  Self.Parent := AOwner;
  //???Self.ster_dummy.Position.Z := -Self.kadłub.CubeWidth * 0.5;
  //Self.ster_dummy.VisibleAtRunTime := true; //???

  Self.ster := TGLCube.Create( AOwner );
  Self.ster.Parent := Self;
  Self.ster.CubeWidth := 0.05;
  Self.ster.CubeDepth := 1;
  //Self.ster.TurnAngle := 90;
  Self.ster.Position.Z := -Self.ster.CubeDepth * 0.5;
  Self.ster.Position.Y := -Self.ster.CubeHeight * 0.5;

  Self.ster_mocowanie := TGLCylinder.Create( AOwner );
  Self.ster_mocowanie.Parent := Self;
  Self.ster_mocowanie.TopRadius := Self.ster.CubeWidth;
  Self.ster_mocowanie.BottomRadius := Self.ster_mocowanie.TopRadius;
  Self.ster_mocowanie.Height := Self.ster.CubeDepth;
  Self.ster_mocowanie.Position.Y := Self.ster.Position.Y;


  if gl_collision_mmanager_f <> nil then
    begin

      with TGLBCollision.Create( Self.ster.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.ster.Behaviours ) do

      with TGLBCollision.Create( Self.ster_mocowanie.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.ster_mocowanie.Behaviours ) do

    end;
  //---//if gl_collision_mmanager_f <> nil then

end;//---//Konstruktor klasy TSter.

//Destruktor klasy TSter.
destructor TSter.Destroy();
begin

  FreeAndNil( Self.ster );
  FreeAndNil( Self.ster_mocowanie );

  inherited;

end;//---//Destruktor klasy TSter.
{$endregion 'TSter.'}


{$region 'TŚruba.'}
//Konstruktor klasy TŚruba.
constructor TŚruba.Create( AOwner : TGLBaseSceneObject; AStatek : TStatek; const czy_obrót_lewo_f : boolean; gl_collision_mmanager_f : TGLCollisionManager );
var
  i : integer;
  ztr : real;
begin

  inherited Create( AOwner );

  Self.statek := AStatek;
  

  Self.prędkość_obrotowa_aktualna_procent := 0;
  Self.prędkość_obrotowa_maksymalna := 24;
  Self.prędkość_obrotowa_przyspieszanie := Self.statek.prędkość_przyspieszanie * 2; // Dobrać tak aby ruch śrub odpowiadał przyśpieszeniu statku (statek zmienia kierunek ruchu, a śruby jeszcze nie wyhamowały).

  //Self.czy_obrót_lewo := false;
  //Self.czy_obrót_lewo := true; //???

  Self.czy_obrót_lewo := czy_obrót_lewo_f;
  Self.czy_usunąć := false;


  Self.Parent := AOwner;
  //Self.TurnAngle := 0;
  //Self.Direction.SetVector( 0, 0, -1 );
  //Self.Position.SetPoint( 0, 1, 0 );
  //Self.VisibleAtRunTime := true; //???
  //Self.ShowAxes := true; //???


  Self.wał := TGLCylinder.Create( Self );
  Self.wał.Parent := Self;
  Self.wał.PitchAngle := 105;
  Self.wał.TopRadius := 0.05;
  Self.wał.BottomRadius := Self.wał.TopRadius;
  Self.wał.Height := 2;
  Self.wał.Position.Y := 0.24;

  Self.wał_łożysko := TGLCylinder.Create( Self );
  Self.wał_łożysko.Parent := Self;
  Self.wał_łożysko.PitchAngle := 90;
  Self.wał_łożysko.TopRadius := Self.wał.TopRadius * 2.5;
  Self.wał_łożysko.BottomRadius := Self.wał_łożysko.TopRadius;
  Self.wał_łożysko.Height := Self.wał_łożysko.TopRadius * 2;
  Self.wał_łożysko.Position.Z := -Self.wał.Height * 0.5;

  Self.wał_podpórka := TGLCylinder.Create( Self );
  Self.wał_podpórka.Parent := Self;
  Self.wał_podpórka.TopRadius := Self.wał.TopRadius;
  Self.wał_podpórka.BottomRadius := Self.wał_podpórka.TopRadius;
  Self.wał_podpórka.Height := 0.5;
  Self.wał_podpórka.Position.Y := Self.wał_podpórka.Height * 0.5;
  Self.wał_podpórka.Position.Z := Self.wał_łożysko.Position.Z;

  Self.wał_do_wirnika := TGLCylinder.Create( Self );
  Self.wał_do_wirnika.Parent := Self;
  Self.wał_do_wirnika.PitchAngle := 90;
  Self.wał_do_wirnika.TopRadius := Self.wał.TopRadius;
  Self.wał_do_wirnika.BottomRadius := Self.wał_do_wirnika.TopRadius;


  Self.wał_mocowanie := TGLCylinder.Create( Self );
  Self.wał_mocowanie.Parent := Self;
  Self.wał_mocowanie.PitchAngle := 90;
  Self.wał_mocowanie.TopRadius := Self.wał.TopRadius * 2;
  Self.wał_mocowanie.BottomRadius := Self.wał.TopRadius;
  Self.wał_mocowanie.Height := 0.2;
  Self.wał_mocowanie.Position.Y := Self.wał_podpórka.Height;
  Self.wał_mocowanie.Position.Z := Self.wał.Height * 0.5 + Self.wał_mocowanie.Height * 0.3;
  //Self.wał_mocowanie.Position.Y := 0.05;



  Self.obrót_dummy := TGLDummyCube.Create( Self );
  Self.obrót_dummy.Parent := Self;
  //Self.obrót_dummy.Position.Z := -Self.wał.Height * 0.5;
  //Self.obrót_dummy.VisibleAtRunTime := true; //???
  //Self.obrót_dummy.ShowAxes := true; //???


  Self.wirnik_środek := TGLSphere.Create( Self );
  Self.wirnik_środek.Parent := Self.obrót_dummy;
  Self.wirnik_środek.Radius := Self.wał.TopRadius * 3;
  //Self.wirnik_środek.Position.Z := -Self.wirnik_środek.Radius * 1.35;

  Self.wał_do_wirnika.Height := Self.wał_łożysko.Height + Self.wirnik_środek.Radius;
  Self.wał_do_wirnika.Position.Z := Self.wał_łożysko.Position.Z + Self.wał_łożysko.Height * 0.4 - Self.wał_do_wirnika.Height * 0.5;
  //Self.wał_do_wirnika.Position.Y := -0.15;


  Self.obrót_dummy.Position.Z := -Self.wał.Height * 0.5 - Self.wał_łożysko.Height * 0.25 - Self.wirnik_środek.Radius * 1.35;


  SetLength( Self.wirnik_łopaty_t, 4 ); // Ilość łopat wirnika.

  if Length( Self.wirnik_łopaty_t ) <> 0 then
    ztr := 360 / Length( Self.wirnik_łopaty_t )
  else//if Length( Self.wirnik_łopaty_t ) <> 0 then
    ztr := 180;

  for i := 0 to Length( Self.wirnik_łopaty_t ) - 1 do
    begin

      Self.wirnik_łopaty_t[ i ] := TGLCone.Create( Self );
      Self.wirnik_łopaty_t[ i ].Parent := Self.obrót_dummy;
      Self.wirnik_łopaty_t[ i ].BottomRadius := Self.wirnik_środek.Radius;
      //Self.wirnik_łopaty_t[ i ].ShowAxes := true;

      Self.wirnik_łopaty_t[ i ].PitchAngle := -90;

      Self.wirnik_łopaty_t[ i ].Height := Self.wirnik_środek.Radius;

      Self.wirnik_łopaty_t[ i ].Position.Y := Self.wirnik_środek.Radius + Self.wirnik_łopaty_t[ i ].BottomRadius * 0.5;

      Self.wirnik_łopaty_t[ i ].Position.AsVector :=
        GLVectorGeometry.MoveObjectAround(
          Self.wirnik_łopaty_t[ i ].Position.AsVector,
          GLVectorGeometry.VectorMake( 0, 0, 1 ),
          Self.wirnik_środek.Position.AsVector, 0, i * ztr );

      // Self.wirnik_łopaty_t[ i ].RollAngle := Self.wirnik_łopaty_t[ i ].RollAngle + i * 80 / 4;

      {$region 'Kąt łopat wirnika.'}
      {$region 'Łopaty 4.'}
      if Length( Self.wirnik_łopaty_t ) = 4 then
        begin

          if i = 0 then
            begin

              if Self.czy_obrót_lewo then
                begin

                  // Lewo.

                  Self.wirnik_łopaty_t[ i ].PitchAngle := -90;
                  Self.wirnik_łopaty_t[ i ].RollAngle := 40;

                end
              else//if Self.czy_obrót_lewo then
                begin

                  // Prawo.

                  Self.wirnik_łopaty_t[ i ].PitchAngle := -90;
                  Self.wirnik_łopaty_t[ i ].RollAngle := -40;

                end;
              //---//if Self.czy_obrót_lewo then

            end
          else//
          if i = 1 then
            begin

              if Self.czy_obrót_lewo then
                begin

                  // Lewo.

                  Self.wirnik_łopaty_t[ i ].PitchAngle := -130;
                  Self.wirnik_łopaty_t[ i ].RollAngle := 0;

                end
              else//if Self.czy_obrót_lewo then
                begin

                  // Prawo.

                  Self.wirnik_łopaty_t[ i ].PitchAngle := -50;
                  Self.wirnik_łopaty_t[ i ].RollAngle := 0;

                end;
              //---//if Self.czy_obrót_lewo then

            end
          else//
          if i = 2 then
            begin

              if Self.czy_obrót_lewo then
                begin

                  // Lewo.

                  Self.wirnik_łopaty_t[ i ].PitchAngle := -90;
                  Self.wirnik_łopaty_t[ i ].RollAngle := -40;

                end
              else//if Self.czy_obrót_lewo then
                begin

                  // Prawo.

                  Self.wirnik_łopaty_t[ i ].PitchAngle := -90;
                  Self.wirnik_łopaty_t[ i ].RollAngle := 40;

                end;
              //---//if Self.czy_obrót_lewo then

            end
          else//
          if i = 3 then
            begin

              if Self.czy_obrót_lewo then
                begin

                  // Lewo.

                  Self.wirnik_łopaty_t[ i ].PitchAngle := -50;
                  Self.wirnik_łopaty_t[ i ].RollAngle := 0;

                end
              else//if Self.czy_obrót_lewo then
                begin

                  // Prawo.

                  Self.wirnik_łopaty_t[ i ].PitchAngle := -130;
                  Self.wirnik_łopaty_t[ i ].RollAngle := 0;

                end;
              //---//if Self.czy_obrót_lewo then

            end;

        end;
      //---//if Length( Self.wirnik_łopaty_t ) = 4 then
      {$endregion 'Łopaty 4.'}
      {$endregion 'Kąt łopat wirnika.'}

    end;
  //---//for i := 0 to Length( Self.wirnik_łopaty_t ) - 1 do


  if gl_collision_mmanager_f <> nil then
    begin

      with TGLBCollision.Create( Self.wał.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.wał.Behaviours ) do

      with TGLBCollision.Create( Self.wał_łożysko.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.wał_łożysko.Behaviours ) do

      with TGLBCollision.Create( Self.wał_mocowanie.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.wał_mocowanie.Behaviours ) do

      with TGLBCollision.Create( Self.wał_podpórka.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.wał_podpórka.Behaviours ) do

      with TGLBCollision.Create( Self.wał_do_wirnika.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.wał_do_wirnika.Behaviours ) do

      with TGLBCollision.Create( Self.wirnik_środek.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.wirnik_środek.Behaviours ) do


      for i := 0 to Length( Self.wirnik_łopaty_t ) - 1 do
        with TGLBCollision.Create( Self.wirnik_łopaty_t[ i ].Behaviours ) do
          begin

            GroupIndex := 0;
            BoundingMode := cbmCube;
            Manager := gl_collision_mmanager_f;

          end;
        //---//with TGLBCollision.Create( Self.wirnik_łopaty_t[ i ].Behaviours ) do

    end;
  //---//if gl_collision_mmanager_f <> nil then

end;//---//Konstruktor klasy TŚruba.

//Destruktor klasy TŚruba.
destructor TŚruba.Destroy();
var
  i : integer;
begin

  FreeAndNil( Self.wał );
  FreeAndNil( Self.wał_łożysko );
  FreeAndNil( Self.wał_mocowanie );
  FreeAndNil( Self.wał_podpórka );
  FreeAndNil( Self.wał_do_wirnika );

  FreeAndNil( Self.wirnik_środek );


  for i := 0 to Length( Self.wirnik_łopaty_t ) - 1 do
    FreeAndNil( Self.wirnik_łopaty_t[ i ] );

  SetLength( Self.wirnik_łopaty_t, 0 );


  FreeAndNil( Self.obrót_dummy );

  inherited;

end;//---//Destruktor klasy TŚruba.

//Funkcja Śruba_Obracaj().
procedure TŚruba.Śruba_Obracaj();
begin

  if    (  Abs( Self.prędkość_obrotowa_aktualna_procent - Self.statek.prędkość_zadana_procent ) < Self.prędkość_obrotowa_przyspieszanie * Statki_Form.gra_współczynnik_prędkości_g  )
    and (
                   ( Self.prędkość_obrotowa_aktualna_procent >= 0 )
               and ( Self.statek.prędkość_zadana_procent >= 0 )    
          or (
                   ( Self.prędkość_obrotowa_aktualna_procent <= 0 )
               and ( Self.statek.prędkość_zadana_procent <= 0 )
             )
        ) then
    Self.prędkość_obrotowa_aktualna_procent := Self.statek.prędkość_zadana_procent
  else
  if Self.prędkość_obrotowa_aktualna_procent < ( Self.statek.prędkość_zadana_procent - Self.prędkość_obrotowa_przyspieszanie ) then
    Self.prędkość_obrotowa_aktualna_procent := Self.prędkość_obrotowa_aktualna_procent + Self.prędkość_obrotowa_przyspieszanie * Statki_Form.gra_współczynnik_prędkości_g
  else
  if Self.prędkość_obrotowa_aktualna_procent > ( Self.statek.prędkość_zadana_procent - Self.prędkość_obrotowa_przyspieszanie ) then
    Self.prędkość_obrotowa_aktualna_procent := Self.prędkość_obrotowa_aktualna_procent - Self.prędkość_obrotowa_przyspieszanie * Statki_Form.gra_współczynnik_prędkości_g;


  if Self.czy_obrót_lewo then
    Self.obrót_dummy.RollAngle := Self.obrót_dummy.RollAngle - Self.prędkość_obrotowa_aktualna_procent * Self.prędkość_obrotowa_maksymalna * 0.01 * Statki_Form.gra_współczynnik_prędkości_g // Lewo.
  else
    Self.obrót_dummy.RollAngle := Self.obrót_dummy.RollAngle + Self.prędkość_obrotowa_aktualna_procent * Self.prędkość_obrotowa_maksymalna * 0.01 * Statki_Form.gra_współczynnik_prędkości_g;

end;//---//Funkcja Śruba_Obracaj().
{$endregion 'TŚruba.'}


{$region 'TTrafienia_Efekt.'}
//Konstruktor klasy TTrafienia_Efekt.
//constructor TTrafienia_Efekt.Create( AOwner : TGLBaseSceneObject; gl_fire_fx_manager_f : TGLFireFXManager; x_f, y_f, z_f : real );
//constructor TTrafienia_Efekt.Create( AOwner : TGLBaseSceneObject; gl_cadence_able_component_f : TGLCadenceAbleComponent; x_f, y_f, z_f : real; gl_cadencer__current_time_f : double; amunicja_f : TAmunicja );
constructor TTrafienia_Efekt.Create( AOwner : TGLBaseSceneObject; x_f, y_f, z_f : real );
var
  zt_gl_base_scene_object : TGLBaseSceneObject;
begin

  //inherited Create( AOwner ); // Nie może być TStatek gdyż po zwolnieniu statku pojawiają się błędy dostępu jeżeli efekty umieszczone na tym statku nadal są na scenie.

  if    ( AOwner is TStatek )
    and ( AOwner.HasParent ) then
    inherited Create( AOwner.Parent )
  else
    inherited Create( AOwner );

  Self.Parent := AOwner;
  //Self.VisibleAtRunTime := true;
  //Self.ShowAxes := true;
  Self.Position.SetPoint( x_f, y_f, z_f );

  Self.czas_trwania := Random( 10000 );
  Self.czas_utworzenia := Czas_Teraz();

  //Self.statek := AStatek; //???
  //Self.czy_usunąć := false; //???


  //Exit;
  //
  // Gdy elementy gry były tworzone bezpośrednio na scenie jedne z nich przesłaniały inne.
  //  Działa gdy AOwner = Statki_Form.GLScene1.Objects
  //
  //if   ( AOwner = nil )
  //  or (  not Assigned( AOwner )  ) then
  //  Exit;
  //
  //
  //// Aby efekt nie był przesłaniany przez inne obiekty.
  //zt_gl_base_scene_object := AOwner.FindChild( 'GLParticleFXRenderer1', true ); //??? Czy szukać po nazwie.
  //
  //if zt_gl_base_scene_object <> nil then
  //  zt_gl_base_scene_object.MoveLast();
  //
  //
  //// Aby efekt nie przesłaniał napisów na ekranie.
  //zt_gl_base_scene_object := AOwner.FindChild( 'Informacje_Główne_GLHUDText', true ); //??? Czy szukać po nazwie.
  //
  //if zt_gl_base_scene_object <> nil then
  //  zt_gl_base_scene_object.MoveLast();

end;//---//Konstruktor klasy TTrafienia_Efekt.

//Destruktor klasy TTrafienia_Efekt.
destructor TTrafienia_Efekt.Destroy();
begin

  inherited;

end;//---//Destruktor klasy TTrafienia_Efekt.
{$endregion 'TTrafienia_Efekt.'}

{$region 'TInformacje_Dodatkowe.'}
//Konstruktor klasy TInformacje_Dodatkowe.
constructor TInformacje_Dodatkowe.Create( const napis_f : string = '' );
begin

  Self.utworzenie_data_czas := Now();
  Self.wyświetlanie_czas_sekund := informacja_dodatkowa__wyświetlanie_czas_sekund__domyślny_c;
  Self.napis := napis_f;

end;//---//Konstruktor klasy TInformacje_Dodatkowe.

//Konstruktor klasy TInformacje_Dodatkowe.
constructor TInformacje_Dodatkowe.Create( const napis_f : string; const wyświetlanie_czas_sekund_f : smallint );
begin

  Self.utworzenie_data_czas := Now();
  Self.wyświetlanie_czas_sekund := wyświetlanie_czas_sekund_f;
  Self.napis := napis_f;

end;//---//Konstruktor klasy TInformacje_Dodatkowe
{$endregion 'TInformacje_Dodatkowe.'}

{$region 'TKlawisz_Konfiguracja.'}
//Konstruktor klasy TKlawisz_Konfiguracja.
constructor TKlawisz_Konfiguracja.Create( AOwner : TComponent; pointer_f : Pointer );
begin

  inherited Create( AOwner );


  Self.Parent := TWinControl(AOwner);
  Self.Align := alBottom; // Aby kolejność się nie odwracała.
  Self.Align := alTop;
  Self.Height := 30;

  Self.klawiatura_konfiguracja_r_w := pointer_f;

  Self.klawiatura_konfiguracja_r_w.mysz_niezdefiniowana := false;

  Self.ParentBackground := false;
  Self.Color := clWhite;
  Self.OnMouseEnter := Self.Panel_Mouse_Enter;
  Self.OnMouseLeave := Self.Panel_Mouse_Leave;

  Self.domyślna_konfiguracja_r.klawisz := Self.klawiatura_konfiguracja_r_w.klawisz;
  Self.domyślna_konfiguracja_r.czy_mysz := Self.klawiatura_konfiguracja_r_w.czy_mysz;
  Self.domyślna_konfiguracja_r.plus_alt := Self.klawiatura_konfiguracja_r_w.plus_alt;
  Self.domyślna_konfiguracja_r.plus_ctrl := Self.klawiatura_konfiguracja_r_w.plus_ctrl;
  Self.domyślna_konfiguracja_r.plus_shift := Self.klawiatura_konfiguracja_r_w.plus_shift;


  Self.Klawisz_Edit := TEdit.Create( Self );
  Self.Klawisz_Edit.Parent := Self;
  Self.Klawisz_Edit.Left := 5;
  Self.Klawisz_Edit.Top := 5;
  Self.Klawisz_Edit.Width := 100;
  Self.Klawisz_Edit.ShowHint := true;
  Self.Klawisz_Edit.Hint := '';
  Self.Klawisz_Edit.ReadOnly := true;
  Self.Nazwa_Klawisza();
  Self.Klawisz_Edit.OnExit := Self.Edit_Exit;
  Self.Klawisz_Edit.OnKeyDown := Self.Edit_Key_Down;
  Self.Klawisz_Edit.OnMouseDown := Self.Edit_Mouse_Down;
  Self.Klawisz_Edit.OnMouseEnter := Self.Panel_Mouse_Enter;
  Self.Klawisz_Edit.OnMouseLeave := Self.Panel_Mouse_Leave;


  Self.Niezdefiniowane_Button := TButton.Create( Self );
  Self.Niezdefiniowane_Button.Parent := Self;
  Self.Niezdefiniowane_Button.Caption := 'Brak';
  Self.Niezdefiniowane_Button.Left := Self.Klawisz_Edit.Left + Self.Klawisz_Edit.Width + 15;
  Self.Niezdefiniowane_Button.Top := Self.Klawisz_Edit.Top;
  Self.Niezdefiniowane_Button.Height := 20;
  Self.Niezdefiniowane_Button.Width := 55;
  Self.Niezdefiniowane_Button.ShowHint := true;
  Self.Niezdefiniowane_Button.Hint := 'Wyczyść przypisany klawisz.';
  Self.Niezdefiniowane_Button.OnClick := Self.Niezdefiniowane_Button_Click;
  Self.Niezdefiniowane_Button.OnMouseEnter := Self.Panel_Mouse_Enter;
  Self.Niezdefiniowane_Button.OnMouseLeave := Self.Panel_Mouse_Leave;

  Self.Domyślny_Button := TButton.Create( Self );
  Self.Domyślny_Button.Parent := Self;
  Self.Domyślny_Button.Caption := 'Domyślny';
  Self.Domyślny_Button.Left := Self.Niezdefiniowane_Button.Left + Self.Niezdefiniowane_Button.Width + 15;
  Self.Domyślny_Button.Top := Self.Klawisz_Edit.Top;
  Self.Domyślny_Button.Height := 20;
  Self.Domyślny_Button.Width := 55;
  Self.Domyślny_Button.ShowHint := true;
  Self.Domyślny_Button.Hint := 'Ustaw domyślny klawisz.';
  Self.Domyślny_Button.OnClick := Self.Domyślny_Button_Click;
  Self.Domyślny_Button.OnMouseEnter := Self.Panel_Mouse_Enter;
  Self.Domyślny_Button.OnMouseLeave := Self.Panel_Mouse_Leave;


  Self.Czy_Mysz_CheckBox := TCheckBox.Create( Self );
  Self.Czy_Mysz_CheckBox.Parent := Self;
  Self.Czy_Mysz_CheckBox.Caption := 'Mysz';
  Self.Czy_Mysz_CheckBox.Left := Self.Domyślny_Button.Left + Self.Domyślny_Button.Width + 15;
  Self.Czy_Mysz_CheckBox.Top := Self.Klawisz_Edit.Top;
  Self.Czy_Mysz_CheckBox.Width := 45;
  Self.Czy_Mysz_CheckBox.ShowHint := true;
  Self.Czy_Mysz_CheckBox.Hint := 'Funkcjonalność sterowana klawiszem myszy.';
  Self.Czy_Mysz_CheckBox.Checked := Self.klawiatura_konfiguracja_r_w.czy_mysz;
  Self.Czy_Mysz_CheckBox.OnClick := Self.Check_Box_Click;
  Self.Czy_Mysz_CheckBox.OnMouseEnter := Self.Panel_Mouse_Enter;
  Self.Czy_Mysz_CheckBox.OnMouseLeave := Self.Panel_Mouse_Leave;


  Self.Plus_Alt_CheckBox := TCheckBox.Create( Self );
  Self.Plus_Alt_CheckBox.Parent := Self;
  Self.Plus_Alt_CheckBox.Caption := 'Alt';
  Self.Plus_Alt_CheckBox.Left := Self.Czy_Mysz_CheckBox.Left + Self.Czy_Mysz_CheckBox.Width + 15;
  Self.Plus_Alt_CheckBox.Top := Self.Klawisz_Edit.Top;
  Self.Plus_Alt_CheckBox.Width := 30;
  Self.Plus_Alt_CheckBox.ShowHint := true;
  Self.Plus_Alt_CheckBox.Hint := 'Wskazany klawisz + Alt.';
  Self.Plus_Alt_CheckBox.Checked := Self.klawiatura_konfiguracja_r_w.plus_alt;
  //Self.klawiatura_konfiguracja_r_w.plus_alt := true;
  Self.Plus_Alt_CheckBox.OnClick := Self.Check_Box_Click;
  Self.Plus_Alt_CheckBox.OnMouseEnter := Self.Panel_Mouse_Enter;
  Self.Plus_Alt_CheckBox.OnMouseLeave := Self.Panel_Mouse_Leave;

  Self.Plus_Ctrl_CheckBox := TCheckBox.Create( Self );
  Self.Plus_Ctrl_CheckBox.Parent := Self;
  Self.Plus_Ctrl_CheckBox.Caption := 'Ctrl';
  Self.Plus_Ctrl_CheckBox.Left := Self.Plus_Alt_CheckBox.Left + Self.Plus_Alt_CheckBox.Width + 10;
  Self.Plus_Ctrl_CheckBox.Top := Self.Klawisz_Edit.Top;
  Self.Plus_Ctrl_CheckBox.Width := 35;
  Self.Plus_Ctrl_CheckBox.ShowHint := true;
  Self.Plus_Ctrl_CheckBox.Hint := 'Wskazany klawisz + Ctrl.';
  Self.Plus_Ctrl_CheckBox.Checked := Self.klawiatura_konfiguracja_r_w.plus_ctrl;
  Self.Plus_Ctrl_CheckBox.OnClick := Self.Check_Box_Click;
  Self.Plus_Ctrl_CheckBox.OnMouseEnter := Self.Panel_Mouse_Enter;
  Self.Plus_Ctrl_CheckBox.OnMouseLeave := Self.Panel_Mouse_Leave;

  Self.Plus_Shift_CheckBox := TCheckBox.Create( Self );
  Self.Plus_Shift_CheckBox.Parent := Self;
  Self.Plus_Shift_CheckBox.Caption := 'Shift';
  Self.Plus_Shift_CheckBox.Left := Self.Plus_Ctrl_CheckBox.Left + Self.Plus_Ctrl_CheckBox.Width + 10;
  Self.Plus_Shift_CheckBox.Top := Self.Klawisz_Edit.Top;
  Self.Plus_Shift_CheckBox.Width := 40;
  Self.Plus_Shift_CheckBox.ShowHint := true;
  Self.Plus_Shift_CheckBox.Hint := 'Wskazany klawisz + Shift.';
  Self.Plus_Shift_CheckBox.Checked := Self.klawiatura_konfiguracja_r_w.plus_shift;
  Self.Plus_Shift_CheckBox.OnClick := Self.Check_Box_Click;
  Self.Plus_Shift_CheckBox.OnMouseEnter := Self.Panel_Mouse_Enter;
  Self.Plus_Shift_CheckBox.OnMouseLeave := Self.Panel_Mouse_Leave;


  Self.Polecenie_Nazwa_Label := TLabel.Create( Self );
  Self.Polecenie_Nazwa_Label.Parent := Self;
  Self.Polecenie_Nazwa_Label.Caption := Self.klawiatura_konfiguracja_r_w.polecenie_nazwa;
  Self.Polecenie_Nazwa_Label.Left := Self.Plus_Shift_CheckBox.Left + Self.Plus_Shift_CheckBox.Width + 10;
  Self.Polecenie_Nazwa_Label.Top := Self.Klawisz_Edit.Top;
  Self.Polecenie_Nazwa_Label.Font.Style := [ fsBold ];
  //Self.Polecenie_Nazwa_Label.Tag := Self.Polecenie_Nazwa_Label.Left;
  //Self.Polecenie_Nazwa_Label.Tag := Self.Polecenie_Nazwa_Label.Font.Size;
  Self.Polecenie_Nazwa_Label.OnMouseEnter := Self.Panel_Mouse_Enter;
  Self.Polecenie_Nazwa_Label.OnMouseLeave := Self.Panel_Mouse_Leave;

end;//---//Konstruktor klasy TKlawisz_Konfiguracja.

//Destruktor klasy TKlawisz_Konfiguracja.
destructor TKlawisz_Konfiguracja.Destroy();
begin

  Self.klawiatura_konfiguracja_r_w := nil;

  FreeAndNil( Self.Polecenie_Nazwa_Label );
  FreeAndNil( Self.Klawisz_Edit );
  FreeAndNil( Self.Domyślny_Button );
  FreeAndNil( Self.Niezdefiniowane_Button );
  FreeAndNil( Self.Czy_Mysz_CheckBox );
  FreeAndNil( Self.Plus_Alt_CheckBox );
  FreeAndNil( Self.Plus_Ctrl_CheckBox );
  FreeAndNil( Self.Plus_Shift_CheckBox );

  inherited;

end;//---//Destruktor klasy TKlawisz_Konfiguracja.

//Funkcja Nazwa_Klawisza().
function TKlawisz_Konfiguracja.Nazwa_Klawisza() : string;
var
  bufor : array [ 0..255 ] of Char;
begin

  if not Self.klawiatura_konfiguracja_r_w.czy_mysz then
    begin

      if Self.klawiatura_konfiguracja_r_w.klawisz = 0 then
        Result := '<brak>'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 19 then
        Result := 'Pause Break'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 33 then
        Result := 'Page Up'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 34 then
        Result := 'Page Down'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 35 then
        Result := 'End'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 36 then
        Result := 'Home'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 37 then
        Result := 'Kursor lewo'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 38 then
        Result := 'Kursor góra'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 39 then
        Result := 'Kursor prawo'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 40 then
        Result := 'Kursor dół'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 45 then
        Result := 'Insert'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 46 then
        Result := 'Delete'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 91 then
        Result := 'Windows lewy'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 92 then
        Result := 'Windows prawy'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 93 then
        Result := 'Menu'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 111 then
        Result := 'Num /'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 144 then
        Result := 'Num Lock'
      else
        begin

          GetKeyNameText(  MapVirtualKey( Self.klawiatura_konfiguracja_r_w.klawisz, 0  ) shl 16, bufor, 256  );
          Result := bufor;

        end;
      //---//

    end
  else//if not Self.klawiatura_konfiguracja_r_w.czy_mysz then
    begin

      if Self.klawiatura_konfiguracja_r_w.mysz_niezdefiniowana then
        Result := '<kliknij w polu przyciskiem myszy>'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = word(mbLeft) then
        Result := 'Mysz lewy'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = word(mbMiddle) then
        Result := 'Mysz środkowy'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = word(mbRight) then
        Result := 'Mysz prawy'
      else
        Result := 'Mysz ' + IntToStr( Self.klawiatura_konfiguracja_r_w.klawisz );

    end;
  //---//if not Self.klawiatura_konfiguracja_r_w.czy_mysz then

  Self.Klawisz_Edit.Text := Result;
  Self.Klawisz_Edit.Hint := Self.Klawisz_Edit.Text + ' (' + IntToStr( Self.klawiatura_konfiguracja_r_w.klawisz ) + ').';

end;//---//Funkcja Nazwa_Klawisza().

//Funkcja Check_Box_Click().
procedure TKlawisz_Konfiguracja.Check_Box_Click( Sender : TObject );
var
  czy_mysz_l : boolean;
begin

  if   ( Sender = nil )
    or (  not Assigned( Sender )  )
    or (  not ( Sender is TCheckBox )  )
    or ( Self = nil )
    or (  not Assigned( Self )  ) then
    Exit;

  czy_mysz_l := Self.klawiatura_konfiguracja_r_w.czy_mysz;


  if TCheckBox(Sender).Caption = 'Mysz' then
    begin

      Self.klawiatura_konfiguracja_r_w.czy_mysz := TCheckBox(Sender).Checked;
      Self.klawiatura_konfiguracja_r_w.klawisz := 0;

      if    ( czy_mysz_l <> Self.klawiatura_konfiguracja_r_w.czy_mysz )
        and ( Self.klawiatura_konfiguracja_r_w.czy_mysz ) then
        begin

          Self.klawiatura_konfiguracja_r_w.mysz_niezdefiniowana := true;

        end
      else//if    ( czy_mysz_l <> Self.klawiatura_konfiguracja_r_w.czy_mysz ) (...)
        begin

          if Self.klawiatura_konfiguracja_r_w.mysz_niezdefiniowana then
            Self.klawiatura_konfiguracja_r_w.mysz_niezdefiniowana := false;

        end;
      //---//if    ( czy_mysz_l <> Self.klawiatura_konfiguracja_r_w.czy_mysz ) (...)

    end
  else
  if TCheckBox(Sender).Caption = 'Alt' then
    Self.klawiatura_konfiguracja_r_w.plus_alt := TCheckBox(Sender).Checked
  else
  if TCheckBox(Sender).Caption = 'Ctrl' then
    Self.klawiatura_konfiguracja_r_w.plus_ctrl := TCheckBox(Sender).Checked
  else
  if TCheckBox(Sender).Caption = 'Shift' then
    Self.klawiatura_konfiguracja_r_w.plus_shift := TCheckBox(Sender).Checked;


  Self.Nazwa_Klawisza();

end;//---//Funkcja Check_Box_Click().

//Funkcja Edit_Exit().
procedure TKlawisz_Konfiguracja.Edit_Exit( Sender : TObject );
begin

  if   ( Sender = nil )
    or (  not Assigned( Sender )  )
    or (  not ( Sender is TEdit )  )
    or ( Self = nil )
    or (  not Assigned( Self )  ) then
    Exit;

  Self.Klawisz_Edit.Tag := 0;

end;//---//Funkcja Edit_Exit().

//Funkcja Edit_Key_Down().
procedure TKlawisz_Konfiguracja.Edit_Key_Down( Sender : TObject; var Key : Word; Shift : TShiftState );
begin

  if   ( Sender = nil )
    or (  not Assigned( Sender )  )
    or (  not ( Sender is TEdit )  )
    or ( Self = nil )
    or (  not Assigned( Self )  )
    or ( Self.klawiatura_konfiguracja_r_w.czy_mysz ) then
    Exit;


  if Key = VK_MENU then // Alt.
    begin

      Self.klawiatura_konfiguracja_r_w.plus_alt := true;

    end
  else//if Key = VK_MENU then
    if Self.klawiatura_konfiguracja_r_w.klawisz = VK_MENU then
      begin

         Self.klawiatura_konfiguracja_r_w.plus_alt := false;

         if Self.klawiatura_konfiguracja_r_w.plus_ctrl then // Prawy Alt zgłasza się jako Alt i Ctrl jednocześnie.
           Self.klawiatura_konfiguracja_r_w.plus_ctrl := false;

      end;
    //---//if Self.klawiatura_konfiguracja_r_w.klawisz = VK_MENU then

  if   ( Key = VK_CONTROL )
    or (
             ( ssAlt in Shift ) // Prawy Alt zgłasza się jako Alt i Ctrl jednocześnie..
         and ( ssCtrl in Shift )
       ) then
    begin

      Self.klawiatura_konfiguracja_r_w.plus_ctrl := true;

    end
  else//if Key = VK_CONTROL then
    if Self.klawiatura_konfiguracja_r_w.klawisz = VK_CONTROL then
      begin

         Self.klawiatura_konfiguracja_r_w.plus_ctrl := false;

      end;
    //---//if Self.klawiatura_konfiguracja_r_w.klawisz = VK_CONTROL then

  if Key = VK_SHIFT then
    begin

      Self.klawiatura_konfiguracja_r_w.plus_shift := true;

    end
  else//if Key = VK_SHIFT then
    if Self.klawiatura_konfiguracja_r_w.klawisz = VK_SHIFT then
      begin

         Self.klawiatura_konfiguracja_r_w.plus_shift := false;

      end;
    //---//if Self.klawiatura_konfiguracja_r_w.klawisz = VK_SHIFT then


  Self.Plus_Alt_CheckBox.Checked := Self.klawiatura_konfiguracja_r_w.plus_alt;
  Self.Plus_Ctrl_CheckBox.Checked := Self.klawiatura_konfiguracja_r_w.plus_ctrl;
  Self.Plus_Shift_CheckBox.Checked := Self.klawiatura_konfiguracja_r_w.plus_shift;


  Self.klawiatura_konfiguracja_r_w.klawisz := Key;
  Self.Nazwa_Klawisza();

end;//---//Funkcja Edit_Key_Down().

//Funkcja Edit_Mouse_Down().
procedure TKlawisz_Konfiguracja.Edit_Mouse_Down( Sender : TObject; Button : TMouseButton; Shift : TShiftState; X, Y : Integer );
begin

  if   ( Sender = nil )
    or (  not Assigned( Sender )  )
    or (  not ( Sender is TEdit )  )
    or ( Self = nil )
    or (  not Assigned( Self )  )
    or ( not Self.klawiatura_konfiguracja_r_w.czy_mysz ) then
    Exit;


  if Self.Klawisz_Edit.Tag = 0 then
    begin

      // Aby pierwsze kliknięcie myszą w polu (ustawienie się w polu) nie zmieniało definicji klawisza.

      Self.Klawisz_Edit.Tag := 1;
      Exit

    end;
  //---//if Self.Klawisz_Edit.Tag = 0 then


  if Self.klawiatura_konfiguracja_r_w.mysz_niezdefiniowana then
    Self.klawiatura_konfiguracja_r_w.mysz_niezdefiniowana := false;


  Self.klawiatura_konfiguracja_r_w.klawisz := word(Button);
  Self.Nazwa_Klawisza();

end;//---//Funkcja Edit_Mouse_Down().

//Funkcja Domyślny_Button_Click().
procedure TKlawisz_Konfiguracja.Domyślny_Button_Click( Sender : TObject );
begin

  if   ( Sender = nil )
    or (  not Assigned( Sender )  )
    or (  not ( Sender is TButton )  )
    or ( Self = nil )
    or (  not Assigned( Self )  ) then
    Exit;


  Self.klawiatura_konfiguracja_r_w.klawisz := Self.domyślna_konfiguracja_r.klawisz;
  Self.klawiatura_konfiguracja_r_w.czy_mysz := Self.domyślna_konfiguracja_r.czy_mysz;
  Self.klawiatura_konfiguracja_r_w.plus_alt := Self.domyślna_konfiguracja_r.plus_alt;
  Self.klawiatura_konfiguracja_r_w.plus_ctrl := Self.domyślna_konfiguracja_r.plus_ctrl;
  Self.klawiatura_konfiguracja_r_w.plus_shift := Self.domyślna_konfiguracja_r.plus_shift;

  Self.Czy_Mysz_CheckBox.Checked := Self.domyślna_konfiguracja_r.czy_mysz;
  Self.Plus_Alt_CheckBox.Checked := Self.domyślna_konfiguracja_r.plus_alt;
  Self.Plus_Ctrl_CheckBox.Checked := Self.domyślna_konfiguracja_r.plus_ctrl;
  Self.Plus_Shift_CheckBox.Checked := Self.domyślna_konfiguracja_r.plus_shift;

  // Dodatkowe sprawdzenie (nie powinny zmienić się te wartości).
  if Self.klawiatura_konfiguracja_r_w.mysz_niezdefiniowana then
    Self.klawiatura_konfiguracja_r_w.mysz_niezdefiniowana := false;

  if Self.klawiatura_konfiguracja_r_w.klawisz <> Self.domyślna_konfiguracja_r.klawisz then
    Self.klawiatura_konfiguracja_r_w.klawisz := Self.domyślna_konfiguracja_r.klawisz;
  //---// Dodatkowe sprawdzenie (nie powinny zmienić się te wartości).

  Self.Nazwa_Klawisza();

end;//---//Funkcja Domyślny_Button_Click().

//Funkcja Niezdefiniowane_Button_Click().
procedure TKlawisz_Konfiguracja.Niezdefiniowane_Button_Click( Sender : TObject );
begin

  if   ( Sender = nil )
    or (  not Assigned( Sender )  )
    or (  not ( Sender is TButton )  )
    or ( Self = nil )
    or (  not Assigned( Self )  ) then
    Exit;


  Self.klawiatura_konfiguracja_r_w.czy_mysz := false;
  Self.klawiatura_konfiguracja_r_w.klawisz := 0;

  Self.Czy_Mysz_CheckBox.Checked := false;
  Self.Plus_Alt_CheckBox.Checked := false;
  Self.Plus_Ctrl_CheckBox.Checked := false;
  Self.Plus_Shift_CheckBox.Checked := false;

  Self.Nazwa_Klawisza();

end;//---//Funkcja Niezdefiniowane_Button_Click().

//Funkcja Panel_Mouse_Enter().
procedure TKlawisz_Konfiguracja.Panel_Mouse_Enter( Sender : TObject );
begin

  if   ( Self = nil )
    or (  not Assigned( Self )  ) then
    Exit;


  Self.Color := $00FFDFBF; //clWhite
  //Self.Polecenie_Nazwa_Label.Font.Color := clNavy;
  //Self.Polecenie_Nazwa_Label.Left := Self.Polecenie_Nazwa_Label.Tag + 10;
  //Self.Polecenie_Nazwa_Label.Font.Size := Self.Polecenie_Nazwa_Label.Font.Size + 3;

end;//---//Funkcja Panel_Mouse_Enter().

//Funkcja Panel_Mouse_Leave().
procedure TKlawisz_Konfiguracja.Panel_Mouse_Leave( Sender : TObject );
begin

  if   ( Self = nil )
    or (  not Assigned( Self )  ) then
    Exit;


  //Self.Polecenie_Nazwa_Label.Left := Self.Polecenie_Nazwa_Label.Tag;
  //Self.Polecenie_Nazwa_Label.Font.Color := clWindowText;
  //Self.Polecenie_Nazwa_Label.Font.Size := Self.Polecenie_Nazwa_Label.Tag;
  Self.Color := clWhite; //clBtnFace

end;//---//Funkcja Panel_Mouse_Leave().
{$endregion 'TKlawisz_Konfiguracja.'}

{$region 'TWygląd_Kolor_Definicja.'}
//Konstruktor klasy TWygląd_Kolor_Definicja.
constructor TWygląd_Kolor_Definicja.Create();
begin

  SetLength( Self.wygląd_kolor_definicja_t, 0 );

end;//---//Konstruktor klasy TWygląd_Kolor_Definicja.

//Destruktor klasy TWygląd_Kolor_Definicja.
destructor TWygląd_Kolor_Definicja.Destroy();
begin

  SetLength( Self.wygląd_kolor_definicja_t, 0 );

end;//---//Destruktor klasy TWygląd_Kolor_Definicja.

//Funkcja Definicja_Istnieje().
function TWygląd_Kolor_Definicja.Definicja_Istnieje( const kolor_definicja_nazwa_f : string ) : boolean;
var
  i : integer;
begin

  //
  // Funkcja sprawdza czy definicja danego koloru już jest zapamiętana.
  //
  // Zwraca prawdę gdy definicja danego koloru już jest zapamiętana.
  //
  // Parametry:
  //   kolor_definicja_nazwa_f
  //

  Result := false;

  for i := 0 to Length( Self.wygląd_kolor_definicja_t ) - 1 do
    if Self.wygląd_kolor_definicja_t[ i ].kolor_definicja_nazwa = kolor_definicja_nazwa_f then
      begin

        Result := true;
        Break;

      end;
    //---//if Self.wygląd_kolor_definicja_t[ i ].kolor_definicja_nazwa = kolor_definicja_nazwa_f then

end;//---//Funkcja Definicja_Istnieje().

//Funkcja Dodaj_Definicję().
procedure TWygląd_Kolor_Definicja.Dodaj_Definicję( const czerwony_f, zielony_f, niebieski_f, przezroczystość_f : real; const kolor_definicja_nazwa_f : string );
var
  i : integer;
begin

  //
  // Funkcja definicja danego koloru już jest zapamiętana.
  //
  // Parametry:
  //   czerwony_f
  //   zielony_f
  //   niebieski_f
  //   przezroczystość_f
  //   kolor_definicja_nazwa_f
  //

  i := Length( Self.wygląd_kolor_definicja_t );
  SetLength( wygląd_kolor_definicja_t, i + 1 );

  wygląd_kolor_definicja_t[ i ].kolor_definicja_nazwa := kolor_definicja_nazwa_f;
  GLVectorGeometry.SetVector( wygląd_kolor_definicja_t[ i ].kolor_vector, czerwony_f, zielony_f, niebieski_f, przezroczystość_f );

end;//---//Funkcja Dodaj_Definicję().

//Funkcja Odczytaj_Definicję().
function TWygląd_Kolor_Definicja.Odczytaj_Definicję( const kolor_definicja_nazwa_f : string ) : GLVectorGeometry.TVector;
var
  i : integer;
begin

  //
  // Zwraca zdefiniowany kolor.
  //
  // Parametry:
  //   kolor_definicja_nazwa_f
  //

  //GLVectorGeometry.SetVector( Result, 0, 0, 0, 1 );
  Result := clrGray20;

  for i := 0 to Length( Self.wygląd_kolor_definicja_t ) - 1 do
    if Self.wygląd_kolor_definicja_t[ i ].kolor_definicja_nazwa = kolor_definicja_nazwa_f then
      begin

        Result := Self.wygląd_kolor_definicja_t[ i ].kolor_vector;
        Break;

      end;
    //---//if Self.wygląd_kolor_definicja_t[ i ].kolor_definicja_nazwa = kolor_definicja_nazwa_f then

end;//---//Funkcja Odczytaj_Definicję().
{$endregion 'TWygląd_Kolor_Definicja.'}

{$region 'TTCP_Klienci_Lista.'}
//Konstruktor klasy TTCP_Klienci_Lista.
constructor TTCP_Klienci_Lista.Create();
begin

  Self.identyfikator_najmniejszy := -1;
  Self.identyfikator_największy := 0;

  Self.klienci_lista_list := TList.Create();

end;//---//Konstruktor klasy TTCP_Klienci_Lista.

//Destruktor klasy TTCP_Klienci_Lista.
destructor TTCP_Klienci_Lista.Destroy();
begin

  Self.Usuń_Wszystkich();

  FreeAndNil( Self.klienci_lista_list );

end;//---//Destruktor klasy TTCP_Klienci_Lista.

//Funkcja Dodaj_Aktualizuj().
function TTCP_Klienci_Lista.Dodaj_Aktualizuj( const peer_port_f, identyfikator_f : integer ) : TTCP_Klient_Dane;
var
  i : integer;
begin

  //
  // Funkcja dodaje albo aktualizuje dane gracza.
  //
  // Zwraca prawdę gdy rekord danych gracza.
  //
  // Parametry:
  //   peer_port_f
  //   identyfikator_f:
  //

  Result := nil;

  if peer_port_f >= 0 then
    for i := Self.klienci_lista_list.Count - 1 downto 0 do
      if TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).identyfikator = identyfikator_f then
        begin

          // Sprawdza czy klient, który się połączył jest na liście.

          Result := TTCP_Klient_Dane(Self.klienci_lista_list[ i ]);
          Result.peer_port_tcp := peer_port_f;
          Result.data_czas__dłączenia := 0;
          Result.data_czas__podłączenia_ostatniego := Now();
          Result.odłączony := false;

          Exit;

        end;
      //---//if TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).identyfikator = identyfikator_f then


  if identyfikator_f > 0 then
    Exit; // Wskazanego identyfikatora nie ma na liście.


  Result := TTCP_Klient_Dane.Create();
  Result.peer_port_tcp := peer_port_f;
  Result.peer_port_udp := 0;
  Result.data_czas__dłączenia := 0;
  Result.data_czas__podłączenia := Now();
  Result.data_czas__podłączenia_ostatniego := Result.data_czas__podłączenia;
  Result.data_czas__udp_kontakt := 0;
  Result.gotowy := false;
  Result.odłączony := false;

  if Self.klienci_lista_list.Count <= 0 then
    begin

      // Dodaje do listy serwer.

      if peer_port_f >= 0 then
        Result.identyfikator := 1
      else//if peer_port_f >= 0 then
        Result.identyfikator := peer_port_f;

    end
  else//if Self.klienci_lista_list.Count <= 0 then
    if peer_port_f >= 0 then
      begin

        // Dodaje do listy gracza.

        Self.identyfikator_największy := Self.identyfikator_największy + 1;
        Result.identyfikator := Self.identyfikator_największy;

      end
    else//if Self.klienci_lista_list.Count <= 0 then
      begin

        // Dodaje do listy SI.

        Result.gotowy := true;

        Self.identyfikator_najmniejszy := Self.identyfikator_najmniejszy - 1;
        Result.identyfikator := Self.identyfikator_najmniejszy;

      end;
    //---//if Self.klienci_lista_list.Count <= 0 then


  Self.klienci_lista_list.Add( Result );

end;//---//Funkcja Dodaj_Aktualizuj().

//Funkcja Usuń().
procedure TTCP_Klienci_Lista.Usuń( const indeks_f : integer );
begin

  if   ( indeks_f < 0 )
    or ( indeks_f > Self.klienci_lista_list.Count - 1 ) then
    Exit;

  TTCP_Klient_Dane(Self.klienci_lista_list[ indeks_f ]).Free();
  Self.klienci_lista_list.Delete( indeks_f );

end;//---//Funkcja Usuń().

//Funkcja Usuń_Identyfikator().
procedure TTCP_Klienci_Lista.Usuń_Identyfikator( const identyfikator_f : integer );
var
  i : integer;
begin

  for i := Self.klienci_lista_list.Count - 1 downto 0 do
    if TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).identyfikator = identyfikator_f then
      begin

        Usuń( i );
        Exit;

      end;
    //---//if TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).identyfikator = identyfikator_f then

end;//---//Funkcja Usuń_Identyfikator().

//Funkcja Usuń_Peer_Port().
procedure TTCP_Klienci_Lista.Usuń_Peer_Port( const peer_port_f : integer );
var
  i : integer;
begin

  for i := Self.klienci_lista_list.Count - 1 downto 0 do
    if TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).peer_port_tcp = peer_port_f then
      begin

        Usuń( i );
        Exit;

      end;
    //---//if TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).peer_port_tcp = peer_port_f then

end;//---//Funkcja Usuń_Peer_Port().

//Funkcja Usuń_Wszystkich().
procedure TTCP_Klienci_Lista.Usuń_Wszystkich();
var
  i : integer;
begin

  for i := Self.klienci_lista_list.Count - 1 downto 0 do
    Self.Usuń( i );


  Self.identyfikator_najmniejszy := -1;
  Self.identyfikator_największy := 0;

end;//---//Funkcja Usuń_Wszystkich().

//Funkcja Nazwa_Niepowtarzalna().
function TTCP_Klienci_Lista.Nazwa_Niepowtarzalna( const peer_port_f : integer; const nazwa_f : string ) : boolean;
var
  i : integer;
begin

  //
  // Funkcja sprawdza czy podana nazwa gracza jest niepowtarzalna.
  //
  // Zwraca prawdę gdy podana nazwa gracza jest niepowtarzalna.
  //
  // Parametry:
  //   peer_port_f - gracz, którego nazwa jest sprawdzana (aby nie porównywać gracza z samym sobą).
  //   nazwa_f - sprawdzana nazwa.
  //

  Result := true;

  for i := 0 to Self.klienci_lista_list.Count - 1 do
    if    ( TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).peer_port_tcp <> peer_port_f )
      and (  AnsiLowerCase( TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).nazwa ) = AnsiLowerCase( nazwa_f )  ) then
      begin

        Result := false;
        Exit;

      end;
    //---//if    ( TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).peer_port_tcp <> peer_port_f ) (...)

end;//---//Funkcja Nazwa_Niepowtarzalna().

//Funkcja Nazwa_Niepowtarzalna().
function TTCP_Klienci_Lista.Nazwa_Niepowtarzalna( const nazwa_f : string ) : boolean;
var
  i : integer;
begin

  //
  // Funkcja sprawdza czy podana nazwa gracza jest niepowtarzalna.
  //
  // Zwraca prawdę gdy podana nazwa gracza jest niepowtarzalna.
  //
  // Parametry:
  //   nazwa_f - sprawdzana nazwa.
  //

  Result := true;

  for i := 0 to Self.klienci_lista_list.Count - 1 do
    if AnsiLowerCase( TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).nazwa ) = AnsiLowerCase( nazwa_f ) then
      begin

        Result := false;
        Exit;

      end;
    //---//if AnsiLowerCase( TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).nazwa ) = AnsiLowerCase( nazwa_f ) then

end;//---//Funkcja Nazwa_Niepowtarzalna().

//Funkcja Odłączony_Peer_Port().
procedure TTCP_Klienci_Lista.Odłączony_Peer_Port( const peer_port_f : integer );
var
  i : integer;
begin

  for i := Self.klienci_lista_list.Count - 1 downto 0 do
    if TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).peer_port_tcp = peer_port_f then
      begin

        TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).data_czas__dłączenia := Now();
        TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).odłączony := true;
        Exit;

      end;
    //---//if TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).peer_port_tcp = peer_port_f then

end;//---//Funkcja Odłączony_Peer_Port().

//Funkcja Znajdź_Identyfikator().
function TTCP_Klienci_Lista.Znajdź_Identyfikator( const identyfikator_f : integer ) : TTCP_Klient_Dane;
var
  i : integer;
begin

  Result := nil;

  for i := 0 to Self.klienci_lista_list.Count - 1 do
    if TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).identyfikator = identyfikator_f then
      begin

        Result := TTCP_Klient_Dane(Self.klienci_lista_list[ i ]);
        Exit;

      end;
    //---//if TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).identyfikator = identyfikator_f then

end;//---//Funkcja Znajdź_Identyfikator().

//Funkcja Znajdź_Peer_Port().
function TTCP_Klienci_Lista.Znajdź_Peer_Port( const peer_port_f : integer ) : TTCP_Klient_Dane;
var
  i : integer;
begin

  Result := nil;

  for i := 0 to Self.klienci_lista_list.Count - 1 do
    if TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).peer_port_tcp = peer_port_f then
      begin

        Result := TTCP_Klient_Dane(Self.klienci_lista_list[ i ]);
        Exit;

      end;
    //---//if TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).peer_port_tcp = peer_port_f then

end;//---//Funkcja Znajdź_Peer_Port().
{$endregion 'TTCP_Klienci_Lista.'}

{$region 'TUDP_Klienci_Lista.'}
//Konstruktor klasy TUDP_Klienci_Lista.
constructor TUDP_Klienci_Lista.Create();
begin

  Self.klienci_lista_list := TList.Create();

end;//---//Konstruktor klasy TUDP_Klienci_Lista.

//Destruktor klasy TUDP_Klienci_Lista.
destructor TUDP_Klienci_Lista.Destroy();
begin

  Self.Usuń_Wszystkich();

  FreeAndNil( Self.klienci_lista_list );

end;//---//Destruktor klasy TUDP_Klienci_Lista.

//Funkcja Dodaj().
procedure TUDP_Klienci_Lista.Dodaj( const adres_ip_f : string; const peer_port_f : word; const identyfikator_f : integer );
var
  i : integer;
  zt_udp_klient_dane : TUDP_Klient_Dane;
begin

  for i := Self.klienci_lista_list.Count - 1 downto 0 do
    if    ( TUDP_Klient_Dane(Self.klienci_lista_list[ i ]).adres_ip = adres_ip_f )
      and ( TUDP_Klient_Dane(Self.klienci_lista_list[ i ]).peer_port = peer_port_f )
      and ( TUDP_Klient_Dane(Self.klienci_lista_list[ i ]).identyfikator = identyfikator_f ) then
      begin

        // Sprawdza czy klient, który się odezwał jest na liście. //???
        // Odświeża czas ostatniego kontaktu.
        // Sprawdza czy dla danego klienta została wyznaczona komenda czynności.


        TUDP_Klient_Dane(Self.klienci_lista_list[ i ]).data_czas_kontakt_ostatni := Now();

        Exit;

      end;
    //---//if    ( TUDP_Klient_Dane(Self.klienci_lista_list[ i ]).adres_ip = adres_ip_f ) (...)


  zt_udp_klient_dane := TUDP_Klient_Dane.Create();
  zt_udp_klient_dane.adres_ip := adres_ip_f;
  zt_udp_klient_dane.data_czas_kontakt_ostatni := Now();
  zt_udp_klient_dane.identyfikator := identyfikator_f;
  zt_udp_klient_dane.peer_port := peer_port_f;
  //zt_udp_klient_dane.komenda := '';

  Self.klienci_lista_list.Add( zt_udp_klient_dane );

end;//---//Funkcja Dodaj().

//Funkcja Usuń().
procedure TUDP_Klienci_Lista.Usuń( const indeks_f : integer );
begin

  if   ( indeks_f < 0 )
    or ( indeks_f > Self.klienci_lista_list.Count - 1 ) then
    Exit;

  TUDP_Klient_Dane(Self.klienci_lista_list[ indeks_f ]).Free();
  Self.klienci_lista_list.Delete( indeks_f );

end;//---//Funkcja Usuń().

//Funkcja Usuń_Peer_Port().
procedure TUDP_Klienci_Lista.Usuń_Peer_Port( const peer_port_f : integer );
var
  i : integer;
begin

  for i := Self.klienci_lista_list.Count - 1 downto 0 do
    if TUDP_Klient_Dane(Self.klienci_lista_list[ i ]).peer_port = peer_port_f then
      begin

        Usuń( i );
        Exit;

      end;
    //---//if TUDP_Klient_Dane(Self.klienci_lista_list[ i ]).peer_port = peer_port_f then

end;//---//Funkcja Usuń_Peer_Port().

//Funkcja Usuń_Przeterminowanych().
procedure TUDP_Klienci_Lista.Usuń_Przeterminowanych();
var
  i : integer;
begin

  for i := Self.klienci_lista_list.Count - 1 downto 0 do
    if SecondsBetween( Now(), TUDP_Klient_Dane(Self.klienci_lista_list[ i ]).data_czas_kontakt_ostatni ) > udp_klient_połączenie_potwierdzanie_sekund_c  + udp_klient_połączenie_potwierdzanie_sekund_c * 0.5 then
      Self.Usuń( i );

end;//---//Funkcja Usuń_Przeterminowanych().

//Funkcja Usuń_Wszystkich().
procedure TUDP_Klienci_Lista.Usuń_Wszystkich();
var
  i : integer;
begin

  for i := Self.klienci_lista_list.Count - 1 downto 0 do
    Self.Usuń( i );

end;//---//Funkcja Usuń_Wszystkich().
{$endregion 'TUDP_Klienci_Lista.'}

//Funkcja DoNotify().
procedure TWieloosobowe_Powiadomienie.DoNotify();
begin

  Statki_Form.Log_Memo.Lines.Add(  DateTimeToStr( Now() )  );
  Statki_Form.Log_Memo.Lines.Add( Self.powiadomienie_treść );

  if Self.wyróżnij then
    Statki_Form.PageControl1.ActivePage := Statki_Form.Log_TabSheet;

end;//---//Funkcja DoNotify().

//Funkcja DoNotify().
procedure TPokój_Rozmów_Powiadomienie.DoNotify();
var
  i : integer;
  zts : string;
begin

  //
  // Funkcja wypisuje treść wiadomości.
  //

  //Pokój_Rozmów_Memo.Lines.Add(  IntToStr( Self.pokój_rozmów_r.id_nadawca ) + ': ' + Self.pokój_rozmów_r.wiadomość  );

  zts :=  IntToStr( Self.pokój_rozmów_r.id_nadawca );

  for i := 0 to Statki_Form.tcp_klienci_lista_g.klienci_lista_list.Count - 1 do
    if TTCP_Klient_Dane(Statki_Form.tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator = Self.pokój_rozmów_r.id_nadawca then
      begin

        zts := TTCP_Klient_Dane(Statki_Form.tcp_klienci_lista_g.klienci_lista_list[ i ]).nazwa + ' (' + zts + '):';
        Break;

      end;
    //---//if TTCP_Klient_Dane(Statki_Form.tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator = Self.pokój_rozmów_r.id_nadawca then

  Statki_Form.Pokój_Rozmów_Memo.Lines.Add( zts );
  Statki_Form.Pokój_Rozmów_Memo.Lines.Add(  '   ' + Self.pokój_rozmów_r.wiadomość  );


  if Statki_Form.Pokój_Rozmów__Informacja_Dodatkowa_CheckBox.Checked then
    Statki_Form.Informacja_Dodatkowa_Dodaj( zts + '   ' + Self.pokój_rozmów_r.wiadomość );

end;//---//Funkcja DoNotify().


//      ***      Funkcje      ***      //

//Funkcja Czas_Między_W_Sekundach().
function Czas_Między_W_Sekundach( const czas_poprzedni_f : int64 ) : int64;
begin

  //
  // Funkcja wylicza ilość sekund bezwzględnego czasu gry jaka upłynęła od podanego czasu do chwili obecnej.
  //
  // Zwraca ilość sekund bezwzględnego czasu gry.
  //
  // Parametry:
  //   czas_poprzedni_f - moment czasu gry, od którego liczyć upływ czasu.
  //

  Result := Round(  Czas_Między_W_Milisekundach( czas_poprzedni_f ) * 0.001  );

end;//---//Funkcja Czas_Między_W_Sekundach().

//Funkcja Czas_Między_W_Milisekundach().
function Czas_Między_W_Milisekundach( const czas_poprzedni_f : int64 ) : int64;
begin

  //
  // Funkcja wylicza ilość milisekund bezwzględnego czasu gry jaka upłynęła od podanego czasu do chwili obecnej.
  //
  // Zwraca ilość milisekund bezwzględnego czasu gry.
  //
  // Parametry:
  //   czas_poprzedni_f - moment czasu gry, od którego liczyć upływ czasu.
  //

  Result := Abs( czas_bezwzględny_g - czas_poprzedni_f ) * czas_bezwzględny_skok_milisekundy_g;

end;//---//Funkcja Czas_Między_W_Milisekundach().

//Funkcja Czas_Teraz().
function Czas_Teraz() : int64;
begin

  //
  // Funkcja zwraca aktualny bezwzględny czas gry.
  //  Ze względu na pauzowanie gdy nie można wyliczać na podstawie czasu systemowego
  //
  // Zwraca aktualny bezwzględny czas gry.
  //

  Result := czas_bezwzględny_g;

end;//---//Funkcja Czas_Teraz().

//Funkcja Czas_Teraz_W_Milisekundach().
function Czas_Teraz_W_Milisekundach() : int64;
begin

  //
  // Funkcja zwraca aktualny bezwzględny czas gry w milisekundach.
  //
  // Zwraca aktualny bezwzględny czas gry w milisekundach.
  //

  Result := Czas_Teraz() * czas_bezwzględny_skok_milisekundy_g;

end;//---//Funkcja Czas_Teraz_W_Milisekundach().

//Funkcja Wieloosobowe__Wektor_4__Do__Vector().
function TStatki_Form.Wieloosobowe__Wektor_4__Do__Vector( const wieloosobowe__wektor_4_f : TWieloosobowe__Wektor_4 ) : GLVectorGeometry.TVector;
begin

  //
  // Funkcja podstawia wartości z typu TWieloosobowe__Wektor_4 do typu GLVectorGeometry.TVector.
  //
  // Zwraca GLVectorGeometry.TVector.
  //

  Result.X := wieloosobowe__wektor_4_f.X;
  Result.Y := wieloosobowe__wektor_4_f.Y;
  Result.Z := wieloosobowe__wektor_4_f.Z;
  Result.W := wieloosobowe__wektor_4_f.W;

end;//---//Funkcja Wieloosobowe__Wektor_4__Do__Vector().

//Funkcja Vector__Do__Wieloosobowe__Wektor_4().
function TStatki_Form.Vector__Do__Wieloosobowe__Wektor_4( const vector_f : GLVectorGeometry.TVector ) : TWieloosobowe__Wektor_4;
begin

  //
  // Funkcja podstawia wartości z typu GLVectorGeometry.TVector do typu TWieloosobowe__Wektor_4.
  //
  // Zwraca TWieloosobowe__Wektor_4.
  //

  Result.X := vector_f.X;
  Result.Y := vector_f.Y;
  Result.Z := vector_f.Z;
  Result.W := vector_f.W;

end;//---//Funkcja Vector__Do__Wieloosobowe__Wektor_4().

//Funkcja Statek_Znajdź().
function TStatki_Form.Statek_Znajdź( pointer_f : Pointer ) : Pointer;
begin

  //
  // Funkcja próbuje znaleźć statek, w który trafiono.
  //
  // Zwraca wskaźnik na statek, w który trafiono.
  //
  // Parametry:
  //   pointer_f
  //

  Result := nil;

  if pointer_f = nil then
    Exit
  else//if pointer_f = nil then
    if TComponent(pointer_f) is TStatek then
      begin

        Result := pointer_f;
        Exit;

      end
    else//if TComponent(pointer_f) is TStatek then
      if TComponent(pointer_f).Owner <> nil then
        Result := Statek_Znajdź( TComponent(pointer_f).Owner );

end;//---//Funkcja Statek_Znajdź().

//Funkcja Amunicja_Wystrzelona_Utwórz_Jeden().
procedure TStatki_Form.Amunicja_Wystrzelona_Utwórz_Jeden( AOwner : TGLBaseSceneObject; ALufa : TLufa; const obracaj_działa_f : boolean; const cel_współrzędne_f : TAffineVector );
var
  zt_amunicja : TAmunicja;
begin

  if   ( amunicja_wystrzelona_list = nil )
    or (  not Assigned( amunicja_wystrzelona_list )  ) then
    Exit;

  zt_amunicja := TAmunicja.Create( AOwner, ALufa, obracaj_działa_f, cel_współrzędne_f, Statki_Form.GLCollisionManager1 );

  Amunicja_Wystrzelona_Efekt_Utwórz( zt_amunicja, false );

//  if MilliSecondsBetween( Now(), pociski_magiczne_ostatni_strzał ) < 500 then
//    Exit;
//
//  pociski_magiczne_ostatni_strzał := Now();
//
//  zt_amunicja := TPocisk_Magiczny.Create( Application );
//  //zt_amunicja := TGLTorus.Create( nil );
//
//  zt_amunicja.Parent := GLScene1.Objects;
//
//  zt_amunicja.Position := GLCamera1.Position;
//  zt_amunicja.Direction := GLCamera1.Direction;
//  zt_amunicja.Tag := 1;
//
//  // Dynamiczne dodanie zdarzenia kolizji.
//  with TGLBCollision.Create( zt_amunicja.Behaviours ) do
//    begin
//
//      GroupIndex := 0;
//      BoundingMode := cbmCube;
//      Manager := GLCollisionManager1;
//
//    end;
//  //---//with TGLBCollision.Create( Pocisk_Magiczny_GLTorus.Behaviours ) do
//
//  // Dynamiczne dodanie efektu.
//  with TGLBFireFX.Create( zt_amunicja.Effects ) do
//    begin
//
//      Manager := GLFireFXManager1;
//
//    end;
//  //---//with TGLBFireFX.Create( zt_amunicja.Effects ) do
//  // Lub.
//  //TGLBFireFX(zt_amunicja.AddNewEffect(TGLBFireFX)).Manager := GLFireFXManager1;

  amunicja_wystrzelona_list.Add( zt_amunicja );

end;//---//Funkcja Amunicja_Wystrzelona_Utwórz_Jeden().

//Funkcja Amunicja_Wystrzelona_Zwolnij_Jeden().
procedure TStatki_Form.Amunicja_Wystrzelona_Zwolnij_Jeden( amunicja_f : TAmunicja  );
begin

  // Usuwać tylko w jednym miejscu. !!!
  // Wywołanie tej funkcji w kliku miejscach może coś zepsuć.

  if   ( amunicja_wystrzelona_list = nil )
    or (  not Assigned( amunicja_wystrzelona_list )  )
    or ( amunicja_f = nil ) then
    Exit;

  //pociski_magiczne_blokada := true;


  if GLCamera1 <> nil then
    if GLCamera1.Parent = amunicja_f then
      if amunicja_wystrzelona_list.Count > 1 then
        Kamera_Przełącz( kt_Amunicja ) // Przełącza na kolejną wystrzeloną amunicję.
      else//if amunicja_wystrzelona_list.Count > 1 then
        Kamera_Przełącz( kt_Statek );

  // Aby nie zwolniło kamery wraz z amunicją.
  while GLCamera1.Parent = amunicja_f do
    Kamera_Przełącz( kt_Statek_Swobodna );


  amunicja_wystrzelona_list.Remove( amunicja_f );
  FreeAndNil( amunicja_f );

end;//---//Funkcja Amunicja_Wystrzelona_Zwolnij_Jeden()

//Funkcja Amunicja_Wystrzelona_Zwolnij_Wszystkie().
procedure TStatki_Form.Amunicja_Wystrzelona_Zwolnij_Wszystkie();
var
  i : integer;
begin

  if   ( amunicja_wystrzelona_list = nil )
    or (  not Assigned( amunicja_wystrzelona_list )  ) then
    Exit;


  if    ( GLCamera1 <> nil )
    and ( GLCamera1.Parent is TAmunicja ) then
    Kamera_Przełącz( kt_Statek_Swobodna );


  for i := amunicja_wystrzelona_list.Count - 1 downto 0 do
    begin

      TAmunicja(amunicja_wystrzelona_list[ i ]).Free();
      amunicja_wystrzelona_list.Delete( i );

    end;
  //---//for i := amunicja_wystrzelona_list.Count - 1 downto 0 do

end;//---//Funkcja Amunicja_Wystrzelona_Zwolnij_Wszystkie().

//Funkcja Amunicja_Wystrzelona_Efekt_Utwórz().
procedure TStatki_Form.Amunicja_Wystrzelona_Efekt_Utwórz( amunicja_f : TAmunicja; const czy_torpeda_efekt_na_wodzie_f : boolean; const czy_wieloosobowa_f : boolean = false  );
var
  zt_gl_dummy_cube : TGLDummyCube;
begin

  //
  // Funkcja dodaje efekt lotu amunicji.
  //
  // Parametry:
  //   czy_torpeda_efekt_na_wodzie_f
  //     false - dodaje efekt śladu za amunicją.
  //     true - dodaje efekt śladu amunicji na wodzie.
  //   czy_wieloosobowa_f:
  //     false - amunicja przeliczana w grze pojedynczej lub na serwerze.
  //     true - amunicja tylko wyświetlana u klientów wieloosobowych.
  //


  if   ( amunicja_f = nil )
    or (  not Assigned( amunicja_f )  ) then
    Exit;


  if czy_torpeda_efekt_na_wodzie_f then
    zt_gl_dummy_cube := amunicja_f.torpeda_efekt_na_wodzie
  else//if czy_torpeda_efekt_na_wodzie_f then
    zt_gl_dummy_cube := amunicja_f.korpus_ustawienie_początkowe_dummy;


  //???
  // Dodaje efekt smugi za pociskiem.
  with GetOrCreateSourcePFX( zt_gl_dummy_cube ) do // uses GLParticleFX.
    begin

      Manager := Efekt__Smuga_GLPerlinPFXManager;
      //TGLPerlinPFXManager(Manager).Acceleration.AsVector := VectorNegate( zt_amunicja.korpus_opadanie_obrót_dummy.AbsoluteDirection );

      VelocityMode := GLParticleFX.svmAbsolute;

      if not czy_torpeda_efekt_na_wodzie_f then // Efekt na wodzie jest w poziomie.
        if not czy_wieloosobowa_f then
          InitialVelocity.AsVector := VectorNegate( amunicja_f.AbsoluteDirection )
        else//if not czy_wieloosobowa_f then
          InitialVelocity.AsVector := amunicja_f.AbsoluteDirection; // Nie wiem dlaczego amunicja wieloosobowa ma odwrócony kierunek bezwzględny.

      //InitialVelocity.AsVector := amunicja_f.AbsoluteDirection;
      //VelocityDispersion := 0.0001;
      //DispersionMode := GLParticleFX.sdmIsotropic;

    end;
  //---//with GetOrCreateSourcePFX( zt_gl_dummy_cube ) do

end;//---//Funkcja Amunicja_Wystrzelona_Efekt_Utwórz().

//Funkcja Odczytaj_Liczbę_Z_Napisu().
function TStatki_Form.Odczytaj_Liczbę_Z_Napisu( napis_f : string; const wartość_minimalna_f : variant; const przełącz_zakładkę_f : boolean = true ) : real;
begin

  //
  // Funkcja odczytuje liczbę z napisu.
  //
  // Zwraca odczytaną liczbę.
  //
  // Parametry:
  //   napis_f
  //   wartość_minimalna_f - jeżeli jest różna od null i wynik jest mniejszy od niej to zwraca tą wartość.
  //   przełącz_zakładkę_f:
  //     false - nie przełącza zakładki.
  //     true - przełącza zakładkę.
  //

  napis_f := StringReplace( napis_f, '.', ',', [ rfReplaceAll ] );
  napis_f := Trim(  StringReplace( napis_f, ' ', '', [ rfReplaceAll ] )  );

  try
    Result := StrToFloat( napis_f );
  except
    on E : Exception do
      begin

        Result := 1;
        Log_Wypisz( 'Błąd odczytania liczby z napisu: ' + napis_f + ' ' + E.Message + ' ' + IntToStr( E.HelpContext ) + '.', przełącz_zakładkę_f );

      end;
    //---//on E : Exception do
  end;
  //---//try

  if    ( wartość_minimalna_f <> null )
    and ( Result < wartość_minimalna_f ) then
    Result := wartość_minimalna_f;

end;//---//Funkcja Odczytaj_Liczbę_Z_Napisu().

//Funkcja Wygląd_Elementy__Utwórz_Element().
function TStatki_Form.Wygląd_Elementy__Utwórz_Element( const statek_f : TStatek; const ląd_prymityw_f : string; const właściciel_gl_base_scene_object_f : TGLBaseSceneObject; const rodzic_gl_dummy_cube_f : TGLDummyCube = nil ) : TGLCustomSceneObject;
begin

  //
  // Funkcja tworzy elementy wyglądu.
  //
  // Zwraca utworzony element wyglądu.
  //
  // Parametry:
  //   statek_f
  //     = nil - tworzy elementów wyglądu lądu.
  //     <> nil - tworzy elementów wyglądu statku.
  //   ląd_prymityw_f -symbol typu elementu wyglądu (kula, prostopadłościan itp.)
  //   właściciel_gl_base_scene_object_f - właściciel tworzonego elementu wyglądu
  //   rodzic_gl_dummy_cube_f - rodzic tworzonego elementu wyglądu:
  //     = nil - rodzicem jest właściciel.
  //     <> nil - rodzicem jest kontener na prymitywy.
  //


  Result := nil;


  if ląd_prymityw_f = wygląd_prymityw__kula_c then
    Result := TGLSphere.Create( właściciel_gl_base_scene_object_f )
  else
  if ląd_prymityw_f = wygląd_prymityw__ostrosłup_c then
    begin

      Result := TGLFrustrum.Create( właściciel_gl_base_scene_object_f );
      TGLFrustrum(Result).Height := 1;
      TGLFrustrum(Result).ApexHeight := 1;

    end
  else//if ląd_prymityw_f = wygląd_prymityw__ostrosłup_c then
  if ląd_prymityw_f = wygląd_prymityw__prostopadłościan_c then
    Result := TGLCube.Create( właściciel_gl_base_scene_object_f )
  else
  if ląd_prymityw_f = wygląd_prymityw__stożek_c then
    Result := TGLCone.Create( właściciel_gl_base_scene_object_f )
  else
  if ląd_prymityw_f = wygląd_prymityw__walec_c then
    Result := TGLCylinder.Create( właściciel_gl_base_scene_object_f )
  else
  if ląd_prymityw_f = wygląd_prymityw_c then
    Result := TGLDummyCube.Create( właściciel_gl_base_scene_object_f )
  else
    //Result := TGLSphere.Create( właściciel_gl_base_scene_object_f );
    if statek_f = nil then
      Log_Wypisz( 'Tworzenie lądu - nieznany typ prymitywu: ' + ląd_prymityw_f + '.', not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked )
    else//if statek_f = nil then
      Log_Wypisz( 'Tworzenie elementów statku - nieznany typ prymitywu: ' + ląd_prymityw_f + '.', not Statki_Form.Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked );


  if Result <> nil then
    begin

      if rodzic_gl_dummy_cube_f = nil then
        Result.Parent := właściciel_gl_base_scene_object_f
      else//if rodzic_gl_dummy_cube_f = nil then
        Result.Parent := rodzic_gl_dummy_cube_f;


      if ląd_prymityw_f <> wygląd_prymityw_c then
        begin

          // Do kontenera prymitywów nie dodaje detekcji kolizji.

          if statek_f = nil then
            begin

              Result.Name := 'Ląd__' + Trim(  FormatFloat( '000000000', ląd_list.Count + 1 )  );
              Result.TagFloat := 1; // Siła wpływu kolizji.

            end
          else//if statek_f = nil then
            Result.Name := 'Statek_Wygląd_Elementy__' + Trim(  FormatFloat( '0000', statek_f.id_statek )  ) + '__' + Trim(  FormatFloat( '000000000', statek_f.wygląd_elementy_list.Count + 1 )  );

          //Result.MoveUp(); // Aby nie zasłaniało Informacje_Główne_GLHUDText. //???



          // Dynamiczne dodanie zdarzenia kolizji.
          with TGLBCollision.Create( Result.Behaviours ) do
            begin

              GroupIndex := 0;
              Manager := GLCollisionManager1;

              if ląd_prymityw_f = wygląd_prymityw__kula_c then
                BoundingMode := cbmSphere
              else//if ląd_prymityw_f = wygląd_prymityw__kula_c then
                BoundingMode := cbmCube;

            end;
          //---//with TGLBCollision.Create( Result.Behaviours ) do

        end;
      //---//if ląd_prymityw_f <> wygląd_prymityw_c then

    end;
  //---//if Result <> nil then

end;//---//Funkcja Wygląd_Elementy__Utwórz_Element().

//Funkcja Wygląd_Elementy__Tekstura_Wczytaj().
function TStatki_Form.Wygląd_Elementy__Tekstura_Wczytaj( gl_custom_scene_object_f : TGLCustomSceneObject; tekstura_ścieżka_f : string ) : boolean;
var
  bit_map : TBitmap;
  obrazek_png : TPngImage; //Potrzebuje w uses pngimage.
begin

  Result := false;

  if Trim( tekstura_ścieżka_f ) = '' then
    Exit;

  if not FileExists( tekstura_ścieżka_f ) then // Application potrzebuje w uses Forms.
    tekstura_ścieżka_f := ExtractFilePath( Application.ExeName ) + 'Tekstury\' + tekstura_ścieżka_f;

  if not FileExists( tekstura_ścieżka_f ) then // Application potrzebuje w uses Forms.
    Exit;

  if AnsiLowerCase(  ExtractFileExt( tekstura_ścieżka_f )  ) <> '.png' then
    Exit;


  bit_map := TBitmap.Create();

  obrazek_png := TPngImage.Create();
  obrazek_png.LoadFromFile( tekstura_ścieżka_f );
  bit_map.Assign( obrazek_png );
  obrazek_png.Free();

  if not bit_map.Empty then
    begin

      gl_custom_scene_object_f.Material.Texture.Image.Assign( bit_map );
      gl_custom_scene_object_f.Material.Texture.Enabled := true;

    end;
  //---//if not bit_map.Empty then

  bit_map.Free();

  Result := true;

end;//---//Funkcja Wygląd_Elementy__Tekstura_Wczytaj().

//Funkcja Ląd_Utwórz().
procedure TStatki_Form.Ląd_Utwórz( const lista_indeks_f : integer; const prymityw_indeks_f : integer = -99; const prymityw_rodzic_gl_dummy_cube_f : TGLDummyCube = nil );
var
  i,
  j,
  jj
    : integer;
  ztr_1,
  ztr_2,
  ztr_3,
  ztr_4
    : real;
  definicja_treść : string;
  zt_xml_document : TXMLDocument; //uses XMLDoc
  zt_gl_custom_scene_object : TGLCustomSceneObject;
  wygląd_kolor_definicja : TWygląd_Kolor_Definicja;
begin

  //
  // Funkcja tworzy ląd (mapę gry).
  //
  // Parametry:
  //   lista_indeks_f:
  //     = -99 - ląd tworzony na podstawie danych otrzymanych z serwera.
  //     <> -99 - ląd tworzony na podstawie danych z pola wyboru lądu.
  //   prymityw_indeks_f:
  //     = -99 - tworzy ląd.
  //     <> -99 - tworzy prymityw.
  //   prymityw_rodzic_gl_dummy_cube_f
  //     = nil - tworzy ląd.
  //     <> nil - tworzy prymityw (rodzicem tworzonych obiektów jest utworzony wcześniej kontener TGLDummyCube).
  //

  if prymityw_indeks_f = -99 then
    begin

      // Tworzy ląd.

      ląd_pozycja_początkowa_parametry_t[ 1 ].korekta_obrót := 0;
      ląd_pozycja_początkowa_parametry_t[ 1 ].korekta_x := 0;
      ląd_pozycja_początkowa_parametry_t[ 1 ].korekta_z := 0;
      ląd_pozycja_początkowa_parametry_t[ 1 ].odstęp_x := 7;
      ląd_pozycja_początkowa_parametry_t[ 1 ].z := 10;
      ląd_pozycja_początkowa_parametry_t[ 2 ].korekta_obrót := 180;
      ląd_pozycja_początkowa_parametry_t[ 2 ].korekta_x := 0;
      ląd_pozycja_początkowa_parametry_t[ 2 ].korekta_z := 0;
      ląd_pozycja_początkowa_parametry_t[ 2 ].odstęp_x := 7;
      ląd_pozycja_początkowa_parametry_t[ 2 ].z := -10;

    end;
  //---//if prymityw_indeks_f = -99 then


  if   ( ląd_list = nil )
    or (  not Assigned( ląd_list )  ) then
    Exit;


  if prymityw_indeks_f = -99 then
    begin

      // Tworzy ląd.

      if lista_indeks_f <> -99 then
        begin

          if   ( lista_indeks_f < 0 )
            or (  lista_indeks_f > Length( lądy_lista_t ) - 1  ) then
            begin

              Application.MessageBox( 'Brak definicji lądu.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
              Exit;

            end;
          //---//if   ( lista_indeks_f < 0 ) (...)

          ląd_definicja_g := lądy_lista_t[ lista_indeks_f ].treść;
          definicja_treść := ląd_definicja_g;

        end
      else//if lista_indeks_f <> -99 then
        definicja_treść := ląd_definicja_g; // Dla klientów.

    end
  else//if prymityw_indeks_f = -99 then
    begin

      // Tworzy prymityw.

      if   ( ląd_list = nil )
        or (  not Assigned( ląd_list )  ) then
        Exit;


      if prymityw_indeks_f <> -99 then
        begin

          if   ( prymityw_indeks_f < 0 )
            or (  prymityw_indeks_f > Length( prymitywy_lista_t ) - 1  ) then
            begin

              Application.MessageBox( 'Brak definicji prymitywu.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
              Exit;

            end;
          //---//if   ( prymityw_indeks_f < 0 ) (...)

          definicja_treść := prymitywy_lista_t[ prymityw_indeks_f ].treść;

        end;
      //---//if prymityw_indeks_f <> -99 then

    end;
  //---//if prymityw_indeks_f = -99 then


  zt_xml_document := TXMLDocument.Create( Application );

  zt_xml_document.Options := zt_xml_document.Options + [ doNodeAutoIndent ]; // Domyślnie ma: doNodeAutoCreate, doAttrNull, doAutoPrefix, doNamespaceDecl.

  try
    // Serwer zgłasza błąd podczas odczytu danych o lądzie od klienta
    //   MSXML is not installed
    //   Assertion failure GLContext.pas
    // W Ląd_Zwolnij() chyba też takie coś się dzieje (inne błędy) ale z podobnego powodu.
    //
    // Udało się uniknąć błędów tak:
    //   w zdarzeniu odczytania danych o lądzie tylko włączyć Timer;
    //   w Timer.OnTimet wyłączyć Timer i wywołać zwalnianie i wczytywanie lądu.
    //
    zt_xml_document.LoadFromXML( definicja_treść );
  except
    on E : Exception do
      if prymityw_indeks_f = -99 then
        //Application.MessageBox(  PChar('Nieprawidłowa definicja lądu.' + #13 + E.Message + ' ' + IntToStr( E.HelpContext )), 'Błąd', MB_OK + MB_ICONEXCLAMATION  );
        Log_Wypisz(  'Nieprawidłowa definicja lądu.' + #13 + #10 + E.Message + ' ' + IntToStr( E.HelpContext ), not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked  )
      else//if prymityw_indeks_f = -99 then
        Log_Wypisz(  'Nieprawidłowa definicja prymitywu.' + #13 + #10 + E.Message + ' ' + IntToStr( E.HelpContext ), not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked  );
  end;
  //---//try

  {$region 'Odczyt danych xml.'}
  if zt_xml_document.Active then
    begin

      wygląd_kolor_definicja := TWygląd_Kolor_Definicja.Create();


      for i := 0 to zt_xml_document.DocumentElement.ChildNodes.Count - 1 do
        begin

          if    ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'kolor_definicja' )
            and (   Trim(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'nazwa' ] )  ) <> ''   )
            and (   not wygląd_kolor_definicja.Definicja_Istnieje(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'nazwa' ] )  )   ) then
            begin

              for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do
                begin

                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].LocalName = 'r' then
                    ztr_1 := Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].Text, 0, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                  else
                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].LocalName = 'g' then
                    ztr_2 := Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].Text, 0, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                  else
                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].LocalName = 'b' then
                    ztr_3 := Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].Text, 0, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                  else
                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].LocalName = 'a' then
                    ztr_4 := Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].Text, 0, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                end;
              //---//for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do


              wygląd_kolor_definicja.Dodaj_Definicję(  ztr_1, ztr_2, ztr_3, ztr_4, VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'nazwa' ] )  );

            end
          else//if    ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'kolor_definicja' ) (...)
          if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' )
            or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = wygląd_prymityw_c ) then
            begin

              if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' then
                zt_gl_custom_scene_object := Wygląd_Elementy__Utwórz_Element(  nil, VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'typ' ] ), Gra_Obiekty_GLDummyCube, prymityw_rodzic_gl_dummy_cube_f  )
              else//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' then
              if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = wygląd_prymityw_c then
                zt_gl_custom_scene_object := Wygląd_Elementy__Utwórz_Element( nil, wygląd_prymityw_c, Gra_Obiekty_GLDummyCube );


              if zt_gl_custom_scene_object <> nil then
                begin

                  ląd_list.Add( zt_gl_custom_scene_object );


                  if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = wygląd_prymityw_c then
                    for j := 0 to Length( prymitywy_lista_t ) - 1 do
                      if prymitywy_lista_t[ j ].plik_nazwa = VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'nazwa' ] ) then
                        begin

                          Ląd_Utwórz( lista_indeks_f, j, TGLDummyCube(zt_gl_custom_scene_object) ); // lista_indeks_f nie ma tutaj znaczenia.
                          Break;

                        end;
                      //---//if prymitywy_lista_t[ j ].plik_nazwa = VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'nazwa' ] ) then



                  for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do
                    begin

                      if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'kolor' then
                        begin

                          if    (   Trim(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Attributes[ 'nazwa' ] )  ) <> ''   )
                            and (   wygląd_kolor_definicja.Definicja_Istnieje(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Attributes[ 'nazwa' ] )  )   ) then
                            begin

                              zt_gl_custom_scene_object.Material.FrontProperties.Emission.Color := wygląd_kolor_definicja.Odczytaj_Definicję(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Attributes[ 'nazwa' ] )  );

                            end
                          else//if    (   Trim(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Attributes[ 'nazwa' ] )  ) <> ''   ) (...)
                            begin

                              for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do
                                begin

                                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'r' then
                                    ztr_1 := Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                                  else
                                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'g' then
                                    ztr_2 := Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                                  else
                                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'b' then
                                    ztr_3 := Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                                  else
                                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'a' then
                                    ztr_4 := Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                                end;
                              //---//for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do


                              zt_gl_custom_scene_object.Material.FrontProperties.Emission.SetColor( ztr_1, ztr_2, ztr_3, ztr_4 );

                            end;
                          //---//if    (   Trim(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Attributes[ 'nazwa' ] )  ) <> ''   ) (...)

                        end
                      else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'kolor' then
                      if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'kolor_nazwa' then
                        begin

                          zt_gl_custom_scene_object.Material.FrontProperties.Emission.Color := GLColor.ColorManager.GetColor( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text ); // Robi wyciek pamięci. // clrGreen clrYellowGreen clrBronze2 clrGray40

                        end
                      else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'kolor_nazwa' then
                      if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'obrót__lewo_prawo' then
                        begin

                          zt_gl_custom_scene_object.TurnAngle := Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                        end
                      else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'obrót__lewo_prawo' then
                      if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'siła_wpływu_kolizji' then
                        begin

                          zt_gl_custom_scene_object.TagFloat := Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0.0001, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                        end
                      else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'siła_wpływu_kolizji' then
                      if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'skala' then
                        begin

                          for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do
                            begin

                              if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'x' then
                                zt_gl_custom_scene_object.Scale.X := Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0.0001, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                              else
                              if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'y' then
                                zt_gl_custom_scene_object.Scale.Y := Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0.0001, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                              else
                              if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'z' then
                                zt_gl_custom_scene_object.Scale.Z := Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0.0001, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                            end;
                          //---//for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do

                        end
                      else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'skala' then
                      if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'skala_proporcjonalna' then
                        begin

                          zt_gl_custom_scene_object.Scale.Scale(  Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0.0001, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked )  );

                        end
                      else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'skala_proporcjonalna' then
                      if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'tekstura' then
                        begin

                          if not Wygląd_Elementy__Tekstura_Wczytaj( zt_gl_custom_scene_object, zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text )  then
                            Log_Wypisz( 'Tworzenie lądu - błąd wczytania tekstury: ' + zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text + '.', not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                        end
                      else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'tekstura' then
                      if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wartość_dodatkowa_01' then
                        begin

                          if zt_gl_custom_scene_object is TGLFrustrum then
                            TGLFrustrum(zt_gl_custom_scene_object).Height := Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                        end
                      else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wartość_dodatkowa_01' then
                      if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'współrzędne' then
                        begin

                          for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do
                            begin

                              if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'x' then
                                zt_gl_custom_scene_object.Position.X := Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                              else
                              if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'y' then
                                zt_gl_custom_scene_object.Position.Y := Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked )
                              else
                              if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'z' then
                                zt_gl_custom_scene_object.Position.Z := Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                            end;
                          //---//for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do

                        end
                      else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'współrzędne' then
                      if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wychylenie__lewo_prawo' then
                        begin

                          zt_gl_custom_scene_object.RollAngle := Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                        end
                      else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wychylenie__lewo_prawo' then
                      if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wychylenie__przód_tył' then
                        begin

                          zt_gl_custom_scene_object.PitchAngle := -Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked );

                        end;
                      //---//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wychylenie__przód_tył' then

                    end;
                  //---//for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do

                end;
              //---//if zt_gl_custom_scene_object <> nil then

            end
          else//if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' ) (...)
          if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'statki_pozycja_początkowa' then
            begin

              for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do
                begin

                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'grupa_1' then
                    begin

                      for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do
                        begin

                          if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'korekta_obrót' then
                            ląd_pozycja_początkowa_parametry_t[ 1 ].korekta_obrót := Round(  Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked )  )
                          else
                          if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'korekta_x' then
                            ląd_pozycja_początkowa_parametry_t[ 1 ].korekta_x := Round(  Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked )  )
                          else
                          if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'korekta_z' then
                            ląd_pozycja_początkowa_parametry_t[ 1 ].korekta_z := Round(  Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked )  )
                          else
                          if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'odstęp_x' then
                            ląd_pozycja_początkowa_parametry_t[ 1 ].odstęp_x := Round(  Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked )  )
                          else
                          if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'z' then
                            ląd_pozycja_początkowa_parametry_t[ 1 ].z := Round(  Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked )  );

                        end;
                      //---//for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do

                    end
                  else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'grupa_1' then
                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'grupa_2' then
                    begin

                      for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do
                        begin

                          if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'korekta_obrót' then
                            ląd_pozycja_początkowa_parametry_t[ 2 ].korekta_obrót := Round(  Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked )  )
                          else
                          if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'korekta_x' then
                            ląd_pozycja_początkowa_parametry_t[ 2 ].korekta_x := Round(  Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked )  )
                          else
                          if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'korekta_z' then
                            ląd_pozycja_początkowa_parametry_t[ 2 ].korekta_z := Round(  Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked )  )
                          else
                          if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'odstęp_x' then
                            ląd_pozycja_początkowa_parametry_t[ 2 ].odstęp_x := Round(  Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked )  )
                          else
                          if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'z' then
                            ląd_pozycja_początkowa_parametry_t[ 2 ].z := Round(  Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked )  );

                        end;
                      //---//for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do

                    end;
                  //---//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'grupa_2' then

                end;
              //---//for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do

            end;
          //---//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'statki_pozycja_początkowa' then

        end;
      //---//for i := 0 to zt_xml_document.DocumentElement.ChildNodes.Count - 1 do


      FreeAndNil( wygląd_kolor_definicja );

    end;
  //---//if zt_xml_document.Active then
  {$endregion 'Odczyt danych xml.'}


  zt_xml_document.Free();


  Radar_Ląd_Rysuj();


  {$region 'Przykład xml.'}
{
<ląd>
  <nazwa>Ląd 1</nazwa>
  <opis><![CDATA[Opis ląd 1.#13#10Nowa linia.]]></opis>


  <statki_pozycja_początkowa> <!-- Rozmieszczenie statków może być zdefiniowane w definicji lądu. -->
    <grupa_1>
      <korekta_obrót>123</korekta_obrót> <!-- Początkowy obrót statku (+) lewo (-) prawo. -->
      <korekta_x>123</korekta_x> <!-- Przesunięcie pozycji wszystkich statków w grupie (-) lewo (+) prawo. -->
      <korekta_z>123</korekta_z> <!-- Przesunięcie pozycji każdego statku w grupie osobno o wielokrotność wartości (-) przód (+) tył. -->
      <odstęp_x>123</odstęp_x> <!-- Odstęp między statkami po bokach. -->
      <z>123</z> <!-- Odstęp od środka planszy (-) przód (+) tył. -->
    </grupa_1>

    <grupa_2>
      <korekta_obrót>123</korekta_obrót>
      <korekta_x>123</korekta_x>
      <korekta_z>-123</korekta_z>
      <odstęp_x>123</odstęp_x>
      <z>-123</z>
    </grupa_2>
  </statki_pozycja_początkowa>


  <kolor_definicja nazwa="kolor nazwa abc">
    <r>0,0</r>
    <g>0,5</g>
    <b>0,0</b>
    <a>0</a>
  </kolor_definicja>


  <obiekt typ="kula">
    <!-- Wymiar wynosi 1 we wszystkich głównych kierunkach. -->

    <kolor>
      <r>0</r>
      <g>1</g>
      <b>0,5</b>
      <a>0</a>
    </kolor>
      <!-- Od 0 (czarny) do 1 (biały), ujemne działają jakoś odwrotnie, a - nie wiem. -->
    <kolor nazwa="kolor nazwa abc"/>
    <kolor_nazwa>clrGreen</kolor_nazwa> <!-- Robi wyciek pamięci. -->

    <skala>
      <x>1</x>
      <y>123,456</y>
      <z>123,456</z>
    </skala>
      <!-- 0 - w danym wymiarze jest jak płaszczyzna, ujemne działają jak dodatnie. -->

    <skala_proporcjonalna>2</skala_proporcjonalna>
      <!-- 0, ujemne działają jak dodatnie. -->

    <siła_wpływu_kolizji>1</siła_wpływu_kolizji>
      <!-- 1 - domyślna wartość, 0 - 1 spowalnia 1 - 3 odbija (im większa wartość tym mocniej odbija). -->

    <współrzędne>
      <x>123,456</x>
      <y>123,456</y>
      <z>123,456</z>
    </współrzędne>

    <wychylenie__lewo_prawo>123,456</wychylenie__lewo_prawo>
    <obrót__lewo_prawo>123,456</obrót__lewo_prawo>
    <wychylenie__przód_tył>123,456</wychylenie__przód_tył>
      <!-- -(minus) w dół, +(plus) w górę. -->
      <!-- 0, ujemne działają, większe wartości obniżane są poprzez wielokrotność 180. -->

    <tekstura>K1\P_1.png</tekstura>
      <!-- Pliki 'png'. Domyślnie ścieżka w katalogu 'Tekstury' w folderze z grą. -->

    <wartość_dodatkowa_01>123,456 abc</wartość_dodatkowa_01>
      <!-- Dla wybranych prymitywów (brył) dodatkowe parametry, których wartość i typ wartości zależy od danego prymitywu. -->
        <!-- Dla prymitywu: ostrosłup - Height - 123,456 - w zakresie od 0 do 1 - ( 0, 1 >. -->
  </obiekt>
</ląd>
}
  {$endregion 'Przykład xml.'}

end;//---//Funkcja Ląd_Utwórz().

//Funkcja Ląd_Zwolnij().
procedure TStatki_Form.Ląd_Zwolnij();
var
  i : integer;
begin

  if   ( ląd_list = nil )
    or (  not Assigned( ląd_list )  ) then
    Exit;


  for i := ląd_list.Count - 1 downto 0 do
    begin
        
      TGLCustomSceneObject(ląd_list[ i ]).Free();
      ląd_list.Delete( i );

    end;
  //---//for i := ląd_list.Count - 1 downto 0 do

end;//---//Funkcja Ląd_Zwolnij().

//Funkcja Statki_Zwolnij().
procedure TStatki_Form.Statki_Zwolnij( const zwolnij_pierwszy_statek_f : boolean = true; zwolnij_statki_za_pierwszym_f : boolean = true );

  //Funkcja Statek_Zwolnij() w Statki_Zwolnij().
  procedure Statek_Zwolnij( const indeks_statku_f : integer );
    var
      i_l : integer;
  begin

    if   ( indeks_statku_f < 0 )
      or (  indeks_statku_f > Length( statki_t ) - 1 ) then
      Exit;


    // Aby nie zwolniło kamery wraz ze statkiem.
    while GLCamera1.Parent = statki_t[ indeks_statku_f ] do
      Kamera_Przełącz( kt_Swobodna );


    for i_l := trafienia_efekt_list.Count - 1 downto 0 do
      begin

        // Zwalnia efekty umieszczone na statku.
        // Jeżeli efekty umieszczone na statku nadal są na scenie pojawiają się błędy dostępu.

        if   ( TTrafienia_Efekt(trafienia_efekt_list[ i_l ]).Owner = statki_t[ indeks_statku_f ] )
          or ( TTrafienia_Efekt(trafienia_efekt_list[ i_l ]).Parent = statki_t[ indeks_statku_f ] ) then
          Trafienia_Efekt_Zwolnij_Jeden( TTrafienia_Efekt(trafienia_efekt_list[ i_l ]) );

      end;
    //---//for i_l := trafienia_efekt_list.Count - 1 downto 0 do


    if statek_gracza = statki_t[ indeks_statku_f ] then
      statek_gracza := nil; // Nie zmienia statki_t[ 0 ].

    if projektowy_tryb__statek = statki_t[ indeks_statku_f ] then
      projektowy_tryb__statek := nil;


    FreeAndNil( statki_t[ indeks_statku_f ] );

  end;//---//Funkcja Statek_Zwolnij() w Statki_Zwolnij().

var
  i : integer;
begin//Funkcja Statki_Zwolnij().

  //
  // Funkcja zwalnia utworzone statki i czyści listę statków.
  //
  // Parametry:
  //   zwolnij_pierwszy_statek_f:
  //     false - nie zwalnia pierwszego statku.
  //     true - zwalnia tylko pierwszy statek.
  //   zwolnij_statki_za_pierwszym_f:
  //     false - nie zwalnia statków po pierwszym statku.
  //     true - nie zwalnia pierwszego statku (gdy prezentuje wszystkie statki zwolni tylko statki prezentowane).
  //
  //     kolejność statków według indeksów w tabeli;
  //     statek pierwszy (indeks 0) jest tym wybranym w menu przez gracza;
  //     gry zwolnij_pierwszy_statek_f i zwolnij_statki_za_pierwszym_f = true zwolni wszystkie statki.
  //

  if    ( zwolnij_pierwszy_statek_f )
    and ( zwolnij_statki_za_pierwszym_f ) then
    begin

      // Aby nie zwolniło kamery wraz ze statkiem.
      while GLCamera1.Parent <> GLScene1.Objects do
        Kamera_Przełącz( kt_Swobodna );

      Trafienia_Efekt_Zwolnij_Wszystkie();

      statek_gracza := nil; // Nie zmienia statki_t[ 0 ].
      projektowy_tryb__statek := nil;

      for i := 0 to Length( statki_t ) - 1 do
        FreeAndNil( statki_t[ i ] );

      SetLength( statki_t, 0 );

    end
  else//if    ( zwolnij_pierwszy_statek_f ) (...)
    begin

      if zwolnij_statki_za_pierwszym_f then
        begin

          for i := 1 to Length( statki_t ) - 1 do
            Statek_Zwolnij( i );

          SetLength( statki_t, 1 );

        end
      else//if zwolnij_statki_za_pierwszym_f then
        if zwolnij_pierwszy_statek_f then
          Statek_Zwolnij( 0 );

    end;
  //---//if    ( zwolnij_pierwszy_statek_f ) (...)

end;//---//Funkcja Statki_Zwolnij().

//Funkcja Statek_Odczytaj_Schemat().
function TStatki_Form.Statek_Odczytaj_Schemat( const lista_indeks_f : integer ) : string;
begin

  if   ( lista_indeks_f < 0 )
    or (  lista_indeks_f > Length( statki_lista_t ) - 1  ) then
    begin

      Result := '';
      
      Log_Wypisz( 'Brak definicji statku.' );
      Exit;

    end;
  //---//if   ( Statek_ComboBox.Items.Count < 0 ) (...)
  
  Result := statki_lista_t[ lista_indeks_f ].treść;

end;//---//Funkcja Statek_Odczytaj_Schemat().

//Funkcja Trafienia_Efekt_Utwórz_Jeden().
procedure TStatki_Form.Trafienia_Efekt_Utwórz_Jeden( AOwner : TGLBaseSceneObject; efekt_rodzaj_f : TEfekt_Rodzaj; x_f, y_f, z_f : real; amunicja_f : TAmunicja; czas_trwania_f, czas_trwania_efekt_dodatkowy_f : Int64 );
var
  czas_trwania_l, // Dla elementów wieloosobowych.
  czas_trwania_efekt_dodatkowy_l // Dla elementów wieloosobowych.
    : Int64;
  zt_trafienia_efekt : TTrafienia_Efekt;
begin

  if   ( trafienia_efekt_list = nil )
    or (  not Assigned( trafienia_efekt_list )  ) then
    Exit;


  //if efekt_rodzaj_f = er_Trafienie_Statek then
  //  zt_trafienia_efekt := TTrafienia_Efekt.Create( AOwner, Efekt__Wpadnięcie_Do_Wody_GLFireFXManager, x_f, y_f, z_f, 0, amunicja_f )
  //else
  //if efekt_rodzaj_f = er_Trafienie_Woda then
  //  zt_trafienia_efekt := TTrafienia_Efekt.Create( AOwner, Efekt__Wpadnięcie_Do_Wody_GLPolygonPFXManager, x_f, y_f + 1, z_f, GLCadencer1.CurrentTime, amunicja_f )
  //else
  //  zt_trafienia_efekt := nil;
  //if gl_cadence_able_component_f is TGLFireFXManager then
  //if gl_cadence_able_component_f is TGLPolygonPFXManager then


  {$region 'Podstawowe efekty.'}
  zt_trafienia_efekt := TTrafienia_Efekt.Create( AOwner, x_f, y_f, z_f );

  // Dynamiczne dodanie efektu.
  //if efekt_rodzaj_f = er_Trafienie_Ląd then
  //  begin
  //
  //    //TGLBFireFX(zt_trafienia_efekt.AddNewEffect(TGLBFireFX)).Manager := Efekt__Wpadnięcie_Do_Wody_0_GLFireFXManager;
  //
  //  end
  //else//if efekt_rodzaj_f = er_Trafienie_Ląd then
  if   ( efekt_rodzaj_f = er_Trafienie_Statek )
    or ( efekt_rodzaj_f = er_Trafienie_Ląd ) then
    begin

      zt_trafienia_efekt.czas_trwania := Random( 1000 );

      // Zmienia rozmiar efektu.
      if amunicja_f <> nil then
        begin

          case amunicja_f.amunicja_rodzaj of
              ar_Artyleria :
                begin

                  zt_trafienia_efekt.Scale.Scale( 5 );

                end;
              //---//ar_Artyleria :

              ar_Pocisk :
                begin

                  //zt_trafienia_efekt.Scale.Scale( 1 );

                end;
              //---//ar_Pocisk :

              ar_Torpeda :
                begin

                  zt_trafienia_efekt.Scale.Scale( 2 );

                end;
              //---//ar_Torpeda :
            end;
          //---//case amunicja_f.amunicja_rodzaj of

        end;
      //---//if amunicja_f <> nil then


      TGLBFireFX(zt_trafienia_efekt.AddNewEffect(TGLBFireFX)).Manager := Efekt__Ogień_GLFireFXManager;

    end
  else//if   ( efekt_rodzaj_f = er_Trafienie_Statek ) (...)
  if efekt_rodzaj_f = er_Trafienie_Woda then
    begin

      zt_trafienia_efekt.czas_trwania := 1500;

      // Gdy kamera jest wewnątrz efektu bardzo zwalnia.

      TGLSourcePFXEffect(zt_trafienia_efekt.AddNewEffect(TGLSourcePFXEffect)).Manager := Efekt__Wpadnięcie_Do_Wody_GLPolygonPFXManager;

      with GetOrCreateSourcePFX( zt_trafienia_efekt ) do // uses GLParticleFX.
        begin

          // Jedno światełko na środku jest zawsze.

          VelocityDispersion := 0.75; // Prędkość rozpadania się i wznoszenia.
          Burst( GLCadencer1.CurrentTime, 100 ); // Ilość wylatujących światełek.

          VelocityDispersion := 0.05; // Prędkość rozpadania się i wznoszenia.
          Burst( GLCadencer1.CurrentTime, 1 ); // Ilość wylatujących światełek.

          VelocityDispersion := 0; // Prędkość rozpadania się i wznoszenia.
          RingExplosion( GLCadencer1.CurrentTime, 1, 1.2, 75 ); // uses GLParticleFX.
          //EffectScale := 0.0001; //??? nie działa dobrze

        end;
      //---//with GetOrCreateSourcePFX( zt_trafienia_efekt ) do

      //TGLBFireFX(zt_trafienia_efekt.AddNewEffect(TGLBFireFX)).Manager := Efekt__Wpadnięcie_Do_Wody_0_GLFireFXManager;

    end;
  //---//if efekt_rodzaj_f = er_Trafienie_Woda then


  if zt_trafienia_efekt <> nil then
    begin

      czas_trwania_l := zt_trafienia_efekt.czas_trwania;

      if czas_trwania_f > 0 then // Dla elementów wieloosobowych.
        zt_trafienia_efekt.czas_trwania := czas_trwania_f;

      trafienia_efekt_list.Add( zt_trafienia_efekt );

    end
  else//if zt_trafienia_efekt <> nil then
    czas_trwania_l := -1;
  {$endregion 'Podstawowe efekty.'}


  {$region 'Dodatkowe efekty.'}
  zt_trafienia_efekt := nil;

  if efekt_rodzaj_f = er_Trafienie_Ląd then
    begin

      zt_trafienia_efekt := TTrafienia_Efekt.Create( AOwner, x_f, y_f, z_f );

      with GetOrCreateSourcePFX( zt_trafienia_efekt ) do // uses GLParticleFX.
        begin

          Manager := Efekt__Mgła_GLPerlinPFXManager;
          // Gdy kamera jest wewnątrz efektu bardzo zwalnia.

          // Zmienia rozmiar efektu.
          if amunicja_f <> nil then
            begin

              case amunicja_f.amunicja_rodzaj of
                  ar_Artyleria :
                    begin

                      //EffectScale := 1;

                    end;
                  //---//ar_Artyleria :

                  ar_Pocisk :
                    begin

                      EffectScale := 0.05;

                    end;
                  //---//ar_Pocisk :

                  ar_Torpeda :
                    begin

                      EffectScale := 0.1;

                    end;
                  //---//ar_Torpeda :
                end;
              //---//case amunicja_f.amunicja_rodzaj of

            end
          else//if amunicja_f <> nil then
            EffectScale := 0.2; // Kolizja statku ze statkiem.

        end;
      //---//with GetOrCreateSourcePFX( zt_trafienia_efekt ) do

    end
  else//if efekt_rodzaj_f = er_Trafienie_Ląd then
  if efekt_rodzaj_f = er_Trafienie_Statek then
    begin

      zt_trafienia_efekt := TTrafienia_Efekt.Create( AOwner, x_f, y_f, z_f );

      zt_trafienia_efekt.czas_trwania := Random( 10000 );

      with GetOrCreateSourcePFX( zt_trafienia_efekt ) do // uses GLParticleFX.
        begin

          Manager := Efekt__Dym_GLPerlinPFXManager;

          // Zmienia rozmiar efektu.
          if amunicja_f <> nil then
            begin

              case amunicja_f.amunicja_rodzaj of
                  ar_Artyleria :
                    begin

                      EffectScale := 5;

                    end;
                  //---//ar_Artyleria :

                  ar_Pocisk :
                    begin

                      //EffectScale := 1;

                    end;
                  //---//ar_Pocisk :

                  ar_Torpeda :
                    begin

                      EffectScale := 3;

                    end;
                  //---//ar_Torpeda :
                end;
              //---//case amunicja_f.amunicja_rodzaj of

            end;
          //---//if amunicja_f <> nil then

        end;
      //---//with GetOrCreateSourcePFX( zt_trafienia_efekt ) do

    end
  else//if efekt_rodzaj_f = er_Trafienie_Statek then
  if efekt_rodzaj_f = er_Trafienie_Woda then
    begin

      // Ustawia ten efekt, gdyż podstawowego nie widać wyraźnie.

      //zt_trafienia_efekt := TTrafienia_Efekt.Create( AOwner, x_f, y_f, z_f );
      //
      //zt_trafienia_efekt.czas_trwania := 1500;
      //
      //// Zmienia rozmiar rozprysku wody.
      //if amunicja_f <> nil then
      //  begin
      //
      //    case amunicja_f.amunicja_rodzaj of
      //        ar_Artyleria :
      //          begin
      //
      //            zt_trafienia_efekt.Scale.Scale( 5 );
      //
      //          end;
      //        //---//ar_Artyleria :
      //
      //        ar_Pocisk :
      //          begin
      //
      //            //zt_trafienia_efekt.Scale.Scale( 1 );
      //
      //          end;
      //        //---//ar_Pocisk :
      //
      //        ar_Torpeda :
      //          begin
      //
      //            zt_trafienia_efekt.Scale.Scale( 2 );
      //
      //          end;
      //        //---//ar_Torpeda :
      //      end;
      //    //---//case amunicja_f.amunicja_rodzaj of
      //
      //  end;
      ////---//if amunicja_f <> nil then
      //
      //
      //TGLBFireFX(zt_trafienia_efekt.AddNewEffect(TGLBFireFX)).Manager := Efekt__Wpadnięcie_Do_Wody_0_GLFireFXManager;

    end;
  //---//if efekt_rodzaj_f = er_Trafienie_Woda then


  if zt_trafienia_efekt <> nil then
    begin

      czas_trwania_efekt_dodatkowy_l := zt_trafienia_efekt.czas_trwania;

      if czas_trwania_efekt_dodatkowy_f > 0 then // Dla elementów wieloosobowych.
        zt_trafienia_efekt.czas_trwania := czas_trwania_efekt_dodatkowy_f;

      trafienia_efekt_list.Add( zt_trafienia_efekt );

    end
  else//if zt_trafienia_efekt <> nil then
    czas_trwania_efekt_dodatkowy_l := -1;
  {$endregion 'Dodatkowe efekty.'}


  Wieloosobowe__Efekt_Odczytaj_Jeden( AOwner, efekt_rodzaj_f, x_f, y_f, z_f, amunicja_f, czas_trwania_l, czas_trwania_efekt_dodatkowy_l );

end;//---//Funkcja Trafienia_Efekt_Utwórz_Jeden().

//Funkcja Trafienia_Efekt_Zwolnij_Jeden().
procedure TStatki_Form.Trafienia_Efekt_Zwolnij_Jeden( trafienia_efekt_f : TTrafienia_Efekt );
begin

  // Usuwać tylko w jednym miejscu. !!!
  // Wywołanie tej funkcji w kliku miejscach może coś zepsuć.

  if   ( trafienia_efekt_list = nil )
    or (  not Assigned( trafienia_efekt_list )  )
    or ( trafienia_efekt_f = nil ) then
    Exit;

  //pociski_magiczne_blokada := true;

  trafienia_efekt_list.Remove( trafienia_efekt_f );
  FreeAndNil( trafienia_efekt_f );

end;//---//Funkcja Trafienia_Efekt_Zwolnij_Jeden()

//Funkcja Trafienia_Efekt_Zwolnij_Wszystkie().
procedure TStatki_Form.Trafienia_Efekt_Zwolnij_Wszystkie();
var
  i : integer;
begin

  if   ( trafienia_efekt_list = nil )
    or (  not Assigned( trafienia_efekt_list )  ) then
    Exit;


  for i := trafienia_efekt_list.Count - 1 downto 0 do
    begin

      TTrafienia_Efekt(trafienia_efekt_list[ i ]).Free();
      trafienia_efekt_list.Delete( i );

    end;
  //---//for i := trafienia_efekt_list.Count - 1 downto 0 do

end;//---//Funkcja Trafienia_Efekt_Zwolnij_Wszystkie().

//Funkcja Amunicja_Rodzaj_Zbiór_Zwróć().
function TStatki_Form.Amunicja_Rodzaj_Zbiór_Zwróć() : TAmunicja_Rodzaj_Zbiór;
begin

  // To samo TAmunicja_Rodzaj, Amunicja_Rodzaj_Zbiór_Zwróć().

  //
  // Funkcja zbiór rodzajów amunicji.
  //
  // Zwraca zbiór rodzajów amunicji.
  //

  Result := Amunicja_Rodzaj_Zbiór_Zwróć( false, ar_Artyleria_CheckBox.Checked, ar_Pocisk_CheckBox.Checked, ar_Torpeda_CheckBox.Checked, ar_Wszystkie_CheckBox.Checked );

end;//---//Funkcja Amunicja_Rodzaj_Zbiór_Zwróć().

//Funkcja Amunicja_Rodzaj_Zbiór_Zwróć().
function TStatki_Form.Amunicja_Rodzaj_Zbiór_Zwróć( const ar_brak_f, ar_artyleria_f, ar_pocisk_f, ar_torpeda_f, ar_wszystkie_f : boolean ) : TAmunicja_Rodzaj_Zbiór;
begin

  // To samo TAmunicja_Rodzaj, Amunicja_Rodzaj_Zbiór_Zwróć().

  //
  // Funkcja na podstawie wybranych rodzajów amunicji tworzy zbiór rodzajów amunicji.
  //
  // Zwraca zbiór rodzajów amunicji.
  //
  // Parametry:
  //   ar_brak
  //   ar_artyleria
  //   ar_pocisk
  //   ar_torpeda
  //   ar_wszystkie
  //

  if ar_wszystkie_f then
    Result := [ ar_Wszystkie ]
  else//if ar_wszystkie_f then
    begin

      Result := [];

      if ar_artyleria_f then
        Result := Result + [ ar_Artyleria ];

      if ar_pocisk_f then
        Result := Result + [ ar_Pocisk ];

      if ar_torpeda_f then
        Result := Result + [ ar_Torpeda ];

    end;
  //---//if ar_wszystkie_f then

end;//---//Funkcja Amunicja_Rodzaj_Zbiór_Zwróć().

//Funkcja Klawisz_Wciśnięto_Sprawdź().
function TStatki_Form.Klawisz_Wciśnięto_Sprawdź( const klawiatura_konfiguracja_r_f : TKlawiatura_Konfiguracja_r; const klawisz_f : Word; const mysz_przycisk_f : SmallInt; const shift_f : TShiftState; const czy_z_wieloosobowe__odczytaj_f : boolean = false ) : boolean;

  //Funkcja Klawisz_Plus__Alt_Ctrl_Shift() w Klawisz_Wciśnięto_Sprawdź().
  function Klawisz_Plus__Alt_Ctrl_Shift( const klawiatura_konfiguracja_r_f : TKlawiatura_Konfiguracja_r ) : boolean; overload;
  begin

    //
    // Funkcja sprawdza czy wciśnięto klawisz z odpowiednią konfiguracją klawiszy Alt, Ctrl, Shift.
    //
    // Zwraca prawdę gdy wciśnięto klawisz z odpowiednią konfiguracją klawiszy Alt, Ctrl, Shift.
    //
    // Parametry:
    //   klawiatura_konfiguracja_r_f
    //

    if    (
               (
                     ( klawiatura_konfiguracja_r_f.plus_alt )
                 and (  IsKeyDown( VK_MENU )  )
               )
            or (
                     ( not klawiatura_konfiguracja_r_f.plus_alt )
                 and (  not IsKeyDown( VK_MENU )  )
               )
          )
      and (
               (
                     ( klawiatura_konfiguracja_r_f.plus_ctrl )
                 and ( IsKeyDown( VK_CONTROL ) )
               )
            or (
                     ( not klawiatura_konfiguracja_r_f.plus_ctrl )
                 and (  not IsKeyDown( VK_CONTROL )  )
               )
          )
      and (
               (
                     ( klawiatura_konfiguracja_r_f.plus_shift )
                 and ( IsKeyDown( VK_SHIFT ) )
               )
            or (
                     ( not klawiatura_konfiguracja_r_f.plus_shift )
                 and (  not IsKeyDown( VK_SHIFT )  )
               )
          )
      then
      Result := true
    else//if    ( (...)
      Result := false;

  end;//---//Funkcja Klawisz_Plus__Alt_Ctrl_Shift() w Klawisz_Wciśnięto_Sprawdź().

  //Funkcja Klawisz_Plus__Alt_Ctrl_Shift() w Klawisz_Wciśnięto_Sprawdź().
  function Klawisz_Plus__Alt_Ctrl_Shift( const klawiatura_konfiguracja_r_f : TKlawiatura_Konfiguracja_r; const shift_f : TShiftState ) : boolean; overload;
  begin

    //
    // Funkcja sprawdza czy wciśnięto klawisz z odpowiednią konfiguracją klawiszy Alt, Ctrl, Shift.
    //
    // Zwraca prawdę gdy wciśnięto klawisz z odpowiednią konfiguracją klawiszy Alt, Ctrl, Shift.
    //
    // Parametry:
    //   klawiatura_konfiguracja_r_f
    //   shift_f:
    //

    if    (
               (
                     ( klawiatura_konfiguracja_r_f.plus_alt )
                 and ( ssAlt in shift_f )
               )
            or (
                     ( not klawiatura_konfiguracja_r_f.plus_alt )
                 and (  not ( ssAlt in shift_f )  )
               )
          )
      and (
               (
                     ( klawiatura_konfiguracja_r_f.plus_ctrl )
                 and ( ssCtrl in shift_f )
               )
            or (
                     ( not klawiatura_konfiguracja_r_f.plus_ctrl )
                 and (  not ( ssCtrl in shift_f )  )
               )
          )
      and (
               (
                     ( klawiatura_konfiguracja_r_f.plus_shift )
                 and ( ssShift in shift_f )
               )
            or (
                     ( not klawiatura_konfiguracja_r_f.plus_shift )
                 and (  not ( ssShift in shift_f )  )
               )
          )
      then
      Result := true
    else//if    ( (...)
      Result := false;

  end;//---//Funkcja Klawisz_Plus__Alt_Ctrl_Shift() w Klawisz_Wciśnięto_Sprawdź().

begin//Funkcja Klawisz_Wciśnięto_Sprawdź().

  //
  // Funkcja sprawdza czy została wciśnięta zadana kombinacja klawiszy.
  //
  // Zwraca prawdę gdy została wciśnięta zadana kombinacja klawiszy.
  //
  // Parametry:
  //   klawiatura_konfiguracja_r_f
  //   klawisz_f - wciśnięty klawisz (0 = brak) (ma znaczenie przy obsłudze klientów wieloosobowych).
  //   mysz_przycisk_f - wciśnięty przycisk myszy (-1 = brak).
  //   shift_f - wciśnięty klawisz funkcyjny (ma znaczenie przy obsłudze przycisków myszy i klientów wieloosobowych).
  //   czy_z_wieloosobowe__odczytaj_f
  //     false - informacja analizowana wewnętrznie w ramach programu.
  //     true - informację przesłał klient do serwera.
  //

  if   (
             ( not klawiatura_konfiguracja_r_f.czy_mysz )
         and (
                  (
                        ( not czy_z_wieloosobowe__odczytaj_f )
                    and (  IsKeyDown( klawiatura_konfiguracja_r_f.klawisz )  )
                    and (  Klawisz_Plus__Alt_Ctrl_Shift( klawiatura_konfiguracja_r_f )  )
                  )
               or (
                        ( czy_z_wieloosobowe__odczytaj_f )
                    and ( klawisz_f <> 0 )
                    and ( klawiatura_konfiguracja_r_f.klawisz = klawisz_f )
                    and (  Klawisz_Plus__Alt_Ctrl_Shift( klawiatura_konfiguracja_r_f, shift_f )  )
                  )
             )
       )
    or (
             ( klawiatura_konfiguracja_r_f.czy_mysz )
         and ( not klawiatura_konfiguracja_r_f.mysz_niezdefiniowana )
         and ( klawiatura_konfiguracja_r_f.klawisz = mysz_przycisk_f )
         and (  Klawisz_Plus__Alt_Ctrl_Shift( klawiatura_konfiguracja_r_f, shift_f )  )
       ) then
    Result := true
  else//if   ( (...)
    Result := false;

end;//---//Funkcja Klawisz_Wciśnięto_Sprawdź().

//Funkcja Statek_Klawisze_Obsługa().
procedure TStatki_Form.Statek_Klawisze_Obsługa( const id_statek_f : integer; const klawisz_f : Word; const mysz_przycisk_f : SmallInt; const shift_f : TShiftState; const amunicja_rodzaj_zbiór_f : TAmunicja_Rodzaj_Zbiór; const czy_z_wieloosobowe__odczytaj_f : boolean = false );

  //Funkcja Klawisz_Wciśnięto_Sprawdź_l() w Statek_Klawisze_Obsługa().
  function Klawisz_Wciśnięto_Sprawdź_l( const klawiatura_konfiguracja_r_f : TKlawiatura_Konfiguracja_r ) : boolean;
  begin

    Result := Klawisz_Wciśnięto_Sprawdź( klawiatura_konfiguracja_r_f, klawisz_f, mysz_przycisk_f, shift_f, czy_z_wieloosobowe__odczytaj_f );

    if    ( czy_klient_g )
      and ( Result )
      and ( statek_gracza <> nil ) then
      begin

        Result := false;

        wieloosobowe__statek_klawisze_obsługa_r.id_statek := statek_gracza.id_statek; //??? na początku gry
        wieloosobowe__statek_klawisze_obsługa_r.klawisz := klawisz_f;
        wieloosobowe__statek_klawisze_obsługa_r.shift := shift_f;
        wieloosobowe__statek_klawisze_obsługa_r.mysz_przycisk := mysz_przycisk_f;
        wieloosobowe__statek_klawisze_obsługa_r.cel_współrzędne := statek_gracza.celownicza_linia.Nodes[ 1 ].AsVector;
        wieloosobowe__statek_klawisze_obsługa_r.ar_artyleria := ar_Artyleria_CheckBox.Checked;
        wieloosobowe__statek_klawisze_obsługa_r.ar_pocisk := ar_Pocisk_CheckBox.Checked;
        wieloosobowe__statek_klawisze_obsługa_r.ar_torpeda := ar_Torpeda_CheckBox.Checked;
        wieloosobowe__statek_klawisze_obsługa_r.ar_wszystkie := ar_Wszystkie_CheckBox.Checked;
        wieloosobowe__statek_klawisze_obsługa_r.polecenie_nazwa := klawiatura_konfiguracja_r_f.polecenie_nazwa;

        Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__statek__klawisze_obsługa_c, -99, '' );

      end;
    //---//if    ( czy_klient_g ) (...)

  end;//---//Funkcja Klawisz_Wciśnięto_Sprawdź_l() w Statek_Klawisze_Obsługa().

var
  i : integer;
  zt_statek : TStatek;
begin//Funkcja Statek_Klawisze_Obsługa().

  //
  // Funkcja ustawia parametry zachowania statku zgodnie z poleceniami gracza.
  //
  // Parametry:
  //   id_statek_f - identyfikator statku, którego dotyczą wytyczne.
  //   klawisz_f - wciśnięty klawisz (0 = brak).
  //   mysz_przycisk_f - wciśnięty przycisk myszy (-1 = brak).
  //   shift_f - wciśnięty klawisz funkcyjny.
  //   amunicja_rodzaj_zbiór_f
  //   czy_z_wieloosobowe__odczytaj_f
  //     false - informacja analizowana wewnętrznie w ramach programu.
  //     true - informację przesłał klient do serwera.
  //

  if    ( klawisz_f = 0 )
    and ( mysz_przycisk_f = -1 ) then
    Exit;


  zt_statek := nil;


  for i := 0 to Length( statki_t ) - 1 do
    if    ( statki_t[ i ] <> nil )
      and ( statki_t[ i ].id_statek = id_statek_f ) then
      begin

        zt_statek := statki_t[ i ];
        Break;

      end;
    //---//if    ( statki_t[ i ] <> nil ) (...)


  if   ( zt_statek = nil )
    or (  not Assigned( zt_statek )  ) then
    Exit;



  //if klawisz_f = Ord( 'L' ) then
  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__podnoś_lufy ) then
    zt_statek.podnoś_lufy := not zt_statek.podnoś_lufy;

  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__obracaj_działa ) then
    zt_statek.obracaj_działa := not zt_statek.obracaj_działa;


  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__prędkość_zadana_procent_zmień__100_plus ) then
    zt_statek.Prędkość_Zadana_Procent_Zmień( 100 );

  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__prędkość_zadana_procent_zmień__25_plus ) then
    zt_statek.Prędkość_Zadana_Procent_Zmień( 25 );

  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__prędkość_zadana_procent_zmień__1_plus ) then
    zt_statek.Prędkość_Zadana_Procent_Zmień( 1 );

  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__prędkość_zadana_procent_zmień__zero ) then
    zt_statek.Prędkość_Zadana_Procent_Zmień( 0 );

  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__prędkość_zadana_procent_zmień__1_minus ) then
    zt_statek.Prędkość_Zadana_Procent_Zmień( -1 );

  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__prędkość_zadana_procent_zmień__25_minus ) then
    zt_statek.Prędkość_Zadana_Procent_Zmień( -25 );

  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__prędkość_zadana_procent_zmień__100_minus ) then
    zt_statek.Prędkość_Zadana_Procent_Zmień( -100 );


  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__radar_widoczność ) then
    Radar_Widoczność_CheckBox.Checked := not Radar_Widoczność_CheckBox.Checked;


  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__skręt_zadany_procent_zmień__100_lewo ) then
    zt_statek.Skręt_Zadany_Procent_Zmień( -100 );

  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__skręt_zadany_procent_zmień__25_lewo ) then
    zt_statek.Skręt_Zadany_Procent_Zmień( -25 );

  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__skręt_zadany_procent_zmień__1_lewo ) then
    zt_statek.Skręt_Zadany_Procent_Zmień( -1 );

  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__skręt_zadany_procent_zmień__zero ) then
    zt_statek.Skręt_Zadany_Procent_Zmień( 0 );

  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__skręt_zadany_procent_zmień__1_prawo ) then
    zt_statek.Skręt_Zadany_Procent_Zmień( 1 );

  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__skręt_zadany_procent_zmień__25_prawo ) then
    zt_statek.Skręt_Zadany_Procent_Zmień( 25 );

  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__skręt_zadany_procent_zmień__100_prawo ) then
    zt_statek.Skręt_Zadany_Procent_Zmień( 100 );


  if   (  Klawisz_Wciśnięto_Sprawdź_l( klawisz__strzał_1 )  )
    or (  Klawisz_Wciśnięto_Sprawdź_l( klawisz__strzał_2 )  ) then
    zt_statek.Strzał( amunicja_rodzaj_zbiór_f, false, false, zt_statek.obracaj_działa, zt_statek.podnoś_lufy, Celowniczy_GLDummyCube.Position.AsAffineVector );

  if   (  Klawisz_Wciśnięto_Sprawdź_l( klawisz__strzał__wszystkie_lufy_1 )  )
    or (  Klawisz_Wciśnięto_Sprawdź_l( klawisz__strzał__wszystkie_lufy_2 )  ) then
    zt_statek.Strzał( amunicja_rodzaj_zbiór_f, false, true, zt_statek.obracaj_działa, zt_statek.podnoś_lufy, Celowniczy_GLDummyCube.Position.AsAffineVector );

  if   (  Klawisz_Wciśnięto_Sprawdź_l( klawisz__strzał__wszystkie_wybrane_1 )  )
    or (  Klawisz_Wciśnięto_Sprawdź_l( klawisz__strzał__wszystkie_wybrane_2 )  ) then
    zt_statek.Strzał( amunicja_rodzaj_zbiór_f, true, true, zt_statek.obracaj_działa, zt_statek.podnoś_lufy, Celowniczy_GLDummyCube.Position.AsAffineVector );


  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__strzał__broń_indeks_zmieniaj ) then
    zt_statek.Broń_Indeks_Zmieniaj_Ustaw( amunicja_rodzaj_zbiór_f );

  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__strzał__broń_indeks_poprzedni ) then
    zt_statek.Broń_Indeks_Zmieniaj_Ustaw( true, amunicja_rodzaj_zbiór_f );

  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__strzał__broń_indeks_następny ) then
    zt_statek.Broń_Indeks_Zmieniaj_Ustaw( false, amunicja_rodzaj_zbiór_f );

end;//---//Funkcja Statek_Klawisze_Obsługa().

//Funkcja Klawisze_Obsługa_Zachowanie_Ciągłe().
procedure TStatki_Form.Klawisze_Obsługa_Zachowanie_Ciągłe( delta_czasu_f : double; const shift_f : TShiftState = []; const mysz_przycisk_f : SmallInt = -1 );

  //Funkcja Klawisz_Wciśnięto_Sprawdź_l() w Klawisze_Obsługa_Zachowanie_Ciągłe().
  function Klawisz_Wciśnięto_Sprawdź_l( const klawiatura_konfiguracja_r_f : TKlawiatura_Konfiguracja_r ) : boolean;
  begin

    Result := Klawisz_Wciśnięto_Sprawdź( klawiatura_konfiguracja_r_f, 0, mysz_przycisk_f, shift_f );

  end;//---//Funkcja Klawisz_Wciśnięto_Sprawdź_l() w Klawisze_Obsługa_Zachowanie_Ciągłe().

begin//Funkcja Klawisze_Obsługa_Zachowanie_Ciągłe().

  //
  // Funkcja przetwarza obsługę klawiszy, które należy obsługiwać cały czas gdy są wciśnięte (np. ruch kamery).
  //
  // Parametry:
  //   delta_czasu_f
  //   shift_f
  //   mysz_przycisk_f
  //

  if not GLSceneViewer1.Focused then
    Exit;


  // Ruch kamery.
  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__kamera__do_przodu ) then
    GLCamera1.Move( delta_czasu_f * kamera_szybkość_ruchu_g );

  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__kamera__do_tyłu ) then
    GLCamera1.Move( -delta_czasu_f * kamera_szybkość_ruchu_g );

  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__kamera__w_lewo ) then
    GLCamera1.Slide( -delta_czasu_f * kamera_szybkość_ruchu_g );

  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__kamera__w_przawo ) then
    GLCamera1.Slide( delta_czasu_f * kamera_szybkość_ruchu_g );


  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__kamera__w_górę ) then // Góra.
    GLCamera1.Lift( delta_czasu_f * kamera_szybkość_ruchu_g );

  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__kamera__w_dół ) then // Dół.
    GLCamera1.Lift( -delta_czasu_f * kamera_szybkość_ruchu_g );


  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__kamera__w_lewo_obrót ) then // Obrót  w lewo.
    GLCamera1.Turn( -delta_czasu_f * kamera_szybkość_ruchu_g * 10 );

  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__kamera__w_przawo_obrót ) then // Obrót  w prawo.
    GLCamera1.Turn( delta_czasu_f * kamera_szybkość_ruchu_g * 10 );

  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__kamera__w_górę_obrót ) then // Obrót  w górę.
    GLCamera1.Pitch( delta_czasu_f * kamera_szybkość_ruchu_g * 10 );

  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__kamera__w_dół_obrót ) then // Obrót  w dół.
    GLCamera1.Pitch( -delta_czasu_f * kamera_szybkość_ruchu_g * 10 );

  //if IsKeyDown( 'Q' ) then // Beczka w lewo.
  //  GLCamera1.Roll( delta_czasu_f * 10 );
  //
  //if IsKeyDown( 'E' ) then // Beczka w prawo.
  //  GLCamera1.Roll( -delta_czasu_f * 10 );
  //---// Ruch kamery.


  if czy_pauza_g then
    Kamera_Odległość_Kontroluj_Ustaw( delta_czasu_f );


  {$region 'Przesuwanie statków (w trybie projektowym).'}
  if Projektowy_Tryb_CheckBox.Checked then
    begin

      if projektowy_tryb__statek <> nil then
        begin

          if Klawisz_Wciśnięto_Sprawdź_l( klawisz__projektowy_tryb__statek__przesunięcie_w_lewo ) then // Przesunięcie w lewo.
            begin

              projektowy_tryb__statek.Slide( -gra_współczynnik_prędkości_g );

            end;
          //---//if Klawisz_Wciśnięto_Sprawdź_l( klawisz__projektowy_tryb__statek__przesunięcie_w_lewo ) then

          if Klawisz_Wciśnięto_Sprawdź_l( klawisz__projektowy_tryb__statek__przesunięcie_w_prawo ) then // Przesunięcie w prawo.
            begin

              projektowy_tryb__statek.Slide( gra_współczynnik_prędkości_g );

            end;
          //---//if Klawisz_Wciśnięto_Sprawdź_l( klawisz__projektowy_tryb__statek__przesunięcie_w_prawo ) then


          if Klawisz_Wciśnięto_Sprawdź_l( klawisz__projektowy_tryb__statek__przesunięcie_w_przód ) then // Przesunięcie w przód.
            begin

              projektowy_tryb__statek.Move( gra_współczynnik_prędkości_g );

            end;
          //---//if Klawisz_Wciśnięto_Sprawdź_l( klawisz__projektowy_tryb__statek__przesunięcie_w_przód ) then

          if Klawisz_Wciśnięto_Sprawdź_l( klawisz__projektowy_tryb__statek__przesunięcie_w_tył ) then // Przesunięcie w tył.
            begin

              projektowy_tryb__statek.Move( -gra_współczynnik_prędkości_g );

            end;
          //---//if Klawisz_Wciśnięto_Sprawdź_l( klawisz__projektowy_tryb__statek__przesunięcie_w_tył ) then


          if Klawisz_Wciśnięto_Sprawdź_l( klawisz__projektowy_tryb__statek__obrót_lewo ) then // Obrót lewo.
            begin

              projektowy_tryb__statek.TurnAngle := projektowy_tryb__statek.TurnAngle + 1;

            end;
          //---//if Klawisz_Wciśnięto_Sprawdź_l( klawisz__projektowy_tryb__statek__obrót_lewo ) then

          if Klawisz_Wciśnięto_Sprawdź_l( klawisz__projektowy_tryb__statek__obrót_prawo ) then // Obrót prawo.
            begin

              projektowy_tryb__statek.TurnAngle := projektowy_tryb__statek.TurnAngle - 1;

            end;
          //---//if Klawisz_Wciśnięto_Sprawdź_l( klawisz__projektowy_tryb__statek__obrót_prawo ) then


          if Klawisz_Wciśnięto_Sprawdź_l( klawisz__projektowy_tryb__statek__przechylenie_w_lewo ) then // Przechylenie w lewo.
            begin

              projektowy_tryb__statek.RollAngle := projektowy_tryb__statek.RollAngle - 1;

            end;
          //---//if Klawisz_Wciśnięto_Sprawdź_l( klawisz__projektowy_tryb__statek__przechylenie_w_lewo ) then

          if Klawisz_Wciśnięto_Sprawdź_l( klawisz__projektowy_tryb__statek__przechylenie_w_prawo ) then // Przechylenie w prawo.
            begin

              projektowy_tryb__statek.RollAngle := projektowy_tryb__statek.RollAngle + 1;

            end;
          //---//if Klawisz_Wciśnięto_Sprawdź_l( klawisz__projektowy_tryb__statek__przechylenie_w_prawo ) then


          if Klawisz_Wciśnięto_Sprawdź_l( klawisz__projektowy_tryb__statek__uniesienie_przodu ) then // Uniesienie przodu.
            begin

              projektowy_tryb__statek.PitchAngle := projektowy_tryb__statek.PitchAngle - 1;

            end;
          //---//if Klawisz_Wciśnięto_Sprawdź_l( klawisz__projektowy_tryb__statek__uniesienie_przodu ) then

          if Klawisz_Wciśnięto_Sprawdź_l( klawisz__projektowy_tryb__statek__uniesienie_tyłu ) then // Uniesienie tyłu.
            begin

              projektowy_tryb__statek.PitchAngle := projektowy_tryb__statek.PitchAngle + 1;

            end;
          //---//if Klawisz_Wciśnięto_Sprawdź_l( klawisz__projektowy_tryb__statek__uniesienie_tyłu ) then

        end;
      //---//if projektowy_tryb__statek <> nil then

    end;
  //---//if Projektowy_Tryb_CheckBox.Checked then
  {$endregion 'Przesuwanie statków (w trybie projektowym).'}



  Exit; // Test. //???
  //if MilliSecondsBetween( Now(), moment_wciśnięcia_klawisza ) >= 100 then
    begin

      // Lepiej działa GLSceneViewer1KeyDown, nie łapie tak szybko ponownego wciśnięcia klawisza.

      //moment_wciśnięcia_klawisza := Now();


      //???
      if IsKeyDown( ';' ) then
        begin

          //Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_Ląd, 0, 10, 0, nil, -1, -1 );
          //Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_Statek, 0, 5, 0, nil, -1, -1 );
          //Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_Woda, 0, 2, 0, nil, -1, -1 );
          //Amunicja_Wystrzelona_Zwolnij_Wszystkie();

        end;
      //---//if IsKeyDown( ';' ) then

    end;
  //---//if MilliSecondsBetween( Now(), moment_wciśnięcia_klawisza ) >= 100 then


  //???
  if IsKeyDown( 'Y' ) then
    begin

      //statek_gracza.falowanie_dummy.ResetRotations();
      //statek_gracza.falowanie_dummy.PitchAngle := 0;
      //Statki_Form.Caption := FloatToStr( statek_gracza.falowanie_dummy.PitchAngle );

      //Statki_Form.Caption := FloatToStr( Czas_Między_W_Sekundach( 0 ) ) + ' ' + FloatToStr( Czas_Między_W_Milisekundach( 0 ) );
      //statek_gracza.torpedy_wyrzutnie_t[ 0 ].Obrót_Kierunek_Zmień( Celowanie_Precyzja_Obrót_SpinEdit.Value, true );
      //Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__odbierz__rekord_statki_c, -99, '' );
      //Wieloosobowe_Statki_Parametry_Ustaw();

      //statek_gracza.artyleria_t[ 0 ].lufy_t[ 0 ].przeładowanie_wskaźnik.Position.Z := statek_gracza.artyleria_t[ 0 ].lufy_t[ 0 ].przeładowanie_wskaźnik.Position.Z + 0.001;


      //Elementy_Gry_Zwolnij();
      //Elementy_Gry_Przygotuj();
      //Ląd_Utwórz( Ląd_ComboBox.ItemIndex );

      //Statek__Odśwież_Wskazany_BitBtnClick( nil );
      //Statek__Utwórz_BitBtnClick( nil );

    end;
  //---//if IsKeyDown( 'Y' ) then


  if IsKeyDown( 'V' ) then
    begin

      //Projektowy_Tryb_CheckBox.Checked := not Projektowy_Tryb_CheckBox.Checked;
      //Amunicja_Wystrzelona_Zwolnij_Wszystkie();

    end;
  //---//if IsKeyDown( 'J' ) then



  if IsKeyDown( 'N' ) then
    begin

      //statek_gracza.artyleria_t[ 0 ].lufy_t[ 0 ].Position.Z := statek_gracza.artyleria_t[ 0 ].lufy_t[ 0 ].Position.Z - 0.01;
      //statek_gracza.działa_t[ 0 ].lufy_t[ 0 ].PitchAngle := statek_gracza.działa_t[ 0 ].lufy_t[ 0 ].PitchAngle + gra_współczynnik_prędkości_g;
      //Statki_Form.Caption := FloatToStr( statek_gracza.działa_t[ 0 ].lufy_t[ 0 ].PitchAngle );

      //statek_gracza.falowanie_dummy.Roll( gra_współczynnik_prędkości_g );
      //statek_gracza.falowanie_dummy.PitchAngle := statek_gracza.falowanie_dummy.PitchAngle - gra_współczynnik_prędkości_g;
      //Statki_Form.Caption := FloatToStr( statek_gracza.falowanie_dummy.PitchAngle );

      //statek_gracza.TurnAngle := statek_gracza.TurnAngle + 0.01; // Plus - lewo.
      //Amunicja_Ruch( gra_współczynnik_prędkości_g );

      //Celowniczy_GLDummyCube.Slide( 0.01 ); //???
      //statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector := Celowniczy_GLDummyCube.Position.AsAffineVector; //???

    end;
  //---//if IsKeyDown( 'N' ) then


  if IsKeyDown( 'M' ) then
    begin

      //statek_gracza.artyleria_t[ 0 ].lufy_t[ 0 ].Position.Z := statek_gracza.artyleria_t[ 0 ].lufy_t[ 0 ].Position.Z + 0.01;
      //statek_gracza.działa_t[ 0 ].lufy_t[ 0 ].PitchAngle := statek_gracza.działa_t[ 0 ].lufy_t[ 0 ].PitchAngle - gra_współczynnik_prędkości_g;
      //Statki_Form.Caption := FloatToStr( statek_gracza.działa_t[ 0 ].lufy_t[ 0 ].PitchAngle );

      //statek_gracza.falowanie_dummy.Roll( -gra_współczynnik_prędkości_g );
      //statek_gracza.falowanie_dummy.PitchAngle := statek_gracza.falowanie_dummy.PitchAngle + gra_współczynnik_prędkości_g;
      //Statki_Form.Caption := FloatToStr( statek_gracza.falowanie_dummy.PitchAngle );

      //Celowniczy_GLDummyCube.Slide( -0.01 ); //???
      //statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector := Celowniczy_GLDummyCube.Position.AsAffineVector; //???

    end;
  //---//if IsKeyDown( 'M' ) then

end;//---//Funkcja Klawisze_Obsługa_Zachowanie_Ciągłe().

//Funkcja Statek_Klient_Cel_Ustaw().
procedure TStatki_Form.Statek_Klient_Cel_Ustaw( const id_statek_f : integer; const cel_współrzędne_f : GLVectorGeometry.TVector );
var
  i : integer;
  zt_statek : TStatek;
begin

  //
  // Funkcja ustawia parametry zachowania statku zgodnie z poleceniami gracza.
  //
  // Parametry:
  //   id_statek_f - identyfikator statku, którego dotyczą wytyczne.
  //   cel_współrzędne_f - bezwzględne współrzędne celu.
  //


  zt_statek := nil;


  for i := 0 to Length( statki_t ) - 1 do
    if    ( statki_t[ i ] <> nil )
      and ( statki_t[ i ].id_statek = id_statek_f ) then
      begin

        zt_statek := statki_t[ i ];
        Break;

      end;
    //---//if    ( statki_t[ i ] <> nil ) (...)


  if   ( zt_statek = nil )
    or (  not Assigned( zt_statek )  ) then
    Exit;


  zt_statek.celownicza_linia.Nodes[ 1 ].AsVector := cel_współrzędne_f;

end;//---//Funkcja Statek_Klient_Cel_Ustaw().

//Funkcja Statki_Ruch().
procedure TStatki_Form.Statki_Ruch( delta_czasu_f : double );
var
  i,
  i_s
    : integer;
  zt_statek : TStatek;
begin//Funkcja Statki_Ruch().

  for i_s := 0 to Length( statki_t ) - 1 do
    begin

      zt_statek := statki_t[ i_s ];

      if zt_statek <> nil then
        begin

          if not zt_statek.czy_usunąć then
            begin

              // czy_usunąć - nie.


              //if zt_statek = statek_gracza then
              if not czy_klient_g then //???
                begin


                  {$region 'Ruch statku.'}
                  zt_statek.Skręt_Procent_Zmień();
                  zt_statek.Prędkość_Procent_Zmień();


                  zt_statek.prędkość_aktualna := zt_statek.prędkość_maksymalna * zt_statek.prędkość_procent * 0.01;
                  zt_statek.Move( zt_statek.prędkość_aktualna * gra_współczynnik_prędkości_g * delta_czasu_f );
                  //GLCamera1.Move( statek_prędkość_l );

                  if zt_statek.prędkość_procent <> 0 then
                    begin

                      //statek_obrót_l := zt_statek.skręt_prędkość * zt_statek.skręt_procent * ( zt_statek.prędkość_procent / 100 ) * delta_czasu_f;
                      zt_statek.prędkość_obrotu_aktualna := zt_statek.skręt_prędkość * zt_statek.skręt_procent * 0.01;

                      if    ( zt_statek.skręt_współczynnik_do_prędkości <> 0 )
                        and (  Abs( zt_statek.prędkość_procent ) < zt_statek.skręt_współczynnik_do_prędkości  ) then
                        //statek_obrót_l := statek_obrót_l * ( 100 * Abs( zt_statek.prędkość_procent ) / zt_statek.skręt_współczynnik_do_prędkości ) / 100;
                        zt_statek.prędkość_obrotu_aktualna := zt_statek.prędkość_obrotu_aktualna * Abs( zt_statek.prędkość_procent ) / zt_statek.skręt_współczynnik_do_prędkości;


                      if zt_statek.prędkość_procent < 0 then
                        zt_statek.prędkość_obrotu_aktualna := -zt_statek.prędkość_obrotu_aktualna;

                      //zt_statek.Turn( zt_statek.prędkość_obrotu_aktualna );
                      zt_statek.TurnAngle := zt_statek.TurnAngle - zt_statek.prędkość_obrotu_aktualna * gra_współczynnik_prędkości_g * delta_czasu_f;


                      zt_statek.falowanie_bok_skręt := -zt_statek.falowanie_bok_skręt_zakres * (  zt_statek.skręt_procent * Abs( zt_statek.prędkość_procent ) * 0.01  ) * 0.01;
                      zt_statek.falowanie_przód_ruch := 1 * zt_statek.prędkość_procent * 0.01;

                    end
                  else//if zt_statek.prędkość_procent <> 0 then
                    begin

                      zt_statek.falowanie_bok_skręt := 0;
                      zt_statek.falowanie_przód_ruch := 0;

                    end;
                  //---//if zt_statek.prędkość_procent <> 0 then



                  //Statki_Form.Caption := FloatToStr( zt_statek.falowanie_bok_skręt ) + ' ' + FloatToStr( zt_statek.skręt_procent ) + ' ' + FloatToStr( zt_statek.prędkość_procent );
                  {$endregion 'Ruch statku.'}


                  {$region '//Ruch dział.'}
                  //if zt_statek.obracaj_działa then
                  //  begin
                  //
                  //    for i := 0 to Length( zt_statek.artyleria_t ) - 1 do
                  //      begin
                  //
                  //        zt_statek.artyleria_t[ i ].Obrót_Zadany_Zmień();
                  //        zt_statek.artyleria_t[ i ].Obrót_Kierunek_Zmień( Celowanie_Precyzja_Obrót_SpinEdit.Value );
                  //
                  //        zt_statek.artyleria_t[ i ].Podniesienie_Zadane_Zmień();
                  //        zt_statek.artyleria_t[ i ].Podniesienie_Kierunek_Zmień( Celowanie_Precyzja_Podniesienie_SpinEdit.Value );
                  //
                  //      end;
                  //    //---//for i := 0 to Length( zt_statek.artyleria_t ) - 1 do
                  //
                  //    for i := 0 to Length( zt_statek.działa_t ) - 1 do
                  //      begin
                  //
                  //        zt_statek.działa_t[ i ].Obrót_Zadany_Zmień();
                  //        zt_statek.działa_t[ i ].Obrót_Kierunek_Zmień( Celowanie_Precyzja_Obrót_SpinEdit.Value );
                  //
                  //        zt_statek.działa_t[ i ].Podniesienie_Zadane_Zmień();
                  //        zt_statek.działa_t[ i ].Podniesienie_Kierunek_Zmień( Celowanie_Precyzja_Podniesienie_SpinEdit.Value );
                  //
                  //      end;
                  //    //---//for i := 0 to Length( zt_statek.działa_t ) - 1 do
                  //
                  //
                  //    for i := 0 to Length( zt_statek.torpedy_wyrzutnie_t ) - 1 do
                  //      begin
                  //
                  //        zt_statek.torpedy_wyrzutnie_t[ i ].Obrót_Zadany_Zmień();
                  //        zt_statek.torpedy_wyrzutnie_t[ i ].Obrót_Kierunek_Zmień( Celowanie_Precyzja_Obrót_SpinEdit.Value, true );
                  //
                  //      end;
                  //    //---//for i := 0 to Length( zt_statek.torpedy_wyrzutnie_t ) - 1 do
                  //
                  //  end
                  //else//if zt_statek.obracaj_działa then
                  //  begin
                  //
                  //    for i := 0 to Length( zt_statek.artyleria_t ) - 1 do
                  //      zt_statek.artyleria_t[ i ].celownik_linia.LineColor.Color := GLColor.clrYellow;
                  //
                  //
                  //    for i := 0 to Length( zt_statek.działa_t ) - 1 do
                  //      zt_statek.działa_t[ i ].celownik_linia.LineColor.Color := GLColor.clrYellow;
                  //
                  //
                  //    for i := 0 to Length( zt_statek.torpedy_wyrzutnie_t ) - 1 do
                  //      zt_statek.torpedy_wyrzutnie_t[ i ].celownik_linia.LineColor.Color := GLColor.clrYellow;
                  //
                  //  end;
                  ////---//if zt_statek.obracaj_działa the
                  {$endregion '//Ruch dział.'}


                  {$region 'Obrót dział.'}
                  if zt_statek.obracaj_działa then
                    begin

                      for i := 0 to Length( zt_statek.artyleria_t ) - 1 do
                        begin

                          zt_statek.artyleria_t[ i ].Obrót_Zadany_Zmień( ar_Artyleria_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );
                          zt_statek.artyleria_t[ i ].Obrót_Kierunek_Zmień( Celowanie_Precyzja_Obrót_SpinEdit.Value );

                        end;
                      //---//for i := 0 to Length( zt_statek.artyleria_t ) - 1 do

                      for i := 0 to Length( zt_statek.działa_t ) - 1 do
                        begin

                          zt_statek.działa_t[ i ].Obrót_Zadany_Zmień( ar_Pocisk_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );
                          zt_statek.działa_t[ i ].Obrót_Kierunek_Zmień( Celowanie_Precyzja_Obrót_SpinEdit.Value );

                        end;
                      //---//for i := 0 to Length( zt_statek.działa_t ) - 1 do


                      for i := 0 to Length( zt_statek.torpedy_wyrzutnie_t ) - 1 do
                        begin

                          zt_statek.torpedy_wyrzutnie_t[ i ].Obrót_Zadany_Zmień( ar_Torpeda_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );
                          zt_statek.torpedy_wyrzutnie_t[ i ].Obrót_Kierunek_Zmień( Celowanie_Precyzja_Obrót_SpinEdit.Value, true );

                        end;
                      //---//for i := 0 to Length( zt_statek.torpedy_wyrzutnie_t ) - 1 do

                    end
                  else//if zt_statek.obracaj_działa then
                    begin

                      for i := 0 to Length( zt_statek.artyleria_t ) - 1 do
                        begin

                          if zt_statek.artyleria_t[ i ].czy_indeks_do_strzału then
                            zt_statek.artyleria_t[ i ].celownik_linia.LineColor.Color := GLColor.clrOrange
                          else//if zt_statek.artyleria_t[ i ].czy_indeks_do_strzału then
                            zt_statek.artyleria_t[ i ].celownik_linia.LineColor.Color := GLColor.clrYellow;

                          zt_statek.artyleria_t[ i ].celownik_linia_szerokość_obrót := 0;
                          zt_statek.artyleria_t[ i ].celownik_linia.LineWidth := zt_statek.artyleria_t[ i ].celownik_linia_szerokość_obrót;

                          zt_statek.artyleria_t[ i ].celownik_linia_bez_falowania.LineColor.Color := zt_statek.artyleria_t[ i ].celownik_linia.LineColor.Color;
                          zt_statek.artyleria_t[ i ].celownik_linia_bez_falowania.LineWidth := zt_statek.artyleria_t[ i ].celownik_linia.LineWidth;
                          zt_statek.artyleria_t[ i ].Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( ar_Artyleria_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );

                        end;
                      //---//for i := 0 to Length( zt_statek.artyleria_t ) - 1 do


                      for i := 0 to Length( zt_statek.działa_t ) - 1 do
                        begin

                          if zt_statek.działa_t[ i ].czy_indeks_do_strzału then
                            zt_statek.działa_t[ i ].celownik_linia.LineColor.Color := GLColor.clrOrange
                          else//if zt_statek.działa_t[ i ].czy_indeks_do_strzału then
                            zt_statek.działa_t[ i ].celownik_linia.LineColor.Color := GLColor.clrYellow;

                          zt_statek.działa_t[ i ].celownik_linia_szerokość_obrót := 0;
                          zt_statek.działa_t[ i ].celownik_linia.LineWidth := zt_statek.działa_t[ i ].celownik_linia_szerokość_obrót;

                          zt_statek.działa_t[ i ].celownik_linia_bez_falowania.LineColor.Color := zt_statek.działa_t[ i ].celownik_linia.LineColor.Color;
                          zt_statek.działa_t[ i ].celownik_linia_bez_falowania.LineWidth := zt_statek.działa_t[ i ].celownik_linia.LineWidth;
                          zt_statek.działa_t[ i ].Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( ar_Pocisk_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );

                        end;
                      //---//for i := 0 to Length( zt_statek.działa_t ) - 1 do

                      for i := 0 to Length( zt_statek.torpedy_wyrzutnie_t ) - 1 do
                        begin

                          if zt_statek.torpedy_wyrzutnie_t[ i ].czy_indeks_do_strzału then
                            zt_statek.torpedy_wyrzutnie_t[ i ].celownik_linia.LineColor.Color := GLColor.clrOrange
                          else//if zt_statek.torpedy_wyrzutnie_t[ i ].czy_indeks_do_strzału then
                            zt_statek.torpedy_wyrzutnie_t[ i ].celownik_linia.LineColor.Color := GLColor.clrYellow;

                          zt_statek.torpedy_wyrzutnie_t[ i ].celownik_linia_szerokość_obrót := 0;
                          zt_statek.torpedy_wyrzutnie_t[ i ].celownik_linia.LineWidth := zt_statek.torpedy_wyrzutnie_t[ i ].celownik_linia_szerokość_obrót;

                          zt_statek.torpedy_wyrzutnie_t[ i ].celownik_linia_bez_falowania.LineColor.Color := zt_statek.torpedy_wyrzutnie_t[ i ].celownik_linia.LineColor.Color;
                          zt_statek.torpedy_wyrzutnie_t[ i ].celownik_linia_bez_falowania.LineWidth := zt_statek.torpedy_wyrzutnie_t[ i ].celownik_linia.LineWidth;
                          zt_statek.torpedy_wyrzutnie_t[ i ].Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( ar_Torpeda_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );

                        end;
                      //---//for i := 0 to Length( zt_statek.torpedy_wyrzutnie_t ) - 1 do

                    end;
                  //---//if zt_statek.obracaj_działa the
                  {$endregion 'Obrót dział.'}


                  {$region 'Podniesienie dział.'}
                  if zt_statek.podnoś_lufy then
                    begin

                      for i := 0 to Length( zt_statek.artyleria_t ) - 1 do
                        begin

                          zt_statek.artyleria_t[ i ].Podniesienie_Zadane_Zmień( ar_Artyleria_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );
                          zt_statek.artyleria_t[ i ].Podniesienie_Kierunek_Zmień( Celowanie_Precyzja_Podniesienie_SpinEdit.Value );

                        end;
                      //---//for i := 0 to Length( zt_statek.artyleria_t ) - 1 do

                      for i := 0 to Length( zt_statek.działa_t ) - 1 do
                        begin

                          zt_statek.działa_t[ i ].Podniesienie_Zadane_Zmień( ar_Pocisk_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );
                          zt_statek.działa_t[ i ].Podniesienie_Kierunek_Zmień( Celowanie_Precyzja_Podniesienie_SpinEdit.Value );

                        end;
                      //---//for i := 0 to Length( zt_statek.działa_t ) - 1 do

                    end
                  else//if zt_statek.podnoś_lufy then
                    begin

                      for i := 0 to Length( zt_statek.artyleria_t ) - 1 do
                        begin

                          //zt_statek.artyleria_t[ i ].celownik_linia.LineColor.Color := GLColor.clrYellow;
                          zt_statek.artyleria_t[ i ].celownik_linia.LineWidth := zt_statek.artyleria_t[ i ].celownik_linia_szerokość_obrót;
                          zt_statek.artyleria_t[ i ].celownik_linia_bez_falowania.LineWidth := zt_statek.artyleria_t[ i ].celownik_linia.LineWidth;
                          zt_statek.artyleria_t[ i ].Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( ar_Artyleria_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );

                        end;
                      //---//for i := 0 to Length( zt_statek.artyleria_t ) - 1 do

                      for i := 0 to Length( zt_statek.działa_t ) - 1 do
                        begin

                          //zt_statek.działa_t[ i ].celownik_linia.LineColor.Color := GLColor.clrYellow;
                          zt_statek.działa_t[ i ].celownik_linia.LineWidth := zt_statek.działa_t[ i ].celownik_linia_szerokość_obrót;
                          zt_statek.działa_t[ i ].celownik_linia_bez_falowania.LineWidth := zt_statek.działa_t[ i ].celownik_linia.LineWidth;
                          zt_statek.działa_t[ i ].Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( ar_Pocisk_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );

                        end;
                      //---//for i := 0 to Length( zt_statek.działa_t ) - 1 do

                      //???
                      //for i := 0 to Length( zt_statek.torpedy_wyrzutnie_t ) - 1 do
                      //  begin
                      //
                      //    zt_statek.torpedy_wyrzutnie_t[ i ].celownik_linia.LineColor.Color := GLColor.clrYellow;
                      //
                      //  end;
                      ////---//for i := 0 to Length( zt_statek.torpedy_wyrzutnie_t ) - 1 do

                    end;
                  //---//if zt_statek.podnoś_lufy the
                  {$endregion 'Podniesienie dział.'}


                  for i := 0 to Length( zt_statek.artyleria_wygląd_t ) - 1 do
                    zt_statek.artyleria_wygląd_t[ i ].Parametry_Aktualizuj_Dla_Wyglądu();

                  for i := 0 to Length( zt_statek.działa_wygląd_t ) - 1 do
                    zt_statek.działa_wygląd_t[ i ].Parametry_Aktualizuj_Dla_Wyglądu();

                  for i := 0 to Length( zt_statek.torpedy_wyrzutnie_wygląd_t ) - 1 do
                    zt_statek.torpedy_wyrzutnie_wygląd_t[ i ].Parametry_Aktualizuj_Dla_Wyglądu();


                  for i := 0 to Length( zt_statek.śruby_t ) - 1 do
                    zt_statek.śruby_t[ i ].Śruba_Obracaj();


                  {$region 'Animacja tonięcia statku.'}
                  if zt_statek.punkty_życia <= 0 then
                    begin

                      if zt_statek.tonięcie__prędkość_w_dół = 0 then
                        begin

                          // Ustalenie współczynników tonięcia (jeden raz).

                          zt_statek.tonięcie__obrót__lewo_prawo := (  Random( 20 ) + 1  ) * 0.01; // Od 0.01 do 0.2.
                          zt_statek.tonięcie__obrót__przód_tył := (  Random( 10 ) + 1  ) * 0.01; // Od 0.001 do 0.01.
                          zt_statek.tonięcie__prędkość_w_dół := (  Random( 10 ) + 1  ) * 0.001; // Od 0.01 do 0.1.


                          if Random( 2 ) = 0 then
                            zt_statek.tonięcie__obrót__lewo_prawo := -zt_statek.tonięcie__obrót__lewo_prawo;

                          if Random( 2 ) = 0 then
                            zt_statek.tonięcie__obrót__przód_tył := -zt_statek.tonięcie__obrót__przód_tył;


                          zt_statek.tonięcie__czas_i := Czas_Teraz();

                        end;
                      //---//if zt_statek.tonięcie__prędkość_w_dół = 0 then


                      //zt_statek.PitchAngle := zt_statek.PitchAngle + 0.2; // Góra (+).
                      //zt_statek.RollAngle := zt_statek.RollAngle + 0.01; // Prawo (+).
                      //zt_statek.Lift( -0.005 ); // Dół (-). // Po obrocie przesuwa prostopadle do dna statku a nie w dół sceny.
                      //zt_statek.Position.Y := zt_statek.Position.Y - 0.01;

                      if zt_statek.Position.Y > Dno_Kolizje_GLCube.Position.Y then // Aby się nie kręcił na dnie.
                        begin

                          zt_statek.PitchAngle := zt_statek.PitchAngle + zt_statek.tonięcie__obrót__przód_tył * gra_współczynnik_prędkości_g; // Góra (+).
                          zt_statek.RollAngle := zt_statek.RollAngle + zt_statek.tonięcie__obrót__lewo_prawo * gra_współczynnik_prędkości_g; // Prawo (+).
                          zt_statek.Position.Y := zt_statek.Position.Y - zt_statek.tonięcie__prędkość_w_dół * gra_współczynnik_prędkości_g;

                          if zt_statek.Position.Y > 0 then // Zanim wytraci prędkość, przy pewnym obrocie, może wzlecieć ponad wodę.
                            zt_statek.Position.Y := 0;

                        end;
                      //---//if zt_statek.Position.Y > Dno_Kolizje_GLCube.Position.Y then

                      //zt_statek.Lift( -0.005 ); // Dół (-). // Po obrocie przesuwa prostopadle do dna statku a nie w dół sceny.


                      if Czas_Między_W_Sekundach( zt_statek.tonięcie__czas_i ) * gra_współczynnik_prędkości_g > oczekiwanie_na_odnowienie_statku_czas_c then //  oczekiwanie_na_odnowienie_statku_czas_c / gra_współczynnik_prędkości_g //???
                        begin

                          zt_statek.czy_usunąć := true;

                        end;
                      //---//if Czas_Między_W_Sekundach( zt_statek.tonięcie__czas_i ) * gra_współczynnik_prędkości_g > oczekiwanie_na_odnowienie_statku_czas_c then

                    end;
                  //---//if zt_statek.punkty_życia <= 0 then
                  {$endregion 'Animacja tonięcia statku.'}

                end;
              //---//if not czy_klient_g then


              zt_statek.Punkty_Życia_Wskaźnik_Rysuj( GLCamera1, 3 );


              {$region 'Falowanie statku.'}
              if zt_statek.falowanie_opóźnienie <= 0 then
                begin

                  //zt_statek.falowanie_bok_wychylenie_aktualne := zt_statek.falowanie_bok_wychylenie_aktualne + 50 * gra_współczynnik_prędkości_g * delta_czasu_f;
                  zt_statek.falowanie_bok_wychylenie_aktualne := zt_statek.falowanie_bok_wychylenie_aktualne + (  25 + Random( 26 )  ) * gra_współczynnik_prędkości_g * delta_czasu_f; // Aby falowanie było bardziej zmienne.

                  if zt_statek.falowanie_bok_wychylenie_aktualne >= 360 then
                    begin

                      //zt_statek.falowanie_bok_wychylenie_aktualne := 0;
                      zt_statek.falowanie_bok_wychylenie_aktualne := zt_statek.falowanie_bok_wychylenie_aktualne - 360;
                      //zt_statek.falowanie_bok_zakres := Random( 10 );

                    end;
                  //---//if zt_statek.falowanie_bok_wychylenie_aktualne >= 360 then

                  zt_statek.falowanie_dummy.RollAngle := Sin(  DegToRad( zt_statek.falowanie_bok_wychylenie_aktualne ) ) * zt_statek.falowanie_bok_zakres + zt_statek.falowanie_bok_skręt;


                  //zt_statek.falowanie_przód_wychylenie_aktualne := zt_statek.falowanie_przód_wychylenie_aktualne + 50 * gra_współczynnik_prędkości_g * delta_czasu_f;
                  zt_statek.falowanie_przód_wychylenie_aktualne := zt_statek.falowanie_przód_wychylenie_aktualne + (  25 + Random( 26 )  ) * gra_współczynnik_prędkości_g * delta_czasu_f; // Aby falowanie było bardziej zmienne.

                  if zt_statek.falowanie_przód_wychylenie_aktualne >= 360 then
                    begin

                      //zt_statek.falowanie_przód_wychylenie_aktualne := 0;
                      zt_statek.falowanie_przód_wychylenie_aktualne := zt_statek.falowanie_przód_wychylenie_aktualne - 360;
                      //zt_statek.falowanie_przód_zakres := Random( 10 );

                    end;
                  //---//if zt_statek.falowanie_przód_wychylenie_aktualne >= 360 then

                  zt_statek.falowanie_dummy.PitchAngle := Sin(  DegToRad( zt_statek.falowanie_przód_wychylenie_aktualne ) ) * zt_statek.falowanie_przód_zakres + zt_statek.falowanie_przód_ruch; // Gdy w przód to unosi przód i odwrotnie dla tyłu (aby oba końce tak samo unosiło należy zapisać w nawiasie ( zt_statek.falowanie_przód_zakres + zt_statek.falowanie_przód_ruch ) ).


                  //zt_statek.falowanie_góra_dół_wysokość_aktualna := zt_statek.falowanie_góra_dół_wysokość_aktualna + 50 * gra_współczynnik_prędkości_g * delta_czasu_f;
                  zt_statek.falowanie_góra_dół_wysokość_aktualna := zt_statek.falowanie_góra_dół_wysokość_aktualna + (  25 + Random( 26 )  ) * gra_współczynnik_prędkości_g * delta_czasu_f;

                  if zt_statek.falowanie_góra_dół_wysokość_aktualna >= 360 then
                    zt_statek.falowanie_góra_dół_wysokość_aktualna := zt_statek.falowanie_góra_dół_wysokość_aktualna - 360;

                  zt_statek.falowanie_dummy.Position.Y := Sin(  DegToRad( zt_statek.falowanie_góra_dół_wysokość_aktualna ) ) * zt_statek.falowanie_góra_dół_zakres;

                end
              else//if zt_statek.falowanie_opóźnienie <= 0 then
                begin

                  if Czas_Teraz_W_Milisekundach() >= zt_statek.falowanie_opóźnienie then
                    begin

                      zt_statek.falowanie_bok_wychylenie_aktualne := Random( 26 ); // Aby falowanie było bardziej zmienne.
                      zt_statek.falowanie_góra_dół_wysokość_aktualna := Random( 26 ); // Aby falowanie było bardziej zmienne.
                      zt_statek.falowanie_przód_wychylenie_aktualne := Random( 26 ); // Aby falowanie było bardziej zmienne.

                      zt_statek.falowanie_opóźnienie := 0;

                    end;
                  //---//if Czas_Teraz_W_Milisekundach() >= zt_statek.falowanie_opóźnienie then

                end;
              //---//if zt_statek.falowanie_opóźnienie <= 0 then
              {$endregion 'Falowanie statku.'}

            end
          else//if not zt_statek.czy_usunąć then
            begin

              // czy_usunąć - tak.


              {$region 'Animacja tonięcia statku.'}
              // To jest raczej nie potrzebne. //???
              //if zt_statek.Position.Y > dno_poziom_c then
              //  zt_statek.Position.Y := zt_statek.Position.Y - zt_statek.tonięcie__prędkość_w_dół;

              if zt_statek.Position.Y > 0 then // Zanim wytraci prędkość, przy pewnym obrocie, może wzlecieć ponad wodę.
                zt_statek.Position.Y := 0;
              {$endregion 'Animacja tonięcia statku.'}


              Statek_Przywróć_Do_Gry( zt_statek );

            end;
          //---//if not zt_statek.czy_usunąć then
          //GLCamera1.
          //GLCamera1.Position.X := zt_statek.Position.X;
          //GLCamera1.Position.Z := zt_statek.Position.Z;

        end;
      //---//if zt_statek <> nil then

    end;
  //---//for i_s := 0 to Length( statki_t ) - 1 do

  Amunicja_Ruch( delta_czasu_f );

end;//---//Funkcja Statki_Ruch().

//Funkcja Amunicja_Ruch().
procedure TStatki_Form.Amunicja_Ruch( delta_czasu_f : double );
var
  i : integer;
  ztr,
  lot_parabolą__kąta_opadania__przed_namierzaniem_modyfikator_l // Zależnie od ustawionego procentu zasięgu celu artylerii modyfikuje kąt do jakiego pochylać amunicję przed rozpoczęciem nakierowywania na cel.
    : real;
  zts : string;
  zt_vector : GLVectorGeometry.TVector;
  zt_amunicja : TAmunicja;
begin

  if   ( amunicja_wystrzelona_list = nil )
    or (  not Assigned( amunicja_wystrzelona_list )  ) then
    Exit;


  if czy_klient_g then
    Exit;


  for i := amunicja_wystrzelona_list.Count - 1 downto 0 do
    begin

      zt_amunicja := TAmunicja(amunicja_wystrzelona_list[ i ]);

      if zt_amunicja <> nil then
        begin

          // Gdy osiągnie odpowiednią głębokość jest usuwany (na wypadek gdyby nie dotknęła dna).
          //if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y <= Dno_GLPlane.AbsolutePosition.Y - 1 then
          if zt_amunicja.AbsolutePosition.Y <= Dno_GLPlane.AbsolutePosition.Y - 1 then
            zt_amunicja.czy_usunąć := true;


          if zt_amunicja.czy_usunąć then
            Amunicja_Wystrzelona_Zwolnij_Jeden( zt_amunicja )
          else//if zt_amunicja.czy_usunąć then
            begin

              {$region 'Ruch do przodu.'}
              if not zt_amunicja.czy_poza_lufą then
                ztr := zt_amunicja.prędkość // Amunicję jest w lufie.
              else//if not zt_amunicja.czy_poza_lufą then
                ztr := zt_amunicja.prędkość * zt_amunicja.skala; // Amunicja jest poza lufą. // Działo może być skalowane. Koryguje wartość o skalę działa, wpływa na szybkość ruchu amunicji.

              ztr := ztr * delta_czasu_f * gra_współczynnik_prędkości_g;
              
              if    (  not ( zt_amunicja.amunicja_rodzaj in [ ar_Torpeda ] )  )
                and ( not zt_amunicja.czy_lot_parabolą ) then
                begin

                  // Nie torpeda, nie parabola.

                  zt_amunicja.Move( ztr );

                end
              else//if not ( zt_amunicja.amunicja_rodzaj in [ ar_Torpeda ] ) then
                begin

                  // Torpeda, parabola.

                  if zt_amunicja.Parent <> Gra_Obiekty_GLDummyCube then
                    zt_amunicja.Move( ztr ) // Amunicja w lufie.
                  else//if zt_amunicja.Parent <> Gra_Obiekty_GLDummyCube then
                    begin

                      // Amunicja poza lufą.

                      zt_amunicja.Position.AddScaledVector( ztr, zt_amunicja.korpus_ustawienie_początkowe_dummy.AbsoluteDirection );
                      zt_amunicja.TransformationChanged();

                    end;
                  //---//if zt_amunicja.Parent <> Gra_Obiekty_GLDummyCube then

                end;
              //---//if not ( zt_amunicja.amunicja_rodzaj in [ ar_Torpeda ] ) then
              {$endregion 'Ruch do przodu.'}


              if zt_amunicja.torpeda_efekt_na_wodzie <> nil then
                zt_amunicja.torpeda_efekt_na_wodzie.Position.AsVector := VectorMake(  zt_amunicja.korpus.AbsolutePosition.X, 0 + ( Random() - 0.5 ) * 0.25, zt_amunicja.korpus.AbsolutePosition.Z  );


              if not zt_amunicja.czy_poza_zasięgiem then
                begin

                  // W skutecznym zasięgu.

                  {$region 'Czy poza zasięgiem.'}
                  //if zt_amunicja.DistanceTo( zt_amunicja.pozycja_startowa ) > zt_amunicja.zasięg then
                  if   (     // Dla lotu liniowego poza zasięgiem jest gdy wyleci poza swój zasięg.
                             (
                                  (
                                        ( zt_amunicja.amunicja_rodzaj in [ ar_Artyleria, ar_Pocisk ] )
                                    and ( not zt_amunicja.czy_lot_parabolą )
                                  )
                               or (  not ( zt_amunicja.amunicja_rodzaj in [ ar_Artyleria, ar_Pocisk ] )  )
                             )
                         and ( zt_amunicja.DistanceTo( zt_amunicja.pozycja_startowa ) > zt_amunicja.zasięg )
                       )
//                    or (     // Dla lotu parabolicznego poza zasięgiem jest gdy znajdzie się pod podłożem. // A Jeżeli leci (pionowo) w górę to nie znajdzie się pod podłożem.
//                             ( zt_amunicja.amunicja_rodzaj in [ ar_Artyleria, ar_Pocisk ] )
//                         and ( zt_amunicja.czy_lot_parabolą )
//                         and ( zt_amunicja.AbsolutePosition.Y <= Dno_GLPlane.AbsolutePosition.Y )
//                       )
//                    or (     // Dla lotu parabolicznego poza zasięgiem jest gdy wyleci poza swój zasięg (liczony w poziomie). // A Jeżeli leci (pionowo) w górę to odległość w poziomie może się prawie nie zmieniać.
//                             ( zt_amunicja.amunicja_rodzaj in [ ar_Artyleria, ar_Pocisk ] )
//                         and ( zt_amunicja.czy_lot_parabolą )
//                         and (   zt_amunicja.pozycja_startowa.DistanceTo(  GLVectorGeometry.VectorMake( zt_amunicja.AbsolutePosition.X, zt_amunicja.pozycja_startowa.AbsolutePosition.Y, zt_amunicja.AbsolutePosition.Z )  ) > zt_amunicja.zasięg   )
//                       )
                    or (
                             ( zt_amunicja.amunicja_rodzaj in [ ar_Artyleria, ar_Pocisk ] )
                         and ( zt_amunicja.czy_lot_parabolą )
                         //and ( zt_amunicja.DistanceTo( zt_amunicja.pozycja_startowa ) > zt_amunicja.zasięg )
                         and (
                                  ( zt_amunicja.pozycja_woda.DistanceTo( zt_amunicja.pozycja_startowa ) > zt_amunicja.zasięg )
                               or ( zt_amunicja.DistanceTo( zt_amunicja.pozycja_startowa ) > zt_amunicja.zasięg * 1.5 ) // Jeżeli leci pionowo w górę.
                             )
                       )
                    then
                    begin

                      zt_amunicja.czy_poza_zasięgiem := true;

                      zt_amunicja.opadanie_obrót_korekta_o_kąt_na_granicy_zasięgu := zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle;

                      zt_amunicja.korpus.Material.FrontProperties.Ambient.Color := clrBlack; //???

                    end;
                  //---//if   ( (...)
                  {$endregion 'Czy poza zasięgiem.'}


                  {$region 'Przesuwa i obraca amunicję razem ze statkiem - wersja 1.'}
                  //if zt_amunicja.statek <> nil then
                  //  begin
                  //
                  //    //zt_amunicja.statek_obrót := statek_obrót_f;
                  //    //zt_amunicja.czy_statek_dane := true;
                  //
                  //
                  //    if zt_amunicja.korpus.DistanceTo( zt_amunicja.pozycja_startowa.AbsolutePosition ) <= zt_amunicja.strzał_od_blokada_dystans then
                  //      begin
                  //
                  //        // Amunicję jest w lufie.
                  //
                  //        zt_amunicja.statek_prędkość := zt_amunicja.statek.prędkość_aktualna;
                  //
                  //
                  //        // Obraca amunicję gdy amunicja jest w lufie.
                  //
                  //        //zt_amunicja.Turn( zt_amunicja.statek.prędkość_obrotu_aktualna );
                  //        zt_amunicja.TurnAngle := zt_amunicja.TurnAngle - zt_amunicja.statek.prędkość_obrotu_aktualna;
                  //        zt_amunicja.korpus.Material.FrontProperties.Ambient.Color := clrGreen; //???
                  //
                  //      end
                  //    else//if zt_amunicja.korpus.DistanceTo( zt_amunicja.pozycja_startowa.AbsolutePosition ) <= zt_amunicja.strzał_od_blokada_dystans then
                  //      begin
                  //
                  //        // Amunicję jest poza lufą.
                  //
                  //        if not zt_amunicja.czy_poza_lufą then
                  //          zt_amunicja.czy_poza_lufą := true;
                  //
                  //
                  //        zt_amunicja.korpus.Material.FrontProperties.Ambient.Color := clrRed; //???
                  //
                  //        //if zt_amunicja.pozycja_startowa.AbsolutePosition.Y <> 0 then
                  //          //???zt_amunicja.pozycja_startowa.Position.Y := zt_amunicja.pozycja_startowa.AbsoluteToLocal( GLVectorGeometry.TVector(0, 0, 0) ).Y; // Zawsze poziom wody.
                  //        //  zt_amunicja.pozycja_startowa.Position.Y := 0;
                  //
                  //
                  //        if Abs( zt_amunicja.statek_prędkość ) > 0 then
                  //          begin
                  //
                  //            // Zmniejsza współczynnik prędkości statku gdy amunicja poza lufą.
                  //
                  //            ztr := Abs( zt_amunicja.statek_prędkość ) * gra_współczynnik_prędkości_g;
                  //
                  //            if zt_amunicja.statek_prędkość < 0 then
                  //              ztr := -ztr;
                  //
                  //            zt_amunicja.statek_prędkość := zt_amunicja.statek_prędkość - ztr;
                  //
                  //
                  //            if Abs( zt_amunicja.statek_prędkość ) < 0.001 then
                  //              zt_amunicja.statek_prędkość := 0;
                  //
                  //          end;
                  //        //---//if Abs( zt_amunicja.statek_prędkość ) > 0 then
                  //
                  //      end;
                  //    //---//if zt_amunicja.korpus.DistanceTo( zt_amunicja.pozycja_startowa.AbsolutePosition ) <= zt_amunicja.strzał_od_blokada_dystans then
                  //
                  //
                  //    if Abs( zt_amunicja.statek_prędkość ) > 0 then
                  //      begin
                  //
                  //        // Przesuwa amunicję o prędkość ruchu statku.
                  //
                  //        //zt_amunicja.Position.AddScaledVector( zt_amunicja.statek_prędkość, zt_amunicja.statek_kierunek );
                  //        //zt_amunicja.Position.AddScaledVector( zt_amunicja.statek_prędkość, statek_gracza.AbsoluteDirection );
                  //        zt_amunicja.Position.AddScaledVector( zt_amunicja.statek_prędkość, zt_amunicja.statek.AbsoluteDirection );
                  //        zt_amunicja.TransformationChanged();
                  //
                  //      end;
                  //    //---//if Abs( zt_amunicja.statek_prędkość ) > 0 then
                  //
                  //  end;
                  ////---//if zt_amunicja.statek <> nil then
                  {$endregion 'Przesuwa i obraca amunicję razem ze statkiem - wersja 1.'}


                  if    ( not zt_amunicja.czy_poza_lufą )
                    and (  zt_amunicja.korpus.DistanceTo( zt_amunicja.pozycja_startowa.AbsolutePosition ) > zt_amunicja.strzał_od_blokada_dystans  ) then
                    begin

                      // Amunicja opuszcza lufę.

                      zt_amunicja.czy_poza_lufą := true;

                      zt_amunicja.korpus.Material.FrontProperties.Ambient.Color := clrYellow; //???


                      {$region 'Po opuszczeniu lufy amunicja zmienia rodzica.'}
                      // Istotna jest wartość nie w momencie strzału tylko w momencie opuszczenia lufy (ze względu na falowanie statku).
                      zt_amunicja.opadanie_obrót_korekta_o_ustawienie_początkowe :=
                        RadToDeg( // uses Math.
                            AngleBetweenVectors( // uses GLVectorGeometry.
                               GLVectorGeometry.VectorMake(  zt_amunicja.korpus_ustawienie_początkowe_dummy.AbsoluteDirection.X, Abs( zt_amunicja.korpus_ustawienie_początkowe_dummy.AbsoluteDirection.Y ), zt_amunicja.korpus_ustawienie_początkowe_dummy.AbsoluteDirection.Z  ),
                               GLVectorGeometry.VectorMake( zt_amunicja.korpus_ustawienie_początkowe_dummy.AbsoluteDirection.X, 0, zt_amunicja.korpus_ustawienie_początkowe_dummy.AbsoluteDirection.Z ),
                               GLVectorGeometry.VectorMake( 0, 0, 0 )
                             )
                          );

                      if zt_amunicja.AbsoluteDirection.Y < 0 then
                        zt_amunicja.opadanie_obrót_korekta_o_ustawienie_początkowe := -zt_amunicja.opadanie_obrót_korekta_o_ustawienie_początkowe;


                      zt_amunicja.pozycja_startowa.Parent := Gra_Obiekty_GLDummyCube;
                      zt_amunicja.pozycja_startowa.AbsolutePosition := zt_amunicja.AbsolutePosition; // Tutaj tymczasowo zapamiętuje aktualny kierunek amunicji.
                      zt_amunicja.pozycja_startowa.AbsoluteDirection := zt_amunicja.AbsoluteDirection; // Tutaj tymczasowo zapamiętuje bezwzględną górę amunicji.
                      zt_amunicja.pozycja_startowa.AbsoluteUp := zt_amunicja.AbsoluteUp;

                      zt_vector := zt_amunicja.korpus_ustawienie_początkowe_dummy.AbsoluteUp;


                      zt_amunicja.Parent := Gra_Obiekty_GLDummyCube; // Po zmianie rodzica amunicja:
                      zt_amunicja.AbsolutePosition := zt_amunicja.pozycja_startowa.AbsolutePosition; // jest w tej samej bezwzględnej pozycji;
                      zt_amunicja.AbsoluteDirection := zt_amunicja.pozycja_startowa.AbsoluteDirection; // zachowuje ten sam bezwzględny kierunek;
                      zt_amunicja.AbsoluteUp := zt_amunicja.pozycja_startowa.AbsoluteUp; // bezwzględna góra znajduje się w tym samym miejscu (kierunku).

                      if zt_amunicja.czy_lot_parabolą then
                        zt_amunicja.pozycja_startowa.AbsolutePosition := zt_amunicja.działo_pozycja_absolutna_vector;

                      zt_amunicja.korpus_opadanie_obrót_dummy.AbsoluteDirection := zt_amunicja.AbsoluteDirection;
                      zt_amunicja.korpus_opadanie_obrót_dummy.AbsoluteUp := GLVectorGeometry.VectorMake( 0, 1, 0 );

                      zt_amunicja.korpus_ustawienie_początkowe_dummy.AbsoluteDirection := zt_amunicja.AbsoluteDirection;
                      zt_amunicja.korpus_ustawienie_początkowe_dummy.AbsoluteUp := zt_vector;


                      // Wylicza pozycję wskaźnika celu.
                      zt_amunicja.pozycja_celu.AbsoluteDirection := zt_amunicja.AbsoluteDirection;
                      zt_amunicja.pozycja_celu.Direction.Y := 0;
                      zt_amunicja.pozycja_celu.Move( zt_amunicja.cel_odległość );
                      //---// Wylicza pozycję wskaźnika celu.
                      {$endregion 'Po opuszczeniu lufy amunicja zmienia rodzica.'}


                      zt_amunicja.Scale.Scale( zt_amunicja.skala );


                      zt_amunicja.czy_pod_wodą := zt_amunicja.AbsolutePosition.Y < 0;
                      zt_amunicja.czy_wynurzanie := zt_amunicja.czy_pod_wodą;


                      if zt_amunicja.statek <> nil then
                        begin

                          zt_amunicja.statek_prędkość := zt_amunicja.statek.prędkość_aktualna;
                          zt_amunicja.pozycja_startowa.AbsoluteDirection := zt_amunicja.statek.AbsoluteDirection; // Tutaj zapamiętuje aktualny kierunek statku.

                        end;
                      //---//if zt_amunicja.statek <> nil then


                      zts := Amunicja__Zanurzenie_Głębokość_Zadana_Edit.Text;
                      zts := StringReplace( zts, ' ', '', [ rfReplaceAll ] );
                      zts := StringReplace( zts, '.', ',', [ rfReplaceAll ] );

                      try
                        zt_amunicja.zanurzenie_głębokość_zadana := StrToFloat( zts );
                      except
                      end;
                      //---//try


                      if    ( zt_amunicja.czy_lot_parabolą ) // Taki sam warunek pozycja_celu_Visible.
                        and ( Amunicja__Cel_Pozycja_Dla_Lotu_Parabolą_Wyświetl_CheckBox.Checked )
                        and ( not zt_amunicja.pozycja_celu.Visible )
                        and (
                                 ( zt_amunicja.id_statek = Gracz_Identyfikator() )
                              or ( // Gdy gra nie jest rozpoczęta.
                                       ( Wieloosobowe_Identyfikator_Edit.Text = '' )
                                   and ( zt_amunicja.id_statek = 0 )
                                 )
                            ) then
                        zt_amunicja.pozycja_celu.Visible := true;

                    end;
                  //---//if    ( not zt_amunicja.czy_poza_lufą ) (...)


                  if zt_amunicja.czy_poza_lufą then
                    begin

                      // Amunicja jest poza lufą.

                      {$region 'Przesuwa i obraca amunicję razem ze statkiem.'}
                      //??? po opuszczeniu lufy gdy statek płynie amunicja wyprzedza statek (1 skok)
                      if Abs( zt_amunicja.statek_prędkość ) > 0 then
                        begin

                          // Zmniejsza współczynnik prędkości statku gdy amunicja jest poza lufą.

                          ztr := Abs( zt_amunicja.statek_prędkość ) * 0.01 * gra_współczynnik_prędkości_g;

                          if zt_amunicja.statek_prędkość > 0 then
                            zt_amunicja.statek_prędkość := zt_amunicja.statek_prędkość - ztr
                          else//if zt_amunicja.statek_prędkość > 0 then
                            zt_amunicja.statek_prędkość := zt_amunicja.statek_prędkość + ztr;


                          if Abs( zt_amunicja.statek_prędkość ) < 0.001 then
                            zt_amunicja.statek_prędkość := 0;

                        end;
                      //---//if Abs( zt_amunicja.statek_prędkość ) > 0 then


                      if Abs( zt_amunicja.statek_prędkość ) > 0 then
                        begin

                          // Przesuwa amunicję o prędkość ruchu statku.

                          //zt_amunicja.Position.AddScaledVector( zt_amunicja.statek_prędkość, zt_amunicja.statek_kierunek );
                          //zt_amunicja.Position.AddScaledVector( zt_amunicja.statek_prędkość, statek_gracza.AbsoluteDirection );
                          zt_amunicja.Position.AddScaledVector( zt_amunicja.statek_prędkość * delta_czasu_f * gra_współczynnik_prędkości_g, zt_amunicja.pozycja_startowa.AbsoluteDirection );
                          zt_amunicja.TransformationChanged();

                        end;
                      //---//if Abs( zt_amunicja.statek_prędkość ) > 0 then
                      {$endregion 'Przesuwa i obraca amunicję razem ze statkiem.'}


                      if zt_amunicja.amunicja_rodzaj in [ ar_Artyleria, ar_Pocisk ] then
                        begin

                          // Artyleria, pocisk.

                          {$region 'Wysokość i obrót dla ruchu parabolą.'}
                          if zt_amunicja.amunicja_rodzaj = ar_Artyleria then
                            begin

                              // Artyleria.

                              if zt_amunicja.czy_lot_parabolą then
                                begin

                                  if zt_amunicja.Tag = 0 then
                                    begin

                                      ztr := zt_amunicja.pozycja_startowa.DistanceTo( zt_amunicja.pozycja_woda ); // Odległość od pozycji startowej w poziomie.

                                      if ztr >= zt_amunicja.cel_odległość * lot_parabolą__kąta_opadania__odległość_od_procent_c then
                                        begin

                                          zt_amunicja.Tag := 1;

                                          // Kąt pod jakim amunicja leci względem wody w momencie kiedy amunicja zaczyna opadać w locie parabolą.
                                          zt_amunicja.korpus_opadanie_obrót_dummy.TagFloat := RadToDeg(  AngleBetweenVectors( zt_amunicja.korpus_ustawienie_początkowe_dummy.AbsoluteDirection, GLVectorGeometry.VectorMake( zt_amunicja.korpus_ustawienie_początkowe_dummy.AbsoluteDirection.X, 0, zt_amunicja.korpus_ustawienie_początkowe_dummy.AbsoluteDirection.Z ), GLVectorGeometry.VectorMake( 0, 0, 0 ) )  );

                                        end;
                                      //---//if ztr >= zt_amunicja.cel_odległość * lot_parabolą__kąta_opadania__odległość_od_procent_c then

                                    end;
                                  //---//if zt_amunicja.Tag = 0 then


                                  if zt_amunicja.Tag = 1 then
                                    begin

                                      ztr := zt_amunicja.pozycja_startowa.DistanceTo( zt_amunicja.pozycja_woda ); // Odległość od pozycji startowej w poziomie.

                                      if ztr >= zt_amunicja.cel_odległość * 0.9 then
                                        if zt_amunicja.działo_podniesienie_procent_kąta_maksymalnego >= 70 then
                                          zt_amunicja.Tag := 2
                                        else//if zt_amunicja.działo_podniesienie_procent_kąta_maksymalnego >= 48 then
                                          zt_amunicja.Tag := 2; // Dla bliskiego dystansu nie naprowadza amunicji na cel.


                                      if zt_amunicja.działo_podniesienie_procent_kąta_maksymalnego <= 33 then
                                        lot_parabolą__kąta_opadania__przed_namierzaniem_modyfikator_l := ( 2 * zt_amunicja.działo_podniesienie_procent_kąta_maksymalnego / 100 )
                                      else//if zt_amunicja.działo_podniesienie_procent_kąta_maksymalnego <= 38 then
                                      if zt_amunicja.działo_podniesienie_procent_kąta_maksymalnego <= 66 then
                                        lot_parabolą__kąta_opadania__przed_namierzaniem_modyfikator_l := ( 1.5 * zt_amunicja.działo_podniesienie_procent_kąta_maksymalnego / 100 )
                                      else//if zt_amunicja.działo_podniesienie_procent_kąta_maksymalnego <= 58 then
                                        lot_parabolą__kąta_opadania__przed_namierzaniem_modyfikator_l := 1;


                                      // Podczas przelatywania zadanego odcinka obniża kąt lotu z pozycji początkowej (po wystrzeleniu) do końcowej (opadania).
                                      zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle :=
                                          ( -lot_parabolą__kąta_opadania__przed_namierzaniem_c - zt_amunicja.korpus_opadanie_obrót_dummy.TagFloat ) // Kąt o jaki należy zmienić pochylenie.
                                        * lot_parabolą__kąta_opadania__przed_namierzaniem_modyfikator_l
                                        * (   ( ztr - zt_amunicja.cel_odległość * lot_parabolą__kąta_opadania__odległość_od_procent_c ) // Początek odcinka, na którym należy zmienić kąt (aktualna odległość minus odległość początku odcinka zmiany kąta).
                                        * 100
                                        / ( zt_amunicja.cel_odległość * lot_parabolą__kąta_opadania__odległość_od_odcinek_zmiany_kąta_procent_c )  ) // Odcinek, na którym należy zmienić kąt.
                                        * 0.01;


                                      //// Kąt na cel z aktualnego położenia amunicji.
                                      //GLVectorGeometry.SetVector
                                      //  (
                                      //      zt_vector
                                      //      // Cel                 Obiekt celujący
                                      //    , zt_amunicja.pozycja_celu.AbsolutePosition.X - zt_amunicja.AbsolutePosition.X
                                      //    , zt_amunicja.pozycja_celu.AbsolutePosition.Y - zt_amunicja.AbsolutePosition.Y
                                      //    , zt_amunicja.pozycja_celu.AbsolutePosition.Z - zt_amunicja.AbsolutePosition.Z
                                      //  );
                                      //
                                      //// Kąt między kierunkiem lotu amunicji a kierunkiem na cel z aktualnego położenia amunicji.
                                      //ztr := RadToDeg(  AngleBetweenVectors( zt_amunicja.korpus_ustawienie_początkowe_dummy.AbsoluteDirection, zt_vector, GLVectorGeometry.VectorMake( 0, 0, 0 ) )  );

                                    end
                                  else//if zt_amunicja.Tag = 1 then
                                  if zt_amunicja.Tag in [ 2, 3 ] then
                                    begin

                                      if zt_amunicja.korpus.AbsolutePosition.Y <= zt_amunicja.pozycja_celu.AbsolutePosition.Y then
                                        zt_amunicja.Tag := 4;

                                      if zt_amunicja.Tag <> 4 then
                                        begin

                                          if zt_amunicja.Tag <> 3 then
                                            ztr := zt_amunicja.pozycja_startowa.DistanceTo( zt_amunicja.pozycja_woda ); // Odległość od pozycji startowej w poziomie.

                                          if   ( zt_amunicja.Tag = 3 )
                                            or (  ztr > zt_amunicja.cel_odległość * ( lot_parabolą__kąta_opadania__odległość_od_procent_c + lot_parabolą__kąta_opadania__odległość_od_odcinek_zmiany_kąta_procent_c )  ) then
                                            begin

                                              zt_amunicja.Tag := 3; // Ogranicza ilość obliczeń.

                                              // Nakierowuje amunicję na cel (jak rakietę).
                                              zt_amunicja.korpus_ustawienie_początkowe_dummy.AbsoluteDirection := GLVectorGeometry.VectorMake
                                                (
                                                    // Cel                 Obiekt celujący
                                                    zt_amunicja.pozycja_celu.AbsolutePosition.X - zt_amunicja.korpus_ustawienie_początkowe_dummy.AbsolutePosition.X
                                                  , zt_amunicja.pozycja_celu.AbsolutePosition.Y - zt_amunicja.korpus_ustawienie_początkowe_dummy.AbsolutePosition.Y
                                                  , zt_amunicja.pozycja_celu.AbsolutePosition.Z - zt_amunicja.korpus_ustawienie_początkowe_dummy.AbsolutePosition.Z
                                                );

                                              //zt_amunicja.korpus.Material.FrontProperties.Ambient.SetColor( 10, 0, 0 ); // Test.

                                            end;
                                          //---//if   ( zt_amunicja.Tag = 3 ) (...)


                                          ztr := zt_amunicja.DistanceTo( zt_amunicja.pozycja_celu ); // Odległość amunicji do celu.

                                          if   ( ztr <= 1 )
                                            or ( ztr <= zt_amunicja.korpus.Height * 2 ) then
                                            zt_amunicja.Tag := 4;


                                          if zt_amunicja.Tag = 4  then
                                            begin

                                              zt_amunicja.korpus_ustawienie_początkowe_dummy.AbsoluteDirection := GLVectorGeometry.VectorMake( 0, -1, 0 ); // Zabezpieczenie aby poza kontrola naprowadzania amunicja leciała tylko w dół.
                                              //zt_amunicja.korpus.Material.FrontProperties.Ambient.SetColor( 10, 10, 10 ); // Test.

                                            end;
                                          //---//if zt_amunicja.Tag = 4  then

                                        end;
                                      //---//if zt_amunicja.Tag <> 4 then

                                    end;
                                  //---//if zt_amunicja.Tag in [ 2, 3 ] then

                                end;
                              //---//if zt_amunicja.czy_opadanie_parabola then

                            end;
                          //---//if zt_amunicja.amunicja_rodzaj = ar_Artyleria then
                          {$endregion 'Wysokość i obrót dla ruchu parabolą.'}


                          {$region 'Wysokość i obrót dla ruchu parabolą - wersja 1.'}
                          // Na podstawie punktów i równania paraboli.
                          //
                          //if zt_amunicja.amunicja_rodzaj = ar_Artyleria then
                          //  begin
                          //
                          //    // Artyleria.
                          //
                          //    if zt_amunicja.czy_lot_parabolą then
                          //      begin
                          //
                          //        //ztr := zt_amunicja.korpus.DistanceTo( zt_amunicja.pozycja_startowa.AbsolutePosition );
                          //
                          //        // Jest utworzony jako bezpośredni potomek sceny.
                          //        zt_amunicja.korpus_ustawienie_początkowe_dummy.Position.X := zt_amunicja.AbsolutePosition.X;
                          //        zt_amunicja.korpus_ustawienie_początkowe_dummy.Position.Z := zt_amunicja.AbsolutePosition.Z;
                          //
                          //        // Dla paraboli ważna jest odległość w linii prostej jako x dla równania na y niż odległość rzeczywista pocisku od lufy.
                          //        ztr := zt_amunicja.korpus_ustawienie_początkowe_dummy.DistanceTo( zt_amunicja.pozycja_startowa.AbsolutePosition );
                          //
                          //        //Statki_Form.Caption := FloatToStr( ztr );
                          //
                          //        zt_amunicja.Position.Y := zt_amunicja.parabola_równanie__a * Sqr( ztr ) + zt_amunicja.parabola_równanie__b * ztr + zt_amunicja.parabola_równanie__c;
                          //
                          //        //if zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle > -80 then
                          //          zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle := -zt_amunicja.parabola_kąt_lotu_początkowy - ztr * zt_amunicja.parabola_kąt_lotu_współczynnik; //???
                          //
                          //      end;
                          //    //---//if zt_amunicja.czy_opadanie_parabola then
                          //
                          //  end;
                          ////---//if zt_amunicja.amunicja_rodzaj = ar_Artyleria then
                          {$endregion 'Wysokość i obrót dla ruchu parabolą - wersja 1.'}

                          {$region 'Wysokość i obrót dla ruchu parabolą - wersja 2.'}
                          // Na podstawie dążenia do zadanego kąta procentowo względem przebytej drogi z zadanej odległości (z uwzględnieniem zasięgu działa).
                          //
                          //if zt_amunicja.amunicja_rodzaj = ar_Artyleria then
                          //  begin
                          //
                          //    // Artyleria.
                          //
                          //    if zt_amunicja.czy_lot_parabolą then
                          //      begin
                          //
                          //        ztr := zt_amunicja.pozycja_startowa.DistanceTo(  GLVectorGeometry.VectorMake( zt_amunicja.AbsolutePosition.X, zt_amunicja.pozycja_startowa.AbsolutePosition.Y, zt_amunicja.AbsolutePosition.Z )  ); // Odległość od pozycji startowej w poziomie.
                          //
                          //        // Obraca czubkiem w dół (im mniejszy dystans do celu tym kąt jest bliższy 80).
                          //        //   Samo wykrywa, w którą stronę obracać aby obracało się czubkiem do dołu (najkrótszą drogą).
                          //        if    ( ztr <= zt_amunicja.cel_odległość )
                          //          and ( zt_amunicja.cel_odległość <> 0 )
                          //          and ( zt_amunicja.Tag = 0 ) then
                          //          zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle :=
                          //            // -( 80 + zt_amunicja.opadanie_obrót_korekta_o_ustawienie_początkowe ) // Kąt docelowy 80 skorygowany o kąt początkowy.
                          //            // -( 60? + zt_amunicja.opadanie_obrót_korekta_o_ustawienie_początkowe ) // Kąt docelowy 80 skorygowany o kąt początkowy. //??? dać kąt maksymalny podniesienia lufy + 10
                          //             -(  ( zt_amunicja.działo_podniesienie_kąt_maksymalny + zt_amunicja.działo_podniesienie_kąt_maksymalny * 0.3 ) + zt_amunicja.opadanie_obrót_korekta_o_ustawienie_początkowe  )
                          //            * ( 100 * ztr / zt_amunicja.cel_odległość ) // Procentowa modyfikacja względem odległości (odległość od pozycji początkowej jest bliższa odległości do celu siła modyfikacji wzrasta do 100%).
                          //            * 0.01;
                          //
                          //      end;
                          //    //---//if zt_amunicja.czy_opadanie_parabola then
                          //
                          //  end;
                          ////---//if zt_amunicja.amunicja_rodzaj = ar_Artyleria then
                          {$endregion 'Wysokość i obrót dla ruchu parabolą - wersja 2.'}

                        end
                      else//if zt_amunicja.amunicja_rodzaj in [ ar_Artyleria, ar_Pocisk ] then
                      if zt_amunicja.amunicja_rodzaj = ar_Torpeda then
                        begin

                          // Torpeda.

                          {$region 'Torpeda - zanurzanie i wynurzanie.'}
                          if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y > 0 then
                            begin

                              // Amunicja ponad wodą.

                              if zt_amunicja.czy_wynurzanie then
                                zt_amunicja.czy_wynurzanie := false;

                              if zt_amunicja.czy_pod_wodą then
                                zt_amunicja.czy_pod_wodą := false;


                              // Obraca czubkiem w dół.
                              //   Samo wykrywa, w którą stronę obracać aby obracało się czubkiem do dołu (najkrótszą drogą).
                              if zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle + zt_amunicja.opadanie_obrót_korekta_o_ustawienie_początkowe > -45 then
                                zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle := zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle - gra_współczynnik_prędkości_g - delta_czasu_f
                              else//if zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle > -45 then
                                zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle := zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle + gra_współczynnik_prędkości_g + delta_czasu_f;


                              {$region 'Modyfikuje prędkości lotu - w powietrzu amunicja zwalnia.'}
                              if zt_amunicja.prędkość > zt_amunicja.prędkość_wytracanie_współczynnik then
                                zt_amunicja.prędkość := zt_amunicja.prędkość - zt_amunicja.prędkość_wytracanie_współczynnik * gra_współczynnik_prędkości_g;

                              if zt_amunicja.prędkość < 0 then
                                zt_amunicja.prędkość := 0;
                              {$endregion 'Modyfikuje prędkości lotu - w powietrzu amunicja zwalnia.'}


                              // Opada po wystrzeleniu.
                              zt_amunicja.prędkość_opadania := zt_amunicja.prędkość_opadania + zt_amunicja.prędkość_opadania_współczynnik;

                              zt_amunicja.Position.AddScaledVector(  zt_amunicja.prędkość_opadania * gra_współczynnik_prędkości_g, GLVectorGeometry.VectorMake( 0, -1, 0 )  );
                              zt_amunicja.TransformationChanged();

                            end
                          else//if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y > 0 then
                            begin

                              // Amunicja w wodzie.

                              // Poziomuje w kierunku ruchu.
                              //   Samo wykrywa, w którą stronę obracać aby obracało się czubkiem do dołu (najkrótszą drogą).
                              if Abs( zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle + zt_amunicja.opadanie_obrót_korekta_o_ustawienie_początkowe ) - gra_współczynnik_prędkości_g * 2 - delta_czasu_f > 0 then // Zabezpiecza aby nie drgało.
                                begin

                                  if zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle + zt_amunicja.opadanie_obrót_korekta_o_ustawienie_początkowe + delta_czasu_f > 0 then
                                    zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle := zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle - gra_współczynnik_prędkości_g - delta_czasu_f
                                  else//if zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle > -45 then
                                    zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle := zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle + gra_współczynnik_prędkości_g + delta_czasu_f;

                                end
                              else//if Abs( zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle + zt_amunicja.opadanie_obrót_korekta_o_ustawienie_początkowe ) - gra_współczynnik_prędkości_g * 2 - delta_czasu_f > 0 then
                                begin

                                  zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle := -zt_amunicja.opadanie_obrót_korekta_o_ustawienie_początkowe;

                                end;
                              //---//if Abs( zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle + zt_amunicja.opadanie_obrót_korekta_o_ustawienie_początkowe ) - gra_współczynnik_prędkości_g * 2 - delta_czasu_f > 0 then


                              {$region 'Modyfikuje prędkości lotu - w wodzie amunicja przyspiesza.'}
                              if zt_amunicja.prędkość < zt_amunicja.prędkość_początkowa - zt_amunicja.prędkość_wytracanie_współczynnik * gra_współczynnik_prędkości_g then
                                zt_amunicja.prędkość := zt_amunicja.prędkość + zt_amunicja.prędkość_wytracanie_współczynnik * gra_współczynnik_prędkości_g;

                              if zt_amunicja.prędkość > zt_amunicja.prędkość_początkowa then
                                zt_amunicja.prędkość := zt_amunicja.prędkość_początkowa;
                              {$endregion 'Modyfikuje prędkości lotu - w wodzie amunicja przyspiesza.'}


                              if not zt_amunicja.czy_pod_wodą then
                                begin

                                  // Pierwsze wpadnięcie do wody (po wpadnięciu do wody prędkość opadania maleje).

                                  zt_amunicja.czy_pod_wodą := true;
                                  zt_amunicja.zanurzenie_głębokość_po_wpadnięciu_do_wody := zt_amunicja.zanurzenie_głębokość_po_wpadnięciu_do_wody + zt_amunicja.prędkość_opadania * 10 * gra_współczynnik_prędkości_g; // Modyfikuje głębokość zanurzenia o prędkość opadania. 10
                                  zt_amunicja.prędkość_opadania := zt_amunicja.prędkość_opadania * woda_współczynnik_tłumienia_c;


                                  if    ( zt_amunicja.torpeda_efekt_na_wodzie <> nil )
                                    and ( zt_amunicja.torpeda_efekt_na_wodzie.Parent = nil ) then
                                    begin

                                      Amunicja_Wystrzelona_Efekt_Utwórz( zt_amunicja, true );
                                      zt_amunicja.torpeda_efekt_na_wodzie.Parent := Gra_Obiekty_GLDummyCube;

                                    end;
                                  //---//if    ( zt_amunicja.torpeda_efekt_na_wodzie <> nil ) (...)

                                end;
                              //---//if not zt_amunicja.czy_pod_wodą then


                              if not zt_amunicja.czy_wynurzanie then
                                begin

                                  // Zwiększa głębokość zanurzenia.

                                  zt_amunicja.prędkość_opadania := zt_amunicja.prędkość_opadania + zt_amunicja.prędkość_opadania_współczynnik * woda_współczynnik_tłumienia_c;

                                  zt_amunicja.Position.AddScaledVector(  zt_amunicja.prędkość_opadania * gra_współczynnik_prędkości_g, GLVectorGeometry.VectorMake( 0, -1, 0 )  );
                                  zt_amunicja.TransformationChanged();

                                  if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y <= -zt_amunicja.zanurzenie_głębokość_po_wpadnięciu_do_wody then
                                    begin

                                      zt_amunicja.czy_wynurzanie := true;
                                      zt_amunicja.zanurzenie_głębokość_po_wpadnięciu_do_wody := 0; // Zeruje wartość na wypadek jeżeli znów amunicja wyskoczyłaby z wody.

                                    end;
                                  //---//if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y <= -zt_amunicja.zanurzenie_głębokość_po_wpadnięciu_do_wody then

                                end
                              else//if not zt_amunicja.czy_wynurzanie then
                                begin

                                  // Dąży do zadanej głębokości.

                                  if    ( zt_amunicja.torpeda_efekt_na_wodzie <> nil )
                                    and ( zt_amunicja.torpeda_efekt_na_wodzie.Parent = nil ) then
                                    begin

                                      Amunicja_Wystrzelona_Efekt_Utwórz( zt_amunicja, true );
                                      zt_amunicja.torpeda_efekt_na_wodzie.Parent := Gra_Obiekty_GLDummyCube;

                                    end;
                                  //---//if    ( zt_amunicja.torpeda_efekt_na_wodzie <> nil ) (...)


                                  if Abs( zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y - zt_amunicja.zanurzenie_głębokość_zadana ) > Abs( 0.01 ) then // Zabezpiecza aby nie drgało.
                                    begin

                                      if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y < zt_amunicja.zanurzenie_głębokość_zadana then
                                        zt_amunicja.prędkość_opadania := zt_amunicja.prędkość_opadania - zt_amunicja.prędkość_opadania_współczynnik * woda_współczynnik_tłumienia_c
                                      else//if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y < zt_amunicja.zanurzenie_głębokość_zadana then
                                        zt_amunicja.prędkość_opadania := zt_amunicja.prędkość_opadania + zt_amunicja.prędkość_opadania_współczynnik * woda_współczynnik_tłumienia_c;


                                      if zt_amunicja.zanurzenie_głębokość_zadana = 0 then
                                        ztr := 0.25
                                      else//if zt_amunicja.zanurzenie_głębokość_zadana = 0 then
                                        begin

                                          // Im mniejszy dystans do zadanej głębokości tym prędkość opadania jest procentowo obniżana do 0 (im dalej tym jej skuteczność osiąga 100%).
                                          //??? wielkość wskaznika osłabić osłabiani gdy daleko
                                          ztr := Abs( 100 - Abs( zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y * 100 / zt_amunicja.zanurzenie_głębokość_zadana )  ) * 0.01;

                                          if ztr > 1 then
                                            ztr := 1; // Nie więcej niż 100%.

                                        end;
                                      //---//if zt_amunicja.zanurzenie_głębokość_zadana = 0 then


                                      zt_amunicja.Position.AddScaledVector(  zt_amunicja.prędkość_opadania * torpeda_dążenie_do_zadanej_głębokości_szybkość_c * ztr * gra_współczynnik_prędkości_g, GLVectorGeometry.VectorMake( 0, -1, 0 )  );
                                      zt_amunicja.TransformationChanged();

                                    end
                                  else//if Abs( zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y - zt_amunicja.zanurzenie_głębokość_zadana ) > Abs( 0.01 ) then
                                    begin

                                      if zt_amunicja.prędkość_opadania <> 0 then
                                        zt_amunicja.prędkość_opadania := 0;

                                    end;
                                  //---//if Abs( zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y - zt_amunicja.zanurzenie_głębokość_zadana ) > Abs( 0.01 ) then

                                end;
                              //---//if not zt_amunicja.czy_wynurzanie then

                            end;
                          //---//if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y > 0 then
                          {$endregion 'Torpeda - zanurzanie i wynurzanie.'}


                          {$region 'Torpeda - zanurzanie i wynurzanie - wersja 1.'}
                          //if not zt_amunicja.czy_wynurzanie then
                          //  begin
                          //
                          //    // Opada i zanurza się po wystrzeleniu.
                          //
                          //    if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y > -zt_amunicja.zanurzenie_głębokość_po_wpadnięciu_do_wody then
                          //      begin
                          //
                          //        if not zt_amunicja.czy_pod_wodą then
                          //          zt_amunicja.prędkość_opadania := zt_amunicja.prędkość_opadania + zt_amunicja.prędkość_opadania_współczynnik
                          //        else//if not zt_amunicja.czy_pod_wodą then
                          //          zt_amunicja.prędkość_opadania := zt_amunicja.prędkość_opadania + zt_amunicja.prędkość_opadania_współczynnik * woda_współczynnik_tłumienia_c;
                          //
                          //
                          //        if    ( not zt_amunicja.czy_pod_wodą )
                          //          and ( zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y <= 0 ) then
                          //          begin
                          //
                          //            // Po wpadnięciu do wody prędkość opadania maleje.
                          //
                          //            zt_amunicja.czy_pod_wodą := true;
                          //            zt_amunicja.zanurzenie_głębokość_po_wpadnięciu_do_wody := zt_amunicja.zanurzenie_głębokość_po_wpadnięciu_do_wody + zt_amunicja.prędkość_opadania * 10; // Modyfikuje głębokość zanurzenia o prędkość opadania.
                          //            zt_amunicja.prędkość_opadania := zt_amunicja.prędkość_opadania * woda_współczynnik_tłumienia_c;
                          //
                          //          end;
                          //        //---//if    ( not zt_amunicja.czy_pod_wodą ) (...)
                          //
                          //
                          //        zt_amunicja.korpus_opadanie_obrót_dummy.Lift( -zt_amunicja.prędkość_opadania );
                          //
                          //      end
                          //    else//if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y > -zt_amunicja.zanurzenie_głębokość_po_wpadnięciu_do_wody then
                          //      begin
                          //
                          //        if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y <= -zt_amunicja.zanurzenie_głębokość_po_wpadnięciu_do_wody then
                          //          zt_amunicja.czy_wynurzanie := true;
                          //
                          //      end;
                          //    //---//if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y > -zt_amunicja.zanurzenie_głębokość_po_wpadnięciu_do_wody then
                          //
                          //
                          //
                          //    // Przechyla się przodem w dół po wystrzeleniu.
                          //    // Jeżeli przechyli się za mocno to zmienią się współrzędne i nie wykryje warunku do wynurzania.
                          //    //if    ( zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle < 89 )
                          //    //  and ( zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y > 0 ) then
                          //    //  zt_amunicja.korpus_ustawienie_początkowe_dummy.PitchAngle := zt_amunicja.korpus_ustawienie_początkowe_dummy.PitchAngle - gra_współczynnik_prędkości_g;
                          //
                          //    if    ( zt_amunicja.korpus_ustawienie_początkowe_dummy.PitchAngle > -89 )
                          //      and ( zt_amunicja.korpus_ustawienie_początkowe_dummy.AbsolutePosition.Y > 0 ) then
                          //      zt_amunicja.korpus_ustawienie_początkowe_dummy.PitchAngle := zt_amunicja.korpus_ustawienie_początkowe_dummy.PitchAngle - gra_współczynnik_prędkości_g;
                          //
                          //  end
                          //else//if not zt_amunicja.czy_wynurzanie then
                          //  begin
                          //
                          //    // Wynurza się do poziomu standardowego płynięcia.
                          //
                          //    if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y < 0 then
                          //      zt_amunicja.korpus_opadanie_obrót_dummy.Lift( zt_amunicja.prędkość_opadania * 0.25 )
                          //    else//if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y < 0 then
                          //      if zt_amunicja.prędkość_opadania <> 0 then
                          //        zt_amunicja.prędkość_opadania := 0;
                          //
                          //  end;
                          ////---//if not zt_amunicja.czy_wynurzanie then
                          //
                          //
                          //if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y <= 0 then
                          //  begin
                          //
                          //    // Gdy jest już w wodzie.
                          //
                          //    // Wyrównuje przechylenie do poziomu.
                          //    //if zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle > 0 then
                          //    //  zt_amunicja.korpus_opadanie_obrót_dummy.Pitch( gra_współczynnik_prędkości_g );
                          //    if zt_amunicja.korpus_ustawienie_początkowe_dummy.PitchAngle < 0 then
                          //      zt_amunicja.korpus_ustawienie_początkowe_dummy.PitchAngle := zt_amunicja.korpus_ustawienie_początkowe_dummy.PitchAngle + gra_współczynnik_prędkości_g;
                          //
                          //  end;
                          ////---//if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y > 0 then
                          {$endregion 'Torpeda - zanurzanie i wynurzanie - wersja 1.'}

                        end;
                      //---//if zt_amunicja.amunicja_rodzaj = ar_Torpeda then

                    end;
                  //---//if zt_amunicja.czy_poza_lufą then

                end
              else//if not zt_amunicja.czy_poza_zasięgiem then
                begin

                  // Poza skutecznym zasięgiem.

                  {$region 'Modyfikuje prędkości lotu.'}
                  if zt_amunicja.prędkość > zt_amunicja.prędkość_wytracanie_współczynnik then
                    zt_amunicja.prędkość := zt_amunicja.prędkość - zt_amunicja.prędkość_wytracanie_współczynnik * gra_współczynnik_prędkości_g;

                  if zt_amunicja.prędkość < 0 then
                    zt_amunicja.prędkość := 0;


                  if not zt_amunicja.czy_pod_wodą then
                    zt_amunicja.prędkość_opadania := zt_amunicja.prędkość_opadania + zt_amunicja.prędkość_opadania_współczynnik * gra_współczynnik_prędkości_g
                  else//if not zt_amunicja.czy_pod_wodą then
                    zt_amunicja.prędkość_opadania := zt_amunicja.prędkość_opadania + zt_amunicja.prędkość_opadania_współczynnik * woda_współczynnik_tłumienia_c * gra_współczynnik_prędkości_g;


                  if    ( not zt_amunicja.czy_pod_wodą )
                    and ( zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y <= 0 ) then
                    begin

                      // Po wpadnięciu do wody prędkość opadania maleje.

                      zt_amunicja.czy_pod_wodą := true;
                      zt_amunicja.prędkość_opadania := zt_amunicja.prędkość_opadania * woda_współczynnik_tłumienia_c;

                    end;
                  //---//if    ( not zt_amunicja.czy_pod_wodą ) (...)
                  {$endregion 'Modyfikuje prędkości lotu.'}


                  {$region 'Poza skutecznym zasięgiem amunicja opada.'}
                  zt_amunicja.Position.AddScaledVector(  -Abs(zt_amunicja.prędkość_opadania) * gra_współczynnik_prędkości_g, GLVectorGeometry.VectorMake( 0, 1, 0 )  );
                  zt_amunicja.TransformationChanged();
                  {$endregion 'Poza skutecznym zasięgiem amunicja opada.'}


                  // Obraca czubkiem w dół (im mniejsza prędkość tym kąt jest bliższy 90).
                  //   Samo wykrywa, w którą stronę obracać aby obracało się czubkiem do dołu (najkrótszą drogą).
                  if zt_amunicja.prędkość_początkowa <> 0 then
                    //zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle := -( 90 + zt_amunicja.opadanie_obrót_korekta_o_ustawienie_początkowe ) * ( 100 - 100 * zt_amunicja.prędkość / zt_amunicja.prędkość_początkowa ) * 0.01;
                    zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle :=
                          zt_amunicja.opadanie_obrót_korekta_o_kąt_na_granicy_zasięgu
                      - ( 90 + zt_amunicja.opadanie_obrót_korekta_o_ustawienie_początkowe + zt_amunicja.opadanie_obrót_korekta_o_kąt_na_granicy_zasięgu ) // Kąt docelowy 90 skorygowany o kąt początkowy i kąt na granicy zasięgu.
                      * ( 100 - 100 * zt_amunicja.prędkość / zt_amunicja.prędkość_początkowa ) // Procentowa modyfikacja względem prędkości (prędkość dąży do 0 siła modyfikacji wzrasta do 100%).
                      * 0.01;


                  {$region 'Modyfikacja współczynnika zadawanych obrażeń.'}
                  if zt_amunicja.obrażenia_zadawane_współczynnik_zmodyfikowany > 0 then
                    begin

                      // zt_amunicja.zasięg + zt_amunicja.zasięg * 0.1{10%} // Końcowy zakres zadawania obrażeń - 0.1 = 10%.
                      //
                      // ( zt_amunicja.zasięg + zt_amunicja.zasięg * 0.1 ) - zt_amunicja.DistanceTo( zt_amunicja.pozycja_startowa ) // Procent wartości obrażeń - obniżenie.
                      //
                      // 100 * (  zt_amunicja.DistanceTo( zt_amunicja.pozycja_startowa ) - ( zt_amunicja.zasięg + zt_amunicja.zasięg * 0.1 )  ) / ( zt_amunicja.zasięg * 0.1 )


                      ztr := zt_amunicja.zasięg * 0.5; // Końcowy zakres zadawania obrażeń 50%.

                      if ztr <> 0 then
                        begin

                          ztr := 100 * (  ( zt_amunicja.zasięg + ztr ) - zt_amunicja.DistanceTo( zt_amunicja.pozycja_startowa )  ) / ztr;

                          zt_amunicja.obrażenia_zadawane_współczynnik_zmodyfikowany := ( zt_amunicja.obrażenia_zadawane_współczynnik * ztr / 100 );

                          if zt_amunicja.obrażenia_zadawane_współczynnik_zmodyfikowany > 1 then
                            zt_amunicja.obrażenia_zadawane_współczynnik_zmodyfikowany := 1
                          else//if zt_amunicja.obrażenia_zadawane_współczynnik_zmodyfikowany > 1 then
                            if zt_amunicja.obrażenia_zadawane_współczynnik_zmodyfikowany < 0.001 then
                              zt_amunicja.obrażenia_zadawane_współczynnik_zmodyfikowany := 0;


                          //zt_amunicja.Move( zt_amunicja.prędkość * zt_amunicja.obrażenia_zadawane_współczynnik_zmodyfikowany );

                        end;
                      //---//if ztr <> 0 then

                    end;
                  //---//if zt_amunicja.obrażenia_zadawane_współczynnik_zmodyfikowany > 0 then
                  {$endregion 'Modyfikacja współczynnika zadawanych obrażeń.'}



                  if    ( zt_amunicja.torpeda_efekt_na_wodzie <> nil )
                    and ( zt_amunicja.torpeda_efekt_na_wodzie.Parent <> nil )
                    and ( zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y < zt_amunicja.zanurzenie_głębokość_zadana -1 ) then
                    begin

                      FreeAndNil( zt_amunicja.torpeda_efekt_na_wodzie );

                    end;
                  //---//if    ( zt_amunicja.torpeda_efekt_na_wodzie <> nil ) (...)

                end;
              //---//if not zt_amunicja.czy_poza_zasięgiem then


              zt_amunicja.pozycja_woda.Position.X := zt_amunicja.AbsolutePosition.X;
              zt_amunicja.pozycja_woda.Position.Z := zt_amunicja.AbsolutePosition.Z;


              // Czy uzbrojona.
              if    ( zt_amunicja.czy_poza_lufą )
                and ( not zt_amunicja.czy_uzbrojona )
                and (  zt_amunicja.korpus.DistanceTo( zt_amunicja.pozycja_startowa.AbsolutePosition ) > zt_amunicja.strzał_od_blokada_dystans * 2  ) then //???
                begin

                  zt_amunicja.czy_uzbrojona := true;
                  zt_amunicja.korpus.Material.FrontProperties.Ambient.Color := clrRed; //???

                end;
              //---//if    ( zt_amunicja.czy_poza_lufą ) (...)

            end;
          //---//if zt_amunicja.czy_usunąć then

        end;
      //---//if zt_amunicja <> nil then

    end;
  //---//for i := amunicja_wystrzelona_list.Count - 1 downto 0 do

end;//---//Funkcja Amunicja_Ruch().

//Funkcja Lufy_Przeładowanie().
procedure TStatki_Form.Lufy_Przeładowanie( delta_czasu_f : double );
var
  i,
  j,
  i_s
    : integer;
  zt_statek : TStatek;
begin

  if czy_klient_g then
    Exit;


  for i_s := 0 to Length( statki_t ) - 1 do
    begin

      zt_statek := statki_t[ i_s ];

      if zt_statek <> nil then
        begin

          for i := 0 to Length( zt_statek.artyleria_t ) - 1 do
            for j := 0 to Length( zt_statek.artyleria_t[ i ].lufy_t ) - 1 do
              if zt_statek.artyleria_t[ i ].lufy_t[ j ] <> nil then
                zt_statek.artyleria_t[ i ].lufy_t[ j ].Przeładowanie( delta_czasu_f );


          for i := 0 to Length( zt_statek.działa_t ) - 1 do
            for j := 0 to Length( zt_statek.działa_t[ i ].lufy_t ) - 1 do
              if zt_statek.działa_t[ i ].lufy_t[ j ] <> nil then
                zt_statek.działa_t[ i ].lufy_t[ j ].Przeładowanie( delta_czasu_f );


          for i := 0 to Length( zt_statek.torpedy_wyrzutnie_t ) - 1 do
            for j := 0 to Length( zt_statek.torpedy_wyrzutnie_t[ i ].lufy_t ) - 1 do
              if zt_statek.torpedy_wyrzutnie_t[ i ].lufy_t[ j ] <> nil then
                zt_statek.torpedy_wyrzutnie_t[ i ].lufy_t[ j ].Przeładowanie( delta_czasu_f );

        end;
      //---//if zt_statek <> nil then

    end;
  //---//for i_s := 0 to Length( statki_t ) - 1 do

end;//---//Funkcja Lufy_Przeładowanie().

//Funkcja Statki_Kolizja_Oznaczenie_Sprawdź().
function TStatki_Form.Statki_Kolizja_Oznaczenie_Sprawdź( string_list_f : TStringList; obiekt_nazwa_f : string ) : boolean;
var
  i : integer;
  zti64 : int64;
  zts : string;
begin

  //
  // Funkcja sprawdza czy jest oznaczona nieprzeterminowana kolizja z podanym obiektem.
  //
  // Zwraca prawdę gdy jest oznaczona nieprzeterminowana kolizja z podanym obiektem.
  //
  // Parametry:
  //   string_list_f - lista kolizji;
  //   obiekt_nazwa_f.
  //

  Result := false;


  if   ( string_list_f = nil )
    or (  not Assigned( string_list_f )  ) then
    Exit;


  for i := string_list_f.Count - 1 downto 0 do
    begin

      zts := Copy(  string_list_f[ i ], Pos( '|', string_list_f[ i ] ) + 1, Length( string_list_f[ i ] )  );

      try
        zti64 := StrToInt64( zts );
      except
        zti64 := statek_kolizja_oznaczenie_ponowne_czas_c;
      end;
      //---//try

      if Czas_Między_W_Sekundach( zti64 ) >= statek_kolizja_oznaczenie_ponowne_czas_c then
        begin

          string_list_f.Delete( i ); // Czyści przeterminowane oznaczenia kolizji.

        end
      else//if Czas_Między_W_Sekundach( zti64 ) >= statek_kolizja_oznaczenie_ponowne_czas_c then
        if Pos( obiekt_nazwa_f, string_list_f[ i ] ) = 1 then
          begin

            // Kolizja z podanym obiektem jest już oznaczona i jest nieprzeterminowana.

            Result := true;
            Exit;

          end;
        //---//if Pos( obiekt_nazwa_f, string_list_f[ i ] ) = 1 then

    end;
  //---//for i := string_list_f.Count - 1 downto 0 do

end;//---//Funkcja Statki_Kolizja_Oznaczenie_Sprawdź().

//Funkcja Trafienia_Efekt_Czas_Trwania_Sprawdź().
procedure TStatki_Form.Trafienia_Efekt_Czas_Trwania_Sprawdź();
var
  i : integer;
begin

  if   ( trafienia_efekt_list = nil )
    or (  not Assigned( trafienia_efekt_list )  ) then
    Exit;


  for i := trafienia_efekt_list.Count - 1 downto 0 do
    begin

      if Czas_Między_W_Milisekundach( TTrafienia_Efekt(trafienia_efekt_list[ i ]).czas_utworzenia ) >= TTrafienia_Efekt(trafienia_efekt_list[ i ]).czas_trwania then
        Trafienia_Efekt_Zwolnij_Jeden( TTrafienia_Efekt(trafienia_efekt_list[ i ]) );

    end;
  //---//for i := trafienia_efekt_list.Count - 1 downto 0 do

end;//---//Funkcja Trafienia_Efekt_Czas_Trwania_Sprawdź().

//Funkcja Kamera_Odległość_Kontroluj_Ustaw().
procedure TStatki_Form.Kamera_Odległość_Kontroluj_Ustaw( delta_czasu_f : double );
var
  zt_vector : GLVectorGeometry.TVector;
begin

  //
  // Funkcja nie pozwala na odsunięcie kamery zbyt daleko od statku, amunicji.
  //
  // Parametry:
  //   delta_czasu_f.
  //


  // Komponent dokładnie nie pilnuje zakresów.
  if Kamera_Odległość_Maksymalna_SpinEdit.Value > Kamera_Odległość_Maksymalna_SpinEdit.MaxValue then
    Kamera_Odległość_Maksymalna_SpinEdit.Value := Kamera_Odległość_Maksymalna_SpinEdit.MaxValue;


  if    ( Kamera_Odległość_Maksymalna_SpinEdit.Value > 0 )
    and ( GLCamera1.Parent <> nil )
    and (
             ( GLCamera1.Parent is TStatek )
          or ( GLCamera1.Parent is TAmunicja )
        )
    and (  GLCamera1.DistanceTo( GLCamera1.Parent ) > Kamera_Odległość_Maksymalna_SpinEdit.Value  ) then
    begin

      //GLCamera1.Position.AddScaledVector
      //  (
      //      //-0.1
      //      -1 * delta_czasu_f
      //    , //NormalizeVector
      //      (
      //        GLVectorGeometry.VectorMake
      //          (
      //              GLCamera1.Position.X
      //            , GLCamera1.Position.Y
      //            , GLCamera1.Position.Z
      //          )
      //      )
      //  );


      zt_vector := GLVectorGeometry.VectorMake
        (
            GLCamera1.Position.X
          , GLCamera1.Position.Y
          , GLCamera1.Position.Z
        );


      NormalizeVector( zt_vector );


      GLCamera1.Position.AddScaledVector
        (
            //-0.1
            -5 * delta_czasu_f
          , zt_vector
        );

    end;
  //---//if    ( Kamera_Odległość_Maksymalna_SpinEdit.Value >= 0 ) (...)

end;//---//Funkcja Kamera_Odległość_Kontroluj_Ustaw().

//Funkcja Kamera_Przełącz().
procedure TStatki_Form.Kamera_Przełącz( const kamera_tryb_f : TKamera_Tryb );
var
  i : integer;
  zt_vector_1,
  zt_vector_2
    : GLVectorGeometry.TVector;
begin

  //
  // Funkcja zmienia punkt zaczepienia kamery.
  //
  // Parametry:
  //   kamera_tryb_f:
  //     true - ustawi kamerę na wystrzelonej amunicji.
  //     false - ustawi kamerę na statku lub swobodną.
  //


  //GLCamera1.ResetRotations(); // Jeżeli żaden warunek nie zostanie spełniony to niepotrzebnie resetuje ustawienie kamery.


  if    ( kamera_tryb_f = kt_Amunicja )
    and ( statek_gracza <> nil )
    and ( amunicja_wystrzelona_list <> nil )
    and ( amunicja_wystrzelona_list.Count > 0 ) then
    begin

      // Ustawia kamerę na amunicji.

      if GLCamera1.Tag <> integer(kt_Amunicja) then
        GLCamera1.ResetRotations();

      {$region 'kt_Amunicja.'}
      i := kamera_indeks_amunicji;

      if not czy_kamera_od_najnowszego_pocisku then
        begin

          // Od najstarszego.

          if i = amunicja_wystrzelona_list.Count - 1 then
            i := 0
          else//if i = amunicja_wystrzelona_list.Count - 1 then
            if i > amunicja_wystrzelona_list.Count - 1 then
              i := amunicja_wystrzelona_list.Count - 1;

        end
      else//if not czy_kamera_od_najnowszego_pocisku then
        begin

          // Od najnowszego.

          if i = 0 then
            i := amunicja_wystrzelona_list.Count - 1
          else//if i = amunicja_wystrzelona_list.Count - 1 then
            if i > amunicja_wystrzelona_list.Count - 1 then
              i := amunicja_wystrzelona_list.Count - 1;

        end;
      //---//if not czy_kamera_od_najnowszego_pocisku then

      //i := 0;


      if not ( GLCamera1.Parent is TAmunicja ) then
        begin

          GLCamera1.Position.SetPoint( 0, 1, 0 );
          GLCamera1.AbsoluteDirection := TAmunicja(GLCamera1.Parent).AbsoluteDirection;
          GLCamera1.ResetRotations();

        end;
      //---//if not ( GLCamera1.Parent is TAmunicja ) then


      // Przełącza na kolejną wystrzeloną amunicję.
      if not czy_kamera_od_najnowszego_pocisku then
        begin

          // Od najstarszego.

          while ( amunicja_wystrzelona_list.Count > i )
            and ( GLCamera1.Parent = amunicja_wystrzelona_list[ i ] )
            and ( statek_gracza.id_statek = TAmunicja(amunicja_wystrzelona_list[ i ]).id_statek ) do // Przełącza tylko na własnej amunicji gracza. //???
            inc( i );

        end
      else//if not czy_kamera_od_najnowszego_pocisku then
        begin

          // Od najnowszego.

          while ( amunicja_wystrzelona_list.Count > i )
            and ( i > 0 )
            and ( GLCamera1.Parent = amunicja_wystrzelona_list[ i ] )
            and ( statek_gracza.id_statek = TAmunicja(amunicja_wystrzelona_list[ i ]).id_statek ) do // Przełącza tylko na własnej amunicji gracza. //???
            dec( i );

        end;
      //---//if not czy_kamera_od_najnowszego_pocisku then


      // Ustawia kamerę na amunicji.
      if    ( amunicja_wystrzelona_list.Count > 0 )
        and ( i < amunicja_wystrzelona_list.Count )
        and ( i >= 0 )
        and ( statek_gracza.id_statek = TAmunicja(amunicja_wystrzelona_list[ i ]).id_statek ) then // Przełącza tylko na własnej amunicji gracza. //???
          begin

            GLCamera1.Parent := amunicja_wystrzelona_list[ i ];
            kamera_indeks_amunicji := i;

          end;
        //---//if    ( amunicja_wystrzelona_list.Count > 0 ) (...)
      {$endregion 'kt_Amunicja.'}


      if GLCamera1.Tag <> integer(kt_Amunicja) then
        GLCamera1.Tag := integer(kt_Amunicja);

    end
  else//if czy_na_pocisk then
  if    ( kamera_tryb_f = kt_Artyleria )
    and ( statek_gracza <> nil )
    and (  Length( statek_gracza.artyleria_t ) > 0  ) then
    begin

      // Ustawia kamerę do celowania artylerią (z góry).

      //zt_vector_1 := GLCamera1.AbsoluteDirection;
      zt_vector_1.Y := GLCamera1.Position.Y;

      if GLCamera1.Tag <> integer(kt_Artyleria) then
        begin

          GLCamera1.ResetRotations();

          //if GLUserInterface1.MouseLookActive then
          //  GLUserInterface1.MouseLookActive := false;

          GLCamera1.Parent := GLScene1.Objects;

          // Ustawia kamerę w kierunku od statku do celu.
          GLCamera1.Direction.SetVector
            (   // Cel                 Obiekt celujący
                statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector ).X - statek_gracza.AbsolutePosition.X
              , 0
              , statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Z - statek_gracza.AbsolutePosition.Z
            );

        end;
      //---//if GLCamera1.Tag <> integer(kt_Artyleria) then


      // Ustawia kamerę nad celem.
      if statek_gracza.DistanceTo(  statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector )  ) <= statek_gracza.artyleria_t[ 0 ].zasięg then
        GLCamera1.Position.AsAffineVector := statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector )
      else//if statek_gracza.DistanceTo(  statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector )  ) <= statek_gracza.artyleria_t[ 0 ].zasięg then
        begin

          // Jeżeli cel jest poza zasięgiem artylerii ustawi kamerę na granicy zasięgu w kierunku celu.

          GLCamera1.Position.AsVector := statek_gracza.AbsolutePosition;
          //GLCamera1.Position.AddScaledVector( statek_gracza.artyleria_t[ 0 ].zasięg, GLCamera1.AbsoluteDirection );

          GLCamera1.Position.AddScaledVector
            (
              statek_gracza.artyleria_t[ 0 ].zasięg,
              GLVectorGeometry.VectorNormalize
                (
                  // Ustawia kamerę w kierunku od statku do celu.
                  GLVectorGeometry.VectorMake
                    (   // Cel                 Obiekt celujący
                        statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector ).X - statek_gracza.AbsolutePosition.X
                      , 0
                      , statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Z - statek_gracza.AbsolutePosition.Z
                    )
                )
            );

        end;
      //---//if statek_gracza.DistanceTo(  statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector )  ) <= statek_gracza.artyleria_t[ 0 ].zasięg then


      if GLCamera1.Tag <> integer(kt_Artyleria) then
        begin

          // Ustawia wysokość kamery i obraca w dół.
          GLCamera1.Position.Y := 10;
          GLCamera1.PitchAngle := -90;

          GLCamera1.Tag := integer(kt_Artyleria);

        end
      else//if GLCamera1.Tag <> integer(kt_Artyleria) then
        GLCamera1.Position.Y := zt_vector_1.Y;

    end
  else//if    ( kamera_tryb_f = kt_Artyleria ) (...)
  if    (
             ( kamera_tryb_f = kt_Statek )
          or ( kamera_tryb_f = kt_Statek_Swobodna )
        )
    and ( statek_gracza <> nil ) then
    begin

      // Ustawia kamerę na statku.

      if GLCamera1.Tag <> integer(kt_Statek) then
        begin

          zt_vector_1 := GLCamera1.AbsoluteDirection;
          GLCamera1.ResetRotations();

        end;
      //---//if GLCamera1.Tag <> integer(kt_Statek) then


      GLCamera1.Parent := statek_gracza;

      //GLCamera1.Position.SetPoint( 0, 1, 0 );
      GLCamera1.Position.AsVector := Wieloosobowe__Wektor_4__Do__Vector( statek_gracza.kamera_na_statek_pozycja );


      if GLCamera1.Tag <> integer(kt_Statek) then
        begin

          ////GLCamera1.Up := statek_gracza.Up;
          //GLCamera1.Up.SetVector( 0, 1, 0 );
          //GLCamera1.AbsoluteDirection := statek_gracza.AbsoluteDirection;
          GLCamera1.AbsoluteDirection := zt_vector_1;

          GLCamera1.Tag := integer(kt_Statek);

        end;
      //---//if GLCamera1.Tag <> integer(kt_Statek) then

    end
  else//if     ( (...)
  if   ( kamera_tryb_f = kt_Swobodna )
    or (
             ( kamera_tryb_f = kt_Statek_Swobodna )
         and ( statek_gracza = nil )
       ) then
    begin

      // Ustawia kamerę swobodną.

      if GLCamera1.Tag <> integer(kt_Swobodna) then
        begin

          zt_vector_1 := GLCamera1.AbsoluteDirection;
          zt_vector_2 := GLCamera1.AbsolutePosition;
          //GLCamera1.ResetRotations();

        end;
      //---//if GLCamera1.Tag <> integer(kt_Swobodna) then


      GLCamera1.Parent := GLScene1.Objects;


      if GLCamera1.Tag <> integer(kt_Swobodna) then
        begin

          GLCamera1.AbsoluteDirection := zt_vector_1;
          GLCamera1.AbsolutePosition := zt_vector_2;
          GLCamera1.Tag := integer(kt_Swobodna);

        end;
      //---//if GLCamera1.Tag <> integer(kt_Swobodna) then

    end;
  //---//if   ( kamera_tryb_f = kt_Swobodna ) (...)
  if    ( kamera_tryb_f = kt_Za_Statkiem )
    and ( statek_gracza <> nil ) then
    begin

      // Ustawia kamerę za statkiem.

      GLCamera1.ResetRotations();

      //GLCamera1.Parent := GLScene1.Objects;
      GLCamera1.Parent := statek_gracza;

      GLCamera1.Position := statek_gracza.Position;
      //GLCamera1.Position.Y := 5;
      GLCamera1.Position.X := GLCamera1.Position.X + statek_gracza.kamera_za_statkiem_pozycja.X;
      GLCamera1.Position.Y := GLCamera1.Position.Y + statek_gracza.kamera_za_statkiem_pozycja.Y;
      GLCamera1.Position.Z := GLCamera1.Position.Z + statek_gracza.kamera_za_statkiem_pozycja.Z;

      GLCamera1.Up.SetVector( 0, 1, 0);
      //GLCamera1.Direction.SetVector( 0, 0, -1 );
      GLCamera1.AbsoluteDirection := statek_gracza.AbsoluteDirection;

      GLCamera1.Move( -5 );

      GLCamera1.Direction.SetVector
        (
            statek_gracza.Position.X - GLCamera1.Position.X
          , statek_gracza.Position.Y - GLCamera1.Position.Y
          , statek_gracza.Position.Z - GLCamera1.Position.Z
        );


      if GLCamera1.Tag <> integer(kt_Za_Statkiem) then
        GLCamera1.Tag := integer(kt_Za_Statkiem);

    end;
  //---//if    ( kamera_tryb_f = kt_Za_Statkiem ) (...)

end;//---//Funkcja Kamera_Przełącz().

//Funkcja Napis_Odśwież().
procedure TStatki_Form.Napis_Odśwież();
var
  i,
  j
    : integer;
  uzbrojenie,
  skręt_kierunek,
  skręt_kierunek_zadany
    : string;
  zt_statek : TStatek;
begin

  zt_statek := statek_gracza;

  if czy_pauza_g then
    Informacje_Główne_GLHUDText.Text := '          PAUZA' + #13#10 + #13#10
  else//if czy_pauza_g then
    Informacje_Główne_GLHUDText.Text := '';


  if zt_statek <> nil then
    begin

      {$region 'Opis skrętu.'}
      if zt_statek.skręt_procent < 0 then
        skręt_kierunek := '<'//'lewo'
      else
      if zt_statek.skręt_procent = 0 then
        skręt_kierunek := '|'//''
      else
      if zt_statek.skręt_procent > 0 then
        skręt_kierunek := '>';//'prawo'

      if zt_statek.skręt_zadany_procent < 0 then
        skręt_kierunek_zadany := '<'//'lewo'
      else
      if zt_statek.skręt_zadany_procent = 0 then
        skręt_kierunek_zadany := '|'//''
      else
      if zt_statek.skręt_zadany_procent > 0 then
        skręt_kierunek_zadany := '>';//'prawo'

      if Abs( zt_statek.skręt_zadany_procent ) > 50 then
        skręt_kierunek_zadany := skręt_kierunek_zadany + skręt_kierunek_zadany;
      {$endregion 'Opis skrętu.'}

      {$region 'Opis uzbrojenia.'}
      uzbrojenie := '';

      if Length( zt_statek.artyleria_t ) > 0 then
        begin

          if uzbrojenie <> '' then
            uzbrojenie := uzbrojenie + #13#10;

          if    ( not ar_Artyleria_CheckBox.Checked )
            and ( not ar_Wszystkie_CheckBox.Checked )then
            uzbrojenie := uzbrojenie + '---';

          uzbrojenie := uzbrojenie +
            ' artyleria:';

          for i := 0 to Length( zt_statek.artyleria_t ) - 1 do
            begin

              if i > 0 then
                uzbrojenie := uzbrojenie + ', ';

              for j := 0 to Length( zt_statek.artyleria_t[ i ].lufy_t ) - 1 do
                if zt_statek.artyleria_t[ i ].lufy_t[ j ].strzał_gotowość then
                  uzbrojenie := uzbrojenie + ' *'
                else//if zt_statek.artyleria_t[ i ].lufy_t[ j ].strzał_gotowość then
                  uzbrojenie := uzbrojenie + ' x';

              uzbrojenie := uzbrojenie +
                ' ' + Trim(  FormatFloat( '### ### ##0', i + 1 )  ) + ' - ' + Trim(  FormatFloat( '### ### ##0', zt_statek.artyleria_t[ i ].amunicja_ilość )  );

            end;
          //---//for i := 0 to Length( Self.artyleria_t ) - 1 do


        end;
      //---//if Length( zt_statek.artyleria_t ) > 0 then

      if Length( zt_statek.działa_t ) > 0 then
        begin

          if uzbrojenie <> '' then
            uzbrojenie := uzbrojenie + #13#10;

          if    ( not ar_Pocisk_CheckBox.Checked )
            and ( not ar_Wszystkie_CheckBox.Checked )then
            uzbrojenie := uzbrojenie + '---';

          uzbrojenie := uzbrojenie +
            ' działa:';

          for i := 0 to Length( zt_statek.działa_t ) - 1 do
            begin

              if i > 0 then
                uzbrojenie := uzbrojenie + ', ';

              for j := 0 to Length( zt_statek.działa_t[ i ].lufy_t ) - 1 do
                if zt_statek.działa_t[ i ].lufy_t[ j ].strzał_gotowość then
                  uzbrojenie := uzbrojenie + ' *'
                else//if zt_statek.działa_t[ i ].lufy_t[ j ].strzał_gotowość then
                  uzbrojenie := uzbrojenie + ' x';

              uzbrojenie := uzbrojenie +
                ' ' + Trim(  FormatFloat( '### ### ##0', i + 1 )  ) + ' - ' + Trim(  FormatFloat( '### ### ##0', zt_statek.działa_t[ i ].amunicja_ilość )  );

            end;
          //---//for i := 0 to Length( Self.działa_t ) - 1 do


        end;
      //---//if Length( zt_statek.działa_t ) > 0 then

      if Length( zt_statek.torpedy_wyrzutnie_t ) > 0 then
        begin

          if uzbrojenie <> '' then
            uzbrojenie := uzbrojenie + #13#10;

          if    ( not ar_Torpeda_CheckBox.Checked )
            and ( not ar_Wszystkie_CheckBox.Checked )then
            uzbrojenie := uzbrojenie + '---';

          uzbrojenie := uzbrojenie +
            ' torpedy:';

          for i := 0 to Length( zt_statek.torpedy_wyrzutnie_t ) - 1 do
            begin

              if i > 0 then
                uzbrojenie := uzbrojenie + ', ';

              for j := 0 to Length( zt_statek.torpedy_wyrzutnie_t[ i ].lufy_t ) - 1 do
                if zt_statek.torpedy_wyrzutnie_t[ i ].lufy_t[ j ].strzał_gotowość then
                  uzbrojenie := uzbrojenie + ' *'
                else//if zt_statek.torpedy_wyrzutnie_t[ i ].lufy_t[ j ].strzał_gotowość then
                  uzbrojenie := uzbrojenie + ' x';

              uzbrojenie := uzbrojenie +
                ' ' + Trim(  FormatFloat( '### ### ##0', i + 1 )  ) + ' - ' + Trim(  FormatFloat( '### ### ##0', zt_statek.torpedy_wyrzutnie_t[ i ].amunicja_ilość )  );


            end;
          //---//for i := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do


        end;
      //---//if Length( zt_statek.torpedy_wyrzutnie_t ) > 0 then
      {$endregion 'Opis uzbrojenia.'}


      Informacje_Główne_GLHUDText.Text := Informacje_Główne_GLHUDText.Text +
        ' życie: ' + Trim(  FormatFloat( '### ### ##0', zt_statek.punkty_życia )  ) + ' (' + Trim(  FormatFloat( '### ### ##0', zt_statek.punkty_życia_procent_zostało )  ) + '%)' + #13#10 +
        ' prędkość %: ' + Trim(  FormatFloat( '### ### ##0', zt_statek.prędkość_zadana_procent )  ) + ' (' + Trim(  FormatFloat( '### ### ##0', zt_statek.prędkość_procent )  ) + ')' +  #13#10 +
        ' ster %: ' + skręt_kierunek_zadany + ' ' + Trim(   FormatFloat(  '### ### ##0', Abs( zt_statek.skręt_zadany_procent )  )   ) + ' (' +  skręt_kierunek + ' ' + Trim(   FormatFloat(  '### ### ##0', Abs( zt_statek.skręt_procent )  )   ) + ')' + #13#10 +
        ' lf ';


      if zt_statek.podnoś_lufy then
        Informacje_Główne_GLHUDText.Text := Informacje_Główne_GLHUDText.Text +
          'v'
      else//if zt_statek.podnoś_lufy then
        Informacje_Główne_GLHUDText.Text := Informacje_Główne_GLHUDText.Text +
          'x';


      Informacje_Główne_GLHUDText.Text := Informacje_Główne_GLHUDText.Text +
        ' obr ' ;

      if zt_statek.obracaj_działa then
        Informacje_Główne_GLHUDText.Text := Informacje_Główne_GLHUDText.Text +
          'v'
      else//if zt_statek.obracaj_działa then
        Informacje_Główne_GLHUDText.Text := Informacje_Główne_GLHUDText.Text +
          'x';


      Informacje_Główne_GLHUDText.Text := Informacje_Główne_GLHUDText.Text +
        ' ind ' ;

      if zt_statek.broń_indeks_zmieniaj then
        Informacje_Główne_GLHUDText.Text := Informacje_Główne_GLHUDText.Text +
          'v'
      else//if zt_statek.broń_indeks_zmieniaj then
        Informacje_Główne_GLHUDText.Text := Informacje_Główne_GLHUDText.Text +
          'x';


      Informacje_Główne_GLHUDText.Text := Informacje_Główne_GLHUDText.Text +
        #13#10 +
        uzbrojenie;

      if Dalmierz_CheckBox.Checked then
        Informacje_Główne_GLHUDText.Text := Informacje_Główne_GLHUDText.Text +
          #13#10 + 'dalmierz: ' + Trim(   FormatFloat(  '### ### ##0.000', GLCamera1.DistanceTo( Celowniczy_GLDummyCube.AbsolutePosition )  )   ) + '.';


      Informacje_Główne_GLHUDText.Text := Informacje_Główne_GLHUDText.Text +
           #13#10 +
//        'punkty życia ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.punkty_życia )  ) + #13#10 +
//        'punkty życia 1 ' + Trim(  FormatFloat( '### ### ##0.000000', statki_t[ 1 ].punkty_życia )  ) + #13#10 +
//        'prędkość procent ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.prędkość_procent )  ) + #13#10 +
//        'prędkość aktualna ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.prędkość_aktualna )  ) + ' z ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.prędkość_maksymalna )  ) + #13#10 +
//        'prędkość aktualna % ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.prędkość_aktualna * 100 / zt_statek.prędkość_maksymalna )  ) + #13#10 +
//        '  przyspieszanie ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.prędkość_przyspieszanie )  ) + #13#10 +
//        '  zadany procent ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.prędkość_zadana_procent )  ) + #13#10 +
//        '  zwalnianie ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.prędkość_zwalnianie )  ) + #13#10 +
//        '  zwalnianie kolizja ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.prędkość__kolizja_zwalnianie )  ) + #13#10 +
//        #13#10 +
//        'kąt skrętu aktualny ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.TurnAngle )  ) + #13#10 +
//        'kąt skrętu aktualny 1 ' + Trim(  FormatFloat( '### ### ##0.000000', statki_t[ 1 ].TurnAngle )  ) + #13#10 +
//        'skręt procent ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.skręt_procent )  ) + ' ' + skręt_kierunek + #13#10 +
//        '  szybkość wychylania steru ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.skręt_szybkość_wychylania_steru )  ) + #13#10 +
//        '  śruba 0 prędkość obrotowa aktualna procent ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.śruby_t[ 0 ].prędkość_obrotowa_aktualna_procent )  ) + #13#10 +
//        '  zadany ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.skręt_zadany_procent )  ) + #13#10;

//        'przeładowanie_wskaźnik__pozycja_rozładowany.Z ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.działa_t[ 0 ].lufy_t[ 0 ].przeładowanie_wskaźnik__pozycja_rozładowany.Z )  ) + #13#10 +
//        'przeładowanie_wskaźnik__pozycja_załadowany.Z ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.działa_t[ 0 ].lufy_t[ 0 ].przeładowanie_wskaźnik__pozycja_załadowany.Z )  ) + #13#10 +
//        'przeładowanie_wskaźnik.Position.Z ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.działa_t[ 0 ].lufy_t[ 0 ].przeładowanie_wskaźnik.Position.Z )  ) + #13#10 +        
//        'przeładowanie_wskaźnik__dystans_do_przesunięcia ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.działa_t[ 0 ].lufy_t[ 0 ].przeładowanie_wskaźnik__dystans_do_przesunięcia )  ) + #13#10 +        
                
//        #13#10 +
//        'obrót ' + #13#10 +
//        '  obrót_kąt_zadany ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.torpedy_wyrzutnie_t[ 0 ].obrót_kąt_zadany )  ) + #13#10 +
//        '  obrót_kąt_zadany bezwzględny ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.torpedy_wyrzutnie_t[ 0 ].obrót_kąt_zadany_bezwzględny )  ) + #13#10 +
//        '  TurnAngle ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.torpedy_wyrzutnie_t[ 0 ].TurnAngle )  ) + #13#10 +
//        '  spr ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.torpedy_wyrzutnie_t[ 0 ].TurnAngle - zt_statek.torpedy_wyrzutnie_t[ 0 ].obrót_kąt_zadany )  ) + #13#10 +
//        '  X ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.torpedy_wyrzutnie_t[ 0 ].obrót_kierunek_zadany.X )  ) + #13#10 +
//        '  Z ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.torpedy_wyrzutnie_t[ 0 ].obrót_kierunek_zadany.Z )  ) + #13#10 +
//        '  podniesienie_kąt_zadany ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.działa_t[ 0 ].podniesienie_kąt_zadany )  ) + #13#10 +
//        '  PitchAngle ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.działa_t[ 0 ].lufy_t[ 0 ].PitchAngle )  ) + #13#10 +


//        'kamera kierunek ' + #13#10 +
//        '  x ' + Trim(  FormatFloat( '### ### ##0.000000', GLCamera1.Direction.X )  ) + #13#10 +
//        '  y ' + Trim(  FormatFloat( '### ### ##0.000000', GLCamera1.Direction.Y )  ) + #13#10 +
//        '  z ' + Trim(  FormatFloat( '### ### ##0.000000', GLCamera1.Direction.Z )  ) + #13#10 +
//        'kamera kierunek absolutny' + #13#10 +
//        '  x ' + Trim(  FormatFloat( '### ### ##0.000000', GLCamera1.AbsoluteDirection.X )  ) + #13#10 +
//        '  y ' + Trim(  FormatFloat( '### ### ##0.000000', GLCamera1.AbsoluteDirection.Y )  ) + #13#10 +
//        '  z ' + Trim(  FormatFloat( '### ### ##0.000000', GLCamera1.AbsoluteDirection.Z )  ) + #13#10 +
//        '  u ' + Trim(  FormatFloat( '### ### ##0.000000', GLCamera1.Up.Y )  ) + #13#10 +
//        'kamera pozycja ' + #13#10 +
//        '  x ' + Trim(  FormatFloat( '### ### ##0.000000', GLCamera1.Position.X )  ) + #13#10 +
//        '  y ' + Trim(  FormatFloat( '### ### ##0.000000', GLCamera1.Position.Y )  ) + #13#10 +
//        '  z ' + Trim(  FormatFloat( '### ### ##0.000000', GLCamera1.Position.Z )  ) + #13#10 +
//        'kamera rodzic pozycja' + #13#10 +
//        '  x ' + Trim(  FormatFloat( '### ### ##0.000000', GLCamera1.Parent.Position.X )  ) + #13#10 +
//        '  y ' + Trim(  FormatFloat( '### ### ##0.000000', GLCamera1.Parent.Position.Y )  ) + #13#10 +
//        '  z ' + Trim(  FormatFloat( '### ### ##0.000000', GLCamera1.Parent.Position.Z )  ) + #13#10 +

//        'statek kierunek ' + #13#10 +
//        '  x ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.Direction.X )  ) + #13#10 +
//        '  y ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.Direction.Y )  ) + #13#10 +
//        '  z ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.Direction.Z )  ) + #13#10 +
//        'statek kierunek absolutny' + #13#10 +
//        '  x ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.AbsoluteDirection.X )  ) + #13#10 +
//        '  y ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.AbsoluteDirection.Y )  ) + #13#10 +
//        '  z ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.AbsoluteDirection.Z )  ) + #13#10 +

//        'mysz' + #13#10 +
//        '  mx ' + Trim(  FormatFloat( '### ### ##0.000000', Mouse.CursorPos.X )  ) + #13#10 +
//        '  my ' + Trim(  FormatFloat( '### ### ##0.000000', Mouse.CursorPos.Y )  ) + #13#10 +
//        '  x ' + Trim(  FormatFloat( '### ### ##0.000000', GLSceneViewer1.Buffer.PixelRayToWorld( Mouse.CursorPos.X, Mouse.CursorPos.Y ).X )  ) + #13#10 +
//        '  y ' + Trim(  FormatFloat( '### ### ##0.000000', GLSceneViewer1.Buffer.PixelRayToWorld( Mouse.CursorPos.X, Mouse.CursorPos.Y ).Y )  ) + #13#10 +
//        '  z ' + Trim(  FormatFloat( '### ### ##0.000000', GLSceneViewer1.Buffer.PixelRayToWorld( Mouse.CursorPos.X, Mouse.CursorPos.Y ).Z )  ) + #13#10;
//        '  x ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.celownicza_linia.Nodes[ 1 ].X )  ) + #13#10 +
//        '  y ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.celownicza_linia.Nodes[ 1 ].Y )  ) + #13#10 +
//        '  z ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.celownicza_linia.Nodes[ 1 ].Z )  ) + #13#10 +

//        '  1 ' + BoolToStr( statek_gracza.torpedy_wyrzutnie_t[ 0 ].lufy_t[ 0 ].czy_indeks_do_strzału_lufa ) + #13#10 +
//        '  2 ' + BoolToStr( statek_gracza.torpedy_wyrzutnie_t[ 0 ].lufy_t[ 1 ].czy_indeks_do_strzału_lufa ) + #13#10 +
//        '  3 ' + BoolToStr( statek_gracza.torpedy_wyrzutnie_t[ 0 ].lufy_t[ 2 ].czy_indeks_do_strzału_lufa ) + #13#10 +

//        '  lufy_t[ 0 ].Position.Z ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.artyleria_t[ 0 ].lufy_t[ 0 ].Position.Z )  ) + #13#10 +
//        '  PitchAngle ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.działa_t[ 0 ].lufy_t[ 0 ].PitchAngle )  ) + #13#10 +
//        '  x ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.działa_wygląd_t[ 0 ].AbsoluteDirection.X )  ) + #13#10 +
//        '  y ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.działa_t[ 0 ].AbsoluteDirection.Y )  ) + #13#10 +
//        '  y ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.działa_wygląd_t[ 0 ].AbsoluteDirection.Y )  ) + #13#10 +
//        '  z ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.działa_t[ 0 ].AbsoluteDirection.Z )  ) + #13#10 +
//        '  z ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.działa_wygląd_t[ 0 ].AbsoluteDirection.Z )  ) + #13#10 +

//        '  statek_gracza.radar_id_statki_w_zasięgu ' + statek_gracza.radar_id_statki_w_zasięgu + #13#10 +
//        '  statek_gracza.radio_id_statki_w_zasięgu ' + statek_gracza.radio_id_statki_w_zasięgu + #13#10 +
//        '  GLCamera1.FocalLength ' + Trim(  FormatFloat( '### ### ##0', GLCamera1.FocalLength ) ) + #13#10 +
//        '  GLUserInterface1.MouseSpeed ' + Trim(  FormatFloat( '### ### ##0.000000', GLUserInterface1.MouseSpeed ) ) + #13#10 +

//        '  statek_gracza.celownicza_linia.Nodes[ 1 ].X ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.celownicza_linia.Nodes[ 1 ].X ) ) + #13#10 +
//        '  statek_gracza.celownicza_linia.Nodes[ 1 ].Y ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.celownicza_linia.Nodes[ 1 ].Y ) ) + #13#10 +
//        '  statek_gracza.celownicza_linia.Nodes[ 1 ].Z ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.celownicza_linia.Nodes[ 1 ].Z ) ) + #13#10 +
//
//        '  statek_gracza.celownicza_linia.Nodes[ 1 ].X loc to abs ' + Trim(   FormatFloat(  '### ### ##0.000000', statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector ).X  )  ) + #13#10 +
//        '  statek_gracza.celownicza_linia.Nodes[ 1 ].Y loc to abs ' + Trim(   FormatFloat(  '### ### ##0.000000', statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Y  )  ) + #13#10 +
//        '  statek_gracza.celownicza_linia.Nodes[ 1 ].Z loc to abs ' + Trim(   FormatFloat(  '### ### ##0.000000', statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Z  )  ) + #13#10 +

//          '  amunicja_wystrzelona_list długość ' + Trim(  FormatFloat( '### ### ##0', amunicja_wystrzelona_list.Count ) ) + #13#10 +
//          '  wieloosobowe__amunicja_t długość ' + Trim(   FormatFloat(  '### ### ##0', Length( wieloosobowe__amunicja_t )  )  ) + #13#10 +
//          '  statki_t ' + Trim(   FormatFloat(  '### ### ##0', Length( statki_t )  )  ) + #13#10 +
          '';

//      if GLCamera1.Parent <> nil then
//        Informacje_Główne_GLHUDText.Text := Informacje_Główne_GLHUDText.Text +
//          '  kamera ' + Trim(   FormatFloat(  '### ### ##0.000000', GLCamera1.DistanceTo( GLCamera1.Parent )  )   );

      if Length( statki_t ) > 1 then
        begin

//          Informacje_Główne_GLHUDText.Text := Informacje_Główne_GLHUDText.Text +
//            'st' + #13#10 +
//            '  x ' + Trim(  FormatFloat( '### ### ##0.000000', statki_t[ 1 ].działa_t[ 0 ].obrót_kąt_zadany )  ) + #13#10 +
//            '  x ' + Trim(  FormatFloat( '### ### ##0.000000', statki_t[ 1 ].działa_t[ 0 ].podniesienie_kąt_zadany )  ) + #13#10 +
//            '  x ' + Trim(  FormatFloat( '### ### ##0.000000', statki_t[ 1 ].celownicza_linia.Nodes[ 1 ].X )  ) + #13#10 +
//            '  y ' + Trim(  FormatFloat( '### ### ##0.000000', statki_t[ 1 ].celownicza_linia.Nodes[ 1 ].Y )  ) + #13#10 +
//            '  z ' + Trim(  FormatFloat( '### ### ##0.000000', statki_t[ 1 ].celownicza_linia.Nodes[ 1 ].Z )  ) + #13#10 +
//            '';

        end;
      //--//

      if amunicja_wystrzelona_list.Count > 0 then
        begin

          Informacje_Główne_GLHUDText.Text := Informacje_Główne_GLHUDText.Text +
//            'a0' + #13#10 +
//            '  prędkość ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).prędkość )  ) + #13#10 +
//            '  prędkość_początkowa ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).prędkość_początkowa )  ) + #13#10 +
//            '  statek prędkość ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).statek_prędkość )  ) + #13#10 +
//            '  odległość pozycja startowa ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).DistanceTo( TAmunicja(amunicja_wystrzelona_list[ 0 ]).pozycja_startowa ) )  ) + #13#10 +
//            '  p a ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.PitchAngle )  ) + #13#10 +
//            '  t a ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.TurnAngle )  ) + #13#10 +
//            '  r a ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.RollAngle )  ) + #13#10 +
//            '  opad korekta kąt ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).opadanie_obrót_korekta_o_ustawienie_początkowe )  ) + #13#10 +
//            '  opad korekta kąt z ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).opadanie_obrót_korekta_o_kąt_na_granicy_zasięgu )  ) + #13#10 +
//            '  aDx ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).AbsoluteDirection.X )  ) + #13#10 +
//            '  aDy ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).AbsoluteDirection.Y )  ) + #13#10 +
//            '  aDz ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).AbsoluteDirection.Z )  ) + #13#10 +
//            '  aRx ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.Up.DirectX )  ) + #13#10 +
//            '  aRy ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.Up.DirectY )  ) + #13#10 +
//            '  aRz ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.Up.DirectZ )  ) + #13#10 +
//            '  aUx ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_ustawienie_początkowe_dummy.AbsoluteUp.X )  ) + #13#10 +
//            '  aUy ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_ustawienie_początkowe_dummy.AbsoluteUp.Y )  ) + #13#10 +
//            '  aUz ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_ustawienie_początkowe_dummy.AbsoluteUp.Z )  ) + #13#10 +
//            '  aPx ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).AbsolutePosition.X )  ) + #13#10 +
//            '  aPy ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).AbsolutePosition.Y )  ) + #13#10 +
//            '  aPz ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).AbsolutePosition.Z )  ) + #13#10 +
//            '  korpus_opadanie_obrót_dummy aPy ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.AbsolutePosition.Y )  ) + #13#10 +
            //'  g ' + Trim(  FormatFloat( '### ### ##0.000000', -TAmunicja(amunicja_wystrzelona_list[ 0 ]).zanurzenie_głębokość_po_wpadnięciu_do_wody )  ) + #13#10 +
//            '  prędkość_opadania ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).prędkość_opadania )  ) + #13#10 +
//            '  prędkość_opadania_współczynnik ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).prędkość_opadania_współczynnik )  ) + #13#10 +
//            '  zasięg ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).zasięg )  ) + #13#10 +
//
//            '  aDx ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.AbsoluteDirection.X )  ) + #13#10 +
//            '  aDy ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.AbsoluteDirection.Y )  ) + #13#10 +
//            '  aDz ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.AbsoluteDirection.Z )  ) + #13#10 +
//            '  PitchAngle ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.PitchAngle )  ) + #13#10 +
//            '  Tag ' + Trim(  FormatFloat( '### ### ##0', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.Tag )  ) + #13#10 +
//            '  TagFloat ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.TagFloat )  ) + #13#10 +

            '';

        end;
      //---//

//      if Length( wieloosobowe__amunicja_t ) > 0 then
//        begin
//
//          Informacje_Główne_GLHUDText.Text := Informacje_Główne_GLHUDText.Text +
//            'wieloosobowe__amunicja_t' + #13#10 +
////            '  czy_torpeda_efekt_na_wodzie ' + BoolToStr( wieloosobowe__amunicja_t[ 0 ].czy_torpeda_efekt_na_wodzie ) + #13#10 +
//            '';
//
//        end;
      //---//

//      if amunicja_wystrzelona_list.Count > 1 then
//        begin
//
//          Informacje_Główne_GLHUDText.Text := Informacje_Główne_GLHUDText.Text +
//            'a1' + #13#10 +
//            '  y ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 1 ]).korpus_opadanie_obrót_dummy.AbsolutePosition.Y )  ) + #13#10 +
//            '  g ' + Trim(  FormatFloat( '### ### ##0.000000', -TAmunicja(amunicja_wystrzelona_list[ 1 ]).zanurzenie_głębokość_po_wpadnięciu_do_wody )  ) + #13#10;
//            '';
//
//        end;
//      //---//
//
//      if amunicja_wystrzelona_list.Count > 2 then
//        begin
//
//          Informacje_Główne_GLHUDText.Text := Informacje_Główne_GLHUDText.Text +
//            'a2' + #13#10 +
//            '  y ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 2 ]).korpus_opadanie_obrót_dummy.AbsolutePosition.Y )  ) + #13#10 +
//            '  g ' + Trim(  FormatFloat( '### ### ##0.000000', -TAmunicja(amunicja_wystrzelona_list[ 2 ]).zanurzenie_głębokość_po_wpadnięciu_do_wody )  ) + #13#10;
//
//        end;
//      //---//
//
//      if amunicja_wystrzelona_list.Count > 3 then
//        begin
//
//          Informacje_Główne_GLHUDText.Text := Informacje_Główne_GLHUDText.Text +
//            'a3' + #13#10 +
//            '  y ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 3 ]).korpus_opadanie_obrót_dummy.AbsolutePosition.Y )  ) + #13#10 +
//            '  g ' + Trim(  FormatFloat( '### ### ##0.000000', -TAmunicja(amunicja_wystrzelona_list[ 3 ]).zanurzenie_głębokość_po_wpadnięciu_do_wody )  ) + #13#10;
//
//        end;
//      //---//

//      if amunicja_wystrzelona_list.Count > 0 then
//        begin
//          Informacje_Główne_GLHUDText.Text := Informacje_Główne_GLHUDText.Text +
//            'a1' + #13#10 +
//            //'  pro ' + Trim(  FormatFloat( '### ### ##0.000000', -TAmunicja(amunicja_wystrzelona_list[ 0 ]).prędkość )  ) + #13#10 +
//            //'  Y ' + Trim(  FormatFloat( '### ### ##0.000000', -TAmunicja(amunicja_wystrzelona_list[ 0 ]).prędkość_opadania * 10 * ( 1 - TAmunicja(amunicja_wystrzelona_list[ 0 ]).obrażenia_zadawane_współczynnik_zmodyfikowany ) )  ) + #13#10 +
//            //'  1 - woz ' + Trim(  FormatFloat( '### ### ##0.000000', 1 - TAmunicja(amunicja_wystrzelona_list[ 0 ]).obrażenia_zadawane_współczynnik_zmodyfikowany )  ) + #13#10 +
//            '  obrażenia_zadawane_współczynnik ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).obrażenia_zadawane_współczynnik )  ) + #13#10 +
//            '  obrażenia_zadawane_współczynnik_zmodyfikowany ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).obrażenia_zadawane_współczynnik_zmodyfikowany )  ) + #13#10;
//
//        end;
//      //---//

//      if Length( statek_gracza.torpedy_wyrzutnie_t ) > 1 then
//        begin
//          Informacje_Główne_GLHUDText.Text := Informacje_Główne_GLHUDText.Text +
//            'tw' + #13#10 +
////            '  torpedy_wyrzutnia_ostatni_strzał_indeks ' + Trim(  FormatFloat( '### ### ##0', statek_gracza.torpedy_wyrzutnia_ostatni_strzał_indeks )  ) + #13#10 +
////            '  statek_gracza.torpedy_wyrzutnie_t[ 0 ].czy_indeks_do_strzału ' + BoolToStr( statek_gracza.torpedy_wyrzutnie_t[ 0 ].czy_indeks_do_strzału ) + #13#10 +
////            '  statek_gracza.torpedy_wyrzutnie_t[ 1 ].czy_indeks_do_strzału ' + BoolToStr( statek_gracza.torpedy_wyrzutnie_t[ 1 ].czy_indeks_do_strzału ) + #13#10 +
////            '  statek_gracza.torpedy_wyrzutnie_t[ 2 ].czy_indeks_do_strzału ' + BoolToStr( statek_gracza.torpedy_wyrzutnie_t[ 2 ].czy_indeks_do_strzału ) + #13#10 +
////            '  statek_gracza.torpedy_wyrzutnie_t[ 0 ].celownik_linia.Visible ' + BoolToStr( statek_gracza.torpedy_wyrzutnie_t[ 0 ].celownik_linia.Visible ) + #13#10 +
////            '  statek_gracza.torpedy_wyrzutnie_t[ 0 ].celownik_linia_bez_falowania ' + BoolToStr( statek_gracza.torpedy_wyrzutnie_t[ 0 ].celownik_linia_bez_falowania.Visible ) + #13#10 +
//            '';
//
//        end;
//      //---//

//GLSceneViewer1.Buffer.PixelRayToWorld( Mouse.CursorPos.X, Mouse.CursorPos.Y ).;



      //???
      //Statki_Form.Caption := FloatToStr( GLCamera1.Direction.X ) + ' ' + FloatToStr( GLCamera1.Direction.Y ) + ' ' + FloatToStr( GLCamera1.Direction.Z );
      //Statki_Form.Caption := FloatToStr( GLCamera1.TurnAngle ) + ' ' + FloatToStr( GLCamera1.PitchAngle ) + ' ' + FloatToStr( GLCamera1.RollAngle );

    end;
  //---//if zt_statek <> nil then


  // Oznacza kiedy nie ma skupienia na 'ekranie' gry.
  //if GLSceneViewer1.Focused then
  if GLSceneViewer1.Tag = 1 then
    Informacje_Główne_GLHUDText.ModulateColor.Color :=  clrWhite
  else//if GLSceneViewer1.Tag <> 0 then
    Informacje_Główne_GLHUDText.ModulateColor.Color := clrGray85;


  Informacje_Dodatkowe_GLHUDText.Position.X := GLSceneViewer1.Width; // Prawy dół.
  Informacje_Dodatkowe_GLHUDText.Position.Y := GLSceneViewer1.Height;


  GLWindowsBitmapFont1.EnsureString( Informacje_Główne_GLHUDText.Text );
  GLWindowsBitmapFont1.EnsureString( Informacje_Dodatkowe_GLHUDText.Text );

end;//---//Funkcja Napis_Odśwież().

//Funkcja Celownicza_Kula_Zmień_Pozycję().
procedure TStatki_Form.Celownicza_Kula_Zmień_Pozycję();
var
  ztr,
  ztr1
    : real;
  mysz_pozycja : TPoint;
  zt_vektor : TAffineVector;
begin

  if statek_gracza = nil then
    Exit;


  mysz_pozycja := Mouse.CursorPos;
  mysz_pozycja := ScreenToClient( mysz_pozycja );
  //Statki_Form.Caption := FloatToStr( mysz_pozycja.X ) + ' ' + FloatToStr( mysz_pozycja.Y ) + ' ' + FloatToStr( 0 ) + ' ' + FloatToStr( 0 );


  zt_vektor := GLSceneViewer1.Buffer.PixelRayToWorld( mysz_pozycja.X, mysz_pozycja.Y );
  //zt_vektor := GLSceneViewer1.Buffer.ScreenToWorld( mysz_pozycja.X, mysz_pozycja.Y );
  //Statki_Form.Caption := FloatToStr( zt_vektor.X ) + ' ' + FloatToStr( zt_vektor.Y ) + ' ' + FloatToStr( zt_vektor.Z );


  //Celownicza_GLSphere.Position.AsAffineVector := zt_vektor;


  //GLLines3.Nodes[ 1 ].AsAffineVector := zt_vektor;//Celownicza_GLSphere.Position.AsAffineVector;

  //zt_vektor := GLScene1.Objects.LocalToAbsolute( zt_vektor );

//  GLLines3.Nodes[ 1 ].X := -zt_vektor.X;
//  GLLines3.Nodes[ 1 ].Y := zt_vektor.Y;
//  GLLines3.Nodes[ 1 ].Z := -zt_vektor.Z;

  //statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector := zt_vektor;
  statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector := statek_gracza.celownicza_linia.AbsoluteToLocal( zt_vektor );

  //???
  //if statek_gracza.celownicza_linia.Nodes[ 1 ].Y < 0 then // Chyba nie jest bardzo ważne, płaszczyzna wydaje się poprawnie wykrywana.
  //  statek_gracza.celownicza_linia.Nodes[ 1 ].Y := 0;


  Celowniczy_GLDummyCube.Position.AsAffineVector := zt_vektor;


//  Celowniczy_GLDummyCube.Position.SetPoint( -6.6, 0.25, 0 ); //???
//  statek_gracza.celownicza_linia.Nodes[ 1 ].X := Celowniczy_GLDummyCube.Position.X; //???
//  statek_gracza.celownicza_linia.Nodes[ 1 ].Y := Celowniczy_GLDummyCube.Position.Y; //???
//  statek_gracza.celownicza_linia.Nodes[ 1 ].Z := Celowniczy_GLDummyCube.Position.Z; //???

//  Celowniczy_GLDummyCube.Position.X := zt_vektor.X;
//  Celowniczy_GLDummyCube.Position.Y := zt_vektor.Y;
//  Celowniczy_GLDummyCube.Position.Z := zt_vektor.Z;


//  Celownicza_GLSphere.Position.X := zt_vektor.X;
//  Celownicza_GLSphere.Position.Y := zt_vektor.Y;
//  Celownicza_GLSphere.Position.Z := zt_vektor.Z;


  //Celownicza_GLSphere.Position.SetPoint(  statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector )  );
  //Celownicza_GLSphere.Position.SetPoint( GLScene1.Objects.LocalToAbsolute(GLLines3.Nodes[ 1 ].AsAffineVector) );
  //Celownicza_GLSphere.Position.SetPoint(  GLSceneViewer1.Buffer.ScreenToWorld( mysz_pozycja.X, mysz_pozycja.Y )  );
  //Celownicza_GLSphere.Position.SetPoint(  GLSceneViewer1.Buffer.ScreenToVector( mysz_pozycja.X, mysz_pozycja.Y )  );
  //Statki_Form.mo
  ztr := GLSceneViewer1.Buffer.GetPixelDepth( mysz_pozycja.X, mysz_pozycja.Y );
  ztr1 := GLSceneViewer1.Buffer.PixelDepthToDistance( ztr ); // Odległość od kamery do wskazanego (myszą) punktu.

  //ztr := statek_gracza.celownicza_linia.DistanceTo( statek_gracza.celownicza_linia.Nodes[ 1 ].AsVector );
  ztr := statek_gracza.DistanceTo( statek_gracza.celownicza_linia.Nodes[ 1 ].AsVector ); // Odległość od statku do wskazanego (myszą) punktu.

  //ztr := TGLBaseSceneObject(statek_gracza.celownicza_linia.Nodes[ 0 ]).DistanceTo( statek_gracza.celownicza_linia.Nodes[ 1 ].AsVector );

  //Celownicza_GLSphere.Position.Z := -ztr1;

  //Statki_Form.Caption := FloatToStr( ztr ) + ' ' + FloatToStr( ztr1 ) + ' ' + FloatToStr( mysz_pozycja.X ) + ' ' + FloatToStr( mysz_pozycja.Y );
  //Statki_Form.Caption := FloatToStr( ztr );
  //Statki_Form.Caption := FloatToStr( ztr1 ) + ' ' + FloatToStr( ztr );

  //Celownicza_GLSphere.Position.SetPoint(  GLSceneViewer1.Buffer.ScreenToVector( Mouse.CursorPos.X, Mouse.CursorPos.Y )  );
  //Celownicza_GLSphere.Position.SetPoint(  GLSceneViewer1.Buffer.PixelRayToWorld( Mouse.CursorPos.X, Mouse.CursorPos.Y )  );

//          GLCamera1.Direction.SetVector
//            (
//                zt_statek.Position.X - GLCamera1.Position.X
//              , zt_statek.Position.Y - GLCamera1.Position.Y
//              , zt_statek.Position.Z - GLCamera1.Position.Z
//            );


  //statek_gracza.GLArrowLine1.Direction.SetVector(  NormalizeVector( statek_gracza.celownicza_linia.Nodes[ 1 ].AsVector )  );
  //statek_gracza.GLArrowLine1.Direction.SetVector( statek_gracza.celownicza_linia.Nodes[ 1 ].AsVector );
  //zt_vektor.Y := 0;
//  NormalizeVector( zt_vektor );
//  statek_gracza.GLArrowLine1.Direction.SetVector( zt_vektor );
//  statek_gracza.GLArrowLine1.Direction.AsVector := GLVectorGeometry.VectorNegate( statek_gracza.GLArrowLine1.Direction.AsVector );

//  statek_gracza.GLArrowLine1.Direction.SetVector
//    (   // Cel                 Obiekt celujący
//        -(statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector ).X - statek_gracza.GLArrowLine1.AbsolutePosition.X)
//      , statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Y - statek_gracza.GLArrowLine1.AbsolutePosition.Y
//      , -(statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Z - statek_gracza.GLArrowLine1.AbsolutePosition.Z)
//    );

//  statek_gracza.GLArrowLine1.Direction.SetVector
//    (   // Cel                 Obiekt celujący
//        -(statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector.X - statek_gracza.GLArrowLine1.Position.X)
//      , statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector.Y - statek_gracza.GLArrowLine1.Position.Y
//      , -(statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector.Z - statek_gracza.GLArrowLine1.Position.Z)
//    );

  //NegateVector( statek_gracza.GLArrowLine1.Direction.AsVector );

end;//---//Funkcja Celownicza_Kula_Zmień_Pozycję().

//Funkcja Pauza().
procedure TStatki_Form.Pauza( const czy_pauza_f : boolean );
begin

  //
  // Funkcja ustawia pauzę.
  //
  // Parametry:
  //   czy_zwolnić:
  //     true - włącza pauzę.
  //     false - wyłącza pauzę.
  //

  czy_pauza_g := czy_pauza_f;


  Czas_Bezwzględny_Timer.Enabled := not czy_pauza_g;
  GLCadencer1.Enabled := not czy_pauza_g;
  Radar_Timer.Enabled := not czy_pauza_g;

  if czy_pauza_g then
    begin

      //mouse_look_active_przed_pauzą := GLUserInterface1.MouseLookActive;
      //GLUserInterface1.MouseLookActive := false;
      Napis_Odśwież();

    end;
  //else//if czy_pauza_g then
    //GLUserInterface1.MouseLookActive := mouse_look_active_przed_pauzą;

end;//---//Funkcja Pauza().

//Funkcja Elementy_Gry_Przygotuj().
procedure TStatki_Form.Elementy_Gry_Przygotuj();
var
  i : integer;
begin

  //
  // Funkcja przygotowuje elementy potrzebne dla gry.
  //

  czas_bezwzględny_g := 0;
  id_amunicja_g := Low( cardinal );

  if not czy_klient_g then // Klient otrzyma wytyczne tworzenia statków osobno.
    begin

        for i := 0 to tcp_klienci_lista_g.klienci_lista_list.Count - 1 do
          begin

            SetLength( statki_t, i + 1 );
            statki_t[ i ] := TStatek.Create(  Gra_Obiekty_GLDummyCube, Statki_Form.GLCollisionManager1, i, Statek_Odczytaj_Schemat( TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).id_statek_schemat ), prymitywy_lista_t  );
            statki_t[ i ].id_grupa := TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).id_grupa;
            statki_t[ i ].id_statek := TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator;
            statki_t[ i ].id_statek_schemat := TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).id_statek_schemat;
            statki_t[ i ].gracz__nazwa.Text := TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).nazwa;

            // Ustawi współrzędne celu poza statkiem.
            statki_t[ i ].celownicza_linia.Nodes[ 1 ].X := 0;
            statki_t[ i ].celownicza_linia.Nodes[ 1 ].Y := 5;
            statki_t[ i ].celownicza_linia.Nodes[ 1 ].Z := -15;


            // Gdy gracz nie jest gotowy to ma id_grupa = 0 i przy rozstawianiu statków indeks jest poza zakresem tabeli gra_pozycja_początkowa_parametry_t.
            //if    ( statki_t[ i ].id_grupa <> 1 )
            //  and ( statki_t[ i ].id_grupa <> 2 ) then
            //   statki_t[ i ].id_grupa := 1;


            if TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator = Gracz_Identyfikator() then
              begin

                statek_gracza := statki_t[ i ];

                // Pozycja kamery na statek. //???

                statek_gracza.Elementy_Gracza_Dostosuj( -99, Punkty_Życia_Wskaźnik__Gracz_CheckBox.Checked, false, false, Obrót_Kąt_Zablokowany_Wskaźnik_CheckBox.Checked, Obrót_Kąt_Zablokowany_Strzał_Wskaźnik_CheckBox.Checked );

                Interfejs_Parametry_Według_Statku_Ustaw();

                Radar_Odwróć_CheckBox.Checked := statek_gracza.id_grupa = 2;

              end
            else//if TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator = Gracz_Identyfikator() then
              begin

                statki_t[ i ].Elementy_Gracza_Widoczność( Gracz_Grupa_SpinEdit.Value, false );
                statki_t[ i ].Elementy_Gracza_Dostosuj( Gracz_Grupa_SpinEdit.Value, false, Punkty_Życia_Wskaźnik__Przeciwnik_CheckBox.Checked, Punkty_Życia_Wskaźnik__Sojusznik_CheckBox.Checked, false, false );

              end;
            //---//if TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator = Gracz_Identyfikator() then

          end;
        //---//for i := 0 to tcp_klienci_lista_g.klienci_lista_list.Count - 1 do


        Ląd_Utwórz( Ląd_ComboBox.ItemIndex ); // Wczytuje pozycje początkowe statków.


        Statki_Rozstaw( nil );

    end;
  //---//if not czy_klient_g then


  Czas_Bezwzględny_Timer.Enabled := true;

  if    ( not czy_klient_g )
    and ( statek_gracza = nil ) then
    Application.MessageBox( 'Nie udało się zlokalizować statku gracza.', 'Informacja', MB_ICONEXCLAMATION );

end;//---//Funkcja Elementy_Gry_Przygotuj().

//Funkcja Elementy_Gry_Zwolnij().
procedure TStatki_Form.Elementy_Gry_Zwolnij();
var
  i : integer;
begin

  //
  // Funkcja zwalnia utworzone elementy gry.
  //

  Amunicja_Wystrzelona_Zwolnij_Wszystkie();


  for i := wieloosobowe_amunicja_wystrzelona_list.Count - 1 downto 0 do
    begin

      //TAmunicja(wieloosobowe_amunicja_wystrzelona_list[ i ]).Free(); //???
      TGLCylinder(wieloosobowe_amunicja_wystrzelona_list[ i ]).Free();
      wieloosobowe_amunicja_wystrzelona_list.Delete( i );

    end;
  //---//for i := wieloosobowe_amunicja_wystrzelona_list.Count - 1 downto 0 do


  Ląd_Zwolnij();

  Trafienia_Efekt_Zwolnij_Wszystkie();

  
  Statki_Zwolnij();

  
  Wieloosobowe_Statki_Rekord_Czyść();

  SetLength( wieloosobowe__amunicja_t, 0 );
  SetLength( wieloosobowe__efekt_t, 0 );


  ar_Artyleria_CheckBox.Enabled := true;
  ar_Pocisk_CheckBox.Enabled := true;
  ar_Torpeda_CheckBox.Enabled := true;

  ar_Artyleria_CheckBox.Tag := integer(ar_Artyleria_CheckBox.Checked);
  ar_Pocisk_CheckBox.Tag := integer(ar_Pocisk_CheckBox.Checked);
  ar_Torpeda_CheckBox.Tag := integer(ar_Torpeda_CheckBox.Checked);
  //ar_Wszystkie_CheckBox.Tag := integer(ar_Wszystkie_CheckBox.Checked);

  ar_Artyleria_CheckBox.Checked := false;
  ar_Pocisk_CheckBox.Checked := false;
  ar_Torpeda_CheckBox.Checked := false;

  //ar_Wszystkie_CheckBox.Checked := true;

end;//---//Funkcja Elementy_Gry_Zwolnij().

//Funkcja Statek_Przywróć_Do_Gry().
procedure TStatki_Form.Statek_Przywróć_Do_Gry( const id_statek_f : integer );
var
  i : integer;
begin

  //
  // Funkcja wyszukuje po id statek, który należy przywrócić do gry i wywołuje funkcje przywracania statku do gry.
  //

  for i := 0 to Length( statki_t ) - 1 do
    if statki_t[ i ].id_statek = id_statek_f then
      begin

        Statek_Przywróć_Do_Gry( statki_t[ i ] );

        Break;

      end;
    //---//if statek_f = statki_t[ i ] then

end;//---//Funkcja Statek_Przywróć_Do_Gry().

//Funkcja Statek_Przywróć_Do_Gry().
procedure TStatki_Form.Statek_Przywróć_Do_Gry( const statek_f : TStatek );
var
  i,
  j,
  id_grupa_l,
  id_statek_l,
  id_statek_schemat_l
    : integer;
  czy_statek_gracza_l : boolean;
  gracz__nazwa_l : string;
begin

  //
  // Funkcja zwalnia i tworzy na nowo statek.
  //


  // Pojawia się błąd access violation nie wiadomo gdzie. //???

  id_statek_l := -99;


  for i := 0 to Length( statki_t ) - 1 do
    if statek_f = statki_t[ i ] then
      begin

        id_grupa_l := statki_t[ i ].id_grupa;
        id_statek_l := statki_t[ i ].id_statek;
        id_statek_schemat_l := statki_t[ i ].id_statek_schemat;
        gracz__nazwa_l := statki_t[ i ].gracz__nazwa.Text;

        if statek_gracza = statki_t[ i ] then
          begin

            czy_statek_gracza_l := true;
            statek_gracza := nil; // Nie zmienia statki_t[ 0 ].

          end
        else//if statek_gracza = statki_t[ i ] then
          czy_statek_gracza_l := false;


        for j := trafienia_efekt_list.Count - 1 downto 0 do
          begin

            // Zwalnia efekty umieszczone na statku.
            // Jeżeli efekty umieszczone na statku nadal są na scenie pojawiają się błędy dostępu.

            if   ( TTrafienia_Efekt(trafienia_efekt_list[ j ]).Owner = statki_t[ i ] )
              or ( TTrafienia_Efekt(trafienia_efekt_list[ j ]).Parent = statki_t[ i ] ) then
              Trafienia_Efekt_Zwolnij_Jeden( TTrafienia_Efekt(trafienia_efekt_list[ j ]) );

          end;
        //---//for j := trafienia_efekt_list.Count - 1 downto 0 do


        if GLCamera1.Parent = statki_t[ i ] then
          Kamera_Przełącz( kt_Statek_Swobodna );


        FreeAndNil( statki_t[ i ] );


        statki_t[ i ] := TStatek.Create(  Gra_Obiekty_GLDummyCube, Statki_Form.GLCollisionManager1, i, Statek_Odczytaj_Schemat( id_statek_schemat_l ), prymitywy_lista_t  );
        statki_t[ i ].id_grupa := id_grupa_l;
        statki_t[ i ].id_statek := id_statek_l;
        statki_t[ i ].id_statek_schemat := id_statek_schemat_l;
        statki_t[ i ].gracz__nazwa.Text := gracz__nazwa_l;


        if czy_statek_gracza_l then
          begin

            statek_gracza := statki_t[ i ];

            statek_gracza.Elementy_Gracza_Dostosuj( -99, Punkty_Życia_Wskaźnik__Gracz_CheckBox.Checked, false, false, Obrót_Kąt_Zablokowany_Wskaźnik_CheckBox.Checked, Obrót_Kąt_Zablokowany_Strzał_Wskaźnik_CheckBox.Checked );

            if not ( GLCamera1.Parent is TStatek ) then
              Kamera_Przełącz( kt_Statek ); // Ustawi kamerę na statku gracza.

          end
        else//if czy_statek_gracza_l then
          begin

            statki_t[ i ].Elementy_Gracza_Widoczność( Gracz_Grupa_SpinEdit.Value, false );
            statki_t[ i ].Elementy_Gracza_Dostosuj( Gracz_Grupa_SpinEdit.Value, false, Punkty_Życia_Wskaźnik__Przeciwnik_CheckBox.Checked, Punkty_Życia_Wskaźnik__Sojusznik_CheckBox.Checked, false, false );

          end;
        //---//if czy_statek_gracza_l then


        if czy_klient_g then
          statki_t[ i ].Visible := false; // Po przywróceniu statku do gry klient umieszcza go na wyliczonej samodzielnie pozycji i dopiero po odebraniu danych o pozycji z serwera zaktualizuje pozycję statku i ustawi na widoczny.


        Break;

      end;
    //---//if statek_f = statki_t[ i ] then


  if id_statek_l = -99 then
    begin

      Application.MessageBox( 'Nie udało się zlokalizować statku do przywrócenia.', 'Informacja', MB_ICONEXCLAMATION );
      Exit;

    end;
  //---//if id_statek_l = -99 then


  if    ( i >= 0 )
    and (  i <= Length( statki_t ) - 1  ) then
    Statki_Rozstaw( statki_t[ i ] );


  if czy_serwer_g then
    begin

      wieloosobowe__statek_przywróć_do_gry__id_statek_g := id_statek_l;
      Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__statek__przywróć_do_gry_c, -99, '' );

    end;
  //---//if czy_serwer_g then

end;//---//Funkcja Statek_Przywróć_Do_Gry().

//Funkcja Statki_Rozstaw().
procedure TStatki_Form.Statki_Rozstaw( const statek_f : TStatek );
var
  i,
  j,
  id_grupa_l,
  pozycja_ustawienie_ilość_prób,
  statki_kolejność_w_grupie_l,
  statki_ilość_w_grupie_l
    : integer;
  ztr : single;
  koniec_grup_l : boolean;
begin

  //
  // Funkcja ustawia początkową pozycję statków (tworzy formację).
  //
  // Parametry:
  //   statek_f:
  //     nil - rozstawia wszystkie statki.
  //     nie nil - rozstawia wskazany statek.
  //


  koniec_grup_l := false; // Aby uruchomić pierwszy przebieg pętli.
  id_grupa_l := -1;


  if statek_f = nil then
    begin

      if Statki_Pozycje_Początkowe_ComboBox.ItemIndex >= 0 then
        begin

          gra_pozycja_początkowa_parametry_t[ 1 ] := statki_pozycja_początkowa_parametry_t[ 1 ];
          gra_pozycja_początkowa_parametry_t[ 2 ] := statki_pozycja_początkowa_parametry_t[ 2 ];

        end
      else//if Statki_Pozycje_Początkowe_ComboBox.ItemIndex >= 0 then
        begin

          gra_pozycja_początkowa_parametry_t[ 1 ] := ląd_pozycja_początkowa_parametry_t[ 1 ];
          gra_pozycja_początkowa_parametry_t[ 2 ] := ląd_pozycja_początkowa_parametry_t[ 2 ];

        end;
      //---//if Statki_Pozycje_Początkowe_ComboBox.ItemIndex >= 0 then

    end;
  //---//if statek_f = nil then


  while not koniec_grup_l do
    begin

      // Pętla dla wszystkich grup.


      koniec_grup_l := true;


      if statek_f = nil then
        begin

          if id_grupa_l <= -1 then
            begin

              // Wyszuka najmniejsze id_grupa.

              for i := 0 to Length( statki_t ) - 1 do
                if   ( id_grupa_l <= -1 )
                  or ( statki_t[ i ].id_grupa < id_grupa_l ) then
                  begin

                    id_grupa_l := statki_t[ i ].id_grupa;

                    if koniec_grup_l then
                      koniec_grup_l := false;

                  end;
                //---//if statki_t[ i ].id_grupa > id_grupa_l then

            end
          else//if id_grupa_l <= -1 then
            begin

              // Wyszuka kolejne id_grupa.

              for i := 0 to Length( statki_t ) - 1 do
                if statki_t[ i ].id_grupa > id_grupa_l then
                  begin

                    koniec_grup_l := false;
                    id_grupa_l := statki_t[ i ].id_grupa;
                    Break;

                  end;
                //---//if statki_t[ i ].id_grupa > id_grupa_l then

            end;
          //---//if id_grupa_l <= -1 then


          if   ( id_grupa_l <= -1 )
            or ( koniec_grup_l ) then
            Exit; // Nie ma więcej grup.

        end
      else//if statek_f = nil then
        begin

          id_grupa_l := statek_f.id_grupa;

        end;
      //---//if statek_f = nil then


      statki_ilość_w_grupie_l := 0;

      for i := 0 to Length( statki_t ) - 1 do
        if statki_t[ i ].id_grupa = id_grupa_l then
          inc( statki_ilość_w_grupie_l );


      // Gdy gracz nie jest gotowy to ma id_grupa = 0 i przy rozstawianiu statków indeks jest poza zakresem tabeli gra_pozycja_początkowa_parametry_t.
      if    ( id_grupa_l <> 1 )
        and ( id_grupa_l <> 2 ) then
         id_grupa_l := 1;


      // Obsługuje tylko 2 grupy.
      statki_kolejność_w_grupie_l := 0;

      for i := 0 to Length( statki_t ) - 1 do
        if    ( statki_t[ i ].id_grupa = id_grupa_l )
          and (
                   ( statek_f = nil )
                or (
                         ( statek_f <> nil )
                     and ( statki_t[ i ].id_statek = statek_f.id_statek )
                   )
              ) then
          begin

            if statek_f = nil then
              inc( statki_kolejność_w_grupie_l )
            else//if statek_f = nil then
              statki_kolejność_w_grupie_l := Random( statki_ilość_w_grupie_l ) + 1;


            //statki_t[ i ].Position.X := gra_pozycja_początkowa_parametry_t[ id_grupa_l ].odstęp_x * ( statki_kolejność_w_grupie_l - 1 );
            statki_t[ i ].Position.X :=
                gra_pozycja_początkowa_parametry_t[ id_grupa_l ].odstęp_x * ( statki_kolejność_w_grupie_l - 1 )
              - (  gra_pozycja_początkowa_parametry_t[ id_grupa_l ].odstęp_x * ( statki_ilość_w_grupie_l - 1 ) * 0.5  )
              + gra_pozycja_początkowa_parametry_t[ id_grupa_l ].korekta_x;

            if id_grupa_l = 1 then
              begin

                statki_t[ i ].Position.Z :=
                    gra_pozycja_początkowa_parametry_t[ id_grupa_l ].z
                  + gra_pozycja_początkowa_parametry_t[ id_grupa_l ].korekta_z * ( statki_kolejność_w_grupie_l - 1 );
                statki_t[ i ].TurnAngle := gra_pozycja_początkowa_parametry_t[ id_grupa_l ].korekta_obrót;

              end
            else//if id_grupa_l = 1 then
              begin

                statki_t[ i ].Position.Z :=
                    gra_pozycja_początkowa_parametry_t[ id_grupa_l ].z
                  + gra_pozycja_początkowa_parametry_t[ id_grupa_l ].korekta_z * ( statki_kolejność_w_grupie_l - 1 );
                statki_t[ i ].TurnAngle := gra_pozycja_początkowa_parametry_t[ id_grupa_l ].korekta_obrót;

              end;
            //---//if id_grupa_l = 1 then


            {$region 'Sprawdza odległość do najbliższego statku i lądu.'}
            ztr := 9999999;
            pozycja_ustawienie_ilość_prób := 0;

            while ( ztr = 9999999 )
              and ( pozycja_ustawienie_ilość_prób < 100 ) do
              begin

                inc( pozycja_ustawienie_ilość_prób );

                statki_t[ i ].statki_rozstawianie_status := srs_Rozstawianie_Kolizja_Sprawdź;


                for j := 0 to Length( statki_t ) - 1 do
                  if statki_t[ j ].id_statek <> statki_t[ i ].id_statek then
                    if ztr > statki_t[ i ].DistanceTo( statki_t[ j ] ) then
                      ztr := statki_t[ i ].DistanceTo( statki_t[ j ] );


                if ztr >= gra_pozycja_początkowa_parametry_t[ id_grupa_l ].odstęp_x then
                  if   ( ląd_list <> nil )
                    and (  Assigned( ląd_list )  ) then
                    for j := 0 to ląd_list.Count - 1 do
                      if ztr > statki_t[ i ].DistanceTo( TGLCustomSceneObject(ląd_list[ j ]) ) then
                        ztr := statki_t[ i ].DistanceTo( TGLCustomSceneObject(ląd_list[ j ]) );


                if ztr >= gra_pozycja_początkowa_parametry_t[ id_grupa_l ].odstęp_x then
                  GLCollisionManager1.CheckCollisions(); // Uwzględnia wielkość obiektów lądu i statków.


                if   ( ztr < gra_pozycja_początkowa_parametry_t[ id_grupa_l ].odstęp_x )
                  or ( statki_t[ i ].statki_rozstawianie_status = srs_Rozstawianie_Kolizja_Wykryta ) then
                  begin

                    ztr := 9999999;
                    statki_t[ i ].Position.X := statki_t[ i ].Position.X + 1;

                    if gra_pozycja_początkowa_parametry_t[ id_grupa_l ].z >= 0 then
                      statki_t[ i ].Position.Z := statki_t[ i ].Position.Z + 1
                    else//if gra_pozycja_początkowa_parametry_t[ id_grupa_l ].z >= 0 then
                      statki_t[ i ].Position.Z := statki_t[ i ].Position.Z - 1;

                  end;
                //---//if ztr < gra_pozycja_początkowa_parametry_t[ id_grupa_l ].odstęp_x then

              end;
            //---//while ( ztr = 9999999 ) (...)


            if statki_t[ i ].statki_rozstawianie_status <> srs_Brak then
              statki_t[ i ].statki_rozstawianie_status := srs_Brak;
            {$endregion 'Sprawdza odległość do najbliższego statku i lądu.'}


            if statek_f <> nil then
              Break;

          end;
        //---//if    ( statki_t[ i ].id_grupa = id_grupa_l ) (...)


      if statek_f <> nil then
        Exit;

    end;
  //---//while not koniec_grup_l do

end;//---//Funkcja Statki_Rozstaw().

//Funkcja Ustawienia_Plik().
procedure TStatki_Form.Ustawienia_Plik( const zapisuj_ustawienia_f : boolean = false );
var
  plik_ini : TIniFile; // uses IniFiles.
  zti : integer;
  ztf : real;
  zts : string;
begin//Funkcja Ustawienia_Plik().
//??? sprawdzic wszystkie pozycje
  //
  // Funkcja wczytuje i zapisuje ustawienia.
  //
  // Parametry:
  //   zapisuj_ustawienia_f:
  //     false - tylko odczytuje ustawienia.
  //     true - zapisuje ustawienia.
  //

  zts := ExtractFilePath( Application.ExeName ) + 'Statki.ini';

  plik_ini := TIniFile.Create( zts );


  {$region 'KLAWIATURA_KONFIGURACJA.'}
  zti := Klawiatura_Konfiguracja__Konfiguracja_Numer_SpinEdit.Value;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'KLAWIATURA_KONFIGURACJA', 'klawiatura_konfiguracja__konfiguracja_numer' )  ) then
    plik_ini.WriteInteger( 'KLAWIATURA_KONFIGURACJA', 'klawiatura_konfiguracja__konfiguracja_numer', zti )
  else
    zti := plik_ini.ReadInteger( 'KLAWIATURA_KONFIGURACJA', 'klawiatura_konfiguracja__konfiguracja_numer', zti ); // Jeżeli nie znajdzie to podstawia wartość zti.

  Klawiatura_Konfiguracja__Konfiguracja_Numer_SpinEdit.Value := zti;


  if Klawiatura_Konfiguracja__Rozmiar_Zakładki_Poszerz_CheckBox.Checked then
    zts := 'tak'
  else//if Klawiatura_Konfiguracja__Rozmiar_Zakładki_Poszerz_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'KLAWIATURA_KONFIGURACJA', 'klawiatura_konfiguracja__rozmiar_zakładki_poszerz' )  ) then
    plik_ini.WriteString( 'KLAWIATURA_KONFIGURACJA', 'klawiatura_konfiguracja__rozmiar_zakładki_poszerz', zts )
  else
    zts := plik_ini.ReadString( 'KLAWIATURA_KONFIGURACJA', 'klawiatura_konfiguracja__rozmiar_zakładki_poszerz', zts ); // Jeżeli nie znajdzie to podstawia wartość zts.

  Klawiatura_Konfiguracja__Rozmiar_Zakładki_Poszerz_CheckBox.Checked := zts = 'tak';
  {$endregion 'KLAWIATURA_KONFIGURACJA.'}

  {$region 'POZOSTAŁE.'}
  zti := Statki_Zaprezentuj__Pozycja_Początkowa__X_SpinEdit.Value;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'POZOSTAŁE', 'statki_zaprezentuj__pozycja_początkowa__x' )  ) then
    plik_ini.WriteInteger( 'POZOSTAŁE', 'statki_zaprezentuj__pozycja_początkowa__x', zti )
  else
    zti := plik_ini.ReadInteger( 'POZOSTAŁE', 'statki_zaprezentuj__pozycja_początkowa__x', zti ); // Jeżeli nie znajdzie to podstawia wartość zti.

  Statki_Zaprezentuj__Pozycja_Początkowa__X_SpinEdit.Value := zti;


  zti := Statki_Zaprezentuj__Pozycja_Początkowa__Y_SpinEdit.Value;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'POZOSTAŁE', 'statki_zaprezentuj__pozycja_początkowa__y' )  ) then
    plik_ini.WriteInteger( 'POZOSTAŁE', 'statki_zaprezentuj__pozycja_początkowa__y', zti )
  else
    zti := plik_ini.ReadInteger( 'POZOSTAŁE', 'statki_zaprezentuj__pozycja_początkowa__y', zti ); // Jeżeli nie znajdzie to podstawia wartość zti.

  Statki_Zaprezentuj__Pozycja_Początkowa__Y_SpinEdit.Value := zti;


  zti := Statki_Zaprezentuj__Pozycja_Początkowa__Z_SpinEdit.Value;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'POZOSTAŁE', 'statki_zaprezentuj__pozycja_początkowa__z' )  ) then
    plik_ini.WriteInteger( 'POZOSTAŁE', 'statki_zaprezentuj__pozycja_początkowa__z', zti )
  else
    zti := plik_ini.ReadInteger( 'POZOSTAŁE', 'statki_zaprezentuj__pozycja_początkowa__z', zti ); // Jeżeli nie znajdzie to podstawia wartość zti.

  Statki_Zaprezentuj__Pozycja_Początkowa__Z_SpinEdit.Value := zti;


  zti := Statki_Zaprezentuj__Odstępy_Między_Statkami_SpinEdit.Value;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'POZOSTAŁE', 'statki_zaprezentuj__odstępy_między_statkami' )  ) then
    plik_ini.WriteInteger( 'POZOSTAŁE', 'statki_zaprezentuj__odstępy_między_statkami', zti )
  else
    zti := plik_ini.ReadInteger( 'POZOSTAŁE', 'statki_zaprezentuj__odstępy_między_statkami', zti ); // Jeżeli nie znajdzie to podstawia wartość zti.

  Statki_Zaprezentuj__Odstępy_Między_Statkami_SpinEdit.Value := zti;


  if Statki_Zaprezentuj__Kolumna_CheckBox.Checked then
    zts := 'tak'
  else//if Statki_Zaprezentuj__Kolumna_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'POZOSTAŁE', 'statki_zaprezentuj__kolumna' )  ) then
    plik_ini.WriteString( 'POZOSTAŁE', 'statki_zaprezentuj__kolumna', zts )
  else
    zts := plik_ini.ReadString( 'POZOSTAŁE', 'statki_zaprezentuj__kolumna', zts ); // Jeżeli nie znajdzie to podstawia wartość zts.

  Statki_Zaprezentuj__Kolumna_CheckBox.Checked := zts = 'tak';
  {$endregion 'POZOSTAŁE.'}

  {$region 'PREFERENCJE.'}
  zti := 1;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'PREFERENCJE', 'gracz_grupa' )  ) then
    plik_ini.WriteInteger( 'PREFERENCJE', 'gracz_grupa', zti )
  else
    zti := plik_ini.ReadInteger( 'PREFERENCJE', 'gracz_grupa', zti ); // Jeżeli nie znajdzie to podstawia wartość zti.

  Gracz_Grupa_SpinEdit.Value := zti;


  zts := Gracz_Nazwa_Edit.Text;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'WIELOOSOBOWE', 'gracz_nazwa' )  ) then
    plik_ini.WriteString( 'WIELOOSOBOWE', 'gracz_nazwa', zts )
  else
    zts := plik_ini.ReadString( 'WIELOOSOBOWE', 'gracz_nazwa', zts ); // Jeżeli nie znajdzie to podstawia wartość zts.

  Gracz_Nazwa_Edit.Text := zts;


  //if kamera_obrót_myszą_g then
  //  zts := 'tak'
  //else//if kamera_obrót_myszą_g then
  //  zts := 'nie';
  //
  //if   (  zapisuj_ustawienia_f )
  //  or (  not plik_ini.ValueExists( 'PREFERENCJE', 'kamera_obrót_myszą' )  ) then
  //  plik_ini.WriteString( 'PREFERENCJE', 'kamera_obrót_myszą', zts )
  //else
  //  zts := plik_ini.ReadString( 'PREFERENCJE', 'kamera_obrót_myszą', zts ); // Jeżeli nie znajdzie to podstawia wartość zts.
  //
  //kamera_obrót_myszą_g := zts = 'tak';


  zti := Ląd_ComboBox.ItemIndex;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'PREFERENCJE', 'ląd' )  ) then
    plik_ini.WriteInteger( 'PREFERENCJE', 'ląd', zti )
  else
    zti := plik_ini.ReadInteger( 'PREFERENCJE', 'ląd', zti ); // Jeżeli nie znajdzie to podstawia wartość zti.

  Ląd_ComboBox.ItemIndex := zti; // Nie wywoła Ląd_ComboBoxChange().


  if Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked then
    zts := 'tak'
  else//if Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'PREFERENCJE', 'ląd__komunikat_błędu_pomiń' )  ) then
    plik_ini.WriteString( 'PREFERENCJE', 'ląd__komunikat_błędu_pomiń', zts )
  else
    zts := plik_ini.ReadString( 'PREFERENCJE', 'ląd__komunikat_błędu_pomiń', zts ); // Jeżeli nie znajdzie to podstawia wartość zts.

  Ląd__Komunikat_Błędu_Pomiń_CheckBox.Checked := zts = 'tak';


  if Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked then
    zts := 'tak'
  else//if Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'PREFERENCJE', 'statek__komunikat_błędu_pomiń' )  ) then
    plik_ini.WriteString( 'PREFERENCJE', 'statek__komunikat_błędu_pomiń', zts )
  else
    zts := plik_ini.ReadString( 'PREFERENCJE', 'statek__komunikat_błędu_pomiń', zts ); // Jeżeli nie znajdzie to podstawia wartość zts.

  Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked := zts = 'tak';


  zti := Statek_ComboBox.ItemIndex;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'PREFERENCJE', 'statek' )  ) then
    plik_ini.WriteInteger( 'PREFERENCJE', 'statek', zti )
  else
    zti := plik_ini.ReadInteger( 'PREFERENCJE', 'statek', zti ); // Jeżeli nie znajdzie to podstawia wartość zti.

  Statek_ComboBox.ItemIndex := zti; // Nie wywoła Statek_ComboBoxChange().


  zti := Statki_Pozycje_Początkowe_ComboBox.ItemIndex;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'PREFERENCJE', 'statki_pozycje_początkowe' )  ) then
    plik_ini.WriteInteger( 'PREFERENCJE', 'statki_pozycje_początkowe', zti )
  else
    zti := plik_ini.ReadInteger( 'PREFERENCJE', 'statki_pozycje_początkowe', zti ); // Jeżeli nie znajdzie to podstawia wartość zti.

  Statki_Pozycje_Początkowe_ComboBox.ItemIndex := zti; // Nie wywoła Statki_Pozycje_Początkowe_ComboBoxChange().
  {$endregion 'PREFERENCJE.'}

  {$region 'USTAWIENIA.'}
  if Amunicja__Cel_Pozycja_Dla_Lotu_Parabolą_Wyświetl_CheckBox.Checked then
    zts := 'tak'
  else//if Amunicja__Cel_Pozycja_Dla_Lotu_Parabolą_Wyświetl_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'amunicja__cel_pozycja_dla_lotu_parabolą_wyświetl' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'amunicja__cel_pozycja_dla_lotu_parabolą_wyświetl', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'amunicja__cel_pozycja_dla_lotu_parabolą_wyświetl', zts ); // Jeżeli nie znajdzie to podstawia wartość zts.

  Amunicja__Cel_Pozycja_Dla_Lotu_Parabolą_Wyświetl_CheckBox.Checked := zts = 'tak';


  zti := Celowanie_Tryb_RadioGroup.ItemIndex;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'celowanie_tryb' )  ) then
    plik_ini.WriteInteger( 'USTAWIENIA', 'celowanie_tryb', zti )
  else
    zti := plik_ini.ReadInteger( 'USTAWIENIA', 'celowanie_tryb', zti ); // Jeżeli nie znajdzie to podstawia wartość zti.

  Celowanie_Tryb_RadioGroup.ItemIndex := zti;


  zti := Celowanie_Precyzja_Obrót_SpinEdit.Value;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'celowanie_precyzja_obrót' )  ) then
    plik_ini.WriteInteger( 'USTAWIENIA', 'celowanie_precyzja_obrót', zti )
  else
    zti := plik_ini.ReadInteger( 'USTAWIENIA', 'celowanie_precyzja_obrót', zti ); // Jeżeli nie znajdzie to podstawia wartość zti.

  Celowanie_Precyzja_Obrót_SpinEdit.Value := zti;


  zti := Celowanie_Precyzja_Podniesienie_SpinEdit.Value;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'celowanie_precyzja_podniesienie' )  ) then
    plik_ini.WriteInteger( 'USTAWIENIA', 'celowanie_precyzja_podniesienie', zti )
  else
    zti := plik_ini.ReadInteger( 'USTAWIENIA', 'celowanie_precyzja_podniesienie', zti ); // Jeżeli nie znajdzie to podstawia wartość zti.

  Celowanie_Precyzja_Podniesienie_SpinEdit.Value := zti;


  if Celownik_Widoczność_CheckBox.Checked then
    zts := 'tak'
  else//if Celownik_Widoczność_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'celownik_widoczność' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'celownik_widoczność', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'celownik_widoczność', zts ); // Jeżeli nie znajdzie to podstawia wartość zts.

  Celownik_Widoczność_CheckBox.Checked := zts = 'tak';


  if Celownik_Widoczność_Mouse_Look_Active_CheckBox.Checked then
    zts := 'tak'
  else//if Celownik_Widoczność_Mouse_Look_Active_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'celownik_widoczność_mouse_look_active' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'celownik_widoczność_mouse_look_active', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'celownik_widoczność_mouse_look_active', zts ); // Jeżeli nie znajdzie to podstawia wartość zts.

  Celownik_Widoczność_Mouse_Look_Active_CheckBox.Checked := zts = 'tak';


  ztf := Odczytaj_Liczbę_Z_Napisu( Celownik_Wielkość_Edit.Text, 0.01 );

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'celownik_wielkość' )  ) then
    plik_ini.WriteFloat( 'USTAWIENIA', 'celownik_wielkość', ztf )
  else
    ztf := plik_ini.ReadFloat( 'USTAWIENIA', 'celownik_wielkość', ztf ); // Jeżeli nie znajdzie to podstawia wartość zti.

  Celownik_Wielkość_Edit.Text := FloatToStr( ztf );


  if Dalmierz_CheckBox.Checked then
    zts := 'tak'
  else//if Dalmierz_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'dalmierz' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'dalmierz', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'dalmierz', zts ); // Jeżeli nie znajdzie to podstawia wartość zts.

  Dalmierz_CheckBox.Checked := zts = 'tak';


  zti := Gra_Współczynnik_Prędkości_SpinEdit.Value;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'gra_współczynnik_prędkości' )  ) then
    plik_ini.WriteInteger( 'USTAWIENIA', 'gra_współczynnik_prędkości', zti )
  else
    zti := plik_ini.ReadInteger( 'USTAWIENIA', 'gra_współczynnik_prędkości', zti ); // Jeżeli nie znajdzie to podstawia wartość zti.

  Gra_Współczynnik_Prędkości_SpinEdit.Value := zti;


  zti := Kamera_Odległość_Maksymalna_SpinEdit.Value;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'kamera_odległość_maksymalna' )  ) then
    plik_ini.WriteInteger( 'USTAWIENIA', 'kamera_odległość_maksymalna', zti )
  else
    zti := plik_ini.ReadInteger( 'USTAWIENIA', 'kamera_odległość_maksymalna', zti ); // Jeżeli nie znajdzie to podstawia wartość zti.

  Kamera_Odległość_Maksymalna_SpinEdit.Value := zti;


  ztf := Odczytaj_Liczbę_Z_Napisu( Kamera_Szybkość_Ruchu_Edit.Text, 1 );

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'kamera_szybkość_ruchu' )  ) then
    plik_ini.WriteFloat( 'USTAWIENIA', 'kamera_szybkość_ruchu', ztf )
  else
    ztf := plik_ini.ReadFloat( 'USTAWIENIA', 'kamera_szybkość_ruchu', ztf ); // Jeżeli nie znajdzie to podstawia wartość zti.

  Kamera_Szybkość_Ruchu_Edit.Text := FloatToStr( ztf );


  ztf := Odczytaj_Liczbę_Z_Napisu( Mysz_Czułość_Edit.Text, 10 );

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'mysz_czułość' )  ) then
    plik_ini.WriteFloat( 'USTAWIENIA', 'mysz_czułość', ztf )
  else
    ztf := plik_ini.ReadFloat( 'USTAWIENIA', 'mysz_czułość', ztf ); // Jeżeli nie znajdzie to podstawia wartość zti.

  Mysz_Czułość_Edit.Text := FloatToStr( ztf );


  ztf := Odczytaj_Liczbę_Z_Napisu( Mysz_Czułość_Luneta_Edit.Text, 0.1 );

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'mysz_czułość_luneta' )  ) then
    plik_ini.WriteFloat( 'USTAWIENIA', 'mysz_czułość_luneta', ztf )
  else
    ztf := plik_ini.ReadFloat( 'USTAWIENIA', 'mysz_czułość_luneta', ztf ); // Jeżeli nie znajdzie to podstawia wartość zti.

  Mysz_Czułość_Luneta_Edit.Text := FloatToStr( ztf );


  if Obrót_Kąt_Zablokowany_Wskaźnik_CheckBox.Checked then
    zts := 'tak'
  else//if Obrót_Kąt_Zablokowany_Wskaźnik_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'obrót_kąt_zablokowany_wskaźnik' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'obrót_kąt_zablokowany_wskaźnik', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'obrót_kąt_zablokowany_wskaźnik', zts ); // Jeżeli nie znajdzie to podstawia wartość zts.

  Obrót_Kąt_Zablokowany_Wskaźnik_CheckBox.Checked := zts = 'tak';


  if Obrót_Kąt_Zablokowany_Strzał_Wskaźnik_CheckBox.Checked then
    zts := 'tak'
  else//if Obrót_Kąt_Zablokowany_Strzał_Wskaźnik_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'obrót_kąt_zablokowany_strzał_wskaźnik' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'obrót_kąt_zablokowany_strzał_wskaźnik', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'obrót_kąt_zablokowany_strzał_wskaźnik', zts ); // Jeżeli nie znajdzie to podstawia wartość zts.

  Obrót_Kąt_Zablokowany_Strzał_Wskaźnik_CheckBox.Checked := zts = 'tak';


  if Pokój_Rozmów__Informacja_Dodatkowa_CheckBox.Checked then
    zts := 'tak'
  else//if Pokój_Rozmów__Informacja_Dodatkowa_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'pokój_rozmów__informacja_dodatkowa' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'pokój_rozmów__informacja_dodatkowa', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'pokój_rozmów__informacja_dodatkowa', zts ); // Jeżeli nie znajdzie to podstawia wartość zts.

  Pokój_Rozmów__Informacja_Dodatkowa_CheckBox.Checked := zts = 'tak';


  if Pokój_Rozmów__Na_Ekranie_CheckBox.Checked then
    zts := 'tak'
  else//if Pokój_Rozmów__Na_Ekranie_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'pokój_rozmów__na_ekranie' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'pokój_rozmów__na_ekranie', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'pokój_rozmów__na_ekranie', zts ); // Jeżeli nie znajdzie to podstawia wartość zts.

  Pokój_Rozmów__Na_Ekranie_CheckBox.Checked := zts = 'tak';


  if Punkty_Życia_Wskaźnik__Gracz_CheckBox.Checked then
    zts := 'tak'
  else//if Punkty_Życia_Wskaźnik__Gracz_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'punkty_życia_wskaźnik__gracz' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'punkty_życia_wskaźnik__gracz', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'punkty_życia_wskaźnik__gracz', zts ); // Jeżeli nie znajdzie to podstawia wartość zts.

  Punkty_Życia_Wskaźnik__Gracz_CheckBox.Checked := zts = 'tak';


  if Punkty_Życia_Wskaźnik__Przeciwnik_CheckBox.Checked then
    zts := 'tak'
  else//if Punkty_Życia_Wskaźnik__Przeciwnik_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'punkty_życia_wskaźnik__przeciwnik' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'punkty_życia_wskaźnik__przeciwnik', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'punkty_życia_wskaźnik__przeciwnik', zts ); // Jeżeli nie znajdzie to podstawia wartość zts.

  Punkty_Życia_Wskaźnik__Przeciwnik_CheckBox.Checked := zts = 'tak';


  if Punkty_Życia_Wskaźnik__Sojusznik_CheckBox.Checked then
    zts := 'tak'
  else//if Punkty_Życia_Wskaźnik__Sojusznik_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'punkty_życia_wskaźnik__sojusznik' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'punkty_życia_wskaźnik__sojusznik', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'punkty_życia_wskaźnik__sojusznik', zts ); // Jeżeli nie znajdzie to podstawia wartość zts.

  Punkty_Życia_Wskaźnik__Sojusznik_CheckBox.Checked := zts = 'tak';


  if Radar_Widoczność_CheckBox.Checked then
    zts := 'tak'
  else//if Radar_Widoczność_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'radar_widoczność' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'radar_widoczność', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'radar_widoczność', zts ); // Jeżeli nie znajdzie to podstawia wartość zts.

  Radar_Widoczność_CheckBox.Checked := zts = 'tak';
  {$endregion 'USTAWIENIA.'}

  {$region 'POZOSTAŁE.'}
  ztf := Odczytaj_Liczbę_Z_Napisu( Amunicja__Zanurzenie_Głębokość_Zadana_Edit.Text, -0.3 );

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'POZOSTAŁE', 'amunicja__zanurzenie_głębokość_zadana' )  ) then
    plik_ini.WriteFloat( 'POZOSTAŁE', 'amunicja__zanurzenie_głębokość_zadana', ztf )
  else
    ztf := plik_ini.ReadFloat( 'POZOSTAŁE', 'amunicja__zanurzenie_głębokość_zadana', ztf ); // Jeżeli nie znajdzie to podstawia wartość zti.

  Amunicja__Zanurzenie_Głębokość_Zadana_Edit.Text := FloatToStr( ztf );


  ztf := Odczytaj_Liczbę_Z_Napisu( Amunicja__Zanurzenie_Głębokość_Zadana__Skok_O_Edit.Text, 0 );

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'POZOSTAŁE', 'amunicja__zanurzenie_głębokość_zadana_skok_o' )  ) then
    plik_ini.WriteFloat( 'POZOSTAŁE', 'amunicja__zanurzenie_głębokość_zadana_skok_o', ztf )
  else
    ztf := plik_ini.ReadFloat( 'POZOSTAŁE', 'amunicja__zanurzenie_głębokość_zadana_skok_o', ztf ); // Jeżeli nie znajdzie to podstawia wartość zti.

  Amunicja__Zanurzenie_Głębokość_Zadana__Skok_O_Edit.Text := FloatToStr( ztf );
  {$endregion 'POZOSTAŁE.'}

  {$region 'WIELOOSOBOWE.'}
  zts := Serwer_Adres_IP_Edit.Text;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'WIELOOSOBOWE', 'serwer_adres_ip' )  ) then
    plik_ini.WriteString( 'WIELOOSOBOWE', 'serwer_adres_ip', zts )
  else
    zts := plik_ini.ReadString( 'WIELOOSOBOWE', 'serwer_adres_ip', zts ); // Jeżeli nie znajdzie to podstawia wartość zts.

  Serwer_Adres_IP_Edit.Text := zts;


  zti := Serwer_Port_SpinEdit.Value;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'WIELOOSOBOWE', 'serwer_port' )  ) then
    plik_ini.WriteInteger( 'WIELOOSOBOWE', 'serwer_port', zti )
  else
    zti := plik_ini.ReadInteger( 'WIELOOSOBOWE', 'serwer_port', zti ); // Jeżeli nie znajdzie to podstawia wartość zti.

  Serwer_Port_SpinEdit.Value := zti;


  zts := Hasło_Edit.Text;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'WIELOOSOBOWE', 'hasło' )  ) then
    plik_ini.WriteString( 'WIELOOSOBOWE', 'hasło', zts )
  else
    zts := plik_ini.ReadString( 'WIELOOSOBOWE', 'hasło', zts ); // Jeżeli nie znajdzie to podstawia wartość zts.

  Hasło_Edit.Text := zts;
  {$endregion 'WIELOOSOBOWE.'}


  plik_ini.Free();


  Ląd_ComboBoxChange( nil );
  Statek_ComboBoxChange( nil );
  Statki_Pozycje_Początkowe_ComboBoxChange( nil );


  //???
  //Projektowy_Tryb_CheckBox.Enabled := false;

end;//---//Ustawienia_Plik().

//Funkcja Wczytaj_Schemat().
procedure TStatki_Form.Wczytaj_Schemat( const katalog_nazwa_f : string; const lista_indeks_f : integer; var schematy_lista_r_t_f : TSchematy_Lista_r_t );
var
  i,
  j
    : integer;
  zts : string;
  search_rec : TSearchRec;
  zt_string_list : TStringList;
  zt_xml_document : TXMLDocument; //uses XMLDoc

  zt_combo_box : TComboBox;
begin

  //
  // Funkcja wczytuje schematy z plików xml w zadanym katalogu i sprawdza poprawność składni xml.
  //
  // Parametry:
  //   katalog_nazwa_f - katalog, w którym wyszukiwać pliki.
  //   lista_indeks_f:
  //     < 0 - czyści tabelę schematów i wczyta wszystkie schematy z plików.
  //     >= 0 - odczyta ponowie schemat tylko dla podanego indeksu tabeli schematów.
  //   schematy_lista_r_t_f - tabela, do której wpisywać dane schematów.
  //

  if    ( lista_indeks_f >= 0 )
    and (
             (  Length( schematy_lista_r_t_f ) < 0  )
          or (  lista_indeks_f > Length( schematy_lista_r_t_f ) - 1  )
        ) then
    Exit;

    
  if katalog_nazwa_f = katalog_schematy_lista__lądy_c then
    begin

      zt_combo_box := Ląd_ComboBox;

    end
  else//if katalog_nazwa_f = katalog_schematy_lista__lądy_c then
  if katalog_nazwa_f = katalog_schematy_lista__statki_c then
    begin

      zt_combo_box := Statek_ComboBox;

    end
  else//if katalog_nazwa_f = katalog_schematy_lista__statki_c then
  if katalog_nazwa_f = katalog_schematy_lista__statki_pozycje_początkowe_c then
    begin

      zt_combo_box := Statki_Pozycje_Początkowe_ComboBox;

    end
  else//if katalog_nazwa_f = katalog_schematy_lista__statki_pozycje_początkowe_c then
    zt_combo_box := nil;


  if lista_indeks_f < 0 then
    begin

      if zt_combo_box <> nil then
        zt_combo_box.Items.Clear();

      SetLength( schematy_lista_r_t_f, 0 );

    end;
  //---//if lista_indeks_f < 0 then   

  
  zt_string_list := TStringList.Create();
  zt_xml_document := TXMLDocument.Create( Application );
  zt_xml_document.Options := zt_xml_document.Options + [ doNodeAutoIndent ]; // Domyślnie ma: doNodeAutoCreate, doAttrNull, doAutoPrefix, doNamespaceDecl.

  j := -99;

  zts := ExtractFilePath( Application.ExeName ) + katalog_nazwa_f + '\';

  // Jeżeli znajdzie plik zwraca 0, jeżeli nie znajdzie zwraca numer błędu. Na początku znajduje '.' '..' potem listę plików.
  if FindFirst( zts + '*.xml', faAnyFile, search_rec ) = 0 then // Application potrzebuje w uses Forms.
    begin

      repeat //FindNext( search_rec ) <> 0;
        // Czasami bez begin i end nieprawidłowo rozpoznaje miejsca na umieszczenie breakpoint (linijkę za wysoko) w XE5.

        if    ( search_rec.Attr <> faDirectory )
          and ( search_rec.Name <> '.' )
          and ( search_rec.Name <> '..' )
          and (
                   ( lista_indeks_f < 0 )
                or ( schematy_lista_r_t_f[ lista_indeks_f ].plik_nazwa = search_rec.Name )
              ) then
          begin

            if zt_xml_document.Active then
              zt_xml_document.Active := false;
              
          
            zt_string_list.Clear();
            zt_string_list.LoadFromFile( zts + search_rec.Name );
  

            try
              zt_xml_document.LoadFromXML( zt_string_list.Text );
            except
              on E : Exception do
                //Application.MessageBox(  PChar('Nieprawidłowa definicja lądu ' + search_rec.Name + '.' + #13 + E.Message + ' ' + IntToStr( E.HelpContext )), 'Błąd', MB_OK + MB_ICONEXCLAMATION  );
                Log_Wypisz(  'Nieprawidłowa definicja lądu ' + search_rec.Name + '.' + #13 + #10 + E.Message + ' ' + IntToStr( E.HelpContext )  );
            end;
            //---//try

            if zt_xml_document.Active then
              begin

                if lista_indeks_f < 0 then
                  begin

                    i := Length( schematy_lista_r_t_f );
                    SetLength( schematy_lista_r_t_f, i + 1 );

                  end
                else//if lista_indeks_f < 0 then                
                  i := lista_indeks_f;
                  

                schematy_lista_r_t_f[ i ].id := IntToStr( i + 1 );
                schematy_lista_r_t_f[ i ].plik_nazwa := search_rec.Name;
                schematy_lista_r_t_f[ i ].treść := zt_string_list.Text; // Jako 'abc'#$D#$A'def'#$D#$A gdy treść pliku abc + #13 + def.

                for j := 0 to zt_xml_document.DocumentElement.ChildNodes.Count - 1 do
                  begin

                    if zt_xml_document.DocumentElement.ChildNodes[ j ].LocalName = 'nazwa' then
                      schematy_lista_r_t_f[ i ].nazwa := zt_xml_document.DocumentElement.ChildNodes[ j ].Text
                    else  
                    if zt_xml_document.DocumentElement.ChildNodes[ j ].LocalName = 'opis' then
                      schematy_lista_r_t_f[ i ].opis := zt_xml_document.DocumentElement.ChildNodes[ j ].Text;

                  end;
                //---//for j := 0 to zt_xml_document.DocumentElement.ChildNodes.Count - 1 do
                  
              end;
            //---//if zt_xml_document.Active then


            j := -88;

          end;
        //---//if    ( search_rec.Attr <> faDirectory )
          

      until FindNext( search_rec ) <> 0; // Zwraca dane kolejnego pliku zgodnego z parametrami wcześniej wywołanej funkcji FindFirst. Jeżeli można przejść do następnego znalezionego pliku zwraca 0.

    end;
  //---//if FindFirst( zts + '*.xml', faAnyFile, search_rec ) = 0 then

  FindClose( search_rec );
  
  zt_string_list.Free();
  zt_xml_document.Free();


  if j = -99 then
    if lista_indeks_f < 0 then
      Application.MessageBox( PChar('Nie odnaleziono plików (' + katalog_nazwa_f + ').'), 'Błąd', MB_OK + MB_ICONEXCLAMATION )
    else//if lista_indeks_f < 0 then
      Application.MessageBox( PChar('Nie odnaleziono pliku (' + katalog_nazwa_f + ').'), 'Błąd', MB_OK + MB_ICONEXCLAMATION );


  if zt_combo_box <> nil then
    begin

      if lista_indeks_f < 0 then
        for i := 0 to Length( schematy_lista_r_t_f ) - 1 do
          if Trim( schematy_lista_r_t_f[ i ].nazwa ) <> '' then
            zt_combo_box.Items.Add( schematy_lista_r_t_f[ i ].nazwa )
          else//if Trim( schematy_lista_r_t_f[ i ].nazwa ) <> '' then
            zt_combo_box.Items.Add( schematy_lista_r_t_f[ i ].plik_nazwa );



      if katalog_nazwa_f = katalog_schematy_lista__statki_c then
        begin

          // Dopisuje statki do listy wyboru dla SI.

          for i := 0 to zt_combo_box.Items.Count - 1 do
            SI__Statek_ComboBox.Items.Add( zt_combo_box.Items[ i ] );

          if SI__Statek_ComboBox.Items.Count > 0 then
            SI__Statek_ComboBox.ItemIndex := 0;

        end;
      //---//if katalog_nazwa_f = katalog_schematy_lista__statki_c then

    end;
  //---//if zt_combo_box <> nil then


  if katalog_nazwa_f = katalog_schematy_lista__lądy_c then
    Wczytaj_Schemat( katalog_schematy_lista__prymitywy_c, -1, prymitywy_lista_t );

end;//---//Funkcja Wczytaj_Schemat().

//Funkcja Wieloosobowe_Amunicja_Parametry_Odczytaj().
procedure TStatki_Form.Wieloosobowe_Amunicja_Parametry_Odczytaj();
var
  i : integer;
begin

  //
  // Funkcja odczytuje parametry amunicji.
  //

  if   ( amunicja_wystrzelona_list = nil )
    or (  not Assigned( amunicja_wystrzelona_list )  ) then
    Exit;


  SetLength( wieloosobowe__amunicja_t, 0 );
  SetLength( wieloosobowe__amunicja_t, amunicja_wystrzelona_list.Count );


  for i := amunicja_wystrzelona_list.Count - 1 downto 0 do
    begin

      wieloosobowe__amunicja_t[ i ].id_statek := TAmunicja(amunicja_wystrzelona_list[ i ]).id_statek;
      wieloosobowe__amunicja_t[ i ].id_wieloosobowe_amunicja := TAmunicja(amunicja_wystrzelona_list[ i ]).id_amunicja;
      wieloosobowe__amunicja_t[ i ].czy_lot_parabolą := TAmunicja(amunicja_wystrzelona_list[ i ]).czy_lot_parabolą;
      wieloosobowe__amunicja_t[ i ].czy_poza_lufą := TAmunicja(amunicja_wystrzelona_list[ i ]).czy_poza_lufą;
      wieloosobowe__amunicja_t[ i ].przeliczone := false;

      wieloosobowe__amunicja_t[ i ].kierunek := TAmunicja(amunicja_wystrzelona_list[ i ]).korpus_ustawienie_początkowe_dummy.AbsoluteDirection;
      wieloosobowe__amunicja_t[ i ].pozycja := TAmunicja(amunicja_wystrzelona_list[ i ]).korpus_ustawienie_początkowe_dummy.AbsolutePosition;
      wieloosobowe__amunicja_t[ i ].pozycja_celu := TAmunicja(amunicja_wystrzelona_list[ i ]).pozycja_celu.AbsolutePosition;

      wieloosobowe__amunicja_t[ i ].turn_angle := TAmunicja(amunicja_wystrzelona_list[ i ]).TurnAngle;
      wieloosobowe__amunicja_t[ i ].pitch_angle := TAmunicja(amunicja_wystrzelona_list[ i ]).PitchAngle;

      wieloosobowe__amunicja_t[ i ].korpus__Height := TAmunicja(amunicja_wystrzelona_list[ i ]).korpus.Height;
      wieloosobowe__amunicja_t[ i ].korpus__TopRadius := TAmunicja(amunicja_wystrzelona_list[ i ]).korpus.TopRadius;
      wieloosobowe__amunicja_t[ i ].korpus__BottomRadius := TAmunicja(amunicja_wystrzelona_list[ i ]).korpus.BottomRadius;

      wieloosobowe__amunicja_t[ i ].amunicja_rodzaj := TAmunicja(amunicja_wystrzelona_list[ i ]).amunicja_rodzaj;

      if TAmunicja(amunicja_wystrzelona_list[ i ]).torpeda_efekt_na_wodzie = nil then
        wieloosobowe__amunicja_t[ i ].torpeda_efekt_na_wodzie_stan := 2
      else//if TAmunicja(amunicja_wystrzelona_list[ i ]).torpeda_efekt_na_wodzie = nil then
      if TAmunicja(amunicja_wystrzelona_list[ i ]).torpeda_efekt_na_wodzie.Parent = nil then
        wieloosobowe__amunicja_t[ i ].torpeda_efekt_na_wodzie_stan := 0
      else//if TAmunicja(amunicja_wystrzelona_list[ i ]).torpeda_efekt_na_wodzie.Parent = nil then
        wieloosobowe__amunicja_t[ i ].torpeda_efekt_na_wodzie_stan := 1;

      //wieloosobowe__amunicja_t[ i ].ztr := TAmunicja(amunicja_wystrzelona_list[ i ]).korpus_opadanie_obrót_dummy.RollAngle;


      //???
      //wieloosobowe__amunicja_t[ i ].pozycja.X := wieloosobowe__amunicja_t[ i ].pozycja.X + 3;
      //wieloosobowe__amunicja_t[ i ].pozycja.Z := wieloosobowe__amunicja_t[ i ].pozycja.Z + 4;

    end;
  //---//for i := amunicja_wystrzelona_list.Count - 1 downto 0 do

end;//---//Funkcja Wieloosobowe_Amunicja_Parametry_Odczytaj().

//Funkcja Wieloosobowe_Amunicja_Parametry_Ustaw().
procedure TStatki_Form.Wieloosobowe_Amunicja_Parametry_Ustaw();

  //Funkcja Parametry_Ustaw() w Wieloosobowe_Amunicja_Parametry_Ustaw().
  procedure Parametry_Ustaw( amunicja_f : TAmunicja; var obiekty_wieloosobowe_amunicja_r_f : TObiekty_Wieloosobowe__Amunicja_r );
  begin

    if   ( amunicja_wystrzelona_list = nil )
      or (  not Assigned( amunicja_wystrzelona_list )  ) then
      Exit;

    amunicja_f.korpus_ustawienie_początkowe_dummy.AbsolutePosition := obiekty_wieloosobowe_amunicja_r_f.pozycja;
    amunicja_f.korpus_ustawienie_początkowe_dummy.AbsoluteDirection := obiekty_wieloosobowe_amunicja_r_f.kierunek;

    amunicja_f.TurnAngle := obiekty_wieloosobowe_amunicja_r_f.turn_angle;
    amunicja_f.PitchAngle := obiekty_wieloosobowe_amunicja_r_f.pitch_angle;

    if    ( Amunicja__Cel_Pozycja_Dla_Lotu_Parabolą_Wyświetl_CheckBox.Checked ) // Taki sam warunek pozycja_celu_Visible.
      and ( not amunicja_f.pozycja_celu.Visible )
      and ( obiekty_wieloosobowe_amunicja_r_f.czy_lot_parabolą )
      and ( obiekty_wieloosobowe_amunicja_r_f.czy_poza_lufą )
      and ( amunicja_f.id_statek = Gracz_Identyfikator() ) then
      begin

        amunicja_f.pozycja_celu.AbsolutePosition := obiekty_wieloosobowe_amunicja_r_f.pozycja_celu;
        amunicja_f.pozycja_celu.Visible := true;

      end;
    //---//if    ( Amunicja__Cel_Pozycja_Dla_Lotu_Parabolą_Wyświetl_CheckBox.Checked ) (...)


    obiekty_wieloosobowe_amunicja_r_f.przeliczone := true;


      if    ( obiekty_wieloosobowe_amunicja_r_f.torpeda_efekt_na_wodzie_stan = 1 )
        and ( amunicja_f.torpeda_efekt_na_wodzie <> nil ) then
        begin

          if amunicja_f.torpeda_efekt_na_wodzie.Parent = nil then
            begin

              Amunicja_Wystrzelona_Efekt_Utwórz( amunicja_f, true, true );
              amunicja_f.torpeda_efekt_na_wodzie.Parent := Gra_Obiekty_GLDummyCube;

            end
          else//if amunicja_f.torpeda_efekt_na_wodzie.Parent = nil then
            begin

              amunicja_f.torpeda_efekt_na_wodzie.Position.AsVector := VectorMake(  amunicja_f.korpus.AbsolutePosition.X, 0 + ( Random() - 0.5 ) * 0.25, amunicja_f.korpus.AbsolutePosition.Z  );

            end;
          //---//if amunicja_f.torpeda_efekt_na_wodzie.Parent <> nil then

        end
      else//if    ( obiekty_wieloosobowe_amunicja_r_f.torpeda_efekt_na_wodzie_stan = 1 ) (...)
      if    ( obiekty_wieloosobowe_amunicja_r_f.torpeda_efekt_na_wodzie_stan = 2 )
        and ( amunicja_f.torpeda_efekt_na_wodzie <> nil ) then
        FreeAndNil( amunicja_f.torpeda_efekt_na_wodzie );

  end;//---//Funkcja Parametry_Ustaw() w Wieloosobowe_Amunicja_Parametry_Ustaw().

var
  i,
  j
    : integer;
  zt_amunicja : TAmunicja;

  ztb : boolean;
begin//Funkcja Wieloosobowe_Amunicja_Parametry_Ustaw().

  //
  // Funkcja ustawia parametry amunicji wieloosobowej.
  //

  // Jeżeli wcześniej utworzonej amunicji nie ma na otrzymanej liście amunicji usuwa wcześniej utworzoną amunicję.
  for i := wieloosobowe_amunicja_wystrzelona_list.Count - 1 downto 0 do
    begin

      ztb := false;

      for j := 0 to Length( wieloosobowe__amunicja_t ) - 1 do
        if wieloosobowe__amunicja_t[ j ].id_wieloosobowe_amunicja = TAmunicja(wieloosobowe_amunicja_wystrzelona_list[ i ]).id_amunicja then
          begin

            ztb := true;
            Parametry_Ustaw( TAmunicja(wieloosobowe_amunicja_wystrzelona_list[ i ]), wieloosobowe__amunicja_t[ j ] );
            //wieloosobowe__amunicja_t[ j ].przeliczone := true;
            Break;

          end;
        //---//if wieloosobowe__amunicja_t[ j ].id_wieloosobowe_amunicja = TAmunicja(wieloosobowe_amunicja_wystrzelona_list[ i ]).id_amunicja then


      if not ztb then
        begin

          //TAmunicja(wieloosobowe_amunicja_wystrzelona_list[ i ]).Free(); //???
          TGLCylinder(wieloosobowe_amunicja_wystrzelona_list[ i ]).Free();
          wieloosobowe_amunicja_wystrzelona_list.Delete( i );

        end;
      //---//if not ztb then

    end;
  //---//for i := wieloosobowe_amunicja_wystrzelona_list.Count - 1 downto 0 do
  //---// Jeżeli wcześniej utworzonej amunicji nie ma na otrzymanej liście amunicji usuwa wcześniej utworzoną amunicję.


  for i := 0 to Length( wieloosobowe__amunicja_t ) - 1 do
    if not wieloosobowe__amunicja_t[ i ].przeliczone then
      begin

        ztb := false;

        for j := 0 to wieloosobowe_amunicja_wystrzelona_list.Count - 1 do
          if wieloosobowe__amunicja_t[ i ].id_wieloosobowe_amunicja = TAmunicja(wieloosobowe_amunicja_wystrzelona_list[ j ]).id_amunicja then
            begin

              // Jeżeli wcześniej utworzona amunicja jest na otrzymanej liście amunicji ustawia jej aktualne parametry.

              ztb := true;
              Parametry_Ustaw( TAmunicja(wieloosobowe_amunicja_wystrzelona_list[ j ]), wieloosobowe__amunicja_t[ i ] );
              //wieloosobowe__amunicja_t[ i ].przeliczone := true;
              Break;

            end;
          //---//if wieloosobowe__amunicja_t[ i ].id_wieloosobowe_amunicja = TAmunicja(wieloosobowe_amunicja_wystrzelona_list[ j ]).id_amunicja then

        if not ztb then
          begin

            // Jeżeli na otrzymanej liście amunicji nie ma wcześniej utworzonej amunicji dodaje brakującą amunicję.

            zt_amunicja := TAmunicja.Create( wieloosobowe__amunicja_t[ i ], Gra_Obiekty_GLDummyCube );


            if wieloosobowe_amunicja_efekt_g = nil then
              begin

                wieloosobowe_amunicja_efekt_g := TAmunicja.Create( wieloosobowe__amunicja_t[ i ], Gra_Obiekty_GLDummyCube ); // Pierwsze utworzenie instancji.

                // Nie ma detekcji kolizji.
                wieloosobowe_amunicja_efekt_g.Position.Y := dno_poziom_c * 2;
                wieloosobowe_amunicja_efekt_g.ResetRotations();
                wieloosobowe_amunicja_efekt_g.Visible := false;

              end;
            //---//if wieloosobowe_amunicja_efekt_g = nil then


            Amunicja_Wystrzelona_Efekt_Utwórz( zt_amunicja, false, true );

            wieloosobowe_amunicja_wystrzelona_list.Add( zt_amunicja );

            Parametry_Ustaw( zt_amunicja, wieloosobowe__amunicja_t[ i ] );
            //wieloosobowe__amunicja_t[ i ].przeliczone := true;

          end;
        //---//if not ztb then

        // ???
//        TAmunicja(wieloosobowe_amunicja_wystrzelona_list[ i ]).Position.X := TAmunicja(wieloosobowe_amunicja_wystrzelona_list[ i ]).Position.X + 1;
//        TAmunicja(wieloosobowe_amunicja_wystrzelona_list[ i ]).Position.Z := TAmunicja(wieloosobowe_amunicja_wystrzelona_list[ i ]).Position.Z + 1;

      end;
    //---//if not wieloosobowe__amunicja_t[ i ].przeliczone then

end;//---//Funkcja Wieloosobowe_Amunicja_Parametry_Ustaw().

//Funkcja Wieloosobowe__Efekt_Odczytaj_Jeden().
procedure TStatki_Form.Wieloosobowe__Efekt_Odczytaj_Jeden( AOwner : TGLBaseSceneObject; efekt_rodzaj_f : TEfekt_Rodzaj; x_f, y_f, z_f : real; amunicja_f : TAmunicja; czas_trwania_f, czas_trwania_efekt_dodatkowy_f : Int64 );
var
  i : integer;
begin

  if not czy_serwer_g then
    Exit;


  if    ( AOwner <> nil )
    and ( AOwner is TStatek ) then
    wieloosobowe__efekt_r.id_statek := TStatek(AOwner).id_statek
  else//if    ( statki_t[ i ] <> nil ) (...)
    wieloosobowe__efekt_r.id_statek := -1; // Scena.


  wieloosobowe__efekt_r.czas_trwania := czas_trwania_f;
  wieloosobowe__efekt_r.czas_trwania_efekt_dodatkowy := czas_trwania_efekt_dodatkowy_f;

  wieloosobowe__efekt_r.efekt_rodzaj := efekt_rodzaj_f;

  wieloosobowe__efekt_r.pozycja.X := x_f;
  wieloosobowe__efekt_r.pozycja.Y := y_f;
  wieloosobowe__efekt_r.pozycja.Z := z_f;

  wieloosobowe__efekt_r.wysłane := false;


  if amunicja_f <> nil then
    begin

      wieloosobowe__efekt_r.amunicja_rodzaj := amunicja_f.amunicja_rodzaj;

    end
  else//if amunicja_f <> nil then
    begin

      wieloosobowe__efekt_r.amunicja_rodzaj := ar_Brak;

    end;
  //---//if amunicja_f <> nil then

  Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__odbierz__rekord_efekt_c, -99, '', true );

  Exit;
  // Efekt wysyłany jako tabela.

  i := Length( wieloosobowe__efekt_t );
  SetLength( wieloosobowe__efekt_t, i + 1 );


  if    ( AOwner <> nil )
    and ( AOwner is TStatek ) then
    wieloosobowe__efekt_t[ i ].id_statek := TStatek(AOwner).id_statek
  else//if    ( statki_t[ i ] <> nil ) (...)
    wieloosobowe__efekt_t[ i ].id_statek := -1; // Scena.


  wieloosobowe__efekt_t[ i ].czas_trwania := czas_trwania_f;
  wieloosobowe__efekt_t[ i ].czas_trwania_efekt_dodatkowy := czas_trwania_efekt_dodatkowy_f;

  wieloosobowe__efekt_t[ i ].efekt_rodzaj := efekt_rodzaj_f;

  wieloosobowe__efekt_t[ i ].pozycja.X := x_f;
  wieloosobowe__efekt_t[ i ].pozycja.Y := y_f;
  wieloosobowe__efekt_t[ i ].pozycja.Z := z_f;

  wieloosobowe__efekt_t[ i ].wysłane := false;


  if amunicja_f <> nil then
    begin

      wieloosobowe__efekt_t[ i ].amunicja_rodzaj := amunicja_f.amunicja_rodzaj;

    end
  else//if amunicja_f <> nil then
    begin

      wieloosobowe__efekt_t[ i ].amunicja_rodzaj := ar_Brak;

    end;
  //---//if amunicja_f <> nil then

end;//---//Funkcja Wieloosobowe__Efekt_Odczytaj_Jeden().

//Funkcja Wieloosobowe_Statki_Rekord_Czyść().
procedure TStatki_Form.Wieloosobowe_Statki_Rekord_Czyść();
var
  i,
  j,
  k
    : integer;
begin

  //
  // Funkcja czyści dane parametrów statków wieloosobowych.
  //

  for i := 0 to Length( wieloosobowe__statki_t ) - 1 do
    begin

      wieloosobowe__statki_t[ i ].id_statek := -99;
      wieloosobowe__statki_t[ i ].id_statek_schemat := -1;
      wieloosobowe__statki_t[ i ].gracz__nazwa := '';

      SetLength( wieloosobowe__statki_t[ i ].śruba_obrót_kąt, 0 );


      {$region 'Działa strzelające.'}
      for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t ) - 1 do
        SetLength( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t, 0 );

      SetLength( wieloosobowe__statki_t[ i ].artyleria_t, 0 );


      for j := 0 to Length( wieloosobowe__statki_t[ i ].działa_t ) - 1 do
        SetLength( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t, 0 );

      SetLength( wieloosobowe__statki_t[ i ].działa_t, 0 );


      for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do
        SetLength( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t, 0 );

      SetLength( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t, 0 );
      {$endregion 'Działa strzelające.'}

      {$region 'Działa ładnie wyglądające.'}
      for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_wygląd_t ) - 1 do
        SetLength( wieloosobowe__statki_t[ i ].artyleria_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t, 0 );

      SetLength( wieloosobowe__statki_t[ i ].artyleria_wygląd_t, 0 );


      for j := 0 to Length( wieloosobowe__statki_t[ i ].działa_wygląd_t ) - 1 do
        SetLength( wieloosobowe__statki_t[ i ].działa_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t, 0 );

      SetLength( wieloosobowe__statki_t[ i ].działa_wygląd_t, 0 );


      for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t ) - 1 do
        SetLength( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t, 0 );

      SetLength( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t, 0 );
      {$endregion 'Działa ładnie wyglądające.'}

    end;
  //---//for i := 0 to Length( wieloosobowe__statki_t ) - 1 do


  SetLength( wieloosobowe__statki_t, 0 );

end;//---//Funkcja Wieloosobowe_Statki_Rekord_Czyść().

//Funkcja Wieloosobowe_Statki_Utwórz().
procedure TStatki_Form.Wieloosobowe_Statki_Utwórz();
var
  i : integer;
begin

  //
  // Funkcja tworzy statki dla klienta gry wieloosobowej.
  //

  // Aby nie zwolniło kamery wraz ze statkiem.
  while GLCamera1.Parent <> GLScene1.Objects do
    Kamera_Przełącz( kt_Statek );

  statek_gracza := nil; // Nie zmienia statki_t[ 0 ].

  for i := 0 to Length( statki_t ) - 1 do
    FreeAndNil( statki_t[ i ] );

  SetLength( statki_t, 0 );


  for i := 0 to Length( wieloosobowe__statki_t ) - 1 do
    begin

      SetLength( statki_t, i + 1 );
      statki_t[ i ] := TStatek.Create(  Gra_Obiekty_GLDummyCube, nil, i, Statek_Odczytaj_Schemat( wieloosobowe__statki_t[ i ].id_statek_schemat ), prymitywy_lista_t  );
      statki_t[ i ].id_grupa := wieloosobowe__statki_t[ i ].id_grupa;
      statki_t[ i ].id_statek := wieloosobowe__statki_t[ i ].id_statek;
      statki_t[ i ].id_statek_schemat := wieloosobowe__statki_t[ i ].id_statek_schemat;
      statki_t[ i ].gracz__nazwa.Text := wieloosobowe__statki_t[ i ].gracz__nazwa;

      if wieloosobowe__statki_t[ i ].id_statek = Gracz_Identyfikator() then
        begin

          statek_gracza := statki_t[ i ];

          // Pozycja kamery na statek. //???

          statek_gracza.Elementy_Gracza_Dostosuj( -99, Punkty_Życia_Wskaźnik__Gracz_CheckBox.Checked, false, false, Obrót_Kąt_Zablokowany_Wskaźnik_CheckBox.Checked, Obrót_Kąt_Zablokowany_Strzał_Wskaźnik_CheckBox.Checked );

          Interfejs_Parametry_Według_Statku_Ustaw();

          Radar_Odwróć_CheckBox.Checked := statek_gracza.id_grupa = 2;

        end
      else//if wieloosobowe__statki_t[ i ].id_statek = Gracz_Identyfikator() then
        begin

          statki_t[ i ].Elementy_Gracza_Widoczność( Gracz_Grupa_SpinEdit.Value, false );
          statki_t[ i ].Elementy_Gracza_Dostosuj( Gracz_Grupa_SpinEdit.Value, false, Punkty_Życia_Wskaźnik__Przeciwnik_CheckBox.Checked, Punkty_Życia_Wskaźnik__Sojusznik_CheckBox.Checked, false, false );

        end;
      //---//if wieloosobowe__statki_t[ i ].id_statek = Gracz_Identyfikator() then

    end;
  //---//for i := 0 to Length( wieloosobowe__statki_t ) - 1 do


  if statek_gracza = nil then
    Application.MessageBox( 'Nie udało się zlokalizować statku gracza.', 'Informacja', MB_ICONEXCLAMATION );

end;//---//Funkcja Wieloosobowe_Statki_Utwórz().

//Funkcja Wieloosobowe_Statki_Parametry_Odczytaj().
procedure TStatki_Form.Wieloosobowe_Statki_Parametry_Odczytaj();
var
  i,
  j,
  k
    : integer;
begin

  //
  // Funkcja odczytuje parametry statków wieloosobowych.
  //

  if Length( wieloosobowe__statki_t ) <> Length( statki_t ) then
    begin


      Wieloosobowe_Statki_Rekord_Czyść();
      SetLength(  wieloosobowe__statki_t, Length( statki_t )  );

    end;
  //---//if Length( wieloosobowe__statki_t ) <> Length( statki_t ) then


  for i := 0 to Length( statki_t ) - 1 do
    begin

      wieloosobowe__statki_t[ i ].cel_współrzędne := Vector__Do__Wieloosobowe__Wektor_4( Celowniczy_GLDummyCube.AbsolutePosition ); //???

      wieloosobowe__statki_t[ i ].id_grupa := statki_t[ i ].id_grupa;
      wieloosobowe__statki_t[ i ].id_statek := statki_t[ i ].id_statek;
      wieloosobowe__statki_t[ i ].id_statek_schemat := statki_t[ i ].id_statek_schemat;
      wieloosobowe__statki_t[ i ].gracz__nazwa := statki_t[ i ].gracz__nazwa.Text;
      wieloosobowe__statki_t[ i ].przeliczone := false;

      wieloosobowe__statki_t[ i ].pozycja := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].AbsolutePosition );
      wieloosobowe__statki_t[ i ].kierunek := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].AbsoluteDirection );

      wieloosobowe__statki_t[ i ].falowanie_bok_skręt := statki_t[ i ].falowanie_bok_skręt;
      wieloosobowe__statki_t[ i ].tonięcie__przechylenie__lewo_prawo := statki_t[ i ].RollAngle;
      wieloosobowe__statki_t[ i ].tonięcie__przechylenie__przód_tył := statki_t[ i ].PitchAngle;
      wieloosobowe__statki_t[ i ].punkty_życia := statki_t[ i ].punkty_życia;
      wieloosobowe__statki_t[ i ].punkty_życia_maksymalne := statki_t[ i ].punkty_życia_maksymalne;
      wieloosobowe__statki_t[ i ].punkty_życia_procent_zostało := statki_t[ i ].punkty_życia_procent_zostało;

      if Length( statki_t[ i ].ster_t )> 0 then
        wieloosobowe__statki_t[ i ].ster_kąt := statki_t[ i ].ster_t[ 0 ].TurnAngle
      else//if Length( statki_t[ i ].ster_t )> 0 then
        wieloosobowe__statki_t[ i ].ster_kąt := 0;


      wieloosobowe__statki_t[ i ].radar_id_statki_w_zasięgu := statki_t[ i ].radar_id_statki_w_zasięgu;
      wieloosobowe__statki_t[ i ].radio_id_statki_w_zasięgu := statki_t[ i ].radio_id_statki_w_zasięgu;


      SetLength(  wieloosobowe__statki_t[ i ].śruba_obrót_kąt, Length( statki_t[ i ].śruby_t )  ); // Ustawia długość tabel.
      wieloosobowe__statki_t[ i ].śruba_obrót_kąt__długość := Length( wieloosobowe__statki_t[ i ].śruba_obrót_kąt );


      {$region 'Działa strzelające - ustawia długość tabel.'}
      SetLength(  wieloosobowe__statki_t[ i ].artyleria_t, Length( statki_t[ i ].artyleria_t )  );
      wieloosobowe__statki_t[ i ].artyleria_t__długość_tabeli := Length( wieloosobowe__statki_t[ i ].artyleria_t );

      for j := 0 to Length( statki_t[ i ].artyleria_t ) - 1 do
        begin

          SetLength(  wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t, Length( statki_t[ i ].artyleria_t[ j ].lufy_t )  );
          wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t__długość_tabeli := Length( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t );

        end;
      //---//for j := 0 to Length( statki_t[ i ].artyleria_t ) - 1 do


      SetLength(  wieloosobowe__statki_t[ i ].działa_t, Length( statki_t[ i ].działa_t )  );
      wieloosobowe__statki_t[ i ].działa_t__długość_tabeli := Length( wieloosobowe__statki_t[ i ].działa_t );

      for j := 0 to Length( statki_t[ i ].działa_t ) - 1 do
        begin

          SetLength(  wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t, Length( statki_t[ i ].działa_t[ j ].lufy_t )  );
          wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t__długość_tabeli := Length( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t );

        end;
      //---//for j := 0 to Length( statki_t[ i ].działa_t ) - 1 do


      SetLength(  wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t, Length( statki_t[ i ].torpedy_wyrzutnie_t )  );
      wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t__długość_tabeli := Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t );

      for j := 0 to Length( statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do
        begin

          SetLength(  wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t, Length( statki_t[ i ].torpedy_wyrzutnie_t[ j ].lufy_t )  );
          wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t__długość_tabeli := Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t );

        end;
      //---//for j := 0 to Length( statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do
      {$endregion 'Działa strzelające - ustawia długość tabel.'}

      {$region 'Działa ładnie wyglądające - ustawia długość tabel.'}
      SetLength(  wieloosobowe__statki_t[ i ].artyleria_wygląd_t, Length( statki_t[ i ].artyleria_wygląd_t )  );
      wieloosobowe__statki_t[ i ].artyleria_wygląd_t__długość_tabeli := Length( wieloosobowe__statki_t[ i ].artyleria_wygląd_t );

      for j := 0 to Length( statki_t[ i ].artyleria_wygląd_t ) - 1 do
        begin

          SetLength(  wieloosobowe__statki_t[ i ].artyleria_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t, Length( statki_t[ i ].artyleria_wygląd_t[ j ].lufy_t )  );
          wieloosobowe__statki_t[ i ].artyleria_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t__długość_tabeli := Length( wieloosobowe__statki_t[ i ].artyleria_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t );

        end;
      //---//for j := 0 to Length( statki_t[ i ].artyleria_wygląd_t ) - 1 do


      SetLength(  wieloosobowe__statki_t[ i ].działa_wygląd_t, Length( statki_t[ i ].działa_wygląd_t )  );
      wieloosobowe__statki_t[ i ].działa_wygląd_t__długość_tabeli := Length( wieloosobowe__statki_t[ i ].działa_wygląd_t );

      for j := 0 to Length( statki_t[ i ].działa_wygląd_t ) - 1 do
        begin

          SetLength(  wieloosobowe__statki_t[ i ].działa_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t, Length( statki_t[ i ].działa_wygląd_t[ j ].lufy_t )  );
          wieloosobowe__statki_t[ i ].działa_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t__długość_tabeli := Length( wieloosobowe__statki_t[ i ].działa_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t );

        end;
      //---//for j := 0 to Length( statki_t[ i ].działa_wygląd_t ) - 1 do


      SetLength(  wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t, Length( statki_t[ i ].torpedy_wyrzutnie_wygląd_t )  );
      wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t__długość_tabeli := Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t );

      for j := 0 to Length( statki_t[ i ].torpedy_wyrzutnie_wygląd_t ) - 1 do
        begin

          SetLength(  wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t, Length( statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ].lufy_t )  );
          wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t__długość_tabeli := Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t );

        end;
      //---//for j := 0 to Length( statki_t[ i ].torpedy_wyrzutnie_wygląd_t ) - 1 do
      {$endregion 'Działa ładnie wyglądające - ustawia długość tabel.'}


      for j := 0 to Length( statki_t[ i ].śruby_t ) - 1 do
        wieloosobowe__statki_t[ i ].śruba_obrót_kąt[ j ] := statki_t[ i ].śruby_t[ j ].obrót_dummy.RollAngle;


      {$region 'Działa strzelające.'}
      for j := 0 to Length( statki_t[ i ].artyleria_t ) - 1 do
        begin

          wieloosobowe__statki_t[ i ].artyleria_t[ j ].czy_lot_parabolą := statki_t[ i ].artyleria_t[ j ].czy_lot_parabolą;
          wieloosobowe__statki_t[ i ].artyleria_t[ j ].obrót_kąt := statki_t[ i ].artyleria_t[ j ].TurnAngle;
          wieloosobowe__statki_t[ i ].artyleria_t[ j ].celownik_linia__podniesienie_kąt := statki_t[ i ].artyleria_t[ j ].celownik_linia.PitchAngle;
          wieloosobowe__statki_t[ i ].artyleria_t[ j ].celownik_linia__kolor := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].artyleria_t[ j ].celownik_linia.LineColor.Color );
          wieloosobowe__statki_t[ i ].artyleria_t[ j ].celownik_linia__szerokość := statki_t[ i ].artyleria_t[ j ].celownik_linia.LineWidth;
          wieloosobowe__statki_t[ i ].artyleria_t[ j ].celownik_linia__wzór := statki_t[ i ].artyleria_t[ j ].celownik_linia.LinePattern;

          wieloosobowe__statki_t[ i ].artyleria_t[ j ].amunicja_ilość := statki_t[ i ].artyleria_t[ j ].amunicja_ilość; // Informacje do wyświetlania dla gracza o jego statku.

          for k := 0 to Length( statki_t[ i ].artyleria_t[ j ].lufy_t ) - 1 do
            begin

              wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_kąt := statki_t[ i ].artyleria_t[ j ].lufy_t[ k ].PitchAngle;
              wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z := statki_t[ i ].artyleria_t[ j ].lufy_t[ k ].korpus.Position.Z;
              wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__pozycja := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].artyleria_t[ j ].lufy_t[ k ].przeładowanie_wskaźnik.AbsolutePosition );
              wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__kolor := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].artyleria_t[ j ].lufy_t[ k ].przeładowanie_wskaźnik.Material.FrontProperties.Ambient.Color );

              wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].strzał_gotowość := statki_t[ i ].artyleria_t[ j ].lufy_t[ k ].strzał_gotowość; // Informacje do wyświetlania dla gracza o jego statku.

            end;
          //---//for k := 0 to Length( statki_t[ i ].artyleria_t[ j ].lufy_t ) - 1 do

        end;
      //---//for j := 0 to Length( statki_t[ i ].artyleria_t ) - 1 do


      for j := 0 to Length( statki_t[ i ].działa_t ) - 1 do
        begin

          wieloosobowe__statki_t[ i ].działa_t[ j ].obrót_kąt := statki_t[ i ].działa_t[ j ].TurnAngle;
          wieloosobowe__statki_t[ i ].działa_t[ j ].celownik_linia__podniesienie_kąt := statki_t[ i ].działa_t[ j ].celownik_linia.PitchAngle;
          wieloosobowe__statki_t[ i ].działa_t[ j ].celownik_linia__kolor := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].działa_t[ j ].celownik_linia.LineColor.Color );
          wieloosobowe__statki_t[ i ].działa_t[ j ].celownik_linia__szerokość := statki_t[ i ].działa_t[ j ].celownik_linia.LineWidth;
          wieloosobowe__statki_t[ i ].działa_t[ j ].celownik_linia__wzór := statki_t[ i ].działa_t[ j ].celownik_linia.LinePattern;

          wieloosobowe__statki_t[ i ].działa_t[ j ].amunicja_ilość := statki_t[ i ].działa_t[ j ].amunicja_ilość; // Informacje do wyświetlania dla gracza o jego statku.

          for k := 0 to Length( statki_t[ i ].działa_t[ j ].lufy_t ) - 1 do
            begin

              wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_kąt := statki_t[ i ].działa_t[ j ].lufy_t[ k ].PitchAngle;
              wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z := statki_t[ i ].działa_t[ j ].lufy_t[ k ].korpus.Position.Z;
              wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__pozycja := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].działa_t[ j ].lufy_t[ k ].przeładowanie_wskaźnik.AbsolutePosition );
              wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__kolor := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].działa_t[ j ].lufy_t[ k ].przeładowanie_wskaźnik.Material.FrontProperties.Ambient.Color );

              wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].strzał_gotowość := statki_t[ i ].działa_t[ j ].lufy_t[ k ].strzał_gotowość; // Informacje do wyświetlania dla gracza o jego statku.

            end;
          //---//for k := 0 to Length( statki_t[ i ].działa_t[ j ].lufy_t ) - 1 do

        end;
      //---//for j := 0 to Length( statki_t[ i ].działa_t ) - 1 do


      for j := 0 to Length( statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do
        begin

          wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obrót_kąt := statki_t[ i ].torpedy_wyrzutnie_t[ j ].TurnAngle;
          wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia__podniesienie_kąt := statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia.PitchAngle;
          wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia__kolor := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia.LineColor.Color );
          wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia__szerokość := statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia.LineWidth;
          wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia__wzór := statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia.LinePattern;

          wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].amunicja_ilość := statki_t[ i ].torpedy_wyrzutnie_t[ j ].amunicja_ilość; // Informacje do wyświetlania dla gracza o jego statku.

          for k := 0 to Length( statki_t[ i ].torpedy_wyrzutnie_t[ j ].lufy_t ) - 1 do
            begin

              wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_kąt := statki_t[ i ].torpedy_wyrzutnie_t[ j ].lufy_t[ k ].PitchAngle;
              wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z := statki_t[ i ].torpedy_wyrzutnie_t[ j ].lufy_t[ k ].korpus.Position.Z;
              wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__pozycja := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].torpedy_wyrzutnie_t[ j ].lufy_t[ k ].przeładowanie_wskaźnik.AbsolutePosition );
              wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__kolor := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].torpedy_wyrzutnie_t[ j ].lufy_t[ k ].przeładowanie_wskaźnik.Material.FrontProperties.Ambient.Color );

              wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].strzał_gotowość := statki_t[ i ].torpedy_wyrzutnie_t[ j ].lufy_t[ k ].strzał_gotowość; // Informacje do wyświetlania dla gracza o jego statku.

            end;
          //---//for k := 0 to Length( statki_t[ i ].torpedy_wyrzutnie_t[ j ].lufy_t ) - 1 do

        end;
      //---//for j := 0 to Length( statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do
      {$endregion 'Działa strzelające.'}

      {$region 'Działa ładnie wyglądające.'}
      for j := 0 to Length( statki_t[ i ].artyleria_wygląd_t ) - 1 do
        begin

          wieloosobowe__statki_t[ i ].artyleria_wygląd_t[ j ].obrót_kąt := statki_t[ i ].artyleria_wygląd_t[ j ].TurnAngle;

          for k := 0 to Length( statki_t[ i ].artyleria_wygląd_t[ j ].lufy_t ) - 1 do
            begin

              wieloosobowe__statki_t[ i ].artyleria_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_kąt := statki_t[ i ].artyleria_wygląd_t[ j ].lufy_t[ k ].PitchAngle;
              wieloosobowe__statki_t[ i ].artyleria_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z := statki_t[ i ].artyleria_wygląd_t[ j ].lufy_t[ k ].korpus.Position.Z;
              wieloosobowe__statki_t[ i ].artyleria_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__pozycja := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].artyleria_wygląd_t[ j ].lufy_t[ k ].przeładowanie_wskaźnik.AbsolutePosition );
              wieloosobowe__statki_t[ i ].artyleria_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__kolor := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].artyleria_wygląd_t[ j ].lufy_t[ k ].przeładowanie_wskaźnik.Material.FrontProperties.Ambient.Color );

            end;
          //---//for k := 0 to Length( statki_t[ i ].artyleria_wygląd_t[ j ].lufy_t ) - 1 do

        end;
      //---//for j := 0 to Length( statki_t[ i ].artyleria_wygląd_t ) - 1 do


      for j := 0 to Length( statki_t[ i ].działa_wygląd_t ) - 1 do
        begin

          wieloosobowe__statki_t[ i ].działa_wygląd_t[ j ].obrót_kąt := statki_t[ i ].działa_wygląd_t[ j ].TurnAngle;

          for k := 0 to Length( statki_t[ i ].działa_wygląd_t[ j ].lufy_t ) - 1 do
            begin

              wieloosobowe__statki_t[ i ].działa_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_kąt := statki_t[ i ].działa_wygląd_t[ j ].lufy_t[ k ].PitchAngle;
              wieloosobowe__statki_t[ i ].działa_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z := statki_t[ i ].działa_wygląd_t[ j ].lufy_t[ k ].korpus.Position.Z;
              wieloosobowe__statki_t[ i ].działa_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__pozycja := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].działa_wygląd_t[ j ].lufy_t[ k ].przeładowanie_wskaźnik.AbsolutePosition );
              wieloosobowe__statki_t[ i ].działa_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__kolor := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].działa_wygląd_t[ j ].lufy_t[ k ].przeładowanie_wskaźnik.Material.FrontProperties.Ambient.Color );

            end;
          //---//for k := 0 to Length( statki_t[ i ].działa_wygląd_t[ j ].lufy_t ) - 1 do

        end;
      //---//for j := 0 to Length( statki_t[ i ].działa_wygląd_t ) - 1 do


      for j := 0 to Length( statki_t[ i ].torpedy_wyrzutnie_wygląd_t ) - 1 do
        begin

          wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ].obrót_kąt := statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ].TurnAngle;

          for k := 0 to Length( statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ].lufy_t ) - 1 do
            begin

              wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_kąt := statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ].lufy_t[ k ].PitchAngle;
              wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z := statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ].lufy_t[ k ].korpus.Position.Z;
              wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__pozycja := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ].lufy_t[ k ].przeładowanie_wskaźnik.AbsolutePosition );
              wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__kolor := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ].lufy_t[ k ].przeładowanie_wskaźnik.Material.FrontProperties.Ambient.Color );

            end;
          //---//for k := 0 to Length( statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ].lufy_t ) - 1 do

        end;
      //---//for j := 0 to Length( statki_t[ i ].torpedy_wyrzutnie_wygląd_t ) - 1 do
      {$endregion 'Działa ładnie wyglądające.'}


      // Wysyłane osobną funkcją do przesyłania sterowania (nacisniętych klawiszy). //???
      wieloosobowe__statki_t[ i ].czy_wszystkie_lufy := false; //???

      wieloosobowe__statki_t[ i ].obracaj_działa := statki_t[ i ].obracaj_działa;
      wieloosobowe__statki_t[ i ].podnoś_lufy := statki_t[ i ].podnoś_lufy;

      wieloosobowe__statki_t[ i ].amunicja_rodzaj := ar_Wszystkie; //???


      // Informacje do wyświetlania dla gracza o jego statku.
      wieloosobowe__statki_t[ i ].obracaj_działa := statki_t[ i ].obracaj_działa;
      wieloosobowe__statki_t[ i ].podnoś_lufy := statki_t[ i ].podnoś_lufy;
      wieloosobowe__statki_t[ i ].prędkość_procent := statki_t[ i ].prędkość_procent;
      wieloosobowe__statki_t[ i ].prędkość_zadana_procent := statki_t[ i ].prędkość_zadana_procent;
      wieloosobowe__statki_t[ i ].skręt_procent := statki_t[ i ].skręt_procent;
      wieloosobowe__statki_t[ i ].skręt_zadany_procent := statki_t[ i ].skręt_zadany_procent;
      //---// Informacje do wyświetlania dla gracza o jego statku.

      //wieloosobowe__statki_t[ i ].ztr := statki_t[ i ].śruby_t[ 0 ].obrót_dummy.RollAngle;


      //???
      //wieloosobowe__statki_t[ i ].pozycja.X := wieloosobowe__statki_t[ i ].pozycja.X + 3;
      //wieloosobowe__statki_t[ i ].pozycja.Z := wieloosobowe__statki_t[ i ].pozycja.Z + 4;

    end;
  //---//for i := 0 to Length( statki_t ) - 1 do

end;//---//Funkcja Wieloosobowe_Statki_Parametry_Odczytaj().

//Funkcja Wieloosobowe_Statki_Parametry_Ustaw().
procedure TStatki_Form.Wieloosobowe_Statki_Parametry_Ustaw();

  //Funkcja Parametry_Ustaw() w Wieloosobowe_Statki_Parametry_Ustaw().
  procedure Parametry_Ustaw( statek_f : TStatek; var obiekty_wieloosobowe_statek_r_f : TObiekty_Wieloosobowe__Statek_r );
  var
    // Nie ma i aby było tak samo jak w konstruktorze. //???
    j,
    k
      : integer;
  begin

    if   ( statek_f = nil )
      or (  not Assigned( statek_f )  ) then
      Exit;

    statek_f.AbsolutePosition := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.pozycja );
    statek_f.AbsoluteDirection := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.kierunek );

    statek_f.falowanie_bok_skręt := obiekty_wieloosobowe_statek_r_f.falowanie_bok_skręt;
    statek_f.RollAngle := obiekty_wieloosobowe_statek_r_f.tonięcie__przechylenie__lewo_prawo;
    statek_f.PitchAngle := obiekty_wieloosobowe_statek_r_f.tonięcie__przechylenie__przód_tył;
    statek_f.punkty_życia := obiekty_wieloosobowe_statek_r_f.punkty_życia;
    statek_f.punkty_życia_procent_zostało := obiekty_wieloosobowe_statek_r_f.punkty_życia_procent_zostało;

    if statek_f.punkty_życia_maksymalne <> obiekty_wieloosobowe_statek_r_f.punkty_życia_maksymalne then
      statek_f.punkty_życia_maksymalne := obiekty_wieloosobowe_statek_r_f.punkty_życia_maksymalne;

    statek_f.radar_id_statki_w_zasięgu := obiekty_wieloosobowe_statek_r_f.radar_id_statki_w_zasięgu;
    statek_f.radio_id_statki_w_zasięgu := obiekty_wieloosobowe_statek_r_f.radio_id_statki_w_zasięgu;

    //statek_f.śruby_t[ 0 ].obrót_dummy.RollAngle := obiekty_wieloosobowe_statek_r_f.ztr;

    for j := 0 to Length( statek_f.śruby_t ) - 1 do
      statek_f.śruby_t[ j ].obrót_dummy.RollAngle := obiekty_wieloosobowe_statek_r_f.śruba_obrót_kąt[ j ];

    for j := 0 to Length( statek_f.ster_t ) - 1 do
      statek_f.ster_t[ j ].TurnAngle := obiekty_wieloosobowe_statek_r_f.ster_kąt;


    {$region 'Działa strzelające.'}
    for j := 0 to Length( statek_f.artyleria_t ) - 1 do
      begin

        statek_f.artyleria_t[ j ].czy_lot_parabolą := obiekty_wieloosobowe_statek_r_f.artyleria_t[ j ].czy_lot_parabolą;
        statek_f.artyleria_t[ j ].TurnAngle := obiekty_wieloosobowe_statek_r_f.artyleria_t[ j ].obrót_kąt;
        statek_f.artyleria_t[ j ].celownik_linia.PitchAngle := obiekty_wieloosobowe_statek_r_f.artyleria_t[ j ].celownik_linia__podniesienie_kąt;
        statek_f.artyleria_t[ j ].celownik_linia.LineColor.Color := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.artyleria_t[ j ].celownik_linia__kolor );
        statek_f.artyleria_t[ j ].celownik_linia.LineWidth := obiekty_wieloosobowe_statek_r_f.artyleria_t[ j ].celownik_linia__szerokość;
        statek_f.artyleria_t[ j ].celownik_linia.LinePattern := obiekty_wieloosobowe_statek_r_f.artyleria_t[ j ].celownik_linia__wzór;
        statek_f.artyleria_t[ j ].celownik_linia_bez_falowania.LineColor.Color := statek_f.artyleria_t[ j ].celownik_linia.LineColor.Color;
        statek_f.artyleria_t[ j ].celownik_linia_bez_falowania.LinePattern := statek_f.artyleria_t[ j ].celownik_linia.LinePattern;
        statek_f.artyleria_t[ j ].celownik_linia_bez_falowania.LineWidth := statek_f.artyleria_t[ j ].celownik_linia.LineWidth;
        TTorpedy_Wyrzutnia(statek_f.artyleria_t[ j ]).Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( false );
        statek_f.artyleria_t[ j ].Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( ar_Artyleria_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );

        for k := 0 to Length( statek_f.artyleria_t[ j ].lufy_t ) - 1 do
          begin

            statek_f.artyleria_t[ j ].lufy_t[ k ].PitchAngle := obiekty_wieloosobowe_statek_r_f.artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_kąt;
            statek_f.artyleria_t[ j ].lufy_t[ k ].korpus.Position.Z := obiekty_wieloosobowe_statek_r_f.artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z;
            statek_f.artyleria_t[ j ].lufy_t[ k ].przeładowanie_wskaźnik.AbsolutePosition := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__pozycja );
            statek_f.artyleria_t[ j ].lufy_t[ k ].przeładowanie_wskaźnik.Material.FrontProperties.Ambient.Color := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__kolor );

          end;
        //---//for k := 0 to Length( statek_f.artyleria_t[ j ].lufy_t ) - 1 do

      end;
    //---//for j := 0 to Length( statek_f.artyleria_t ) - 1 do


    for j := 0 to Length( statek_f.działa_t ) - 1 do
      begin

        statek_f.działa_t[ j ].TurnAngle := obiekty_wieloosobowe_statek_r_f.działa_t[ j ].obrót_kąt;
        statek_f.działa_t[ j ].celownik_linia.PitchAngle := obiekty_wieloosobowe_statek_r_f.działa_t[ j ].celownik_linia__podniesienie_kąt;
        statek_f.działa_t[ j ].celownik_linia.LineColor.Color := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.działa_t[ j ].celownik_linia__kolor );
        statek_f.działa_t[ j ].celownik_linia.LineWidth := obiekty_wieloosobowe_statek_r_f.działa_t[ j ].celownik_linia__szerokość;
        statek_f.działa_t[ j ].celownik_linia.LinePattern := obiekty_wieloosobowe_statek_r_f.działa_t[ j ].celownik_linia__wzór;
        statek_f.działa_t[ j ].celownik_linia_bez_falowania.LineColor.Color := statek_f.działa_t[ j ].celownik_linia.LineColor.Color;
        statek_f.działa_t[ j ].celownik_linia_bez_falowania.LinePattern := statek_f.działa_t[ j ].celownik_linia.LinePattern;
        statek_f.działa_t[ j ].celownik_linia_bez_falowania.LineWidth := statek_f.działa_t[ j ].celownik_linia.LineWidth;
        TTorpedy_Wyrzutnia(statek_f.działa_t[ j ]).Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( false );
        statek_f.działa_t[ j ].Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( ar_Pocisk_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );

        for k := 0 to Length( statek_f.działa_t[ j ].lufy_t ) - 1 do
          begin

            statek_f.działa_t[ j ].lufy_t[ k ].PitchAngle := obiekty_wieloosobowe_statek_r_f.działa_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_kąt;
            statek_f.działa_t[ j ].lufy_t[ k ].korpus.Position.Z := obiekty_wieloosobowe_statek_r_f.działa_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z;
            statek_f.działa_t[ j ].lufy_t[ k ].przeładowanie_wskaźnik.AbsolutePosition := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.działa_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__pozycja );
            statek_f.działa_t[ j ].lufy_t[ k ].przeładowanie_wskaźnik.Material.FrontProperties.Ambient.Color := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.działa_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__kolor );

          end;
        //---//for k := 0 to Length( statek_f.działa_t[ j ].lufy_t ) - 1 do

      end;
    //---//for j := 0 to Length( statek_f.działa_t ) - 1 do


    for j := 0 to Length( statek_f.torpedy_wyrzutnie_t ) - 1 do
      begin

        statek_f.torpedy_wyrzutnie_t[ j ].TurnAngle := obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_t[ j ].obrót_kąt;
        statek_f.torpedy_wyrzutnie_t[ j ].celownik_linia.PitchAngle := obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_t[ j ].celownik_linia__podniesienie_kąt;
        statek_f.torpedy_wyrzutnie_t[ j ].celownik_linia.LineColor.Color := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_t[ j ].celownik_linia__kolor );
        statek_f.torpedy_wyrzutnie_t[ j ].celownik_linia.LineWidth := obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_t[ j ].celownik_linia__szerokość;
        statek_f.torpedy_wyrzutnie_t[ j ].celownik_linia.LinePattern := obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_t[ j ].celownik_linia__wzór;
        statek_f.torpedy_wyrzutnie_t[ j ].celownik_linia_bez_falowania.LineColor.Color := statek_f.torpedy_wyrzutnie_t[ j ].celownik_linia.LineColor.Color;
        statek_f.torpedy_wyrzutnie_t[ j ].celownik_linia_bez_falowania.LinePattern := statek_f.torpedy_wyrzutnie_t[ j ].celownik_linia.LinePattern;
        statek_f.torpedy_wyrzutnie_t[ j ].celownik_linia_bez_falowania.LineWidth := statek_f.torpedy_wyrzutnie_t[ j ].celownik_linia.LineWidth;
        statek_f.torpedy_wyrzutnie_t[ j ].Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( ar_Torpeda_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );

        for k := 0 to Length( statek_f.torpedy_wyrzutnie_t[ j ].lufy_t ) - 1 do
          begin

            statek_f.torpedy_wyrzutnie_t[ j ].lufy_t[ k ].PitchAngle := obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_kąt;
            statek_f.torpedy_wyrzutnie_t[ j ].lufy_t[ k ].korpus.Position.Z := obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z;
            statek_f.torpedy_wyrzutnie_t[ j ].lufy_t[ k ].przeładowanie_wskaźnik.AbsolutePosition := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__pozycja );
            statek_f.torpedy_wyrzutnie_t[ j ].lufy_t[ k ].przeładowanie_wskaźnik.Material.FrontProperties.Ambient.Color := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__kolor );

          end;
        //---//for k := 0 to Length( statek_f.torpedy_wyrzutnie_t[ j ].lufy_t ) - 1 do

      end;
    //---//for j := 0 to Length( statek_f.torpedy_wyrzutnie_t ) - 1 do
    {$endregion 'Działa strzelające.'}

    {$region 'Działa ładnie wyglądające.'}
    for j := 0 to Length( statek_f.artyleria_wygląd_t ) - 1 do
      begin

        statek_f.artyleria_wygląd_t[ j ].TurnAngle := obiekty_wieloosobowe_statek_r_f.artyleria_wygląd_t[ j ].obrót_kąt;

        for k := 0 to Length( statek_f.artyleria_wygląd_t[ j ].lufy_t ) - 1 do
          begin

            statek_f.artyleria_wygląd_t[ j ].lufy_t[ k ].PitchAngle := obiekty_wieloosobowe_statek_r_f.artyleria_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_kąt;
            statek_f.artyleria_wygląd_t[ j ].lufy_t[ k ].korpus.Position.Z := obiekty_wieloosobowe_statek_r_f.artyleria_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z;
            statek_f.artyleria_wygląd_t[ j ].lufy_t[ k ].przeładowanie_wskaźnik.AbsolutePosition := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.artyleria_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__pozycja );
            statek_f.artyleria_wygląd_t[ j ].lufy_t[ k ].przeładowanie_wskaźnik.Material.FrontProperties.Ambient.Color := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.artyleria_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__kolor );

          end;
        //---//for k := 0 to Length( statek_f.artyleria_wygląd_t[ j ].lufy_t ) - 1 do

      end;
    //---//for j := 0 to Length( statek_f.artyleria_wygląd_t ) - 1 do


    for j := 0 to Length( statek_f.działa_wygląd_t ) - 1 do
      begin

        statek_f.działa_wygląd_t[ j ].TurnAngle := obiekty_wieloosobowe_statek_r_f.działa_wygląd_t[ j ].obrót_kąt;

        for k := 0 to Length( statek_f.działa_wygląd_t[ j ].lufy_t ) - 1 do
          begin

            statek_f.działa_wygląd_t[ j ].lufy_t[ k ].PitchAngle := obiekty_wieloosobowe_statek_r_f.działa_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_kąt;
            statek_f.działa_wygląd_t[ j ].lufy_t[ k ].korpus.Position.Z := obiekty_wieloosobowe_statek_r_f.działa_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z;
            statek_f.działa_wygląd_t[ j ].lufy_t[ k ].przeładowanie_wskaźnik.AbsolutePosition := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.działa_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__pozycja );
            statek_f.działa_wygląd_t[ j ].lufy_t[ k ].przeładowanie_wskaźnik.Material.FrontProperties.Ambient.Color := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.działa_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__kolor );

          end;
        //---//for k := 0 to Length( statek_f.działa_wygląd_t[ j ].lufy_t ) - 1 do

      end;
    //---//for j := 0 to Length( statek_f.działa_wygląd_t ) - 1 do


    for j := 0 to Length( statek_f.torpedy_wyrzutnie_wygląd_t ) - 1 do
      begin

        statek_f.torpedy_wyrzutnie_wygląd_t[ j ].TurnAngle := obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_wygląd_t[ j ].obrót_kąt;

        for k := 0 to Length( statek_f.torpedy_wyrzutnie_wygląd_t[ j ].lufy_t ) - 1 do
          begin

            statek_f.torpedy_wyrzutnie_wygląd_t[ j ].lufy_t[ k ].PitchAngle := obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_kąt;
            statek_f.torpedy_wyrzutnie_wygląd_t[ j ].lufy_t[ k ].korpus.Position.Z := obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z;
            statek_f.torpedy_wyrzutnie_wygląd_t[ j ].lufy_t[ k ].przeładowanie_wskaźnik.AbsolutePosition := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__pozycja );
            statek_f.torpedy_wyrzutnie_wygląd_t[ j ].lufy_t[ k ].przeładowanie_wskaźnik.Material.FrontProperties.Ambient.Color := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__kolor );

          end;
        //---//for k := 0 to Length( statek_f.torpedy_wyrzutnie_wygląd_t[ j ].lufy_t ) - 1 do

      end;
    //---//for j := 0 to Length( statek_f.torpedy_wyrzutnie_wygląd_t ) - 1 do
    {$endregion 'Działa ładnie wyglądające.'}


    obiekty_wieloosobowe_statek_r_f.przeliczone := true;

    // ???
    //statek_f.Position.X := statek_f.Position.X + 3;
    //statek_f.Position.Z := statek_f.Position.Z + 4;

    if not statek_f.Visible then
      statek_f.Visible := true; // Po przywróceniu statku do gry klient umieszcza go na wyliczonej samodzielnie pozycji i dopiero po odebraniu danych o pozycji z serwera zaktualizuje pozycję statku i ustawi na widoczny.


    {$region 'Informacje do wyświetlania dla gracza o jego statku.'}
    if    ( statek_gracza <> nil )
      and ( statek_f.id_statek = Gracz_Identyfikator() ) then //statek_gracza.id_statek
      begin

        // Potem można przesyłać po TCP tylko do danego gracza.

        statek_gracza.obracaj_działa := obiekty_wieloosobowe_statek_r_f.obracaj_działa;
        statek_gracza.podnoś_lufy := obiekty_wieloosobowe_statek_r_f.podnoś_lufy;
        statek_gracza.prędkość_procent := obiekty_wieloosobowe_statek_r_f.prędkość_procent;
        statek_gracza.prędkość_zadana_procent := obiekty_wieloosobowe_statek_r_f.prędkość_zadana_procent;
        statek_gracza.skręt_procent := obiekty_wieloosobowe_statek_r_f.skręt_procent;
        statek_gracza.skręt_zadany_procent := obiekty_wieloosobowe_statek_r_f.skręt_zadany_procent;

        for j := 0 to Length( statek_gracza.artyleria_t ) - 1 do
          begin

            statek_gracza.artyleria_t[ j ].amunicja_ilość := obiekty_wieloosobowe_statek_r_f.artyleria_t[ j ].amunicja_ilość;

            for k := 0 to Length( statek_gracza.artyleria_t[ j ].lufy_t ) - 1 do
              statek_gracza.artyleria_t[ j ].lufy_t[ k ].strzał_gotowość := obiekty_wieloosobowe_statek_r_f.artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].strzał_gotowość;

          end;
        //---//for j := 0 to Length( Self.artyleria_t ) - 1 do

        for j := 0 to Length( statek_gracza.działa_t ) - 1 do
          begin

            statek_gracza.działa_t[ j ].amunicja_ilość := obiekty_wieloosobowe_statek_r_f.działa_t[ j ].amunicja_ilość;

            for k := 0 to Length( statek_gracza.działa_t[ j ].lufy_t ) - 1 do
              statek_gracza.działa_t[ j ].lufy_t[ k ].strzał_gotowość := obiekty_wieloosobowe_statek_r_f.działa_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].strzał_gotowość;

          end;
        //---//for j := 0 to Length( Self.działa_t ) - 1 do

        for j := 0 to Length( statek_gracza.torpedy_wyrzutnie_t ) - 1 do
          begin

            statek_gracza.torpedy_wyrzutnie_t[ j ].amunicja_ilość := obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_t[ j ].amunicja_ilość;

            for k := 0 to Length( statek_gracza.torpedy_wyrzutnie_t[ j ].lufy_t ) - 1 do
              statek_gracza.torpedy_wyrzutnie_t[ j ].lufy_t[ k ].strzał_gotowość := obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].strzał_gotowość;

          end;
        //---//for j := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do

      end;
    //---//if    ( statek_gracza <> nil ) (...)
    {$endregion 'Informacje do wyświetlania dla gracza o jego statku.'}

  end;//---//Funkcja Parametry_Ustaw() w Wieloosobowe_Statki_Parametry_Ustaw().

var
  i,
  j
    : integer;
begin//Funkcja Wieloosobowe_Statki_Parametry_Ustaw().

  //
  // Funkcja ustawia parametry statków wieloosobowych.
  //

  if Length( statki_t ) <> Length( wieloosobowe__statki_t ) then
    begin

      Wieloosobowe_Statki_Utwórz();

    end;
  //---//if Length( statki_t ) <> Length( wieloosobowe__statki_t ) then



  for i := 0 to Length( wieloosobowe__statki_t ) - 1 do
    if not wieloosobowe__statki_t[ i ].przeliczone then
      begin

        for j := 0 to Length( statki_t ) - 1 do
          if wieloosobowe__statki_t[ i ].id_statek = statki_t[ j ].id_statek then
            begin

              // Jeżeli wcześniej utworzony statek jest na otrzymanej liście statków ustawia jego aktualne parametry.

              Parametry_Ustaw( statki_t[ j ], wieloosobowe__statki_t[ i ] );
              Break;

            end;
          //---//if wieloosobowe__statki_t[ i ].id_statek = statki_t[ j ].id_statek then

      end;
    //---//if not wieloosobowe__statki_t[ i ].przeliczone then


  for i := 0 to Length( wieloosobowe__statki_t ) - 1 do
    if not wieloosobowe__statki_t[ i ].przeliczone then
      Wieloosobowe_Statki_Utwórz();


  if klient_pierwsze_ustawienie_kamery_g then
    begin

      klient_pierwsze_ustawienie_kamery_g := false;

      if not ( GLCamera1.Parent is TStatek ) then
        Kamera_Przełącz( kt_Statek ); // Ustawi kamerę na statku gracza.

    end;
  //---//if klient_pierwsze_ustawienie_kamery_g then

end;//---//Funkcja Wieloosobowe_Statki_Parametry_Ustaw().

//Funkcja Wieloosobowe__Tekst_Wyślij().
procedure TStatki_Form.Wieloosobowe__Tekst_Wyślij( const napis_f : string; const peer_port_f : integer = -99 );
var
  i : integer;
  lista : TList;
begin

  if not czy_serwer_g then
    begin

      // Klient.

      if IdTCPClient1.Connected then
        begin

          IdTCPClient1.IOHandler.WriteLn( napis_f, IdGlobal.IndyTextEncoding_UTF8 );

        end;
      //---//if IdTCPClient1.Connected then

    end
  else//if not czy_serwer_g then
    begin

      // Serwer.

      lista := IdTCPServer1.Contexts.LockList();

      try
        for i := 0 to lista.Count - 1 do
          if   ( peer_port_f = -99 )
            or ( TIdContext(lista[ i ]).Connection.Socket.Binding.PeerPort = peer_port_f ) then
            begin
              try
                TIdContext(lista[ i ]).Connection.IOHandler.WriteLn( napis_f, IdGlobal.IndyTextEncoding_UTF8 );
              except
                on E : Exception do
                  begin
                    Wieloosobowe__Log_Wypisz(
                        'Nie udało się wysłać danych (t) do klienta: ' + IntToStr( TIdContext(lista[ i ]).Binding.PeerPort ) + #13 + #10 +
                        E.Message + ' ' + IntToStr( E.HelpContext ) + '.'
                      );
                    //Application.MessageBox(
                    //    PChar('Nie udało się wysłać danych (t) do klienta: ' + IntToStr( TIdContext(lista[ i ]).Binding.PeerPort ) + #13 +
                    //    E.Message + ' ' + IntToStr( E.HelpContext ) + '.'), 'Błąd',
                    //    MB_OK + MB_ICONEXCLAMATION
                    //  );
                  end;
              end;
            end;
          //---//if   ( peer_port_f = -99 ) (...)
      finally
        IdTCPServer1.Contexts.UnlockList();
      end;
      //---//try

    end;
  //---//if not czy_serwer_g then

end;//---//Funkcja Wieloosobowe__Tekst_Wyślij().

//Funkcja Wieloosobowe__Tekst_Wyślij_UDP().
procedure TStatki_Form.Wieloosobowe__Tekst_Wyślij_UDP( const napis_f : string );
var
  i : integer;
  lista : TList;
begin

  if not czy_serwer_g then
    begin

      // Klient.

      if IdUDPClient1.Connected then // Tylko podłącza klienta do portu (lokalnie). Jeżeli nie ma serwera i tak wyświetla, że się połączył.
        begin

          IdUDPClient1.Send( napis_f, IdGlobal.IndyTextEncoding_UTF8 ); // W XE 3 IdGlobal.TIdTextEncoding.UTF8. // try nie obsługuje błędu (np. gdy nie ma serwera).

        end;
      //---//if IdUDPClient1.Connected then

    end
  else//if not czy_serwer_g then
    begin

      // Serwer.

      for i := udp_klienci_lista_g.klienci_lista_list.Count - 1 downto 0 do
        begin

          IdUDPServer1.Send( TUDP_Klient_Dane(udp_klienci_lista_g.klienci_lista_list[ i ]).adres_ip, TUDP_Klient_Dane(udp_klienci_lista_g.klienci_lista_list[ i ]).peer_port, napis_f, IdGlobal.IndyTextEncoding_UTF8 );

        end;
      //---//for i := udp_klienci_lista_g.klienci_lista_list.Count - 1 downto 0 do

    end;
  //---//if not czy_serwer_g then

end;//---//Funkcja Wieloosobowe__Tekst_Wyślij_UDP().

//Funkcja Wieloosobowe__Strumień_Wyślij().
procedure TStatki_Form.Wieloosobowe__Strumień_Wyślij( const komenda_f : string; const peer_port_f : integer; const wartość_f : TWieloosobowe_String; const czy_udp_f : boolean = false );

  //Funkcja Strumień_Napis_Wpisz() w Wieloosobowe__Strumień_Wyślij().
  procedure Strumień_Napis_Wpisz( napis_f : string; strumień_pamięci_f : TMemoryStream );
  var
    i : integer;
    zt_wieloosobowe_string : TWieloosobowe_String;
  begin

    i := Ceil(  Length( napis_f ) / High( zt_wieloosobowe_string )  );

    strumień_pamięci_f.Write(  i, SizeOf( i )  );


    while Length( napis_f ) > 0 do
      begin

        zt_wieloosobowe_string := Copy(  napis_f, 1, High( zt_wieloosobowe_string )  );
        Delete(  napis_f, 1, High( zt_wieloosobowe_string )  );

        strumień_pamięci_f.Write( zt_wieloosobowe_string, wieloosobowe_string__rozmiar_c );

      end;
    //---//while Length( napis_f ) > 0 do

  end;//---//Funkcja Strumień_Napis_Wpisz() w Wieloosobowe__Strumień_Wyślij().

var
  i,
  j,
  k
    : integer;
  zts : string;
  lista : TList;
  zt_tcp_klient_dane : TTCP_Klient_Dane;
  strumień_pamięci_l : TMemoryStream;
  zt_id_bytes : TIdBytes;
begin//Funkcja Wieloosobowe__Strumień_Wyślij().

  //
  // Funkcja wysyła zadany rekord danych - komenda (komenda_f) jest wysyłana zawsze.
  //
  // Parametry:
  //   komenda_f - rodzaj rekordu.
  //   peer_port_f
  //       (parametr nie ma znaczenia gdy wysyła klient)
  //     -99 - serwer wysyła do wszystkich klientów.
  //     <> -99 - serwer wysyła do wskazanego klienta.
  //   wartość_f - wartość wysyłana w poleceniu.
  //   czy_udp_f
  //     false - wysyła poprzez TCP.
  //     true - wysyła poprzez UDP.
  //


  if   (  Trim( komenda_f ) = ''  )
    or (
             ( komenda_f <> wieloosobowe__komenda__gra__rozpocznij_c )
         and ( komenda_f <> wieloosobowe__komenda__gra__zakończ_c )
         and ( komenda_f <> wieloosobowe__komenda__gra_współczynnik_prędkości_c )
         and ( komenda_f <> wieloosobowe__komenda__gracz_gotowość_c )
         and ( komenda_f <> wieloosobowe__komenda__gracz_lista_odśwież_c )
         and ( komenda_f <> wieloosobowe__komenda__hasło__sprawdź_c )
         and ( komenda_f <> wieloosobowe__komenda__identyfikator__nadaj_c )
         and ( komenda_f <> wieloosobowe__komenda__identyfikator__przypomnij_c )
         and ( komenda_f <> wieloosobowe__komenda__identyfikator__zapamiętaj_c )
         and ( komenda_f <> wieloosobowe__komenda__odbierz__ląd_definicja_c )
         and ( komenda_f <> wieloosobowe__komenda__odbierz__prymitywy_definicja_c )
         and ( komenda_f <> wieloosobowe__komenda__odbierz__rekord_amunicja_c )
         and ( komenda_f <> wieloosobowe__komenda__odbierz__rekord_efekt_c )
         and ( komenda_f <> wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c )
         and ( komenda_f <> wieloosobowe__komenda__odbierz__rekord_statki_c )
         and ( komenda_f <> wieloosobowe__komenda__odbierz__statki_definicje_c )
         and ( komenda_f <> wieloosobowe__komenda__pauza_c )
         //and ( komenda_f <> wieloosobowe__komenda__serwer_wyłącza_się_c )
         and ( komenda_f <> wieloosobowe__komenda__statek__klawisze_obsługa_c )
         and ( komenda_f <> wieloosobowe__komenda__statek__przywróć_do_gry_c )
         and ( komenda_f <> wieloosobowe__komenda__udp__klient_połączony_nadal_c )
         and ( komenda_f <> wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_r_c )
         and ( komenda_f <> wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_2_r_c )
       ) then
    Exit;


  strumień_pamięci_l := TMemoryStream.Create();


  {$region 'Zapisuje rekord do strumienia.'}
  //if komenda_f = wieloosobowe__komenda__gra__rozpocznij_c then
  //  begin
  //  end
  //else//if komenda_f = wieloosobowe__komenda__gra__rozpocznij_c then
  //if komenda_f = wieloosobowe__komenda__gra__zakończ_c then
  //  begin
  //  end
  //else//if komenda_f = wieloosobowe__komenda__gra__zakończ_c then
  if komenda_f = wieloosobowe__komenda__gra_współczynnik_prędkości_c then
    begin

      if czy_serwer_g then
        begin

          // Tylko serwer wysyła informację o współczynniku prędkości gry.

          Strumień_Napis_Wpisz( wartość_f, strumień_pamięci_l );

        end;
      //---//if czy_serwer_g then

    end
  else//if komenda_f = wieloosobowe__komenda__gra_współczynnik_prędkości_c then
  if komenda_f = wieloosobowe__komenda__gracz_gotowość_c then
    begin

      if czy_serwer_g then
        begin

          // Serwer potwierdza, że gracz jest gotowy.

          if wartość_f = 'Tak' then
            begin

              Strumień_Napis_Wpisz( wartość_f, strumień_pamięci_l );

            end;
          //---//if wartość_f = 'Tak' then

        end
      else//if czy_serwer_g then
      if czy_klient_g then
        begin

          // Tylko klient zwraca się o nadanie statusu gotowości.

          Strumień_Napis_Wpisz( wartość_f, strumień_pamięci_l );

          if wartość_f = 'Tak' then
            begin

              i := Gracz_Grupa_SpinEdit.Value;
              strumień_pamięci_l.Write(  i, SizeOf ( integer )  );

              i := Statek_ComboBox.ItemIndex;
              strumień_pamięci_l.Write(  i, SizeOf ( integer )  );

              Strumień_Napis_Wpisz( Gracz_Nazwa_Edit.Text, strumień_pamięci_l );

            end;
          //---//if wartość_f = 'Tak' then

        end;
      //---//if czy_klient_g then

    end
  else//if komenda_f = wieloosobowe__komenda__gracz_gotowość_c then
  if komenda_f = wieloosobowe__komenda__gracz_lista_odśwież_c then
    begin

      if czy_serwer_g then
        begin

          // Tylko serwer wysyła listę graczy.

          Strumień_Napis_Wpisz( Ląd_ComboBox.Text, strumień_pamięci_l );

          if Statki_Pozycje_Początkowe_ComboBox.ItemIndex > 0 then
            Strumień_Napis_Wpisz( Statki_Pozycje_Początkowe_ComboBox.Text, strumień_pamięci_l )
          else//if Statki_Pozycje_Początkowe_ComboBox.ItemIndex > 0 then
            Strumień_Napis_Wpisz( '<według mapy>', strumień_pamięci_l );


          for i := 0 to tcp_klienci_lista_g.klienci_lista_list.Count - 1 do
            begin

              zt_tcp_klient_dane := TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]);


              strumień_pamięci_l.Write(  zt_tcp_klient_dane.identyfikator, SizeOf( integer )  );
              strumień_pamięci_l.Write(  zt_tcp_klient_dane.id_grupa, SizeOf( integer )  );
              strumień_pamięci_l.Write(  zt_tcp_klient_dane.id_statek_schemat, SizeOf( integer )  );
              strumień_pamięci_l.Write(  zt_tcp_klient_dane.peer_port_tcp, SizeOf( integer )  );
              strumień_pamięci_l.Write(  zt_tcp_klient_dane.peer_port_udp, SizeOf( integer )  );

              strumień_pamięci_l.Write(  zt_tcp_klient_dane.data_czas__dłączenia, SizeOf( TDateTime )  );
              strumień_pamięci_l.Write(  zt_tcp_klient_dane.data_czas__podłączenia, SizeOf( TDateTime )  );
              strumień_pamięci_l.Write(  zt_tcp_klient_dane.data_czas__podłączenia_ostatniego, SizeOf( TDateTime )  );
              strumień_pamięci_l.Write(  zt_tcp_klient_dane.data_czas__udp_kontakt, SizeOf( TDateTime )  );

              strumień_pamięci_l.Write(  zt_tcp_klient_dane.gotowy, SizeOf( boolean )  );
              strumień_pamięci_l.Write(  zt_tcp_klient_dane.odłączony, SizeOf( boolean )  );

              strumień_pamięci_l.Write( zt_tcp_klient_dane.nazwa, wieloosobowe_string__rozmiar_c );

            end;
          //---//klienci_lista_list

        end
      //---//if czy_serwer_g then

      // Klienta pyta serwer o aktualną listę graczy.

    end
  else//if komenda_f = wieloosobowe__komenda__gracz_lista_odśwież_c then
  if komenda_f = wieloosobowe__komenda__hasło__sprawdź_c then
    begin

      if czy_serwer_g then
        begin

          // Serwer wysyła odpowiedź czy hasło jest prawidłowe.

          Strumień_Napis_Wpisz( wartość_f, strumień_pamięci_l );

        end;
      //else//if czy_serwer_g then
      //if czy_klient_g then
      //  begin
      //
      //    // Tylko klient wysyła hasło do sprawdzenia.
      //
      //    Strumień_Napis_Wpisz( Hasło_Edit.Text, strumień_pamięci_l );
      //
      //  end;
      ////---//if czy_klient_g then

    end
  else//if komenda_f = wieloosobowe__komenda__hasło__sprawdź_c then
  if komenda_f = wieloosobowe__komenda__identyfikator__nadaj_c then
    begin

      if czy_klient_g then
        begin

          // Tylko klient zwraca się o nadanie identyfikatora.

          Strumień_Napis_Wpisz( Hasło_Edit.Text, strumień_pamięci_l ); // Tylko klient wysyła hasło do sprawdzenia.

        end;
      //---//if czy_klient_g then

    end
  else//if komenda_f = wieloosobowe__komenda__identyfikator__nadaj_c then
  if komenda_f = wieloosobowe__komenda__identyfikator__przypomnij_c then
    begin

      if czy_klient_g then
        begin

          // Tylko klient przypomina swój identyfikator.

          Strumień_Napis_Wpisz( Hasło_Edit.Text, strumień_pamięci_l ); // Tylko klient wysyła hasło do sprawdzenia.
          Strumień_Napis_Wpisz( wartość_f, strumień_pamięci_l );

        end;
      //---//if czy_klient_g then

    end
  else//if komenda_f = wieloosobowe__komenda__identyfikator__przypomnij_c then
  if komenda_f = wieloosobowe__komenda__identyfikator__zapamiętaj_c then
    begin

      if czy_serwer_g then
        begin

          // Tylko serwer nadaje identyfikator.

          Strumień_Napis_Wpisz( wartość_f, strumień_pamięci_l );

        end;
      //---//if czy_serwer_g then

    end
  else//if komenda_f = wieloosobowe__komenda__identyfikator__zapamiętaj_c then
  if komenda_f = wieloosobowe__komenda__odbierz__ląd_definicja_c then
    begin

      if not czy_klient_g then
        begin

          // Tylko serwer wysyła dane o lądzie.

          Strumień_Napis_Wpisz( ląd_definicja_g, strumień_pamięci_l );

        end;
      //---//if not czy_klient_g then

    end
  else//if komenda_f = wieloosobowe__komenda__odbierz__ląd_definicja_c then
  if komenda_f = wieloosobowe__komenda__odbierz__prymitywy_definicja_c then
    begin

      if not czy_klient_g then
        begin

          // Tylko serwer wysyła dane o prymitywach.

          try
            i := StrToInt( wartość_f );
          except
            i := -99;
          end;
          //---//try

          if    ( i >= 0 )
            and (  i <= Length( prymitywy_lista_t ) - 1  ) then
            begin

              Strumień_Napis_Wpisz( prymitywy_lista_t[ i ].plik_nazwa, strumień_pamięci_l );
              Strumień_Napis_Wpisz( prymitywy_lista_t[ i ].treść, strumień_pamięci_l );

            end;
          //---//if    ( i >= 0 ) (...)

        end;
      //---//if not czy_klient_g then

    end
  else//if komenda_f = wieloosobowe__komenda__odbierz__prymitywy_definicja_c then
  if komenda_f = wieloosobowe__komenda__odbierz__rekord_amunicja_c then
    begin

      Wieloosobowe_Amunicja_Parametry_Odczytaj();


      for i := 0 to Length( wieloosobowe__amunicja_t ) - 1 do
        begin

          strumień_pamięci_l.Write( wieloosobowe__amunicja_t[ i ], obiekty_wieloosobowe__amunicja_r__rozmiar_c );

        end;
      //---//for i := 0 to Length( wieloosobowe__amunicja_t ) - 1 do

    end
  else//if komenda_f = wieloosobowe__komenda__odbierz__rekord_amunicja_c then
  if komenda_f = wieloosobowe__komenda__odbierz__rekord_efekt_c then
    begin

      strumień_pamięci_l.Write( wieloosobowe__efekt_r, obiekty_wieloosobowe__efekt_r__rozmiar_c );

      // Efekt wysyłany jako tabela.
      //for i := 0 to Length( wieloosobowe__efekt_t ) - 1 do
      //  begin
      //
      //    if not wieloosobowe__efekt_t[ i ].wysłane then
      //      begin
      //
      //        strumień_pamięci_l.Write( wieloosobowe__efekt_t[ i ], obiekty_wieloosobowe__efekt_r__rozmiar_c );
      //        wieloosobowe__efekt_t[ i ].wysłane := true;
      //
      //      end;
      //    //---//if not wieloosobowe__efekt_t[ i ].wysłane then
      //
      //  end;
      ////---//for i := 0 to Length( wieloosobowe__efekt_t ) - 1 do

    end
  else//if komenda_f = wieloosobowe__komenda__odbierz__rekord_efekt_c then
  if komenda_f = wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c then
    begin

      //pokój_rozmów_r.wiadomość__długość := Length( pokój_rozmów_r.wiadomość );
      strumień_pamięci_l.Write( pokój_rozmów_r, pokój_rozmów_r__rozmiar_c );

      // Gdy będą napisy z dowolną długością.
      //if pokój_rozmów_r.wiadomość__długość > 0 then
      //  strumień_pamięci_l.WriteBuffer(
      //      Pointer( pokój_rozmów_r.wiadomość )^, // value of first name
      //      char_rozmiar_c * pokój_rozmów_r.wiadomość__długość
      //    );

    end
  else//if komenda_f = wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c then
  if komenda_f = wieloosobowe__komenda__odbierz__rekord_statki_c then
    begin

      Wieloosobowe_Statki_Parametry_Odczytaj();

      {$region 'Zakomentowane - obsługiwane w taki sposób zgłasza błędy dostępu - wieloosobowe__komenda__odbierz__rekord_statki_c.'}
      //for i := 0 to Length( wieloosobowe__statki_t ) - 1 do
      //  begin
      //
      //    strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ], obiekty_wieloosobowe__statki_r__rozmiar_c );
      //
      //
      //    for j := 0 to Length( wieloosobowe__statki_t[ i ].śruba_obrót_kąt ) - 1 do
      //      strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].śruba_obrót_kąt[ j ], SizeOf( real )  );
      //
      //
      //    for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t ) - 1 do
      //      begin
      //
      //        strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].artyleria_t[ j ], obiekty_wieloosobowe__działo_r__rozmiar_c  );
      //
      //        for k := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
      //          strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );
      //
      //      end;
      //    //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t ) - 1 do
      //
      //    for j := 0 to Length( wieloosobowe__statki_t[ i ].działa_t ) - 1 do
      //      begin
      //
      //        strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].działa_t[ j ], obiekty_wieloosobowe__działo_r__rozmiar_c  );
      //
      //        for k := 0 to Length( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
      //          strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );
      //
      //      end;
      //    //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].działa_t ) - 1 do
      //
      //    for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do
      //      begin
      //
      //        strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ], obiekty_wieloosobowe__działo_r__rozmiar_c  );
      //
      //        for k := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
      //          strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );
      //
      //      end;
      //    //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do
      //
      //
      //    for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_wygląd_t ) - 1 do
      //      begin
      //
      //        strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].artyleria_wygląd_t[ j ], obiekty_wieloosobowe__działo_r__rozmiar_c  );
      //
      //        for k := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
      //          strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].artyleria_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );
      //
      //      end;
      //    //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_wygląd_t ) - 1 do
      //
      //    for j := 0 to Length( wieloosobowe__statki_t[ i ].działa_wygląd_t ) - 1 do
      //      begin
      //
      //        strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].działa_wygląd_t[ j ], obiekty_wieloosobowe__działo_r__rozmiar_c  );
      //
      //        for k := 0 to Length( wieloosobowe__statki_t[ i ].działa_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
      //          strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].działa_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );
      //
      //      end;
      //    //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].działa_wygląd_t ) - 1 do
      //
      //    for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t ) - 1 do
      //      begin
      //
      //        strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ], obiekty_wieloosobowe__działo_r__rozmiar_c  );
      //
      //        for k := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
      //          strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );
      //
      //      end;
      //    //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t ) - 1 do
      //
      //  end;
      ////---//for i := 0 to Length( rekord_r_t ) - 1 do
      {$endregion 'Zakomentowane - obsługiwane w taki sposób zgłasza błędy dostępu - wieloosobowe__komenda__odbierz__rekord_statki_c.'}


      {$region 'wieloosobowe__komenda__odbierz__rekord_statki_c.'}
      for i := 0 to Length( wieloosobowe__statki_t ) - 1 do
        begin

          //strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ], obiekty_wieloosobowe__statki_r__rozmiar_c );

          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].id_grupa, SizeOf( integer )  );
          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].id_statek, SizeOf( integer )  );
          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].id_statek_schemat, SizeOf( integer )  );
          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].artyleria_t__długość_tabeli, SizeOf( integer )  );
          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].działa_t__długość_tabeli, SizeOf( integer )  );
          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t__długość_tabeli, SizeOf( integer )  );
          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].artyleria_wygląd_t__długość_tabeli, SizeOf( integer )  );
          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].działa_wygląd_t__długość_tabeli, SizeOf( integer )  );
          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t__długość_tabeli, SizeOf( integer )  );
          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].śruba_obrót_kąt__długość, SizeOf( integer )  );

          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].falowanie_bok_skręt, SizeOf( real )  );
          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].prędkość_procent, SizeOf( real )  );
          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].prędkość_zadana_procent, SizeOf( real )  );
          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].punkty_życia, SizeOf( real )  );
          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].punkty_życia_maksymalne, SizeOf( real )  );
          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].punkty_życia_procent_zostało, SizeOf( real )  );
          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].skręt_procent, SizeOf( real )  );
          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].skręt_zadany_procent, SizeOf( real )  );
          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].ster_kąt, SizeOf( real )  );
          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].tonięcie__przechylenie__lewo_prawo, SizeOf( real )  );
          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].tonięcie__przechylenie__przód_tył, SizeOf( real )  );

          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].czy_wszystkie_lufy, SizeOf( boolean )  );
          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].obracaj_działa, SizeOf( boolean )  );
          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].podnoś_lufy, SizeOf( boolean )  );
          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].przeliczone, SizeOf( boolean )  );

          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].gracz__nazwa, SizeOf( TWieloosobowe_String )  );

          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].cel_współrzędne, SizeOf( TWieloosobowe__Wektor_4 )  );
          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].kierunek, SizeOf( TWieloosobowe__Wektor_4 )  );
          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].pozycja, SizeOf( TWieloosobowe__Wektor_4 )  );

          strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].amunicja_rodzaj, SizeOf( TAmunicja_Rodzaj )  );


          for j := 0 to Length( wieloosobowe__statki_t[ i ].śruba_obrót_kąt ) - 1 do
            strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].śruba_obrót_kąt[ j ], SizeOf( real )  );


          for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t ) - 1 do
            begin

              //strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].artyleria_t[ j ], obiekty_wieloosobowe__działo_r__rozmiar_c  );

              strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].czy_lot_parabolą, SizeOf( boolean )  );
              strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obrót_kąt, SizeOf( real )  );
              strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].celownik_linia__podniesienie_kąt, SizeOf( real )  );
              strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].celownik_linia__szerokość, SizeOf( single )  );
              strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].celownik_linia__wzór, SizeOf( word )  );
              strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].amunicja_ilość, SizeOf( integer )  );
              strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t__długość_tabeli, SizeOf( integer )  );
              strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].celownik_linia__kolor, SizeOf( TWieloosobowe__Wektor_4 )  );

              for k := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
                begin

                  //strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );

                  strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_kąt, SizeOf( real )  );
                  strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z, SizeOf( real )  );
                  strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].strzał_gotowość, SizeOf( boolean )  );
                  strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__kolor, SizeOf( TWieloosobowe__Wektor_4 )  );
                  strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__pozycja, SizeOf( TWieloosobowe__Wektor_4 )  );

                end;
              //---//for k := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do

            end;
          //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t ) - 1 do

          for j := 0 to Length( wieloosobowe__statki_t[ i ].działa_t ) - 1 do
            begin

              //strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].działa_t[ j ], obiekty_wieloosobowe__działo_r__rozmiar_c  );

              strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].działa_t[ j ].obrót_kąt, SizeOf( real )  );
              strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].działa_t[ j ].celownik_linia__podniesienie_kąt, SizeOf( real )  );
              strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].działa_t[ j ].celownik_linia__szerokość, SizeOf( single )  );
              strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].działa_t[ j ].celownik_linia__wzór, SizeOf( word )  );
              strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].działa_t[ j ].amunicja_ilość, SizeOf( integer )  );
              strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t__długość_tabeli, SizeOf( integer )  );
              strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].działa_t[ j ].celownik_linia__kolor, SizeOf( TWieloosobowe__Wektor_4 )  );

              for k := 0 to Length( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
                begin

                  //strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );

                  strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_kąt, SizeOf( real )  );
                  strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z, SizeOf( real )  );
                  strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].strzał_gotowość, SizeOf( boolean )  );
                  strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__kolor, SizeOf( TWieloosobowe__Wektor_4 )  );
                  strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__pozycja, SizeOf( TWieloosobowe__Wektor_4 )  );

                end;
              //---//for k := 0 to Length( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do

            end;
          //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].działa_t ) - 1 do

          for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do
            begin

              //strumień_pamięci_l.Write(  wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ], obiekty_wieloosobowe__działo_r__rozmiar_c  );

              strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obrót_kąt, SizeOf( real )  );
              strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia__podniesienie_kąt, SizeOf( real )  );
              strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia__szerokość, SizeOf( single )  );
              strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia__wzór, SizeOf( word )  );
              strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].amunicja_ilość, SizeOf( integer )  );
              strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t__długość_tabeli, SizeOf( integer )  );
              strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia__kolor, SizeOf( TWieloosobowe__Wektor_4 )  );

              for k := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
                begin

                  //strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );

                  strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_kąt, SizeOf( real )  );
                  strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z, SizeOf( real )  );
                  strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].strzał_gotowość, SizeOf( boolean )  );
                  strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__kolor, SizeOf( TWieloosobowe__Wektor_4 )  );
                  strumień_pamięci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__pozycja, SizeOf( TWieloosobowe__Wektor_4 )  );

                end;
              //---//for k := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do

            end;
          //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do


          Strumień_Napis_Wpisz( wieloosobowe__statki_t[ i ].radar_id_statki_w_zasięgu, strumień_pamięci_l );
          Strumień_Napis_Wpisz( wieloosobowe__statki_t[ i ].radio_id_statki_w_zasięgu, strumień_pamięci_l );

        end;
      //---//for i := 0 to Length( rekord_r_t ) - 1 do
      {$endregion 'wieloosobowe__komenda__odbierz__rekord_statki_c.'}


      // Tutaj można przetestować odczytanie strumienia. //???
      // Wieloosobowe_Statki_Rekord_Czyść();
      // strumień_pamięci_l.Position := 0; // while strumień_pamięci_l.Position < strumień_pamięci_l.Size do (...)

    end
  else//if komenda_f = wieloosobowe__komenda__odbierz__rekord_statki_c then
  if komenda_f = wieloosobowe__komenda__odbierz__statki_definicje_c then
    begin

      if not czy_klient_g then
        begin

          // Tylko serwer wysyła dane o statkach.

          for i := 0 to Length( statki_lista_t ) - 1 do
            begin

              Strumień_Napis_Wpisz( statki_lista_t[ i ].id, strumień_pamięci_l );
              Strumień_Napis_Wpisz( statki_lista_t[ i ].nazwa, strumień_pamięci_l );
              Strumień_Napis_Wpisz( statki_lista_t[ i ].opis, strumień_pamięci_l );
              Strumień_Napis_Wpisz( statki_lista_t[ i ].plik_nazwa, strumień_pamięci_l );
              Strumień_Napis_Wpisz( statki_lista_t[ i ].treść, strumień_pamięci_l );

            end;
          //---//for i := 0 to Length( statki_lista_t ) - 1 do

        end;
      //---//if not czy_klient_g then

    end
  else//if komenda_f = wieloosobowe__komenda__odbierz__statki_definicje_c then
  if komenda_f = wieloosobowe__komenda__pauza_c then
    begin

      if czy_serwer_g then
        begin

          // Tylko serwer wysyła informację o pauzie.

          Strumień_Napis_Wpisz( wartość_f, strumień_pamięci_l );

        end;
      //---//if czy_serwer_g then

    end
  else//if komenda_f = wieloosobowe__komenda__pauza_c then
  if komenda_f = wieloosobowe__komenda__serwer_wyłącza_się_c then
    begin

      strumień_pamięci_l.Write(  wieloosobowe__komenda__serwer_wyłącza_się_c, SizeOf ( wieloosobowe__komenda__serwer_wyłącza_się_c )  );

    end
  else//if komenda_f = wieloosobowe__komenda__serwer_wyłącza_się_c then
  if komenda_f = wieloosobowe__komenda__statek__klawisze_obsługa_c then
    begin

      if czy_klient_g then // Tylko klient wysyła informacje o obsłudze klawiszy na serwer.
        strumień_pamięci_l.Write( wieloosobowe__statek_klawisze_obsługa_r, obiekty_wieloosobowe__statek_klawisze_obsługa_r__rozmiar_c );

    end
  else//if komenda_f = wieloosobowe__komenda__statek__klawisze_obsługa_c then
  if komenda_f = wieloosobowe__komenda__statek__przywróć_do_gry_c then
    begin

      strumień_pamięci_l.Write(  wieloosobowe__statek_przywróć_do_gry__id_statek_g, SizeOf( wieloosobowe__statek_przywróć_do_gry__id_statek_g )  );
      wieloosobowe__statek_przywróć_do_gry__id_statek_g := -99;

    end
  else//if komenda_f = wieloosobowe__komenda__statek__przywróć_do_gry_c then
  if komenda_f = wieloosobowe__komenda__udp__klient_połączony_nadal_c then
    begin

      if czy_klient_g then
        begin

          // Tylko klient informuje o aktywności swojego podłączenia do serwera.

          if czy_udp_f then
            begin

              Strumień_Napis_Wpisz
                (
                  IntToStr( IdTCPClient1.Socket.Binding.Port ) + ';' +
                  Wieloosobowe_Identyfikator_Edit.Text + ';' +
                  FloatToStr( double(Now()) ) + ';',
                  strumień_pamięci_l
                );

            end;
          //---//if czy_udp_f then

        end;
      //---//if czy_klient_g then

    end
  else//if komenda_f = wieloosobowe__komenda__udp__klient_połączony_nadal_c then
  if komenda_f = wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_r_c then
    begin

      Komunikacja_Rekord_Testowy_Obsługa( false );
      strumień_pamięci_l.Write( komunikacja_rekord_testowy_r, komunikacja_rekord_testowy_r__rozmiar_c );

    end
  else//if komenda_f = wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_r_c then
  if komenda_f = wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_2_r_c then
    begin

      komunikacja_rekord_testowy_2_r.napis := 'ąę ŚĆ łŃ';
      komunikacja_rekord_testowy_2_r.liczba_całkowita := Length( komunikacja_rekord_testowy_2_r.napis );

      //strumień_pamięci_l.Write( komunikacja_rekord_testowy_2_r, komunikacja_rekord_testowy_2_r__rozmiar_c ); // Tak nie działa.

      strumień_pamięci_l.Write(  komunikacja_rekord_testowy_2_r.liczba_całkowita, SizeOf( integer )  );
      strumień_pamięci_l.Write(  komunikacja_rekord_testowy_2_r.liczba_rzeczywista, SizeOf( real )  );
      strumień_pamięci_l.Write(  komunikacja_rekord_testowy_2_r.data_czas, SizeOf( TDateTime )  );

      if komunikacja_rekord_testowy_2_r.liczba_całkowita > 0 then
        strumień_pamięci_l.WriteBuffer(
            Pointer( komunikacja_rekord_testowy_2_r.napis )^,
            char_rozmiar_c * komunikacja_rekord_testowy_2_r.liczba_całkowita
          );

    end;
  //else//if komenda_f = wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_2_r_c then
  //  ;
  {$endregion 'Zapisuje rekord do strumienia.'}


  strumień_pamięci_l.Position := 0; // Chyba nie trzeba.
  //strumień_rozmiar := strumień_pamięci_l.Size;


  {$region 'Wysyła dane.'}
  if not czy_serwer_g then
    begin

      // Klient.

      if not czy_udp_f then
        begin

          // TCP.

          if IdTCPClient1.Connected then
            begin

              //IdTCPClient1.IOHandler.WriteBufferOpen(); //???
              IdTCPClient1.IOHandler.WriteLn( komenda_f, IdGlobal.IndyTextEncoding_UTF8 ); // W XE 3 IdGlobal.TIdTextEncoding.UTF8.
              IdTCPClient1.IOHandler.WriteLn(  IntToStr( strumień_pamięci_l.Size ), IdGlobal.IndyTextEncoding_UTF8  );
              IdTCPClient1.IOHandler.Write( strumień_pamięci_l, strumień_pamięci_l.Size );
              //IdTCPClient1.IOHandler.WriteBufferFlush(); //???

            end;
          //---//if IdTCPClient1.Connected then

        end
      else//if not czy_udp_f then
        begin

          // UDP.

          if IdUDPClient1.Connected then // Tylko podłącza klienta do portu (lokalnie). Jeżeli nie ma serwera i tak wyświetla, że się połączył.
            begin

              IdGlobal.ReadTIdBytesFromStream( strumień_pamięci_l, zt_id_bytes, strumień_pamięci_l.Size );


              IdUDPClient1.Send( komenda_f, IdGlobal.IndyTextEncoding_UTF8 ); // W XE 3 IdGlobal.TIdTextEncoding.UTF8.
              IdUDPClient1.Send(  IntToStr( strumień_pamięci_l.Size ), IdGlobal.IndyTextEncoding_UTF8  );
              IdUDPClient1.SendBuffer( IdUDPClient1.Host, IdUDPClient1.Port, zt_id_bytes );

            end;
          //---//if IdUDPClient1.Connected then

        end;
      //---//if not czy_udp_f then

    end
  else//if not czy_serwer_g then
    begin

      // Serwer.

      if not czy_udp_f then
        begin

          // TCP.

          lista := IdTCPServer1.Contexts.LockList();

          try
            for i := 0 to lista.Count - 1 do
              if   ( peer_port_f = -99 )
                or ( TIdContext(lista[ i ]).Connection.Socket.Binding.PeerPort = peer_port_f ) then
                begin
                  try
                    strumień_pamięci_l.Position := 0; // Chyba nie trzeba.

                    //TIdContext(lista[ i ]).Connection.IOHandler.WriteBufferOpen(); //???
                    TIdContext(lista[ i ]).Connection.IOHandler.WriteLn( komenda_f, IdGlobal.IndyTextEncoding_UTF8 ); // W XE 3 IdGlobal.TIdTextEncoding.UTF8.
                    TIdContext(lista[ i ]).Connection.IOHandler.WriteLn(  IntToStr( strumień_pamięci_l.Size ), IdGlobal.IndyTextEncoding_UTF8  );
                    TIdContext(lista[ i ]).Connection.IOHandler.Write( strumień_pamięci_l, strumień_pamięci_l.Size );
                    //TIdContext(lista[ i ]).Connection.IOHandler.WriteBufferFlush(); //???
                  except
                    on E : Exception do
                      begin
                        Wieloosobowe__Log_Wypisz(
                            'Nie udało się wysłać danych (s) do klienta: ' + IntToStr( TIdContext(lista[ i ]).Binding.PeerPort ) + #13 + #10 +
                            E.Message + ' ' + IntToStr( E.HelpContext ) + '.'
                          );
                        //Application.MessageBox(
                        //    PChar('Nie udało się wysłać danych (s) do klienta: ' + IntToStr( TIdContext(lista[ i ]).Binding.PeerPort ) + #13 +
                        //    E.Message + ' ' + IntToStr( E.HelpContext ) + '.'), 'Błąd',
                        //    MB_OK + MB_ICONEXCLAMATION
                        //  );
                      end;
                  end;
                end;
              //---//if   ( peer_port_f = -99 ) (...)
          finally
            IdTCPServer1.Contexts.UnlockList();
          end;
          //---//try

        end
      else//if not czy_udp_f then
        begin

          // UDP.

          IdGlobal.ReadTIdBytesFromStream( strumień_pamięci_l, zt_id_bytes, strumień_pamięci_l.Size );


          for i := udp_klienci_lista_g.klienci_lista_list.Count - 1 downto 0 do
            if   ( peer_port_f = -99 )
              or ( TUDP_Klient_Dane(udp_klienci_lista_g.klienci_lista_list[ i ]).peer_port = peer_port_f ) then //???
              begin

                IdUDPServer1.Send( TUDP_Klient_Dane(udp_klienci_lista_g.klienci_lista_list[ i ]).adres_ip, TUDP_Klient_Dane(udp_klienci_lista_g.klienci_lista_list[ i ]).peer_port, komenda_f, IdGlobal.IndyTextEncoding_UTF8 );
                IdUDPServer1.Send(  TUDP_Klient_Dane(udp_klienci_lista_g.klienci_lista_list[ i ]).adres_ip, TUDP_Klient_Dane(udp_klienci_lista_g.klienci_lista_list[ i ]).peer_port, IntToStr( strumień_pamięci_l.Size ), IdGlobal.IndyTextEncoding_UTF8  );
                IdUDPServer1.SendBuffer( TUDP_Klient_Dane(udp_klienci_lista_g.klienci_lista_list[ i ]).adres_ip, TUDP_Klient_Dane(udp_klienci_lista_g.klienci_lista_list[ i ]).peer_port, zt_id_bytes );

              end;
            //---//if   ( peer_port_f = -99 ) (...)

        end;
      //---//if not czy_udp_f then

    end;
  //---//if not czy_serwer_g then
  {$endregion 'Wysyła dane.'}


  FreeAndNil( strumień_pamięci_l );

end;//---//Funkcja Wieloosobowe__Strumień_Wyślij().

//Funkcja Wieloosobowe__Odczytaj().
function TStatki_Form.Wieloosobowe__Odczytaj( const io_handler_f : TIdIOHandler; const komenda_udp_f : string; const id_context_f : TIdContext; const id_socket_handle_f : TIdSocketHandle ) : string; // uses IdIOHandler.

  //Funkcja Strumień_Napis_Odczytaj() w Wieloosobowe__Odczytaj().
  function Strumień_Napis_Odczytaj( strumień_pamięci_f : TMemoryStream ) : string;
  var
    i,
    j
      : integer;
    zt_wieloosobowe_string : TWieloosobowe_String;
  begin

    strumień_pamięci_f.Read(  i, SizeOf( i )  );

    Result := '';

    for j := 1 to i do
      begin

        zt_wieloosobowe_string := '';
        strumień_pamięci_f.Read( zt_wieloosobowe_string, wieloosobowe_string__rozmiar_c );
        Result := Result + zt_wieloosobowe_string;

      end;
    //---//for j := 0 to i do

  end;//---//Funkcja Strumień_Napis_Odczytaj() w Wieloosobowe__Odczytaj().

var
  i,
  j,
  k,
  strumień_rozmiar
    : integer;
  ztdu : double;
  zts,
  komenda_l
    : string;
  czy_udp_l : boolean;
  pokój_rozmów_r_l : TPokój_Rozmów_r;
  zt_tcp_klient_dane : TTCP_Klient_Dane;
  komunikacja_rekord_testowy_2_r_l : TKomunikacja_Rekord_Testowy_2_r; // Ze zmienną lokalną lepiej działa (?). //???
  wieloosobowe__statek_klawisze_obsługa_r_l : TObiekty_Wieloosobowe__Statek_Klawisze_Obsługa_r;
  strumień_pamięci_l : TMemoryStream;
  zt_id_bytes : TIdBytes;
begin//Funkcja Wieloosobowe__Odczytaj().

  Result := '';


  if    (
             ( io_handler_f = nil )
          or (  not Assigned( io_handler_f )  )
        )
    and ( Trim( komenda_udp_f ) = ''  ) then
    Exit;


  if    ( io_handler_f <> nil )
    and (  Assigned( io_handler_f )  ) then
    czy_udp_l := false
  else//if    ( io_handler_f <> nil ) (...)
    czy_udp_l := true;


  if not czy_udp_l then
    komenda_l := io_handler_f.ReadLn( IdGlobal.IndyTextEncoding_UTF8 ) // W XE 3 IdGlobal.TIdTextEncoding.UTF8.
  else//if not czy_udp_l then
    komenda_l := komenda_udp_f;


  if id_context_f <> nil then
    begin

      zts := 'TCP ';
      zts := zts + id_context_f.Binding.PeerIP; // 127.0.0.1
      zts := zts + '; ' + IntToStr( id_context_f.Binding.PeerPort ); // 62951 - Niepowtarzalny dla klientów numer.
      zts := zts + '; ' + IntToStr( id_context_f.Binding.Port ); // 3500
      zts := zts + '; ' + komenda_l;

      //Wieloosobowe__Log_Wypisz( zts );

    end
  else//if id_context_f <> nil then
  if id_socket_handle_f <> nil then
    begin

      zts := 'UDP ';
      zts := zts + id_socket_handle_f.PeerIP; // 127.0.0.1
      zts := zts + '; ' + IntToStr( id_socket_handle_f.PeerPort ); // 62951 - Niepowtarzalny dla klientów numer.
      zts := zts + '; ' + IntToStr( id_socket_handle_f.Port ); // 3500
      zts := zts + '; ' + komenda_l;

      //Wieloosobowe__Log_Wypisz( zts );

    end;
  //---//if id_socket_handle_f <> nil then


  if   ( komenda_l = wieloosobowe__komenda__gra__rozpocznij_c )
    or ( komenda_l = wieloosobowe__komenda__gra__zakończ_c )
    or ( komenda_l = wieloosobowe__komenda__gra_współczynnik_prędkości_c )
    or ( komenda_l = wieloosobowe__komenda__gracz_gotowość_c )
    or ( komenda_l = wieloosobowe__komenda__gracz_lista_odśwież_c )
    or ( komenda_l = wieloosobowe__komenda__hasło__sprawdź_c )
    or ( komenda_l = wieloosobowe__komenda__identyfikator__nadaj_c )
    or ( komenda_l = wieloosobowe__komenda__identyfikator__przypomnij_c )
    or ( komenda_l = wieloosobowe__komenda__identyfikator__zapamiętaj_c )
    or ( komenda_l = wieloosobowe__komenda__odbierz__ląd_definicja_c )
    or ( komenda_l = wieloosobowe__komenda__odbierz__prymitywy_definicja_c )
    or ( komenda_l = wieloosobowe__komenda__odbierz__rekord_amunicja_c )
    or ( komenda_l = wieloosobowe__komenda__odbierz__rekord_efekt_c )
    or ( komenda_l = wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c )
    or ( komenda_l = wieloosobowe__komenda__odbierz__rekord_statki_c )
    or ( komenda_l = wieloosobowe__komenda__odbierz__statki_definicje_c )
    or ( komenda_l = wieloosobowe__komenda__pauza_c )
    //or ( komenda_l = wieloosobowe__komenda__serwer_wyłącza_się_c )
    or ( komenda_l = wieloosobowe__komenda__statek__klawisze_obsługa_c )
    or ( komenda_l = wieloosobowe__komenda__statek__przywróć_do_gry_c )
    or ( komenda_l = wieloosobowe__komenda__udp__klient_połączony_nadal_c )
    or ( komenda_l = wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_r_c )
    or ( komenda_l = wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_2_r_c ) then
    begin

      {$region 'Odczytuje dane.'}
      // Rozmiar strumienia.
      if not czy_udp_l then
        zts := io_handler_f.ReadLn( IdGlobal.IndyTextEncoding_UTF8 )
      else//if not czy_udp_l then
        begin

          i := 0;

          if czy_serwer_g then
            zts := IdUDPServer1.ReceiveString( -1, IdGlobal.IndyTextEncoding_UTF8 )
          else//if czy_serwer_g then
            zts := IdUDPClient1.ReceiveString( -1, IdGlobal.IndyTextEncoding_UTF8 );

        end;
      //---//if not czy_udp_l then


      try
        strumień_rozmiar := StrToInt( zts );
      except
        strumień_rozmiar := 0;

        zts := 'Błędny rozmiar strumienia od ';

        if id_context_f <> nil then
          zts := zts + IntToStr( id_context_f.Binding.PeerPort )
        else//if id_context_f <> nil then
        if id_socket_handle_f <> nil then
          zts := zts + IntToStr( id_socket_handle_f.PeerPort );

        zts := zts + '.';

        Log_Memo.Lines.Add( zts );
      end;
      //---//try

      if    ( czy_udp_l )
        and ( strumień_rozmiar > 0 ) then
        begin

          SetLength( zt_id_bytes, strumień_rozmiar ); //???  IdUDPClient1.BufferSize // Najlepiej przesyłać informację wielkość wysyłanego (do odebrania) strumienia.

          if czy_serwer_g then
            i := IdUDPServer1.ReceiveBuffer( zt_id_bytes ) // Nie oczekuje na dane (przechodzi dalej, nie zatrzymuje się tutaj).
          else//if czy_serwer_g then
            i := IdUDPClient1.ReceiveBuffer( zt_id_bytes ); // Nie oczekuje na dane (przechodzi dalej, nie zatrzymuje się tutaj).

        end;
      //---//if    ( czy_udp_l ) (...)


      //if    ( strumień_rozmiar > 0 )
      //  and (
      //           ( not czy_udp_l )
      //        or (
      //                 ( czy_udp_l )
      //             and ( i > 0 )
      //           )
      //      ) then
      if    (
                 ( not czy_udp_l )
              or (
                       ( czy_udp_l )
                   and ( i > 0 )
                 )
            ) then
        begin

          strumień_pamięci_l := TMemoryStream.Create();


          if strumień_rozmiar > 0 then
            if not czy_udp_l then
              begin

                io_handler_f.ReadStream( strumień_pamięci_l, strumień_rozmiar ); // Najlepiej przesyłać informację wielkość wysyłanego (do odebrania) strumienia.

              end
            else//if not czy_udp_l then
              begin

                //SetLength( zt_id_bytes, strumień_rozmiar ); //???  IdUDPClient1.BufferSize // Najlepiej przesyłać informację wielkość wysyłanego (do odebrania) strumienia.
                //
                //i := IdUDPClient1.ReceiveBuffer( zt_id_bytes ); // Nie oczekuje na dane (przechodzi dalej, nie zatrzymuje się tutaj).

                if i > 0 then
                  IdGlobal.WriteTIdBytesToStream( strumień_pamięci_l, zt_id_bytes );

              end;
            //---//if not czy_udp_l then


          strumień_pamięci_l.Position := 0;

//          strumień_pamięci_l.Read( rekord_r, strumień_rozmiar ); // Najlepiej przesyłać informację wielkość wysyłanego (do odebrania) strumienia.
          //strumień_pamięci_l.Read( rekord_r_t, strumień_rozmiar );
        {$endregion 'Odczytuje dane.'}

          {$region 'Przetwarza odczytane dane.'}
          if komenda_l = wieloosobowe__komenda__gra__rozpocznij_c then
            begin

              if czy_klient_g then
                begin

                  // Tylko klient odczytuje komunikat o rozpoczęciu gry.

                  czas_bezwzględny_g := 0;

                  if not IdUDPClient1.Connected then
                    begin

                      Gracz_Gotowość_Tak_BitBtn.Enabled := false;
                      Gracz_Gotowość_Nie_BitBtn.Enabled := false;

                      Statek_GroupBox.Enabled := false;

                      Statki_Zaprezentuj_Button.Enabled := false;
                      Statki_Zaprezentuj__Zwolnij_BitBtn.Enabled := false;


                      Elementy_Gry_Zwolnij();


                      IdUDPClient1.Host := Serwer_Adres_IP_Edit.Text;
                      IdUDPClient1.Port := Serwer_Port_SpinEdit.Value;
                      IdUDPClient1.ReceiveTimeout := 5; //???

                      IdUDPClient1.Connect();

                    end;
                  //---//if not IdUDPClient1.Connected then



                  udp_data_czas_sprawdzanie_połączeń_ostatnie_g := Now();
                  //udp_klienci_lista_g.Dodaj( '0', 0, Gracz_Identyfikator() ); // Przechowa dane o (próbie) swoim ostatnim kontakcie z serwerem.


                  Klient_IdUDP_Czyta_Timer.Enabled := true;
                  Klient_Wysyła_Timer.Enabled := true;

                  klient_pierwsze_ustawienie_kamery_g := true;


                  SetLength( prymitywy_lista_t, 0 );


                  Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__udp__klient_połączony_nadal_c, -99, '', true );

                end;
              //---//if czy_klient_g then

            end
          else//if komenda_l = wieloosobowe__komenda__gra__rozpocznij_c then
          if komenda_l = wieloosobowe__komenda__gra__zakończ_c then
            begin

              if czy_klient_g then
                begin

                  // Tylko klient odczytuje komunikat o zakończeniu gry.

                  Klient_IdUDP_Czyta_Timer.Enabled := false;
                  Klient_Wysyła_Timer.Enabled := false;


                  if IdUDPClient1.Connected then
                    IdUDPClient1.Disconnect();


                  //udp_klienci_lista_g.Usuń_Wszystkich();


                  Gracz_Gotowość_BitBtnClick( Gracz_Gotowość_Nie_BitBtn );

                  //Gracz_Gotowość_Tak_BitBtn.Enabled := true;
                  //Gracz_Gotowość_Nie_BitBtn.Enabled := true;

                  Statek_GroupBox.Enabled := true;

                  Statki_Zaprezentuj_Button.Enabled := true;
                  Statki_Zaprezentuj__Zwolnij_BitBtn.Enabled := true;


                  Elementy_Gry_Zwolnij();
                  Statek__Utwórz_BitBtnClick( nil );

                  if not ( GLCamera1.Parent is TStatek ) then
                    Kamera_Przełącz( kt_Statek ); // Ustawi kamerę na statku gracza.

                end;
              //---//if czy_klient_g then

            end
          else//if komenda_l = wieloosobowe__komenda__gra__zakończ_c then
          if komenda_l = wieloosobowe__komenda__gra_współczynnik_prędkości_c then
            begin

              if czy_klient_g then
                begin

                  // Tylko klient odczytuje komunikat o współczynniku prędkości gry.

                  zts := Strumień_Napis_Odczytaj( strumień_pamięci_l );

                  try
                    Gra_Współczynnik_Prędkości_SpinEdit.Value := StrToInt( zts );
                  except
                    Log_Wypisz( 'Nieprawidłowa wartość współczynnika prędkości gry: ' + zts + '.', false );
                  end;
                  //---//try

                end;
              //---//if czy_klient_g then

            end
          else//if komenda_l = wieloosobowe__komenda__gra_współczynnik_prędkości_c then
          if komenda_l = wieloosobowe__komenda__gracz_gotowość_c then
            begin

              zts := Strumień_Napis_Odczytaj( strumień_pamięci_l );

              if czy_serwer_g then
                begin

                  // Tylko serwer określa status gotowości.

                  i := -99;

                  if id_context_f <> nil then
                    i := id_context_f.Binding.PeerPort
                  else//if id_context_f <> nil then
                  if id_socket_handle_f <> nil then
                    i := id_socket_handle_f.PeerPort;

                  if i <> -99 then
                    begin

                      zt_tcp_klient_dane := tcp_klienci_lista_g.Znajdź_Peer_Port( i );

                      if zt_tcp_klient_dane <> nil then
                        begin

                          if zts = 'Tak' then
                            begin

                              // Gracz zgłasza, że jest gotowy.

                              strumień_pamięci_l.Read(  j, SizeOf ( integer )  );
                              zt_tcp_klient_dane.id_grupa := j;

                              strumień_pamięci_l.Read(  j, SizeOf ( integer )  );
                              zt_tcp_klient_dane.id_statek_schemat := j;

                              zts := Strumień_Napis_Odczytaj( strumień_pamięci_l );


                              if tcp_klienci_lista_g.Nazwa_Niepowtarzalna( zt_tcp_klient_dane.peer_port_tcp, zts ) then
                                begin

                                  zt_tcp_klient_dane.nazwa := zts;
                                  zt_tcp_klient_dane.gotowy := true;

                                  Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__gracz_gotowość_c, zt_tcp_klient_dane.peer_port_tcp, 'Tak' ); // Serwer potwierdza, że gracz jest gotowy.

                                end
                              else//if tcp_klienci_lista_g.Nazwa_Niepowtarzalna( zt_tcp_klient_dane.peer_port_tcp, zts ) then
                                begin

                                  zt_tcp_klient_dane.gotowy := false;

                                  //Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__gracz_gotowość_c, zt_tcp_klient_dane.peer_port_tcp, 'Nie' ); // Serwer wskazuje błąd gotowości gracza.
                                  Wieloosobowe__Tekst_Wyślij( 'Nazwa gracza powinna być niepowtarzalna.', i );

                                end;
                              //---//if tcp_klienci_lista_g.Nazwa_Niepowtarzalna( zt_tcp_klient_dane.peer_port, zts ) then

                            end
                          else//if zts = 'Tak' then
                            begin

                              // Gracz zgłasza, że nie jest gotowy.

                              zt_tcp_klient_dane.gotowy := false;

                            end;
                          //---//if zts = 'Tak' then

                          Gracze_Lista_Odśwież();

                          Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__gracz_lista_odśwież_c, -99, '' );

                        end;
                      //---//if zt_tcp_klient_dane <> nil then

                    end;
                  //---//if i <> -99 then

                end
              else//if czy_serwer_g then
              if czy_klient_g then
                begin

                  // Klient otrzymuje potwierdzenie statusu gotowości.

                  if zts = 'Tak' then
                    begin

                      // Status gotowości potwierdzony.

                      Gracz_Gotowość_Nie_BitBtn.Enabled := true;
                      Gracz_Gotowość_Tak_BitBtn.Enabled := false;

                      Gracz_Grupa_SpinEdit.Enabled := false;
                      Gracz_Nazwa_Edit.Enabled := false;
                      Statek_GroupBox.Enabled := false;

                    end;
                  //---//if zts = 'Tak' then

                end;
              //---//if czy_klient_g then

            end
          else//if komenda_l = wieloosobowe__komenda__gracz_gotowość_c then
          if komenda_l = wieloosobowe__komenda__gracz_lista_odśwież_c then
            begin

              if czy_serwer_g then
                Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__gracz_lista_odśwież_c, -99, '' ) // Na zapytanie klienta serwer odsyła aktualną listę graczy.
              else//if czy_serwer_g then
              if czy_klient_g then
                begin

                  // Tylko klient odbiera listę graczy.

                  Mapa_Label.Caption := 'Mapa: ' + Strumień_Napis_Odczytaj( strumień_pamięci_l ) + '.';
                  Statki_Pozycje_Początkowe_Label.Caption := 'Pozycje początkowe statków: ' + Strumień_Napis_Odczytaj( strumień_pamięci_l ) + '.';


                  tcp_klienci_lista_g.Usuń_Wszystkich();

                  while strumień_pamięci_l.Position < strumień_pamięci_l.Size do
                    begin

                      zt_tcp_klient_dane := TTCP_Klient_Dane.Create();


                      strumień_pamięci_l.Read(  zt_tcp_klient_dane.identyfikator, SizeOf( integer )  );
                      strumień_pamięci_l.Read(  zt_tcp_klient_dane.id_grupa, SizeOf( integer )  );
                      strumień_pamięci_l.Read(  zt_tcp_klient_dane.id_statek_schemat, SizeOf( integer )  );
                      strumień_pamięci_l.Read(  zt_tcp_klient_dane.peer_port_tcp, SizeOf( integer )  );
                      strumień_pamięci_l.Read(  zt_tcp_klient_dane.peer_port_udp, SizeOf( integer )  );

                      strumień_pamięci_l.Read(  zt_tcp_klient_dane.data_czas__dłączenia, SizeOf( TDateTime )  );
                      strumień_pamięci_l.Read(  zt_tcp_klient_dane.data_czas__podłączenia, SizeOf( TDateTime )  );
                      strumień_pamięci_l.Read(  zt_tcp_klient_dane.data_czas__podłączenia_ostatniego, SizeOf( TDateTime )  );
                      strumień_pamięci_l.Read(  zt_tcp_klient_dane.data_czas__udp_kontakt, SizeOf( TDateTime )  );

                      strumień_pamięci_l.Read(  zt_tcp_klient_dane.gotowy, SizeOf( boolean )  );
                      strumień_pamięci_l.Read(  zt_tcp_klient_dane.odłączony, SizeOf( boolean )  );

                      strumień_pamięci_l.Read( zt_tcp_klient_dane.nazwa, wieloosobowe_string__rozmiar_c );


                      tcp_klienci_lista_g.klienci_lista_list.Add( zt_tcp_klient_dane );

                    end;
                  //---//while strumień_pamięci_l.Position < strumień_pamięci_l.Size do


                  Gracze_Lista_Odśwież();

                end;
              //---//if czy_klient_g then

            end
          else//if komenda_l = wieloosobowe__komenda__gracz_lista_odśwież_c then
          if komenda_l = wieloosobowe__komenda__hasło__sprawdź_c then
            begin

              if czy_klient_g then
                begin

                  // Tylko klient czeka na potwierdzenie prawidłowości hasła.

                  zts := Strumień_Napis_Odczytaj( strumień_pamięci_l );

                  if zts = 'Tak' then
                    begin

                      // Hasło prawidłowe.

                    end
                  else//if zts = 'Tak' then
                    Wieloosobowe__Odłącz_BitBtnClick( nil );

                end;
              //---//if czy_klient_g then

            end
          else//if komenda_l = wieloosobowe__komenda__hasło__sprawdź_c then
          if komenda_l = wieloosobowe__komenda__identyfikator__nadaj_c then
            begin

              if czy_serwer_g then
                begin

                  // Tylko serwer nadaje identyfikator.

                  i := -99;

                  if id_context_f <> nil then
                    i := id_context_f.Binding.PeerPort
                  else//if id_context_f <> nil then
                  if id_socket_handle_f <> nil then
                    i := id_socket_handle_f.PeerPort;

                  if i <> -99 then
                    begin

                      zts := Strumień_Napis_Odczytaj( strumień_pamięci_l );

                      if zts = Hasło_Edit.Text then
                        begin

                          zt_tcp_klient_dane := tcp_klienci_lista_g.Dodaj_Aktualizuj( i, -99 );

                          if zt_tcp_klient_dane <> nil then
                            begin

                              j := zt_tcp_klient_dane.identyfikator;

                              Wieloosobowe__Strumień_Wyślij(  wieloosobowe__komenda__identyfikator__zapamiętaj_c, i, IntToStr( j )  );

                              Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__gracz_lista_odśwież_c, -99, '' );


                              Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__odbierz__statki_definicje_c, i, '' );

                            end
                          else//if zt_tcp_klient_dane <> nil then
                            Wieloosobowe__Tekst_Wyślij( 'Nie udało się nadać identyfikatora.', i );


                          Gracze_Lista_Odśwież();

                        end
                      else//if zts = Hasło_Edit.Text then
                        begin

                          Wieloosobowe__Tekst_Wyślij( 'Nieprawidłowe hasło (n).', i ); // Jeżeli najpierw rozłączy to potem nie ma sensu wysyłać komunikatu.
                          Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__hasło__sprawdź_c, i, 'Nie' );

                        end;
                      //---//if zts = Hasło_Edit.Text then

                    end;
                  //---//if i <> -99 then

                end;
              //---//if czy_serwer_g then

            end
          else//if komenda_l = wieloosobowe__komenda__identyfikator__nadaj_c then
          if komenda_l = wieloosobowe__komenda__identyfikator__przypomnij_c then
            begin

              if czy_serwer_g then
                begin

                  // Tylko serwer obsługuje wysłane przypomnienia identyfikatorów.

                  i := -99;

                  if id_context_f <> nil then
                    i := id_context_f.Binding.PeerPort
                  else//if id_context_f <> nil then
                  if id_socket_handle_f <> nil then
                    i := id_socket_handle_f.PeerPort;

                  if i <> -99 then
                    begin

                      zts := Strumień_Napis_Odczytaj( strumień_pamięci_l );

                      if zts = Hasło_Edit.Text then
                        begin

                          zts := Strumień_Napis_Odczytaj( strumień_pamięci_l );

                          try
                            j := StrToInt( zts );

                            if tcp_klienci_lista_g.Dodaj_Aktualizuj( i, j ) = nil then
                              begin

                                Wieloosobowe__Tekst_Wyślij( 'Wskazanego identyfikatora nie ma na liście ''' + zts + '''.', i );
                                Wieloosobowe__Tekst_Wyślij( wieloosobowe__komenda__serwer_wyłącza_się_c, i );

                              end;
                            //---//if tcp_klienci_lista_g.Dodaj_Aktualizuj( i, j ) = nil then

                          except
                            Wieloosobowe__Tekst_Wyślij( 'Nie udało się przypomnieć identyfikatora.', i );
                            Wieloosobowe__Tekst_Wyślij( 'Nieprawidłowe hasło (p1).', i ); // Jeżeli najpierw rozłączy to potem nie ma sensu wysyłać komunikatu.
                            Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__hasło__sprawdź_c, i, 'Nie' );
                          end;
                          //---//try

                          Gracze_Lista_Odśwież();

                          Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__gracz_lista_odśwież_c, -99, '' );

                        end
                      else//if zts = Hasło_Edit.Text then
                        begin

                          Wieloosobowe__Tekst_Wyślij( 'Nieprawidłowe hasło (p2).', i ); // Jeżeli najpierw rozłączy to potem nie ma sensu wysyłać komunikatu.
                          Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__hasło__sprawdź_c, i, 'Nie' );

                        end;
                      //---//if zts = Hasło_Edit.Text then

                    end;
                  //---//if i <> -99 then

                end;
              //---//if czy_serwer_g then

            end
          else//if komenda_l = wieloosobowe__komenda__identyfikator__przypomnij_c then
          if komenda_l = wieloosobowe__komenda__identyfikator__zapamiętaj_c then
            begin

              if czy_klient_g then
                begin

                  // Tylko serwer nadaje identyfikator.

                  Wieloosobowe_Identyfikator_Edit.Text := Strumień_Napis_Odczytaj( strumień_pamięci_l );
                  Wieloosobowe_Identyfikator_Gra_Label.Caption := Wieloosobowe_Identyfikator_Edit.Text;

                end;
              //---//if czy_klient_g then

            end
          else//if komenda_l = wieloosobowe__komenda__identyfikator__zapamiętaj_c then
          if komenda_l = wieloosobowe__komenda__odbierz__ląd_definicja_c then
            begin

              if czy_klient_g then
                begin

                  // Tylko klient odczytuje dane o lądzie.

                  ląd_definicja_g := Strumień_Napis_Odczytaj( strumień_pamięci_l );

                  Ląd_Zwolnij();
                  Ląd_Utwórz( -99 );

                end;
              //---//if czy_klient_g then

            end
          else//if komenda_l = wieloosobowe__komenda__odbierz__ląd_definicja_c then
          if komenda_l = wieloosobowe__komenda__odbierz__prymitywy_definicja_c then
            begin

              if czy_klient_g then
                begin

                  // Tylko klient odczytuje dane o prymitywach.

                  i := Length( prymitywy_lista_t );
                  SetLength( prymitywy_lista_t, i + 1 );

                  prymitywy_lista_t[ i ].plik_nazwa := Strumień_Napis_Odczytaj( strumień_pamięci_l );
                  prymitywy_lista_t[ i ].treść := Strumień_Napis_Odczytaj( strumień_pamięci_l );

                end;
              //---//if czy_klient_g then

            end
          else//if komenda_l = wieloosobowe__komenda__odbierz__prymitywy_definicja_c then
          if komenda_l = wieloosobowe__komenda__odbierz__rekord_amunicja_c then
            begin

              SetLength( wieloosobowe__amunicja_t, 0 );

              while strumień_pamięci_l.Position < strumień_pamięci_l.Size do
                begin

                  i := Length( wieloosobowe__amunicja_t );
                  SetLength( wieloosobowe__amunicja_t, i + 1 );

                  strumień_pamięci_l.Read( wieloosobowe__amunicja_t[ i ], obiekty_wieloosobowe__amunicja_r__rozmiar_c );

                end;
              //---//while strumień_pamięci_l.Position < strumień_pamięci_l.Size do

            end
          else//if komenda_l = wieloosobowe__komenda__odbierz__rekord_amunicja_c then
          if komenda_l = wieloosobowe__komenda__odbierz__rekord_efekt_c then
            begin

              strumień_pamięci_l.Read( wieloosobowe__efekt_r, obiekty_wieloosobowe__efekt_r__rozmiar_c );
              Wieloosobowe__Trafienia_Efekt_Utwórz( wieloosobowe__efekt_r );

              // Efekt wysyłany jako tabela.
              //SetLength( wieloosobowe__efekt_t, 0 );
              //
              //while strumień_pamięci_l.Position < strumień_pamięci_l.Size do
              //  begin
              //
              //    i := Length( wieloosobowe__efekt_t );
              //    SetLength( wieloosobowe__efekt_t, i + 1 );
              //
              //    strumień_pamięci_l.Read( wieloosobowe__efekt_t[ i ], obiekty_wieloosobowe__efekt_r__rozmiar_c );
              //
              //  end;
              ////---//while strumień_pamięci_l.Position < strumień_pamięci_l.Size do
              //
              //Wieloosobowe__Trafienia_Efekt_Utwórz( wieloosobowe__efekt_t );
              //SetLength( wieloosobowe__efekt_t, 0 );

            end
          else//if komenda_l = wieloosobowe__komenda__odbierz__rekord_efekt_c then
          if komenda_l = wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c then
            begin

              strumień_pamięci_l.Read( pokój_rozmów_r_l, pokój_rozmów_r__rozmiar_c );

              // Gdy będą napisy z dowolną długością.
              //SetLength( pokój_rozmów_r_l.wiadomość, pokój_rozmów_r_l.wiadomość__długość );
              //
              //if pokój_rozmów_r_l.wiadomość__długość > 0 then
              //  strumień_pamięci_l.ReadBuffer(
              //      Pointer( pokój_rozmów_r_l.wiadomość )^, // value of first name
              //      char_rozmiar_c * pokój_rozmów_r_l.wiadomość__długość
              //    );

              //Wieloosobowe__Log_Wypisz(   'P_R_o od: ' + IntToStr( pokój_rozmów_r_l.id_nadawca ) + ' do: ' + IntToStr( pokój_rozmów_r_l.id_odbiorca ) + ' opóźnienie: ' + IntToStr(  SecondsBetween( Now(), pokój_rozmów_r_l.data_czas_wysłania )  ) + ' wiadomość : ' + pokój_rozmów_r_l.wiadomość + '.'  ); //???

              if   ( czy_klient_g )
                or ( pokój_rozmów_r_l.odbiorca_rodzaj = pror_Wszyscy )
                or (
                         ( pokój_rozmów_r_l.odbiorca_rodzaj = pror_Grupa_Jedna )
                     and ( pokój_rozmów_r_l.id_odbiorca = Gracz_Grupa_SpinEdit.Value )
                   )
                or (
                         ( pokój_rozmów_r_l.odbiorca_rodzaj = pror_Gracz_Jeden )
                     and ( pokój_rozmów_r_l.id_odbiorca = Gracz_Identyfikator() )
                   ) then
                Pokój_Rozmów__Wyświetl_Wiadomość( pokój_rozmów_r_l );

              if czy_serwer_g then
                begin

                  // Przesyła wiadomość do klientów.

                  pokój_rozmów_r.id_nadawca := pokój_rozmów_r_l.id_nadawca;
                  pokój_rozmów_r.id_odbiorca := pokój_rozmów_r_l.id_odbiorca;
                  //pokój_rozmów_r.wiadomość__długość := pokój_rozmów_r_l.wiadomość__długość;
                  pokój_rozmów_r.odbiorca_rodzaj := pokój_rozmów_r_l.odbiorca_rodzaj;
                  pokój_rozmów_r.data_czas_wysłania := pokój_rozmów_r_l.data_czas_wysłania;
                  pokój_rozmów_r.wiadomość := pokój_rozmów_r_l.wiadomość;

                  if pokój_rozmów_r.odbiorca_rodzaj = pror_Wszyscy then
                    Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c, -99, '' )
                  else//if pokój_rozmów_r.odbiorca_rodzaj = pror_Wszyscy then
                    begin

                      for i := 0 to tcp_klienci_lista_g.klienci_lista_list.Count - 1 do
                        if   ( pokój_rozmów_r.id_nadawca = TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator ) // Odsyła wiadomości do nadawcy.
                          or (
                                   ( pokój_rozmów_r.odbiorca_rodzaj = pror_Gracz_Jeden )
                               and ( pokój_rozmów_r.id_odbiorca = TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator )
                             )
                          or (
                                   ( pokój_rozmów_r.odbiorca_rodzaj = pror_Grupa_Jedna )
                               and ( pokój_rozmów_r.id_odbiorca = TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).id_grupa )
                             ) then
                          begin

                            Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c, TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).peer_port_tcp, '' );

                            if    ( pokój_rozmów_r.odbiorca_rodzaj = pror_Gracz_Jeden )
                              and ( pokój_rozmów_r.id_nadawca <> TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator ) then
                              Break;

                          end;
                        //---//if    ( pokój_rozmów_r.id_nadawca <> TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator ) (...)

                    end;
                  //---//if pokój_rozmów_r.odbiorca_rodzaj = pror_Wszyscy then

                end;
              //---//if czy_serwer_g then

            end
          else//if komenda_l = wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c then
          if komenda_l = wieloosobowe__komenda__odbierz__rekord_statki_c then
            begin

              {$region 'Zakomentowane - obsługiwane w taki sposób zgłasza błędy dostępu - wieloosobowe__komenda__odbierz__rekord_statki_c.'}
              //Wieloosobowe_Statki_Rekord_Czyść();
              //
              //while strumień_pamięci_l.Position < strumień_pamięci_l.Size do
              //  begin
              //
              //    i := Length( wieloosobowe__statki_t );
              //    SetLength( wieloosobowe__statki_t, i + 1 );
              //
              //
              //    strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ], obiekty_wieloosobowe__statki_r__rozmiar_c );
              //
              //
              //    SetLength( wieloosobowe__statki_t[ i ].śruba_obrót_kąt, wieloosobowe__statki_t[ i ].śruba_obrót_kąt__długość );
              //
              //    for j := 0 to Length( wieloosobowe__statki_t[ i ].śruba_obrót_kąt ) - 1 do
              //      strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].śruba_obrót_kąt[ j ], SizeOf( real )  );
              //
              //
              //    SetLength( wieloosobowe__statki_t[ i ].artyleria_t, wieloosobowe__statki_t[ i ].artyleria_t__długość_tabeli );
              //
              //    for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t ) - 1 do
              //      begin
              //
              //        strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ], obiekty_wieloosobowe__działo_r__rozmiar_c );
              //
              //        SetLength( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t, wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t__długość_tabeli );
              //
              //        for k := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
              //          strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );
              //
              //      end;
              //    //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t ) - 1 do
              //
              //
              //    SetLength( wieloosobowe__statki_t[ i ].działa_t, wieloosobowe__statki_t[ i ].działa_t__długość_tabeli );
              //
              //    for j := 0 to Length( wieloosobowe__statki_t[ i ].działa_t ) - 1 do
              //      begin
              //
              //        strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].działa_t[ j ], obiekty_wieloosobowe__działo_r__rozmiar_c );
              //
              //        SetLength( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t, wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t__długość_tabeli );
              //
              //        for k := 0 to Length( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
              //          strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );
              //
              //      end;
              //    //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].działa_t ) - 1 do
              //
              //
              //    SetLength( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t, wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t__długość_tabeli );
              //
              //    for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do
              //      begin
              //
              //        strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ], obiekty_wieloosobowe__działo_r__rozmiar_c );
              //
              //        SetLength( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t, wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t__długość_tabeli );
              //
              //        for k := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
              //          strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );
              //
              //      end;
              //    //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do
              //
              //
              //
              //    SetLength( wieloosobowe__statki_t[ i ].artyleria_wygląd_t, wieloosobowe__statki_t[ i ].artyleria_wygląd_t__długość_tabeli );
              //
              //    for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_wygląd_t ) - 1 do
              //      begin
              //
              //        strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].artyleria_wygląd_t[ j ], obiekty_wieloosobowe__działo_r__rozmiar_c );
              //
              //
              //        SetLength( wieloosobowe__statki_t[ i ].artyleria_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t, wieloosobowe__statki_t[ i ].artyleria_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t__długość_tabeli );
              //
              //        for k := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
              //          strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].artyleria_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );
              //
              //      end;
              //    //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_wygląd_t ) - 1 do
              //
              //
              //    SetLength( wieloosobowe__statki_t[ i ].działa_wygląd_t, wieloosobowe__statki_t[ i ].działa_wygląd_t__długość_tabeli );
              //
              //    for j := 0 to Length( wieloosobowe__statki_t[ i ].działa_wygląd_t ) - 1 do
              //      begin
              //
              //        strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].działa_wygląd_t[ j ], obiekty_wieloosobowe__działo_r__rozmiar_c );
              //
              //
              //        SetLength( wieloosobowe__statki_t[ i ].działa_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t, wieloosobowe__statki_t[ i ].działa_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t__długość_tabeli );
              //
              //        for k := 0 to Length( wieloosobowe__statki_t[ i ].działa_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
              //          strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].działa_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );
              //
              //      end;
              //    //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].działa_wygląd_t ) - 1 do
              //
              //
              //    SetLength( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t, wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t__długość_tabeli );
              //
              //    for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t ) - 1 do
              //      begin
              //
              //        strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ], obiekty_wieloosobowe__działo_r__rozmiar_c );
              //
              //
              //        SetLength( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t, wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t__długość_tabeli );
              //
              //        for k := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
              //          strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );
              //
              //      end;
              //    //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t ) - 1 do
              //
              //  end;
              ////---//while strumień_pamięci_l.Position < strumień_pamięci_l.Size do
              {$endregion 'Zakomentowane - obsługiwane w taki sposób zgłasza błędy dostępu - wieloosobowe__komenda__odbierz__rekord_statki_c.'}


              {$region 'wieloosobowe__komenda__odbierz__rekord_statki_c.'}
              Wieloosobowe_Statki_Rekord_Czyść();

              while strumień_pamięci_l.Position < strumień_pamięci_l.Size do
                begin

                  i := Length( wieloosobowe__statki_t );
                  SetLength( wieloosobowe__statki_t, i + 1 );


                  //strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ], obiekty_wieloosobowe__statki_r__rozmiar_c );

                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].id_grupa, SizeOf( integer )  );
                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].id_statek, SizeOf( integer )  );
                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].id_statek_schemat, SizeOf( integer )  );
                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].artyleria_t__długość_tabeli, SizeOf( integer )  );
                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].działa_t__długość_tabeli, SizeOf( integer )  );
                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t__długość_tabeli, SizeOf( integer )  );
                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].artyleria_wygląd_t__długość_tabeli, SizeOf( integer )  );
                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].działa_wygląd_t__długość_tabeli, SizeOf( integer )  );
                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygląd_t__długość_tabeli, SizeOf( integer )  );
                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].śruba_obrót_kąt__długość, SizeOf( integer )  );

                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].falowanie_bok_skręt, SizeOf( real )  );
                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].prędkość_procent, SizeOf( real )  );
                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].prędkość_zadana_procent, SizeOf( real )  );
                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].punkty_życia, SizeOf( real )  );
                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].punkty_życia_maksymalne, SizeOf( real )  );
                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].punkty_życia_procent_zostało, SizeOf( real )  );
                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].skręt_procent, SizeOf( real )  );
                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].skręt_zadany_procent, SizeOf( real )  );
                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].ster_kąt, SizeOf( real )  );
                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].tonięcie__przechylenie__lewo_prawo, SizeOf( real )  );
                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].tonięcie__przechylenie__przód_tył, SizeOf( real )  );

                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].czy_wszystkie_lufy, SizeOf( boolean )  );
                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].obracaj_działa, SizeOf( boolean )  );
                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].podnoś_lufy, SizeOf( boolean )  );
                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].przeliczone, SizeOf( boolean )  );

                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].gracz__nazwa, SizeOf( TWieloosobowe_String )  );

                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].cel_współrzędne, SizeOf( TWieloosobowe__Wektor_4 )  );
                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].kierunek, SizeOf( TWieloosobowe__Wektor_4 )  );
                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].pozycja, SizeOf( TWieloosobowe__Wektor_4 )  );

                  strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].amunicja_rodzaj, SizeOf( TAmunicja_Rodzaj )  );


                  SetLength( wieloosobowe__statki_t[ i ].śruba_obrót_kąt, wieloosobowe__statki_t[ i ].śruba_obrót_kąt__długość );

                  for j := 0 to Length( wieloosobowe__statki_t[ i ].śruba_obrót_kąt ) - 1 do
                    strumień_pamięci_l.Read(  wieloosobowe__statki_t[ i ].śruba_obrót_kąt[ j ], SizeOf( real )  );


                  SetLength( wieloosobowe__statki_t[ i ].artyleria_t, wieloosobowe__statki_t[ i ].artyleria_t__długość_tabeli );

                  for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t ) - 1 do
                    begin

                      //strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ], obiekty_wieloosobowe__działo_r__rozmiar_c );

                      strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].czy_lot_parabolą, SizeOf( boolean )  );
                      strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obrót_kąt, SizeOf( real )  );
                      strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].celownik_linia__podniesienie_kąt, SizeOf( real )  );
                      strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].celownik_linia__szerokość, SizeOf( single )  );
                      strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].celownik_linia__wzór, SizeOf( word )  );
                      strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].amunicja_ilość, SizeOf( integer )  );
                      strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t__długość_tabeli, SizeOf( integer )  );
                      strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].celownik_linia__kolor, SizeOf( TWieloosobowe__Wektor_4 )  );

                      SetLength( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t, wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t__długość_tabeli );

                      for k := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
                        begin

                          //strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );

                          strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_kąt, SizeOf( real )  );
                          strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z, SizeOf( real )  );
                          strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].strzał_gotowość, SizeOf( boolean )  );
                          strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__kolor, SizeOf( TWieloosobowe__Wektor_4 )  );
                          strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__pozycja, SizeOf( TWieloosobowe__Wektor_4 )  );

                        end;
                      //---//for k := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do

                    end;
                  //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t ) - 1 do


                  SetLength( wieloosobowe__statki_t[ i ].działa_t, wieloosobowe__statki_t[ i ].działa_t__długość_tabeli );

                  for j := 0 to Length( wieloosobowe__statki_t[ i ].działa_t ) - 1 do
                    begin

                      //strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].działa_t[ j ], obiekty_wieloosobowe__działo_r__rozmiar_c );

                      strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].działa_t[ j ].obrót_kąt, SizeOf( real )  );
                      strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].działa_t[ j ].celownik_linia__podniesienie_kąt, SizeOf( real )  );
                      strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].działa_t[ j ].celownik_linia__szerokość, SizeOf( single )  );
                      strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].działa_t[ j ].celownik_linia__wzór, SizeOf( word )  );
                      strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].działa_t[ j ].amunicja_ilość, SizeOf( integer )  );
                      strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t__długość_tabeli, SizeOf( integer )  );
                      strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].działa_t[ j ].celownik_linia__kolor, SizeOf( TWieloosobowe__Wektor_4 )  );

                      SetLength( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t, wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t__długość_tabeli );

                      for k := 0 to Length( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
                        begin

                          //strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );

                          strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_kąt, SizeOf( real )  );
                          strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z, SizeOf( real )  );
                          strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].strzał_gotowość, SizeOf( boolean )  );
                          strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__kolor, SizeOf( TWieloosobowe__Wektor_4 )  );
                          strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__pozycja, SizeOf( TWieloosobowe__Wektor_4 )  );

                        end;
                      //---//for k := 0 to Length( wieloosobowe__statki_t[ i ].działa_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do

                    end;
                  //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].działa_t ) - 1 do


                  SetLength( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t, wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t__długość_tabeli );

                  for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do
                    begin

                      //strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ], obiekty_wieloosobowe__działo_r__rozmiar_c );

                      strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obrót_kąt, SizeOf( real )  );
                      strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia__podniesienie_kąt, SizeOf( real )  );
                      strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia__szerokość, SizeOf( single )  );
                      strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia__wzór, SizeOf( word )  );
                      strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].amunicja_ilość, SizeOf( integer )  );
                      strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t__długość_tabeli, SizeOf( integer )  );
                      strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia__kolor, SizeOf( TWieloosobowe__Wektor_4 )  );

                      SetLength( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t, wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t__długość_tabeli );

                      for k := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
                        begin

                          //strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );

                          strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_kąt, SizeOf( real )  );
                          strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z, SizeOf( real )  );
                          strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].strzał_gotowość, SizeOf( boolean )  );
                          strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__kolor, SizeOf( TWieloosobowe__Wektor_4 )  );
                          strumień_pamięci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].przeładowanie_wskaźnik__pozycja, SizeOf( TWieloosobowe__Wektor_4 )  );

                        end;
                      //---//for k := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do

                    end;
                  //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do


                  wieloosobowe__statki_t[ i ].radar_id_statki_w_zasięgu := Strumień_Napis_Odczytaj( strumień_pamięci_l );
                  wieloosobowe__statki_t[ i ].radio_id_statki_w_zasięgu := Strumień_Napis_Odczytaj( strumień_pamięci_l );

                end;
              //---//while strumień_pamięci_l.Position < strumień_pamięci_l.Size do
              {$endregion 'wieloosobowe__komenda__odbierz__rekord_statki_c.'}

            end
          else//if komenda_l = wieloosobowe__komenda__odbierz__rekord_statki_c then
          if komenda_l = wieloosobowe__komenda__odbierz__statki_definicje_c then
            begin

              SetLength( statki_lista_t, 0 );

              if czy_klient_g then
                begin

                  // Tylko klient odczytuje dane o statkach.

                  while strumień_pamięci_l.Position < strumień_pamięci_l.Size do
                    begin

                      i := Length( statki_lista_t );
                      SetLength( statki_lista_t, i + 1 );

                      statki_lista_t[ i ].id := Strumień_Napis_Odczytaj( strumień_pamięci_l );
                      statki_lista_t[ i ].nazwa := Strumień_Napis_Odczytaj( strumień_pamięci_l );
                      statki_lista_t[ i ].opis := Strumień_Napis_Odczytaj( strumień_pamięci_l );
                      statki_lista_t[ i ].plik_nazwa := Strumień_Napis_Odczytaj( strumień_pamięci_l );
                      statki_lista_t[ i ].treść := Strumień_Napis_Odczytaj( strumień_pamięci_l );

                    end;
                  //---//while strumień_pamięci_l.Position < strumień_pamięci_l.Size do


                  j := Statek_ComboBox.ItemIndex;
                  Statek_ComboBox.Items.Clear();

                  for i := 0 to Length( statki_lista_t ) - 1 do
                    if Trim( statki_lista_t[ i ].nazwa ) <> '' then
                      Statek_ComboBox.Items.Add( statki_lista_t[ i ].nazwa )
                    else//if Trim( statki_lista_t[ i ].nazwa ) <> '' then
                      Statek_ComboBox.Items.Add( statki_lista_t[ i ].plik_nazwa );


                  Statki_Zwolnij();

                  Statek_ComboBox.ItemIndex := j;

                  if    ( Statek_ComboBox.ItemIndex < 0 )
                    and (  Statek_ComboBox.Items.Count >= 1  ) then
                    Statek_ComboBox.ItemIndex := 0;

                  Statek_ComboBoxChange( nil );

                  Statek__Utwórz_BitBtnClick( nil ); //??? jakiś statek chyba musi być utworzony bo zgłasza błędy do sprawdzenia.

                end;
              //---//if czy_klient_g then

            end
          else//if komenda_l = wieloosobowe__komenda__odbierz__statki_definicje_c then
          if komenda_l = wieloosobowe__komenda__pauza_c then
            begin

              if czy_klient_g then
                begin

                  // Tylko klient odczytuje komunikat o pauzie.

                  Pauza(  Strumień_Napis_Odczytaj( strumień_pamięci_l ) = 'Tak'  );

                end;
              //---//if czy_klient_g then

            end
          else//if komenda_l = wieloosobowe__komenda__pauza_c then
          if komenda_l = wieloosobowe__komenda__serwer_wyłącza_się_c then
            begin

              Result := wieloosobowe__komenda__serwer_wyłącza_się_c;
              strumień_pamięci_l.Read(  zts, SizeOf ( wieloosobowe__komenda__serwer_wyłącza_się_c )  );

            end
          else//if komenda_l = wieloosobowe__komenda__serwer_wyłącza_się_c then
          if komenda_l = wieloosobowe__komenda__statek__klawisze_obsługa_c then
            begin

              if czy_serwer_g then
                begin

                  // Tylko serwer odbiera informacje o obsłudze klawiszy od klientów.

                  strumień_pamięci_l.Read( wieloosobowe__statek_klawisze_obsługa_r_l, obiekty_wieloosobowe__statek_klawisze_obsługa_r__rozmiar_c );

                  // Tłumaczy konfigurację klawiatury klienta na konfigurację klawiatury serwera.
                  j := 1;

                  if Trim( wieloosobowe__statek_klawisze_obsługa_r_l.polecenie_nazwa ) <> '' then
                    begin

                      for i := 0 to Length( klawiatura_konfiguracja_r_t ) - 1 do
                        if wieloosobowe__statek_klawisze_obsługa_r_l.polecenie_nazwa = klawiatura_konfiguracja_r_t[ i ].polecenie_nazwa then
                          begin

                            j := 0;


                            if klawiatura_konfiguracja_r_t[ i ].czy_mysz then
                              begin

                                wieloosobowe__statek_klawisze_obsługa_r_l.klawisz := 0;
                                wieloosobowe__statek_klawisze_obsługa_r_l.mysz_przycisk := klawiatura_konfiguracja_r_t[ i ].klawisz;

                              end
                            else//if klawiatura_konfiguracja_r_t[ i ].czy_mysz then
                              begin

                                wieloosobowe__statek_klawisze_obsługa_r_l.klawisz := klawiatura_konfiguracja_r_t[ i ].klawisz;
                                wieloosobowe__statek_klawisze_obsługa_r_l.mysz_przycisk := -1;

                              end;
                            //---//if klawiatura_konfiguracja_r_t[ i ].czy_mysz then


                            wieloosobowe__statek_klawisze_obsługa_r_l.shift := [];

                            if klawiatura_konfiguracja_r_t[ i ].plus_alt then
                              wieloosobowe__statek_klawisze_obsługa_r_l.shift := wieloosobowe__statek_klawisze_obsługa_r_l.shift + [ ssAlt ];

                            if klawiatura_konfiguracja_r_t[ i ].plus_ctrl then
                              wieloosobowe__statek_klawisze_obsługa_r_l.shift := wieloosobowe__statek_klawisze_obsługa_r_l.shift + [ ssCtrl ];

                            if klawiatura_konfiguracja_r_t[ i ].plus_shift then
                              wieloosobowe__statek_klawisze_obsługa_r_l.shift := wieloosobowe__statek_klawisze_obsługa_r_l.shift + [ ssShift ];

                            Break;

                          end;
                      //---//for i := 0 to Length( klawiatura_konfiguracja_r_t ) - 1 do

                    end;
                  //---//if Trim( wieloosobowe__statek_klawisze_obsługa_r_l.polecenie_nazwa ) <> '' then
                  //---// Tłumaczy konfigurację klawiatury klienta na konfigurację klawiatury serwera.


                  if j = 0 then // Jeżeli kombinacja klawiszy jest nierozpoznana nic nie zmienia.
                    Statek_Klawisze_Obsługa
                      (
                        wieloosobowe__statek_klawisze_obsługa_r_l.id_statek, wieloosobowe__statek_klawisze_obsługa_r_l.klawisz, wieloosobowe__statek_klawisze_obsługa_r_l.mysz_przycisk, wieloosobowe__statek_klawisze_obsługa_r_l.shift,
                        Amunicja_Rodzaj_Zbiór_Zwróć( false, wieloosobowe__statek_klawisze_obsługa_r_l.ar_artyleria, wieloosobowe__statek_klawisze_obsługa_r_l.ar_pocisk, wieloosobowe__statek_klawisze_obsługa_r_l.ar_torpeda, wieloosobowe__statek_klawisze_obsługa_r_l.ar_wszystkie ),
                        true
                      );

                  Statek_Klient_Cel_Ustaw( wieloosobowe__statek_klawisze_obsługa_r_l.id_statek, wieloosobowe__statek_klawisze_obsługa_r_l.cel_współrzędne );

                end;
              //---//if czy_serwer_g then

            end
          else//if komenda_l = wieloosobowe__komenda__statek__klawisze_obsługa_c then
          if komenda_l = wieloosobowe__komenda__statek__przywróć_do_gry_c then
            begin

              strumień_pamięci_l.Read( wieloosobowe__statek_przywróć_do_gry__id_statek_g, SizeOf( wieloosobowe__statek_przywróć_do_gry__id_statek_g )  );
              Statek_Przywróć_Do_Gry( wieloosobowe__statek_przywróć_do_gry__id_statek_g );
              wieloosobowe__statek_przywróć_do_gry__id_statek_g := -99;

            end
          else//if komenda_l = wieloosobowe__komenda__statek__przywróć_do_gry_c then
          if komenda_l = wieloosobowe__komenda__udp__klient_połączony_nadal_c then
            begin

              if czy_serwer_g then
                begin

                  // Tylko serwer odczytuje aktywność podłączenia klientów.

                  if czy_udp_l then
                    begin

                      // Sprawdza czy klient UDP przysłał dane zgodne z klientem TCP i czy znacznik czasu wysyłki nie jest za stary, zapamiętuje peer port klienta  UDP.

                      zts := Strumień_Napis_Odczytaj( strumień_pamięci_l );

                      i := Pos( ';', zts );
                      j := -99;

                      if i > 1 then
                        try
                          j := StrToInt(  Copy( zts, 1, i - 1 )  ); // TCP peer_port.
                        except
                        end;
                        //---//try

                      if j <> -99 then
                        begin

                          Delete( zts, 1, i );

                          zt_tcp_klient_dane := tcp_klienci_lista_g.Znajdź_Peer_Port( j );

                          if zt_tcp_klient_dane <> nil then
                            begin

                              i := Pos( ';', zts );
                              j := -1;

                              if i > 1 then
                                try
                                  j := StrToInt(  Copy( zts, 1, i - 1 )  ); // Identyfikator gracza.
                                except
                                end;
                                //---//try


                              if    ( j <> -1 )
                                and ( zt_tcp_klient_dane.identyfikator = j ) then
                                begin

                                  Delete( zts, 1, i );


                                  i := Pos( ';', zts );
                                  ztdu := -1;

                                  if i > 1 then
                                    try
                                      ztdu := StrToFloat(  Copy( zts, 1, i - 1 )  ); // Znacznik czasu.
                                    except
                                    end;
                                    //---//try

                                  if SecondsBetween( Now(), ztdu ) <= udp_klient_połączenie_potwierdzanie_sekund_c * 2 then
                                    begin

                                      zt_tcp_klient_dane.peer_port_udp := id_socket_handle_f.PeerPort;
                                      zt_tcp_klient_dane.data_czas__udp_kontakt := Now();
                                      udp_klienci_lista_g.Dodaj( id_socket_handle_f.PeerIP, id_socket_handle_f.PeerPort, zt_tcp_klient_dane.identyfikator );

                                      //udp_klienci_lista_g.Usuń_Przeterminowanych();
                                      //udp_data_czas_sprawdzanie_połączeń_ostatnie_g := Now();

                                    end;
                                  //---//if SecondsBetween( Now(), ztdu ) <= udp_klient_połączenie_potwierdzanie_sekund_c * 2 then

                                end;
                              //---//if    ( j <> -1 ) (...)

                            end;
                          //---//if zt_tcp_klient_dane <> nil then

                        end;
                      //---//if j <> -99 then

                    end;
                  //---//if czy_udp_l then

                end;
              //---//if czy_serwer_g then

            end
          else//if komenda_l = wieloosobowe__komenda__udp__klient_połączony_nadal_c then
          if komenda_l = wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_r_c then
            begin

              strumień_pamięci_l.Read( komunikacja_rekord_testowy_r, komunikacja_rekord_testowy_r__rozmiar_c );
              Komunikacja_Rekord_Testowy_Obsługa();

            end
          else//if komenda_l = wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_r_c then
          if komenda_l = wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_2_r_c then
            begin

              strumień_pamięci_l.Read(  komunikacja_rekord_testowy_2_r_l.liczba_całkowita, SizeOf( integer )  );
              strumień_pamięci_l.Read(  komunikacja_rekord_testowy_2_r_l.liczba_rzeczywista, SizeOf( real )  );
              strumień_pamięci_l.Read(  komunikacja_rekord_testowy_2_r_l.data_czas, SizeOf( TDateTime )  );

              //strumień_pamięci_l.Read( komunikacja_rekord_testowy_2_r_l, komunikacja_rekord_testowy_2_r__rozmiar_c ); // Tak nie działa.

              if komunikacja_rekord_testowy_2_r_l.liczba_całkowita > 0 then
                begin

                  SetLength( komunikacja_rekord_testowy_2_r_l.napis, komunikacja_rekord_testowy_2_r_l.liczba_całkowita );

                  strumień_pamięci_l.ReadBuffer(
                      Pointer( komunikacja_rekord_testowy_2_r_l.napis )^,
                      char_rozmiar_c * komunikacja_rekord_testowy_2_r_l.liczba_całkowita
                    );

                end;
              //---//if komunikacja_rekord_testowy_2_r_l.liczba_całkowita > 0 then

              Wieloosobowe__Log_Wypisz(   'RT o ' + IntToStr( komunikacja_rekord_testowy_2_r_l.liczba_całkowita ) + ' ' + ': ' + komunikacja_rekord_testowy_2_r_l.napis + '.'  ); //???

            end;
          //else//if komenda_l = wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_2_r_c then
          //  ;


          FreeAndNil( strumień_pamięci_l );


          if komenda_l = wieloosobowe__komenda__odbierz__rekord_amunicja_c then
            Wieloosobowe_Amunicja_Parametry_Ustaw()
          else//if komenda_l = wieloosobowe__komenda__odbierz__rekord_amunicja_c then
          if komenda_l = wieloosobowe__komenda__odbierz__rekord_statki_c then
            Wieloosobowe_Statki_Parametry_Ustaw();
          {$endregion 'Przetwarza odczytane dane.'}

        end
      else//if    ( strumień_rozmiar > 0 ) (...)
        begin

          if komenda_l = wieloosobowe__komenda__odbierz__rekord_amunicja_c then
            begin

              // Jeżeli nie ma już amunicji na scenie to przychodzi pusta informacja (komenda i pusty strumień wielkość równa 0)
              // Klienci usuną u siebie pozostałą widoczną amunicję.

              SetLength( wieloosobowe__amunicja_t, 0 );
              Wieloosobowe_Amunicja_Parametry_Ustaw();

            end;
          //---//if komenda_l = wieloosobowe__komenda__odbierz__rekord_amunicja_c then

        end;
      //---//
      //---//if    ( strumień_rozmiar > 0 ) (...)

    end
  else//if   ( komenda_l = wieloosobowe__komenda__odbierz__rekord_amunicja_c ) (...)
    Result := komenda_l;

end;//---//Funkcja Wieloosobowe__Odczytaj().

//Funkcja Wieloosobowe__Trafienia_Efekt_Utwórz().
procedure TStatki_Form.Wieloosobowe__Trafienia_Efekt_Utwórz( obiekty_wieloosobowe__efekt_r_f : TObiekty_Wieloosobowe__Efekt_r );
var
  i : integer;
  zt_gl_base_scene_object : TGLBaseSceneObject;
begin

  if obiekty_wieloosobowe__efekt_r_f.id_statek = -1 then // Scena.
    zt_gl_base_scene_object := Gra_Obiekty_GLDummyCube
  else//if obiekty_wieloosobowe__efekt_r_f.id_statek = -1 then
    begin

      zt_gl_base_scene_object := nil;

      for i := 0 to Length( statki_t ) - 1 do
        if    ( statki_t[ i ] <> nil )
          and ( statki_t[ i ].id_statek = obiekty_wieloosobowe__efekt_r_f.id_statek ) then
          begin

            zt_gl_base_scene_object := statki_t[ i ];
            Break;

          end;
        //---//if    ( statki_t[ i ] <> nil ) (...)

    end;
  //---//if obiekty_wieloosobowe__efekt_r_f.id_statek = -1 then


  if wieloosobowe_amunicja_efekt_g <> nil then
    begin

      wieloosobowe_amunicja_efekt_g.amunicja_rodzaj := obiekty_wieloosobowe__efekt_r_f.amunicja_rodzaj;

    end;
  //---//if wieloosobowe_amunicja_efekt_g <> nil then


  Trafienia_Efekt_Utwórz_Jeden( zt_gl_base_scene_object, obiekty_wieloosobowe__efekt_r_f.efekt_rodzaj, obiekty_wieloosobowe__efekt_r_f.pozycja.X, obiekty_wieloosobowe__efekt_r_f.pozycja.Y, obiekty_wieloosobowe__efekt_r_f.pozycja.Z, wieloosobowe_amunicja_efekt_g, obiekty_wieloosobowe__efekt_r_f.czas_trwania, obiekty_wieloosobowe__efekt_r_f.czas_trwania_efekt_dodatkowy );

end;//---//Funkcja Wieloosobowe__Trafienia_Efekt_Utwórz().

//Funkcja Wieloosobowe__Trafienia_Efekt_Utwórz().
procedure TStatki_Form.Wieloosobowe__Trafienia_Efekt_Utwórz( obiekty_wieloosobowe__efekt_t_f : array of TObiekty_Wieloosobowe__Efekt_r );
var
  i,
  j
    : integer;
  zt_gl_base_scene_object : TGLBaseSceneObject;
begin

  for i := 0 to Length( wieloosobowe__efekt_t ) - 1 do
    begin

      if obiekty_wieloosobowe__efekt_t_f[ i ].id_statek = -1 then // Scena.
        zt_gl_base_scene_object := Gra_Obiekty_GLDummyCube
      else//if obiekty_wieloosobowe__efekt_t_f[ i ].id_statek = -1 then
        begin

          zt_gl_base_scene_object := nil;

          for j := 0 to Length( statki_t ) - 1 do
            if    ( statki_t[ j ] <> nil )
              and ( statki_t[ j ].id_statek = obiekty_wieloosobowe__efekt_t_f[ i ].id_statek ) then
              begin

                zt_gl_base_scene_object := statki_t[ j ];
                Break;

              end;
            //---//if    ( statki_t[ j ] <> nil ) (...)

        end;
      //---//if obiekty_wieloosobowe__efekt_t_f[ i ].id_statek = -1 then


      if wieloosobowe_amunicja_efekt_g <> nil then
        begin

          wieloosobowe_amunicja_efekt_g.amunicja_rodzaj := obiekty_wieloosobowe__efekt_t_f[ i ].amunicja_rodzaj;

        end;
      //---//if wieloosobowe_amunicja_efekt_g <> nil then


      Trafienia_Efekt_Utwórz_Jeden( zt_gl_base_scene_object, obiekty_wieloosobowe__efekt_t_f[ i ].efekt_rodzaj, obiekty_wieloosobowe__efekt_t_f[ i ].pozycja.X, obiekty_wieloosobowe__efekt_t_f[ i ].pozycja.Y, obiekty_wieloosobowe__efekt_t_f[ i ].pozycja.Z, wieloosobowe_amunicja_efekt_g, obiekty_wieloosobowe__efekt_t_f[ i ].czas_trwania, obiekty_wieloosobowe__efekt_t_f[ i ].czas_trwania_efekt_dodatkowy );

    end;
  //---//for i := 0 to Length( wieloosobowe__efekt_t ) - 1 do

end;//---//Funkcja Wieloosobowe__Trafienia_Efekt_Utwórz().

//Funkcja Wieloosobowe__Log_Wypisz().
procedure TStatki_Form.Wieloosobowe__Log_Wypisz( const napis_f : string; const wyróżnij_f : boolean = false );
var
  wieloosobowe_powiadomienie_l : TWieloosobowe_Powiadomienie;
begin

  wieloosobowe_powiadomienie_l := TWieloosobowe_Powiadomienie.Create();
  wieloosobowe_powiadomienie_l.powiadomienie_treść := napis_f;
  wieloosobowe_powiadomienie_l.wyróżnij := wyróżnij_f;
  wieloosobowe_powiadomienie_l.Notify();

  // Bez Free().

end;//---//Funkcja Wieloosobowe__Log_Wypisz().

//Funkcja Gracz_Identyfikator().
function TStatki_Form.Gracz_Identyfikator() : integer;
begin

  //
  // Funkcja zwraca identyfikator gracza.
  //
  // Zwraca identyfikator gracza lub -9999 gdy brak identyfikatora.
  //

  try
    Result := StrToInt( Wieloosobowe_Identyfikator_Edit.Text );
  except
    Result := -9999;
  end;
  //---//try

end;//---//Funkcja Gracz_Identyfikator().

//Funkcja Gracze_Lista_Odśwież().
procedure TStatki_Form.Gracze_Lista_Odśwież();
var
  i,
  j,
  kolumna_kopia,
  wiersz_kopia
    : integer;
  zts : string;
  zt_pokój_rozmów__wyślij_do__odbiorca_rodzaj : TPokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj;
begin

  kolumna_kopia := Gracze_Lista_StringGrid.Col;
  wiersz_kopia := Gracze_Lista_StringGrid.Row;

  if Gracze_Lista_StringGrid.ColCount <> 13 then
    Gracze_Lista_StringGrid.ColCount := 13;

  if tcp_klienci_lista_g.klienci_lista_list.Count > 0 then
    Gracze_Lista_StringGrid.RowCount := tcp_klienci_lista_g.klienci_lista_list.Count + 1
  else//if tcp_klienci_lista_g.klienci_lista_list.Count > 0 then
    Gracze_Lista_StringGrid.RowCount := 2; // Pusta lista.


  if Gracze_Lista_StringGrid.Cells[ 0, 0 ] = '' then
    begin

      Gracze_Lista_StringGrid.Cells[ 0, 0 ] := 'L. p.';
      Gracze_Lista_StringGrid.Cells[ 1, 0 ] := 'Id';
      Gracze_Lista_StringGrid.Cells[ 2, 0 ] := 'Nazwa';
      Gracze_Lista_StringGrid.Cells[ 3, 0 ] := 'Statek';
      Gracze_Lista_StringGrid.Cells[ 4, 0 ] := 'Grupa';
      Gracze_Lista_StringGrid.Cells[ 5, 0 ] := 'Gotowy';
      Gracze_Lista_StringGrid.Cells[ 6, 0 ] := 'Peer port tcp';
      Gracze_Lista_StringGrid.Cells[ 7, 0 ] := 'Peer port udp';
      Gracze_Lista_StringGrid.Cells[ 8, 0 ] := 'Czas podłączenia';
      Gracze_Lista_StringGrid.Cells[ 9, 0 ] := 'Czas podłączenia ostatniego';
      Gracze_Lista_StringGrid.Cells[ 10, 0 ] := 'Czas dłączenia';
      Gracze_Lista_StringGrid.Cells[ 11, 0 ] := 'Czas kontaktu udp ostatniego';
      Gracze_Lista_StringGrid.Cells[ 12, 0 ] := 'Odłączony';

    end;
  //---//if Gracze_Lista_StringGrid.Cells[ 0, 0 ] = '' then


  // Czyści wpisy.
  for i := 0 to Gracze_Lista_StringGrid.ColCount - 1 do
    for j := 1 to Gracze_Lista_StringGrid.RowCount - 1 do
      begin

        Gracze_Lista_StringGrid.Cells[ i, j ] := '';
        Gracze_Lista_StringGrid.Cells[ i, j ] := '';
        Gracze_Lista_StringGrid.Cells[ i, j ] := '';
        Gracze_Lista_StringGrid.Cells[ i, j ] := '';
        Gracze_Lista_StringGrid.Cells[ i, j ] := '';
        Gracze_Lista_StringGrid.Cells[ i, j ] := '';
        Gracze_Lista_StringGrid.Cells[ i, j ] := '';
        Gracze_Lista_StringGrid.Cells[ i, j ] := '';
        Gracze_Lista_StringGrid.Cells[ i, j ] := '';
        Gracze_Lista_StringGrid.Cells[ i, j ] := '';

      end;
    //---//for j := 0 to Gracze_Lista_StringGrid.RowCount - 1 do


  for i := 0 to tcp_klienci_lista_g.klienci_lista_list.Count - 1 do
    begin

      Gracze_Lista_StringGrid.Cells[ 0, i + 1 ] := IntToStr( i + 1 );
      Gracze_Lista_StringGrid.Cells[ 1, i + 1 ] := IntToStr( TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator );
      Gracze_Lista_StringGrid.Cells[ 2, i + 1 ] := TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).nazwa;

      j := TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).id_statek_schemat;
      Gracze_Lista_StringGrid.Cells[ 3, i + 1 ] := Trim(  FormatFloat( '### ### ##0', j )  );
        if    ( j >= 0 )
          and (  j <= Length( statki_lista_t ) - 1 ) then
          Gracze_Lista_StringGrid.Cells[ 3, i + 1 ] := Gracze_Lista_StringGrid.Cells[ 3, i + 1 ] + ' - ' + statki_lista_t[ j ].nazwa;

      Gracze_Lista_StringGrid.Cells[ 4, i + 1 ] := Trim(  FormatFloat( '### ### ##0', TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).id_grupa )  );

      if TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).gotowy then
        Gracze_Lista_StringGrid.Cells[ 5, i + 1 ] := 'tak'
      else//if TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).gotowy then
        Gracze_Lista_StringGrid.Cells[ 5, i + 1 ] := 'nie';

      Gracze_Lista_StringGrid.Cells[ 6, i + 1 ] := Trim(  FormatFloat( '### ### ##0', TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).peer_port_tcp )  );
      Gracze_Lista_StringGrid.Cells[ 7, i + 1 ] := Trim(  FormatFloat( '### ### ##0', TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).peer_port_udp )  );
      Gracze_Lista_StringGrid.Cells[ 8, i + 1 ] := DateTimeToStr( TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).data_czas__podłączenia );
      Gracze_Lista_StringGrid.Cells[ 9, i + 1 ] := DateTimeToStr( TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).data_czas__podłączenia_ostatniego );

      if TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).data_czas__dłączenia <> 0 then
        Gracze_Lista_StringGrid.Cells[ 10, i + 1 ] := DateTimeToStr( TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).data_czas__dłączenia );

      if TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).data_czas__udp_kontakt <> 0 then
        Gracze_Lista_StringGrid.Cells[ 11, i + 1 ] := DateTimeToStr( TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).data_czas__udp_kontakt );

      if TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).odłączony then
        Gracze_Lista_StringGrid.Cells[ 12, i + 1 ] := 'tak'
      else//if TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).odłączony then
        Gracze_Lista_StringGrid.Cells[ 12, i + 1 ] := 'nie';

    end;
  //---//for i := 0 to tcp_klienci_lista_g.klienci_lista_list.Count - 1 do


  if tcp_klienci_lista_g.klienci_lista_list.Count <= 0 then
    Gracze_Lista_StringGrid.Cells[ 1, 1 ] := '<brak>';


  if Gracze_Lista_StringGrid.ColCount - 1 >= kolumna_kopia then
    Gracze_Lista_StringGrid.Col := kolumna_kopia;

  if Gracze_Lista_StringGrid.RowCount - 1 >= wiersz_kopia then
    Gracze_Lista_StringGrid.Row := wiersz_kopia;


  {$region 'Dodaje odbiorców wiadomości dla pokoju rozmów.'}
  j := Pokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj_ComboBox.ItemIndex;

  for i := 0 to Pokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj_ComboBox.Items.Count - 1 do
    TPokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj(Pokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj_ComboBox.Items.Objects[ i ]).Free();

  Pokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj_ComboBox.Clear();


  zt_pokój_rozmów__wyślij_do__odbiorca_rodzaj := TPokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj.Create();
  zt_pokój_rozmów__wyślij_do__odbiorca_rodzaj.id_odbiorca := 0;
  zt_pokój_rozmów__wyślij_do__odbiorca_rodzaj.odbiorca_rodzaj := pror_Wszyscy;
  Pokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj_ComboBox.Items.AddObject( '<wszyscy>', zt_pokój_rozmów__wyślij_do__odbiorca_rodzaj );


  for i := Gracz_Grupa_SpinEdit.MinValue to Gracz_Grupa_SpinEdit.MaxValue do
    begin

      zt_pokój_rozmów__wyślij_do__odbiorca_rodzaj := TPokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj.Create();
      zt_pokój_rozmów__wyślij_do__odbiorca_rodzaj.id_odbiorca := i;
      zt_pokój_rozmów__wyślij_do__odbiorca_rodzaj.odbiorca_rodzaj := pror_Grupa_Jedna;

      zts := 'grupa ' + Trim(  FormatFloat( '0', i )  );

      if Gracz_Grupa_SpinEdit.Value = i then
        zts := zts + ' sojusznicy';

      Pokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj_ComboBox.Items.AddObject( zts, zt_pokój_rozmów__wyślij_do__odbiorca_rodzaj );

    end;
  //---//for i := Gracz_Grupa_SpinEdit.MinValue to Gracz_Grupa_SpinEdit.MaxValue do


  for i := 0 to tcp_klienci_lista_g.klienci_lista_list.Count - 1 do
    //if TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator >= -1 then // Do SI też można wysyłać komunikaty. //???
    if Gracz_Identyfikator() <> TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator then // Samemu do siebie nie można wysyłać wiadomości.
      begin

        zt_pokój_rozmów__wyślij_do__odbiorca_rodzaj := TPokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj.Create();
        zt_pokój_rozmów__wyślij_do__odbiorca_rodzaj.id_odbiorca := TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator;
        zt_pokój_rozmów__wyślij_do__odbiorca_rodzaj.odbiorca_rodzaj := pror_Gracz_Jeden;

        zts := 'gracz ' + TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).nazwa + ' (' +Trim(  FormatFloat( '00', TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator )  ) + ')';

        Pokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj_ComboBox.Items.AddObject( zts, zt_pokój_rozmów__wyślij_do__odbiorca_rodzaj );

      end;
    //---//if Gracz_Identyfikator() <> TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator then


  if j < 0 then
    j := 0;

  if    ( j >= 0 )
    and ( j <= Pokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj_ComboBox.Items.Count - 1 ) then
    Pokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj_ComboBox.ItemIndex := j;
  {$endregion 'Dodaje odbiorców wiadomości dla pokoju rozmów.'}

end;//---//Funkcja Gracze_Lista_Odśwież().

//Funkcja Gracze_Lista_Rozłącz().
procedure TStatki_Form.Gracze_Lista_Rozłącz( const peer_port_f : integer );
var
  i : integer;
  lista : TList;
begin

  //
  // Funkcja odłącza klientów.
  //
  // Parametry:
  //   peer_port_f:
  //     = -99 - odłączy wszystkich klientów.
  //     <> -99 - odłączy wskazanego klienta.
  //

  lista := IdTCPServer1.Contexts.LockList();

  try
    for i := 0 to lista.Count - 1 do
      if   ( peer_port_f = -99 )
        or ( TIdContext(lista[ i ]).Connection.Socket.Binding.PeerPort = peer_port_f ) then
        TIdContext(lista[ i ]).Connection.Disconnect(); // Nie wywołuje IdTCPClient1.OnDisconnected().
  finally
    IdTCPServer1.Contexts.UnlockList();
  end;
  //---//try

end;//---//Funkcja Gracze_Lista_Rozłącz().

//Funkcja Informacja_Dodatkowa_Dodaj().
procedure TStatki_Form.Informacja_Dodatkowa_Dodaj( const napis_f : string; const wyświetlanie_czas_sekund_f : smallint = 0 );
begin

  if   ( informacje_dodatkowe_list = nil )
    or (  not Assigned( informacje_dodatkowe_list )  ) then
    Exit;


  if wyświetlanie_czas_sekund_f <= 0 then
    informacje_dodatkowe_list.Add(  TInformacje_Dodatkowe.Create( napis_f )  )
  else//if wyświetlanie_czas_sekund_f <= 0 then
    informacje_dodatkowe_list.Add(  TInformacje_Dodatkowe.Create( napis_f, wyświetlanie_czas_sekund_f )  );

  Informacje_Dodatkowe_TimerTimer( nil );

end;//---//Funkcja Informacja_Dodatkowa_Dodaj().

//Funkcja Interfejs_Parametry_Według_Statku_Ustaw().
procedure TStatki_Form.Interfejs_Parametry_Według_Statku_Ustaw();
begin

  //
  // Funkcja ustawia podpowiedzi w elementach interfejsu na podstawie danych wczytanego statku.
  //

  if statek_gracza = nil then
    Exit;


  Radar_Zasięg_SpinEdit.MaxValue := statek_gracza.radar_zasięg;
  Radar_Zasięg_SpinEdit.Value := Radar_Zasięg_SpinEdit.MaxValue;

  Kamera_Odległość_Maksymalna_SpinEdit.MaxValue := statek_gracza.kamera_odległość_maksymalna;
  Kamera_Odległość_Maksymalna_SpinEdit.Value := Kamera_Odległość_Maksymalna_SpinEdit.MaxValue;

  Radar_Zasięg_SpinEdit.Hint := 'Zasięg radaru: ' + Trim(  FormatFloat( '### ### ##0', statek_gracza.radar_zasięg )  ) + ', radia: ' + Trim(  FormatFloat( '### ### ##0', statek_gracza.radio_zasięg )  ) + '.';

  Radar_Chart.UndoZoom();


  ar_Artyleria_CheckBox.Tag := integer(ar_Artyleria_CheckBox.Checked);
  ar_Pocisk_CheckBox.Tag := integer(ar_Pocisk_CheckBox.Checked);
  ar_Torpeda_CheckBox.Tag := integer(ar_Torpeda_CheckBox.Checked);

  ar_Artyleria_CheckBox.Checked := false;
  ar_Pocisk_CheckBox.Checked := false;
  ar_Torpeda_CheckBox.Checked := false;


  ar_Artyleria_CheckBox.Enabled := Length( statek_gracza.artyleria_t ) > 0;
  ar_Pocisk_CheckBox.Enabled := Length( statek_gracza.działa_t ) > 0;
  ar_Torpeda_CheckBox.Enabled := Length( statek_gracza.torpedy_wyrzutnie_t ) > 0;


  if ar_Artyleria_CheckBox.Enabled then
    ar_Artyleria_CheckBox.Checked := boolean(ar_Artyleria_CheckBox.Tag);

  if ar_Pocisk_CheckBox.Enabled then
    ar_Pocisk_CheckBox.Checked := boolean(ar_Pocisk_CheckBox.Tag);

  if ar_Torpeda_CheckBox.Enabled then
    ar_Torpeda_CheckBox.Checked := boolean(ar_Torpeda_CheckBox.Tag);

end;//---//Funkcja Interfejs_Parametry_Według_Statku_Ustaw().

//Funkcja Klawisz_Konfiguracja_Zwolnij().
procedure TStatki_Form.Klawisz_Konfiguracja_Zwolnij();
var
  i : integer;
begin

  for i := Klawiatura_Konfiguracja_ScrollBox.ControlCount - 1 downto 0 do // Tylko wizualne. // Zwalnia elementy okna, które są podrzędne dla Element_Nadrzedny (tu ScrollBox1).
    Klawiatura_Konfiguracja_ScrollBox.Controls[ i ].Free();

end;//---//Funkcja Klawisz_Konfiguracja_Zwolnij().

//Funkcja Log_Wypisz().
procedure TStatki_Form.Log_Wypisz( const napis_f : string; const przełącz_zakładkę_f : boolean = true );
begin

  //
  // Funkcja wpisuje napis do pola logu.
  //
  // Parametry:
  //   napis_f
  //   przełącz_zakładkę_f:
  //     false - nie przełącza zakładki.
  //     true - przełącza zakładkę.
  //
  // Gdy wpisuje logi to serwer TCP blokuje się i Log_Memo staje się niewidoczne - lepiej używać Wieloosobowe__Log_Wypisz().
  //

  if Trim( napis_f ) = '' then
    Exit;

  Log_Memo.Lines.Add( '___' );
  Log_Memo.Lines.Add( napis_f );
  //Log_Memo.Lines.Add( '---' );

  if przełącz_zakładkę_f then
    PageControl1.ActivePage := Log_TabSheet;

end;//---//Funkcja Log_Wypisz().

//Funkcja Pokój_Rozmów__Wyświetl_Wiadomość().
procedure TStatki_Form.Pokój_Rozmów__Wyświetl_Wiadomość( pokój_rozmów_r_f : TPokój_Rozmów_r );
var
  pokój_rozmów_powiadomienie_l : TPokój_Rozmów_Powiadomienie;
begin

  pokój_rozmów_powiadomienie_l := TPokój_Rozmów_Powiadomienie.Create();
  pokój_rozmów_powiadomienie_l.pokój_rozmów_r := pokój_rozmów_r_f;
  pokój_rozmów_powiadomienie_l.Notify();

  // Bez Free().

end;//---//Funkcja Pokój_Rozmów__Wyświetl_Wiadomość().

//Funkcja Radar_Ląd_Rysuj().
procedure TStatki_Form.Radar_Ląd_Rysuj();
var
  i : integer;
begin

  if   ( ląd_list = nil )
    or (  not Assigned( ląd_list )  ) then
    Exit;

  for i := 0 to ląd_list.Count - 1 do
    begin


      if   ( statek_gracza = nil )
        or (
                 ( statek_gracza <> nil )
             and ( statek_gracza.DistanceTo( TGLCustomSceneObject(ląd_list[ i ]) ) <= Radar_Zasięg_SpinEdit.Value )
           ) then
        Radar_Chart.Series[ radar__ląd_c ].AddXY( TGLCustomSceneObject(ląd_list[ i ]).AbsolutePosition.X, -TGLCustomSceneObject(ląd_list[ i ]).AbsolutePosition.Z );

    end;
  //---//for i := 0 to ląd_list.Count - 1 do


end;//---//Funkcja Radar_Ląd_Rysuj().

//Funkcja Radar_Statki_Rysuj().
procedure TStatki_Form.Radar_Statki_Rysuj();
var
  i : integer;
  ślad_rysuj : boolean;
  zt_color : TColor;
  zt_gl_coordinates_3 : TGLCoordinates3;
begin//Funkcja Statki_Ruch().

  Radar_Timer.Tag := Radar_Timer.Tag + 1;

  if Radar_Timer.Tag >= 5 then
    begin

      Radar_Timer.Tag := 0;
      ślad_rysuj := true;

    end
  else//if Radar_Timer.Tag >= 5 then
    ślad_rysuj := false;


  zt_gl_coordinates_3 := TGLCoordinates3.Create( Application );

  for i := 0 to Length( statki_t ) - 1 do
    begin

      if statki_t[ i ] <> nil then
        begin

          if   ( statek_gracza = nil )
            or (
                     ( statek_gracza <> nil )
                 and (
                          ( statek_gracza.id_statek = statki_t[ i ].id_statek )
                       or ( statek_gracza.DistanceTo( statki_t[ i ] ) <= Radar_Zasięg_SpinEdit.Value ) // Do aktualnie ustawionego zasięgu radaru.
                       or (  Radio_Dane_Wymień( statek_gracza, statki_t[ i ].id_statek )  )
                     )
               ) then
            begin

              zt_color := clBlack;

              if statek_gracza <> nil then
                if statek_gracza.id_grupa = statki_t[ i ].id_grupa then
                  zt_color := clLime
                else//if statek_gracza.id_grupa = statki_t[ i ].id_grupa then
                  zt_color := clRed;

              Radar_Chart.Series[ radar__statki_c ].AddXY( statki_t[ i ].AbsolutePosition.X, -statki_t[ i ].AbsolutePosition.Z, '', zt_color );

              if ślad_rysuj then
                begin

                  Radar_Chart.Series[ radar__statki_ślady_c ].AddXY(  statki_t[ i ].AbsolutePosition.X, -statki_t[ i ].AbsolutePosition.Z, IntToStr( Czas_Teraz() )  );

                end;
              //---//if ślad_rysuj then


              // Określa punkt wskazujący kierunek statku.
              zt_gl_coordinates_3.AsAffineVector := statki_t[ i ].Position.AsAffineVector;
              zt_gl_coordinates_3.AddScaledVector( Radar_Zasięg_SpinEdit.Value * 0.075, statki_t[ i ].AbsoluteDirection );
              Radar_Chart.Series[ radar__statki_kierunek_c ].AddXY( zt_gl_coordinates_3.X, -zt_gl_coordinates_3.Z, '', zt_color );

            end;
          //---//if   ( statek_gracza = nil ) (...)


          if statki_t[ i ] = statek_gracza then
            begin

              Radar_Chart.Series[ radar__statek_margines_c ].AddXY( statki_t[ i ].AbsolutePosition.X - Radar_Zasięg_SpinEdit.Value, -statki_t[ i ].AbsolutePosition.Z - Radar_Zasięg_SpinEdit.Value );
              Radar_Chart.Series[ radar__statek_margines_c ].AddXY( statki_t[ i ].AbsolutePosition.X + Radar_Zasięg_SpinEdit.Value, -statki_t[ i ].AbsolutePosition.Z + Radar_Zasięg_SpinEdit.Value );

            end;
          //---//if statki_t[ i ] = statek_gracza then

        end;
      //---//if statki_t[ i ] <> nil then

    end;
  //---//for i := 0 to Length( statki_t ) - 1 do


  if    ( statek_gracza <> nil )
    and ( statek_gracza.DistanceTo( Celowniczy_GLDummyCube ) <= Radar_Zasięg_SpinEdit.Value ) then
    Radar_Chart.Series[ radar__celownik_c ].AddXY( Celowniczy_GLDummyCube.AbsolutePosition.X, -Celowniczy_GLDummyCube.AbsolutePosition.Z );


  FreeAndNil( zt_gl_coordinates_3 );

end;//---//Funkcja Radar_Statki_Rysuj().

//Funkcja Radar_Wyczyść().
procedure TStatki_Form.Radar_Wyczyść( const czyść_wszystko_f : boolean = false );
var
  i : integer;
begin

  //
  // Funkcja czyści wykres radaru.
  //
  // Parametry:
  //   czyść_wszystko_f:
  //     false - ślad ruchu statków jest czyszczony względem czasu trwania.
  //     true - czyści wszystko.
  //

  Radar_Chart.Series[ radar__celownik_c ].Clear();
  Radar_Chart.Series[ radar__ląd_c ].Clear();
  Radar_Chart.Series[ radar__statki_c ].Clear();
  Radar_Chart.Series[ radar__statki_kierunek_c ].Clear();
  Radar_Chart.Series[ radar__statek_margines_c ].Clear();


  if czyść_wszystko_f then
    Radar_Chart.Series[ radar__statki_ślady_c ].Clear()
  else//if czyść_wszystko_f then
    for i := Radar_Chart.Series[ radar__statki_ślady_c ].Count - 1 downto 0 do
      try
        if Czas_Między_W_Sekundach(  StrToInt( Radar_Chart.Series[ radar__statki_ślady_c ].Labels.Labels[ i ] )  ) > 10 then
          Radar_Chart.Series[ radar__statki_ślady_c ].Delete( i );
      except
        Radar_Chart.Series[ radar__statki_ślady_c ].Clear();
      end;
      //---//try

end;//---//Funkcja Radar_Wyczyść().

//Funkcja Radio_Statki_W_Zasięgu().
procedure TStatki_Form.Radio_Statki_W_Zasięgu();
var
  i,
  j
    : integer;
begin

  //
  // Funkcja ustawia statkom jakie id statki mają w zasięgu radaru i radia.
  //

  if czy_klient_g then
    Exit;


  if    ( czy_gra_lokalna_g )
    and ( not Radar_Dane_Z_Radia_CheckBox.Checked ) then
    Exit;


  for i := 0 to Length( statki_t ) - 1 do
    begin

      if statki_t[ i ] <> nil then
        begin

          statki_t[ i ].radar_id_statki_w_zasięgu := '-99';
          statki_t[ i ].radio_id_statki_w_zasięgu := '-99';


          for j := 0 to Length( statki_t ) - 1 do
            begin

              if statki_t[ j ] <> nil then
                begin

                  // Jakie statki ma w zasięgu radaru statek.
                  if    ( statki_t[ i ].id_statek <> statki_t[ j ].id_statek )
                    and ( statki_t[ i ].DistanceTo( statki_t[ j ] ) <= statki_t[ i ].radar_zasięg ) then
                    begin

                      statki_t[ i ].radar_id_statki_w_zasięgu := statki_t[ i ].radar_id_statki_w_zasięgu +
                        ', ' + IntToStr( statki_t[ j ].id_statek );

                    end;
                  //---//if    ( statki_t[ i ].id_statek <> statki_t[ j ].id_statek ) (...)


                  // Jakie statki z własnej grupy ma w zasięgu radia statek.
                  if    ( statki_t[ i ].id_statek <> statki_t[ j ].id_statek )
                    and ( statki_t[ i ].id_grupa = statki_t[ j ].id_grupa )
                    and ( statki_t[ i ].DistanceTo( statki_t[ j ] ) <= statki_t[ i ].radio_zasięg ) then
                    begin

                      statki_t[ i ].radio_id_statki_w_zasięgu := statki_t[ i ].radio_id_statki_w_zasięgu +
                        ', ' + IntToStr( statki_t[ j ].id_statek );

                    end;
                  //---//if    ( statki_t[ i ].id_statek <> statki_t[ j ].id_statek ) (...)

                end;
              //---//if statki_t[ j ] <> nil then

            end;
          //---//for j := 0 to Length( statki_t ) - 1 do


          statki_t[ i ].radar_id_statki_w_zasięgu := statki_t[ i ].radar_id_statki_w_zasięgu +
            ', -99';

          statki_t[ i ].radio_id_statki_w_zasięgu := statki_t[ i ].radio_id_statki_w_zasięgu +
            ', -99';

        end;
      //---//if statki_t[ i ] <> nil then

    end;
  //---//for i := 0 to Length( statki_t ) - 1 do

end;//---//Funkcja Radio_Statki_W_Zasięgu().

//Funkcja Radio_Dane_Wymień().
function TStatki_Form.Radio_Dane_Wymień( const zt_statek_f : TStatek; id_statek_f : integer ) : boolean;
var
  i,
  j
    : integer;
begin

  //
  // Funkcja sprawdza czy informacje o danym statku mogą zostać przekazane przez radio.
  //
  // Zwraca prawdę gdy informacje o danym statku mogą zostać przekazane przez radio.
  //
  // Parametry:
  //   zt_statek_f - statek pytający o informacje.
  //   id_statek_f - id sprawdzanego statku.
  //

  Result := false;

  if   ( not Radar_Dane_Z_Radia_CheckBox.Checked )
    or ( zt_statek_f = nil ) then
    Exit;


  for i := 0 to Length( statki_t ) - 1 do
    begin

      if    ( statki_t[ i ] <> nil )
        and ( statki_t[ i ].id_grupa = zt_statek_f.id_grupa ) // Informacje wymieniają tylko statki z tej samej grupy.
        and (   Pos(  ', ' + IntToStr( statki_t[ i ].id_statek ) + ',',  zt_statek_f.radio_id_statki_w_zasięgu  ) > 0   ) // Statki są w zasięgu radiowym.
        and (   Pos(  ', ' + IntToStr( id_statek_f ) + ',',  statki_t[ i ].radar_id_statki_w_zasięgu  ) > 0   ) // Statek ma zasięgu radaru sprawdzany statek.
        then
        begin

          Result := true;
          Exit;

        end;
      //---//if statki_t[ i ] <> nil then

    end;
  //---//for i := 0 to Length( statki_t ) - 1 do

end;//---//Funkcja Radio_Dane_Wymień().

//Funkcja Komunikacja_Rekord_Testowy_Obsługa().
procedure TStatki_Form.Komunikacja_Rekord_Testowy_Obsługa( const tylko_wyświetl_f : boolean = true );
var
  i : integer;
begin

  //
  // Funkcja wyświetla zawartość testowego rekordu komunikacji
  // i ewentualnie podstawia dane do testowego rekordu komunikacji.
  //
  // Parametry:
  //   tylko_wyświetl_f:
  //     false - podstawi dane.
  //     true - tylko wyświetli.
  //


  if not tylko_wyświetl_f then
    begin

      komunikacja_rekord_testowy_r.liczba_całkowita := Random( 99 );
      komunikacja_rekord_testowy_r.liczba_rzeczywista := Random( 999 ) + Random( 9999 ) * 0.0001;
      komunikacja_rekord_testowy_r.data_czas := Now();
      komunikacja_rekord_testowy_r.napis_krótki := 'ąĄęĘŚĆńół';

      for i := 1 to 10 do
        komunikacja_rekord_testowy_r.napis_krótki := komunikacja_rekord_testowy_r.napis_krótki +
          Char(  Random( 188 ) + 32  ); // Od 32 do 220.

    end;
  //---//if not tylko_wyświetl_f then


  Log_Memo.Lines.Add(  '*' + IntToStr( komunikacja_rekord_testowy_r.liczba_całkowita ) + '*liczba całkowita'  );
  Log_Memo.Lines.Add(  '*' + FloatToStr( komunikacja_rekord_testowy_r.liczba_rzeczywista ) + '*liczba rzeczywista'  );
  Log_Memo.Lines.Add(  '*' + DateTimeToStr( komunikacja_rekord_testowy_r.data_czas ) + '*data czas'  );
  Log_Memo.Lines.Add( '*' + komunikacja_rekord_testowy_r.napis_krótki + '*napis krótki' );
  Log_Memo.Lines.Add(    'Opóźnienie: ' + Trim(   FormatFloat(  '### ### ##0', SecondsBetween( Now(), komunikacja_rekord_testowy_r.data_czas )  )   ) + ' [s].'    );

end;//---//Funkcja Komunikacja_Rekord_Testowy_Obsługa().

//---//      ***      Funkcje      ***      //---//


//FormShow().
procedure TStatki_Form.FormShow( Sender: TObject );
begin

  // Wywołanie w obrębie działania tego zdarzenia Application.MessageBox, ShowMessage wyświetla błąd 'Argument out of range' ale nie przerywa wykonywania reszty kodu.

  czas_bezwzględny_g := 0;
  czas_bezwzględny_skok_milisekundy_g := 50;
  Czas_Bezwzględny_Timer.Interval := czas_bezwzględny_skok_milisekundy_g;

  czy_kamera_od_najnowszego_pocisku := true;
  czy_pauza_g := false;

  czy_gra_lokalna_g := false;
  czy_serwer_g := false;
  czy_klient_g := false;
  czy_wyłączanie_serwera_g := false;
  //czy_wysyłanie_trwa_g := false;
  klient_pierwsze_ustawienie_kamery_g := false;
  pokój_rozmów__zmiana_szerokości__aktywność_g := false;

  pokój_rozmów__zmiana_szerokości__szerokość_początkowa_g := 0;
  pokój_rozmów__zmiana_szerokości__wysokość_początkowa_g := 0;
  pokój_rozmów__zmiana_szerokości__x_początkowy_g := 0;
  pokój_rozmów__zmiana_szerokości__y_początkowy_g := 0;

  ląd_definicja_g := '';

  ląd_pozycja_początkowa_parametry_t[ 1 ].korekta_obrót := 0;
  ląd_pozycja_początkowa_parametry_t[ 1 ].korekta_x := 0;
  ląd_pozycja_początkowa_parametry_t[ 1 ].korekta_z := 0;
  ląd_pozycja_początkowa_parametry_t[ 1 ].odstęp_x := 7;
  ląd_pozycja_początkowa_parametry_t[ 1 ].z := 10;
  ląd_pozycja_początkowa_parametry_t[ 2 ].korekta_obrót := 180;
  ląd_pozycja_początkowa_parametry_t[ 2 ].korekta_x := 0;
  ląd_pozycja_początkowa_parametry_t[ 2 ].korekta_z := 0;
  ląd_pozycja_początkowa_parametry_t[ 2 ].odstęp_x := 7;
  ląd_pozycja_początkowa_parametry_t[ 2 ].z := -10;

  gra_pozycja_początkowa_parametry_t[ 1 ] := ląd_pozycja_początkowa_parametry_t[ 1 ];
  gra_pozycja_początkowa_parametry_t[ 2 ] := ląd_pozycja_początkowa_parametry_t[ 2 ];

  statki_pozycja_początkowa_parametry_t[ 1 ] := ląd_pozycja_początkowa_parametry_t[ 1 ];
  statki_pozycja_początkowa_parametry_t[ 2 ] := ląd_pozycja_początkowa_parametry_t[ 2 ];

  kamera_indeks_amunicji := 0;
  kamera_szybkość_ruchu_g := 1;
  wieloosobowe__statek_przywróć_do_gry__id_statek_g := -99;
  //moment_wciśnięcia_klawisza := Now();
  pokój_rozmów_ostatnia_wiadomość_wysłana_data_czas := 0;

  projektowy_tryb__statek := nil;
  wieloosobowe_amunicja_efekt_g := nil;
  statek_gracza := nil; // Nie zmienia statki_t[ 0 ].

  Randomize();

  GLSceneViewer1.Align := alClient;
  Klawiatura_Konfiguracja_ScrollBox.Align := alClient;

  //mouse_look_active_przed_pauzą := GLUserInterface1.MouseLookActive;

  PageControl1.ActivePage := Gra_TabSheet; //Gra_TabSheet Wieloosobowe_TabSheet Ustawienia_TabSheet Pozostałe_TabSheet Klawiatura_Konfiguracja_TabSheet
  //PageControl1.ActivePage := Wieloosobowe_TabSheet; //???
  //Button1.Visible := false;//???

  // Nie wykrywa mi kolizji z Plane więc ta bryła służy do wykrywania trafień w wodę.
  Woda_Kolizje_GLCube.Position.Y := Woda_GLPlane.Position.Y - Woda_Kolizje_GLCube.CubeHeight * 0.5;
  Woda_Kolizje_GLCube.CubeDepth := Woda_GLPlane.Height;
  Woda_Kolizje_GLCube.CubeWidth := Woda_GLPlane.Width;

  Dno_GLPlane.Height := Woda_GLPlane.Height;
  Dno_GLPlane.Width := Woda_GLPlane.Width;

  Dno_Kolizje_GLCube.Position.Y := Dno_GLPlane.Position.Y - Dno_Kolizje_GLCube.CubeHeight * 0.5;
  Dno_Kolizje_GLCube.CubeDepth := Woda_GLPlane.Height;
  Dno_Kolizje_GLCube.CubeWidth := Woda_GLPlane.Width;

  Gracz_Nazwa_Edit.MaxLength := SizeOf( TWieloosobowe_String ) - 1;
  Pokój_Rozmów_Wiadomość_Edit.MaxLength := SizeOf( TWieloosobowe_String ) - 1;

  Kamera_Odległość_Maksymalna_SpinEdit.Value := 0;

  GLCamera1.Tag := integer(kt_Brak);

  Ustawienia_ScrollBox.VertScrollBar.Position := 0;
  Ustawienia_ScrollBox.HorzScrollBar.Position := 0;

  Klawiatura_Konfiguracja__Domyślna_ButtonClick( Sender );

  amunicja_wystrzelona_list := TList.Create();
  wieloosobowe_amunicja_wystrzelona_list := TList.Create();

  informacje_dodatkowe_list := TList.Create();
  ląd_list := TList.Create();
  trafienia_efekt_list := TList.Create();

  tcp_klienci_lista_g := TTCP_Klienci_Lista.Create();
  udp_klienci_lista_g := TUDP_Klienci_Lista.Create();

  pokój_rozmów_ostatnia_wiadomości_wysłane_treść_string_list := TStringList.Create();

  Wczytaj_Schemat( katalog_schematy_lista__lądy_c, -1, lądy_lista_t );
  Wczytaj_Schemat( katalog_schematy_lista__statki_c, -1, statki_lista_t );
  Wczytaj_Schemat( katalog_schematy_lista__statki_pozycje_początkowe_c, -1, statki_pozycje_początkowe_lista_t );

  Ustawienia_Plik();

  if    ( Ląd_ComboBox.ItemIndex < 0 )
    and (  Ląd_ComboBox.Items.Count >= 1  ) then
    Ląd_ComboBox.ItemIndex := 0; // Nie wywoła Ląd_ComboBoxChange().

  if    ( Statek_ComboBox.ItemIndex < 0 )
    and (  Statek_ComboBox.Items.Count >= 1  ) then
    Statek_ComboBox.ItemIndex := 0;


  Gra_Współczynnik_Prędkości_SpinEditChange( Sender );
  Celownik_Wielkość_EditChange( Sender );
  Kamera_Szybkość_Ruchu_EditChange( Sender );
  Mysz_Czułość_EditChange( Sender );
  Amunicja__Zanurzenie_Głębokość_Zadana_EditChange( Sender );
  Amunicja__Zanurzenie_Głębokość_Zadana_EditChange( Amunicja__Zanurzenie_Głębokość_Zadana__Skok_O_Edit );


  Czas_Bezwzględny_Timer.Enabled := true;
  Informacje_Dodatkowe_Timer.Enabled := true;
  Radar_Timer.Enabled := true;



  Statek__Utwórz_BitBtnClick( Sender );


  Gracze_Lista_Odśwież();


  Klawiatura_Konfiguracja__Wczytaj_ButtonClick( Klawiatura_Konfiguracja__Przyciski_Panel );

  Pokój_Rozmów__Na_Ekranie_CheckBoxClick( Sender );

  //tcp_klienci_lista_g.Dodaj_Aktualizuj( serwer_peer_port_c, -99 ); // Serwer ma peer_port_f i identyfikator_f = -1.
  //Elementy_Gry_Przygotuj();

  // test //???
//  Wieloosobowe__Podłącz_BitBtnClick( Sender );
//  Gracz_Grupa_SpinEdit.Value := 1;
//  SI__Grupa_SpinEdit.Value := 1;
//  Gracz_Nazwa_Edit.Text := 'G1';
//  SI__Nazwa_Edit.Text := 'B1';
//  SI__Statek_ComboBox.ItemIndex := 2;
//  SI__Dodaj_BitBtnClick( Sender );
//
//  SI__Grupa_SpinEdit.Value := 2;
//  SI__Nazwa_Edit.Text := 'Ba1';
//  SI__Dodaj_BitBtnClick( Sender );
//  SI__Nazwa_Edit.Text := 'Ba2';
//  SI__Dodaj_BitBtnClick( Sender );
//  SI__Nazwa_Edit.Text := 'Ba3';
//  SI__Dodaj_BitBtnClick( Sender );
//
//  Gracz_Gotowość_BitBtnClick( Gracz_Gotowość_Tak_BitBtn );
//  Gra_Rozpocznij_BitBtnClick( Sender );

  //statek_gracza := TStatek.Create( Gra_Obiekty_GLDummyCube, Statki_Form.GLCollisionManager1, 1, '', prymitywy_lista_t );
  //statek_gracza.id_statek := 1;
  //statek_gracza.Position.SetPoint( 20, 0, -8 );

  //statek_gracza.TurnAngle := -45;
  //statek_gracza.prędkość_procent := 90;
  //statek_gracza.prędkość_zadana_procent := 90;
  //
  //statki_t[ 1 ].prędkość_procent := 60;
  //statki_t[ 1 ].prędkość_zadana_procent := 60;
  //statki_t[ 1 ].TurnAngle := -30;
  //statki_t[ 1 ].Position.X := statki_t[ 1 ].Position.X - 3.5;

//  SetLength( statki_t, 1 );
//  statki_t[ 0 ] := TStatek.Create( Gra_Obiekty_GLDummyCube, Statki_Form.GLCollisionManager1, 0, '', prymitywy_lista_t );
//  statki_t[ 0 ].id_statek := 1;
//  statek_gracza := statki_t[ 0 ];
//  //statek_gracza := nil; // Nie zmienia statki_t[ 0 ].


//  SetLength( statki_t, 2 );
//  statki_t[ 1 ] := TStatek.Create( Gra_Obiekty_GLDummyCube, Statki_Form.GLCollisionManager1, 1, '', prymitywy_lista_t );
//  statki_t[ 1 ].id_statek := 2;
//  statki_t[ 1 ].Elementy_Gracza_Widoczność( false );


  //GLCamera1.TargetObject := statek_gracza;
  //GLNavigator1

  //GLSceneViewer1Click( Sender );

  GLSceneViewer1.Tag := 0;
  GLSceneViewer1MouseDown( Sender, System.UITypes.TMouseButton.mbLeft, [ System.Classes.ssHorizontal ], 0, 0 ); // Ze względu na GLSceneViewer1.Tag i ssHorizontal nie strzeli.

  //Kamera_Przełącz( 1 = 10 ); //???
  // Z prawej strony w lewo.
//  GLCamera1.Position.X := 2;
//  GLCamera1.Position.Y := 2;
//  GLCamera1.Position.Z := 4;
//  GLCamera1.Direction.SetVector( -1, 0, 0 );

  // Z lewej strony w prawo.
  GLCamera1.Position.X := -3;
  GLCamera1.Position.Y := 2;
  GLCamera1.Position.Z := 0;
  GLCamera1.Direction.SetVector( 1, 0, 0 );

  // Z tyłu w przód.
//  GLCamera1.Position.X := 4;
//  GLCamera1.Position.Y := 1;
//  GLCamera1.Position.Z := 6;
//  GLCamera1.Direction.SetVector( 0, 0, -1 );

  // Z góry w dół.
//  GLCamera1.Position.X := 0;
//  GLCamera1.Position.Y := 3;
//  GLCamera1.Position.Z := 0;
//  GLCamera1.Direction.SetVector( 0, -1, 0 );
//  GLCamera1.RollAngle := 180;

//  GLLines1.AddNode( 0, 1, 0 ); // Biała.
//  GLLines1.AddNode( 0, 1, -2 );
//
//  GLLines2.AddNode( 0, 1.05, 0 ); // Zielona.
//  GLLines2.AddNode( 0, 1.05, 2 );
//
//  GLLines3.AddNode( 0, 1.1, 0 ); // Niebieska.
//  GLLines3.AddNode( 0, 1.1, 2 );

  GLLines1.AddNode( -1, 1, 0 ); // Biała.
  GLLines1.AddNode( -1, 1, 2 );

  GLLines2.AddNode( -1.05, 1, 0 ); // Zielona.
  GLLines2.AddNode( -1.05, 1, 2 );

  GLLines3.AddNode( -1.1, 1, 0 ); // Niebieska.
  GLLines3.AddNode( -1.1, 1, 2 );

  celowanie_tryb_g := ct_Punkt;

  Celowniczy_GLDummyCube.Position.SetPoint( -4, 0, -1 ); //???
  //statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector := Celowniczy_GLDummyCube.Position.AsAffineVector; //???

  Statki_Form.WindowState := wsMaximized; //???
  //Pokój_Rozmów_Memo.ReadOnly := false; //???

  //Wieloosobowe_Identyfikator_Edit.ReadOnly := false; //???

  // Dla 50 / 1 animacja jest w miarę płynna (wysyłka albo odbiór).
  Serwer_Wysyła_Timer.Interval := 50;
  Klient_IdTCP_Czyta_Timer.Interval := 100;
  Klient_IdUDP_Czyta_Timer.Interval := 1;

  //???
  //Serwer_Wysyła_Timer.Interval := 600000;
  //Klient_IdTCP_Czyta_Timer.Interval := 3000;

end;//---//FormShow().

//FormClose().
procedure TStatki_Form.FormClose( Sender: TObject; var Action: TCloseAction );
var
  i : integer;
begin

  Informacje_Dodatkowe_Timer.Enabled := false;


  Pauza( true );

  Radar_Wyczyść( true );


  Gra_Zakończ_BitBtnClick( Sender );
  Wieloosobowe__Odłącz_BitBtnClick( Sender );


  Elementy_Gry_Zwolnij();


  SetLength( klawiatura_konfiguracja_r_t, 0 );
  Klawisz_Konfiguracja_Zwolnij();
  
  SetLength( lądy_lista_t, 0 );
  SetLength( prymitywy_lista_t, 0 );
  SetLength( statki_lista_t, 0 );
  SetLength( statki_pozycje_początkowe_lista_t, 0 );


  FreeAndNil( wieloosobowe_amunicja_efekt_g );

  FreeAndNil( amunicja_wystrzelona_list );
  FreeAndNil( wieloosobowe_amunicja_wystrzelona_list );

  FreeAndNil( ląd_list );
  FreeAndNil( trafienia_efekt_list );

  FreeAndNil( tcp_klienci_lista_g );
  FreeAndNil( udp_klienci_lista_g );


  pokój_rozmów_ostatnia_wiadomości_wysłane_treść_string_list.Clear();
  FreeAndNil( pokój_rozmów_ostatnia_wiadomości_wysłane_treść_string_list );


  for i := informacje_dodatkowe_list.Count - 1 downto 0 do
    begin

      TInformacje_Dodatkowe(informacje_dodatkowe_list[ i ]).Free();
      informacje_dodatkowe_list.Delete( i );

    end;
  //---//for i := informacje_dodatkowe_list.Count - 1 downto 0 do

  FreeAndNil( informacje_dodatkowe_list );


  for i := 0 to Pokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj_ComboBox.Items.Count - 1 do
    TPokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj(Pokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj_ComboBox.Items.Objects[ i ]).Free();

  Pokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj_ComboBox.Clear();

end;//---//FormClose().

//FormResize().
procedure TStatki_Form.FormResize( Sender: TObject );
var
  zti : integer;
begin

  Radar_Panel.Height := Round( GLSceneViewer1.Height * Radar_Panel.Tag * 0.01 );
  Radar_Panel.Top := GLSceneViewer1.Height - Radar_Panel.Height;

  Radar_Panel.Width := Radar_Panel.Height;


  if Pokój_Rozmów_GroupBox.Parent = Statki_Form then
    begin

      if Radar_Panel.Visible then
        zti := Radar_Panel.Height
      else//if Radar_Panel.Visible then
        zti := 0;

      Pokój_Rozmów_GroupBox.Top := GLSceneViewer1.Height - zti - Pokój_Rozmów_GroupBox.Height - 10;

    end;
  //---//if Pokój_Rozmów_GroupBox.Parent = Statki_Form then

end;//---//FormResize().

//GLSceneViewer1Exit().
procedure TStatki_Form.GLSceneViewer1Exit( Sender: TObject );
begin

  GLSceneViewer1.Tag := 0;

end;//---//GLSceneViewer1Exit().

//GLSceneViewer1Click().
procedure TStatki_Form.GLSceneViewer1Click(Sender: TObject);
begin

  //if not GLSceneViewer1.Focused then
  //  GLSceneViewer1.SetFocus();

end;//---//GLSceneViewer1Click().

//GLSceneViewer1MouseDown().
procedure TStatki_Form.GLSceneViewer1MouseDown( Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer );
var
  zt_statek : TStatek;
  Selected : TGLSceneObject;
begin

  if not GLSceneViewer1.Focused then
    GLSceneViewer1.SetFocus();

  if GLSceneViewer1.Tag = 0 then
    begin

      // Aby pierwsze kliknięcie myszą nie wywoływało akcji obsługi klawiszy (gdy zmienia się skupienie).

      GLSceneViewer1.Tag := 1;
      Exit;

    end;
  //---//if GLSceneViewer1.Tag = 0 then


  //if not czy_pauza_g then
    begin

      //// Pauza nie jest całkowicie aktywna (nie wszystkie klawisze są obsługiwane podczas pauzy).
      // Może lepiej aby pauza była aktywna.

      if statek_gracza <> nil then
        Statek_Klawisze_Obsługa( statek_gracza.id_statek, 0, Word(Button), Shift, Amunicja_Rodzaj_Zbiór_Zwróć() );


      Klawisze_Obsługa_Zachowanie_Ciągłe( 0.15, Shift, Word(Button) ); // Na wypadek gdyby przypisano np. ruch kamery pod przycisk myszy.

    end;
  //---//if not czy_pauza_g then


  if czy_pauza_g then
    Napis_Odśwież();


  if not Projektowy_Tryb_CheckBox.Checked then
    Exit;


  Selected := nil;

  if ( GLSceneViewer1.Buffer.GetPickedObject( x, y ) is TGLSceneObject ) then
    Selected := ( GLSceneViewer1.Buffer.GetPickedObject( x, y ) as TGLSceneObject );

  if Selected <> nil then
    begin

      zt_statek := Statek_Znajdź( Selected.Owner );


      if zt_statek <> nil then
        begin

          projektowy_tryb__statek := zt_statek;
          Log_Wypisz(  'Tryb projektowy - id_statek: ' + IntToStr( projektowy_tryb__statek.id_statek ) + '.'  );

        end
      else//if zt_statek <> nil then
        Log_Wypisz( 'Tryb projektowy - nie odnaleziono statku.' );

    end;
  //---//if Selected <> nil then

end;//---//GLSceneViewer1MouseDown().

//GLSceneViewer1MouseWheel().
procedure TStatki_Form.GLSceneViewer1MouseWheel( Sender: TObject; Shift: TShiftState; WheelDelta: Integer; MousePos: TPoint; var Handled: Boolean );
var
  zti,
  luneta_zasięg_l
    : integer;
  ztr : real;
const
  kamera_ogniskowa_domyślna_l_c : single = 50;
begin

  if GLCamera1.Parent = GLScene1.Objects then
    begin

      // Kamera za statkiem.

      if WheelDelta >= 0 then
        //GLCamera1.Position.Z := GLCamera1.Position.Z
        GLCamera1.Move( 1 )
      else//if WheelDelta >= 0 then
        //GLCamera1.Position.Z := GLCamera1.Position.Z;
        GLCamera1.Move( -1 );

    end
  else//if GLCamera1.Parent = GLScene1.Objects then
    begin

      // Kamera na statku.

      // Określa rząd wielkości aktualnej wartości przybliżenia (jak szybko zmienia się przybliżenie lunety).
      zti := Round( GLCamera1.FocalLength );

      if WheelDelta < 0 then
        dec( zti );

      zti := Length(  IntToStr( zti )  ) - 1;
      zti := Round(  Power( 10, zti )  );
      //---// Określa rząd wielkości aktualnej wartości przybliżenia (jak szybko zmienia się przybliżenie lunety).


      if statek_gracza <> nil then
        luneta_zasięg_l := statek_gracza.luneta_zasięg
      else//if statek_gracza <> nil then
        luneta_zasięg_l := 600;


      if WheelDelta >= 0 then
        begin

          // Przybliżanie.

          if GLCamera1.FocalLength < luneta_zasięg_l then
            GLCamera1.FocalLength := GLCamera1.FocalLength + zti
          else//if GLCamera1.FocalLength < luneta_zasięg_l then
            GLCamera1.FocalLength := luneta_zasięg_l;


          if GLCamera1.FocalLength > luneta_zasięg_l then
            GLCamera1.FocalLength := luneta_zasięg_l;

        end
      else//if WheelDelta >= 0 then
        begin

          // Oddalanie.

          if GLCamera1.FocalLength > kamera_ogniskowa_domyślna_l_c then
            GLCamera1.FocalLength := GLCamera1.FocalLength - zti
          else//if GLCamera1.FocalLength > kamera_ogniskowa_domyślna_l_c then
            GLCamera1.FocalLength := kamera_ogniskowa_domyślna_l_c;


          if GLCamera1.FocalLength < kamera_ogniskowa_domyślna_l_c then
            GLCamera1.FocalLength := kamera_ogniskowa_domyślna_l_c;

        end;
      //---//if WheelDelta >= 0 then


      // Modyfikuje czułość myszy zależnie od procentu przybliżenia lunety (100% przybliżenia – najwolniejszy ruch).
      zti := Round( luneta_zasięg_l - kamera_ogniskowa_domyślna_l_c ); // Zakres zmiany ogniskowej kamery.
      ztr := mysz_czułość_g - mysz_czułość_luneta_g; // Zakres zmiany prędkości myszy.

      if zti = 0 then
        zti := 1; // Aby nie było dzielenie przez zero.

      GLUserInterface1.MouseSpeed :=
          mysz_czułość_g
        - ztr
        * (  ( GLCamera1.FocalLength - kamera_ogniskowa_domyślna_l_c ) * 100 / zti  ) // Aktualny procent przybliżenia lunety.
        * 0.01;

      if GLUserInterface1.MouseSpeed < mysz_czułość_luneta_g then
        GLUserInterface1.MouseSpeed := mysz_czułość_luneta_g;
      //---// Modyfikuje czułość myszy zależnie od procentu przybliżenia lunety (100% przybliżenia – najwolniejszy ruch).

    end;
  //---//if GLCamera1.Parent = GLScene1.Objects then

end;//---//GLSceneViewer1MouseWheel().

//GLSceneViewer1MouseMove().
procedure TStatki_Form.GLSceneViewer1MouseMove( Sender: TObject; Shift: TShiftState; X, Y: Integer );
begin

  if    ( czy_pauza_g )
    and ( GLSceneViewer1.Focused ) then
    begin

      GLUserInterface1.MouseLook();
      GLUserInterface1.MouseUpdate();
      GLSceneViewer1.Invalidate();

    end;
  //---//if    ( czy_pauza_g ) (...)

end;//---//GLSceneViewer1MouseMove().

//GLSceneViewer1KeyDown().
procedure TStatki_Form.GLSceneViewer1KeyDown( Sender: TObject; var Key: Word; Shift: TShiftState );

  //Funkcja Klawisz_Wciśnięto_Sprawdź_l() w GLSceneViewer1KeyDown().
  function Klawisz_Wciśnięto_Sprawdź_l( const klawiatura_konfiguracja_r_f : TKlawiatura_Konfiguracja_r ) : boolean;
  begin

    Result := Klawisz_Wciśnięto_Sprawdź( klawiatura_konfiguracja_r_f, Key, -1, Shift );

  end;//---//Funkcja Klawisz_Wciśnięto_Sprawdź_l() w GLSceneViewer1KeyDown().

var
  klawisz_l : word;
begin//GLSceneViewer1KeyDown().

  //if Key = VK_ESCAPE then
  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__zamknij_program ) then
    begin

      GLCadencer1.Enabled := false;
      Close();

    end;
  //---//if Klawisz_Wciśnięto_Sprawdź_l( klawisz__zamknij_program ) then


  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__mouse_look_active ) then
    begin

      GLUserInterface1.MouseLookActive := not GLUserInterface1.MouseLookActive;


      if    ( GLUserInterface1.MouseLookActive )
        and ( Celownik_Widoczność_Mouse_Look_Active_CheckBox.Checked )
        and ( not Celownik_Widoczność_CheckBox.Checked ) then
        begin

          Celownik_Widoczność_Mouse_Look_Active_CheckBox.Tag := 1;
          Celownik_Widoczność_CheckBox.Checked := true;

        end
      else//if    ( GLUserInterface1.MouseLookActive ) (...)
      if    ( not GLUserInterface1.MouseLookActive )
        and ( Celownik_Widoczność_Mouse_Look_Active_CheckBox.Checked )
        and ( Celownik_Widoczność_CheckBox.Checked )
        and ( Celownik_Widoczność_Mouse_Look_Active_CheckBox.Tag = 1 ) then
        begin

          Celownik_Widoczność_Mouse_Look_Active_CheckBox.Tag := 0;
          Celownik_Widoczność_CheckBox.Checked := false;

        end;
      //---//if    ( not GLUserInterface1.MouseLookActive ) (...)

    end;
  //---//if Klawisz_Wciśnięto_Sprawdź_l( klawisz__mouse_look_active ) then


  if Klawisz_Wciśnięto_Sprawdź_l( klawisz__opcje ) then
    begin

      if PageControl1.Width > 1 then
        PageControl1.Width := 1
      else//if PageControl1.Width > 1 then
        begin

          PageControl1.Width := Round( Self.Width * 0.2 );

          if PageControl1.Width < 350 then
            PageControl1.Width := Round( Self.Width * 0.35 );

        end;
      //---//if PageControl1.Width > 1 then

    end;
  //---//if Klawisz_Wciśnięto_Sprawdź_l( klawisz__opcje ) then


  //if Key = Ord( 'P' ) then
  if    (  Klawisz_Wciśnięto_Sprawdź_l( klawisz__pauza )  )
    and ( not czy_klient_g ) then
    begin

      Pauza( not czy_pauza_g );

      if czy_pauza_g then
        Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__pauza_c, -99, 'Tak' )
      else//if czy_pauza_g then
        Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__pauza_c, -99, 'Nie' );

    end;
  //---//if    (  Klawisz_Wciśnięto_Sprawdź_l( klawisz__pauza )  ) (...)


//  if    (  Key = Ord( 'S' )  )
//    and ( ssAlt in Shift ) then
//    Wieloosobowe__Tryb_RadioGroup.Visible := not Wieloosobowe__Tryb_RadioGroup.Visible;


  //if not czy_pauza_g then
    begin

      //// Pauza nie jest całkowicie aktywna (nie wszystkie klawisze są obsługiwane podczas pauzy).
      // Może lepiej aby pauza była aktywna.


      if Klawisz_Wciśnięto_Sprawdź_l( klawisz__amunicja__zanurzenie_głębokość_zadana__plus ) then
        begin

          klawisz_l := VK_UP;
          Edit_Jako_Spin_KeyDown( Amunicja__Zanurzenie_Głębokość_Zadana_Edit, klawisz_l, [] );

        end;
      //---//if Klawisz_Wciśnięto_Sprawdź_l( klawisz__amunicja__zanurzenie_głębokość_zadana__plus ) then

      if Klawisz_Wciśnięto_Sprawdź_l( klawisz__amunicja__zanurzenie_głębokość_zadana__minus ) then
        begin

          klawisz_l := VK_DOWN;
          Edit_Jako_Spin_KeyDown( Amunicja__Zanurzenie_Głębokość_Zadana_Edit, klawisz_l, [] );

        end;
      //---//if Klawisz_Wciśnięto_Sprawdź_l( klawisz__amunicja__zanurzenie_głębokość_zadana__minus ) then


      if Klawisz_Wciśnięto_Sprawdź_l( klawisz__celowanie_tryb ) then
        if Celowanie_Tryb_RadioGroup.ItemIndex = 0 then
          Celowanie_Tryb_RadioGroup.ItemIndex := 1
        else//if Celowanie_Tryb_RadioGroup.ItemIndex = 0 then
          Celowanie_Tryb_RadioGroup.ItemIndex := 0;

      if Klawisz_Wciśnięto_Sprawdź_l( klawisz__celownik_widoczność ) then
        Celownik_Widoczność_CheckBox.Checked := not Celownik_Widoczność_CheckBox.Checked;

      if Klawisz_Wciśnięto_Sprawdź_l( klawisz__celownik_widoczność_mouse_look_active ) then
        begin

          Celownik_Widoczność_Mouse_Look_Active_CheckBox.Checked := not Celownik_Widoczność_Mouse_Look_Active_CheckBox.Checked;

          if Celownik_Widoczność_Mouse_Look_Active_CheckBox.Checked then
            Informacja_Dodatkowa_Dodaj( 'Wyświetlaj celownik w trybie obracania kamery myszą.', 3 )
          else//if Celownik_Widoczność_Mouse_Look_Active_CheckBox.Checked then
            Informacja_Dodatkowa_Dodaj( 'Nie wyświetlaj celownika w trybie obracania kamery myszą.', 3 );

        end;
      //---//if Klawisz_Wciśnięto_Sprawdź_l( klawisz__celownik_widoczność_mouse_look_active ) then


      if Klawisz_Wciśnięto_Sprawdź_l( klawisz__dalmierz ) then
        Dalmierz_CheckBox.Checked := not Dalmierz_CheckBox.Checked;


      if Klawisz_Wciśnięto_Sprawdź_l( klawisz__kamera__Amunicja ) then
        Kamera_Przełącz( kt_Amunicja );

      if Klawisz_Wciśnięto_Sprawdź_l( klawisz__kamera__Artyleria ) then
        Kamera_Przełącz( kt_Artyleria );

      if Klawisz_Wciśnięto_Sprawdź_l( klawisz__kamera__Statek ) then
        Kamera_Przełącz( kt_Statek );

      if Klawisz_Wciśnięto_Sprawdź_l( klawisz__kamera__Swobodna ) then
        Kamera_Przełącz( kt_Swobodna );

      if Klawisz_Wciśnięto_Sprawdź_l( klawisz__kamera__Za_Statkiem ) then
        Kamera_Przełącz( kt_Za_Statkiem );


      if Klawisz_Wciśnięto_Sprawdź_l( klawisz__obrót_kąt_zablokowany_wskaźnik ) then
        Obrót_Kąt_Zablokowany_Wskaźnik_CheckBox.Checked := not Obrót_Kąt_Zablokowany_Wskaźnik_CheckBox.Checked;

      if Klawisz_Wciśnięto_Sprawdź_l( klawisz__obrót_kąt_zablokowany_strzał_wskaźnik ) then
        Obrót_Kąt_Zablokowany_Strzał_Wskaźnik_CheckBox.Checked := not Obrót_Kąt_Zablokowany_Strzał_Wskaźnik_CheckBox.Checked;


      if Klawisz_Wciśnięto_Sprawdź_l( klawisz__pokój_rozmów__na_ekranie ) then
        Pokój_Rozmów__Na_Ekranie_CheckBox.Checked := not Pokój_Rozmów__Na_Ekranie_CheckBox.Checked;

      if Klawisz_Wciśnięto_Sprawdź_l( klawisz__pokój_rozmów__informacja_dodatkowa ) then
        Pokój_Rozmów__Informacja_Dodatkowa_CheckBox.Checked := not Pokój_Rozmów__Informacja_Dodatkowa_CheckBox.Checked;


      if Klawisz_Wciśnięto_Sprawdź_l( klawisz__punkty_życia_wskaźnik__gracz ) then
        Punkty_Życia_Wskaźnik__Gracz_CheckBox.Checked := not Punkty_Życia_Wskaźnik__Gracz_CheckBox.Checked;

      if Klawisz_Wciśnięto_Sprawdź_l( klawisz__punkty_życia_wskaźnik__przeciwnik ) then
        Punkty_Życia_Wskaźnik__Przeciwnik_CheckBox.Checked := not Punkty_Życia_Wskaźnik__Przeciwnik_CheckBox.Checked;

      if Klawisz_Wciśnięto_Sprawdź_l( klawisz__punkty_życia_wskaźnik__sojusznik ) then
        Punkty_Życia_Wskaźnik__Sojusznik_CheckBox.Checked := not Punkty_Życia_Wskaźnik__Sojusznik_CheckBox.Checked;


      if Klawisz_Wciśnięto_Sprawdź_l( klawisz__projektowy_tryb__włącz_wyłącz ) then
        Projektowy_Tryb_CheckBox.Checked := not Projektowy_Tryb_CheckBox.Checked;


      if    (  Klawisz_Wciśnięto_Sprawdź_l( klawisz__strzelaj_z__artyleria )  )
        and ( ar_Artyleria_CheckBox.Enabled ) then
        ar_Artyleria_CheckBox.Checked := not ar_Artyleria_CheckBox.Checked;

      if    (  Klawisz_Wciśnięto_Sprawdź_l( klawisz__strzelaj_z__pocisk )  )
        and ( ar_Pocisk_CheckBox.Enabled ) then
        ar_Pocisk_CheckBox.Checked := not ar_Pocisk_CheckBox.Checked;

      if    (  Klawisz_Wciśnięto_Sprawdź_l( klawisz__strzelaj_z__torpeda )  )
        and ( ar_Torpeda_CheckBox.Enabled ) then
        ar_Torpeda_CheckBox.Checked := not ar_Torpeda_CheckBox.Checked;

      if    (  Klawisz_Wciśnięto_Sprawdź_l( klawisz__strzelaj_z__wszystkie )  )
        and ( ar_Wszystkie_CheckBox.Enabled ) then
        ar_Wszystkie_CheckBox.Checked := not ar_Wszystkie_CheckBox.Checked;


      if not czy_klient_g then
        begin

          if Klawisz_Wciśnięto_Sprawdź_l( klawisz__gra_współczynnik_prędkości__plus ) then
            Gra_Współczynnik_Prędkości_SpinEdit.Value := Gra_Współczynnik_Prędkości_SpinEdit.Value + Gra_Współczynnik_Prędkości_SpinEdit.Increment;

          if Klawisz_Wciśnięto_Sprawdź_l( klawisz__gra_współczynnik_prędkości__normalna ) then
            Gra_Współczynnik_Prędkości_SpinEdit.Value := 100;

          if Klawisz_Wciśnięto_Sprawdź_l( klawisz__gra_współczynnik_prędkości__minus ) then
            Gra_Współczynnik_Prędkości_SpinEdit.Value := Gra_Współczynnik_Prędkości_SpinEdit.Value - Gra_Współczynnik_Prędkości_SpinEdit.Increment;


          if    (  Klawisz_Wciśnięto_Sprawdź_l( klawisz__ląd_odśwież_wskazany )  )
            and ( Ląd_GroupBox.Enabled ) then
            Ląd__Odśwież_Wskazany_BitBtnClick( Sender );


          if    (  Klawisz_Wciśnięto_Sprawdź_l( klawisz__statek__utwórz )  )
            and ( Statek_GroupBox.Enabled ) then
            Statek__Utwórz_BitBtnClick( Sender );

        end;
      //---//if not czy_klient_g then



      if statek_gracza <> nil then
        Statek_Klawisze_Obsługa( statek_gracza.id_statek, Key, -1, Shift, Amunicja_Rodzaj_Zbiór_Zwróć() );

    end;
  //else//if not czy_pauza_g then


  {$region 'Przesuwanie statków (w trybie projektowym).'}
  if Projektowy_Tryb_CheckBox.Checked then
    begin

      if projektowy_tryb__statek <> nil then
        begin

          if Klawisz_Wciśnięto_Sprawdź_l( klawisz__projektowy_tryb__statek__prędkość_zadana_0_100 ) then
            begin

              if projektowy_tryb__statek.prędkość_procent <> 0 then
                begin

                  projektowy_tryb__statek.prędkość_procent := 0;

                end
              else//if projektowy_tryb__statek.prędkość_procent <> 0 then
                begin

                  projektowy_tryb__statek.prędkość_procent := 100;

                end;
              //---//if projektowy_tryb__statek.prędkość_procent <> 0 then

              projektowy_tryb__statek.prędkość_zadana_procent := projektowy_tryb__statek.prędkość_procent;

            end;
          //---//if Klawisz_Wciśnięto_Sprawdź_l( klawisz__projektowy_tryb__statek__prędkość_zadana_0_100 ) then


          if Klawisz_Wciśnięto_Sprawdź_l( klawisz__projektowy_tryb__statek___resetuj_obrót ) then
            projektowy_tryb__statek.ResetRotations();

        end;
      //---//if projektowy_tryb__statek <> nil then

    end;
  //---//if Projektowy_Tryb_CheckBox.Checked then
  {$endregion 'Przesuwanie statków (w trybie projektowym).'}


  if czy_pauza_g then
    begin

      if GLSceneViewer1.Focused then
        begin

          Klawisze_Obsługa_Zachowanie_Ciągłe( 0.15 ); // Aby w trakcie pauzy również wykonywane były zachowania klawiszy.

        end;
      //---//if GLSceneViewer1.Focused then


      Napis_Odśwież();

    end;
  //---//if czy_pauza_g then

end;//---//GLSceneViewer1KeyDown().

//GLCadencer1Progress().
procedure TStatki_Form.GLCadencer1Progress( Sender: TObject; const deltaTime, newTime: Double );
begin

  Klawisze_Obsługa_Zachowanie_Ciągłe( deltaTime * 5 );


  if GLSceneViewer1.Focused then
    begin

      GLUserInterface1.MouseLook();
      GLUserInterface1.MouseUpdate();
      GLSceneViewer1.Invalidate();

    end;
  //---//if GLSceneViewer1.Focused then


  GLCollisionManager1.CheckCollisions(); //???


  Statki_Ruch( deltaTime );

  Lufy_Przeładowanie( deltaTime );


  Trafienia_Efekt_Czas_Trwania_Sprawdź();


  Napis_Odśwież();


  Celownicza_Kula_Zmień_Pozycję();


  Kamera_Odległość_Kontroluj_Ustaw( deltaTime );

  //statek_gracza.artyleria_t[ 0 ].Podniesienie_Zadane_Zmień(); //???
  //statek_gracza.artyleria_t[ 0 ].Podniesienie_Kierunek_Zmień( Celowanie_Precyzja_Podniesienie_SpinEdit.Value ); //???

//  GLLines1.Nodes[ 1 ].X := -GLCamera1.AbsoluteDirection.X;
//  GLLines1.Nodes[ 1 ].Z := -GLCamera1.AbsoluteDirection.Z;

  //GLLines3.Nodes[ 1 ].X := statek_gracza.AbsoluteDirection.X;
  //GLLines3.Nodes[ 1 ].Z := statek_gracza.AbsoluteDirection.Z;


  GLLines1.Nodes[ 1 ].Y := 1 + GLCamera1.AbsoluteDirection.Y;
//  GLLines1.Nodes[ 1 ].Z := -GLCamera1.AbsoluteDirection.Z;

  //GLLines3.Nodes[ 1 ].AsAffineVector := Celownicza_GLSphere.Position.AsAffineVector;


//  Wieloosobowe_Statki_Parametry_Odczytaj();
//  Wieloosobowe_Statki_Parametry_Ustaw();


  //Wieloosobowe_Amunicja_Parametry_Odczytaj();
  //Wieloosobowe_Amunicja_Parametry_Ustaw();



  //GLCylinder1.AbsoluteDirection := GLCamera1.AbsoluteDirection;
  //GLCylinder1.Up := GLCamera1.Up;

  //GLArrowLine_Żółta.Direction := statki_t[ 0 ].torpedy_wyrzutnie_t[ 0 ].lufy_t[ 0 ].Direction;
  //if    (  Length( statki_t ) > 0  )
  //  and (  Length( statki_t[ 0 ].torpedy_wyrzutnie_t ) > 0  ) then
  //  GLArrowLine_Zielona.Direction.AsVector := statki_t[ 0 ].torpedy_wyrzutnie_t[ 0 ].lufy_t[ 0 ].AbsoluteDirection;
  //
  //if amunicja_wystrzelona_list.Count > 0 then
  //  GLArrowLine_Żółta.Direction.AsVector := TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_ustawienie_początkowe_dummy.AbsoluteDirection;

//X_Lewo_GLCube.AbsoluteDirection := VectorSubtract( GLCamera1.AbsoluteDirection, X_Lewo_GLCube.AbsolutePosition );

end;//---//GLCadencer1Progress().

//GLCollisionManager1Collision().
procedure TStatki_Form.GLCollisionManager1Collision( Sender: TObject; object1, object2: TGLBaseSceneObject );

  //Funkcja Oznacz_Kolizję() w GLCollisionManager1Collision().
  function Oznacz_Kolizję( object_1_f, object_2_f : TGLBaseSceneObject ) : boolean;

    //Funkcja Kolizja_Statek_Statek_Przelicz() Oznacz_Kolizję() w GLCollisionManager1Collision().
    procedure Kolizja_Statek_Statek_Przelicz( statek_1_f, statek_2_f : TStatek; gl_base_scene_object_1_f, gl_base_scene_object_2_f : TGLBaseSceneObject );
    var
      kąt_między_statkami_l,
      ztr,
      kąt_średni_między_statkami_l,
      kąt_współczynnik_l // Zależnie od kąta między statkami modyfikuje obliczenia; 1 - silne uderzenie, 0.01 - lekkie uderzenie (statki ślizgają się po sobie i obracają).
        : real;
      zt_vector_1,
      zt_vector_2
        : GLVectorGeometry.TVector;
    begin

      //
      // Funkcja przelicza skutki zderzenia dwóch statków.
      //
      // Parametry:
      //   statek_1_f
      //   statek_2_f
      //   gl_base_scene_object_1_f - element pierwszego statku, który uczestniczy w kolizji.
      //   gl_base_scene_object_2_f - element drugiego statku, który uczestniczy w kolizji.
      //

      {$region 'Wylicza kąt między statkami i współczynnik kąta.'}
      if statek_1_f.prędkość_aktualna < 0 then
        zt_vector_1 := GLVectorGeometry.VectorNegate( statek_1_f.AbsoluteDirection )
      else//if statek_1_f.prędkość_aktualna < 0 then
        zt_vector_1 := statek_1_f.AbsoluteDirection;

      if statek_2_f.prędkość_aktualna < 0 then
        zt_vector_2 := GLVectorGeometry.VectorNegate( statek_2_f.AbsoluteDirection )
      else//if statek_1_f.prędkość_aktualna < 0 then
        zt_vector_2 := statek_2_f.AbsoluteDirection;


      kąt_między_statkami_l := //180 - // Jeżeli chce się sprawdzić drugą część kąta.
        RadToDeg( // uses Math.
            AngleBetweenVectors( // uses GLVectorGeometry.
               zt_vector_1,
               zt_vector_2,
               GLVectorGeometry.VectorMake( 0, 0, 0 )
             )
          );

      //Statki_Form.Caption := FloatToStr( kąt_między_statkami_l );

      if    ( kąt_między_statkami_l > 45 )
        and ( kąt_między_statkami_l < 135 ) then
        kąt_współczynnik_l := 1 // Uderzenie z boku.
      else//if    ( kąt_między_statkami_l > 45 ) (...)
        begin

          // Uderzenie z przodu lub z tyłu.

          if   (
                     ( statek_1_f.prędkość_aktualna = 0 ) // Jeden statek płynie, a drugi stoi.
                 and ( statek_2_f.prędkość_aktualna <> 0 )
               )
            or (
                     ( statek_1_f.prędkość_aktualna <> 0 ) // Jeden statek płynie, a drugi stoi.
                 and ( statek_2_f.prędkość_aktualna = 0 )
               )
            or (
                     ( kąt_między_statkami_l > 150 ) // Płyną w przeciwnych kierunkach.
                 and (  Sign( statek_1_f.prędkość_aktualna ) = Sign( statek_2_f.prędkość_aktualna )  )
               )
            or (
                     ( kąt_między_statkami_l < 30 ) // Jeden ze statków cofa a drugi nie.
                 and (  Sign( statek_1_f.prędkość_aktualna ) <> Sign( statek_2_f.prędkość_aktualna )  )
               ) then
            kąt_współczynnik_l := 1
          else//if Sign( statek_1_f.prędkość_aktualna ) <> Sign( statek_1_f.prędkość_aktualna ) then
            kąt_współczynnik_l := 0.01

        end;
      //---//if    ( kąt_między_statkami_l > 45 ) (...)

      //Statki_Form.Caption := FloatToStr( kąt_współczynnik_l );
      {$endregion 'Wylicza kąt między statkami i współczynnik kąta.'}


      {$region 'Oznacza kolizję, wyświetla efekt, nalicza obrażenia.'}
      if    (
                 (  Abs( statek_1_f.prędkość_procent ) > kolizja_oznaczanie_prędkość_procent_c  )
              or (  Abs( statek_2_f.prędkość_procent ) > kolizja_oznaczanie_prędkość_procent_c  )
            )
        and (   not Statki_Kolizja_Oznaczenie_Sprawdź(  statek_1_f.kolizja_oznaczenie_string_list, IntToStr( statek_2_f.id_statek )  )   )
        and (   not Statki_Kolizja_Oznaczenie_Sprawdź(  statek_2_f.kolizja_oznaczenie_string_list, IntToStr( statek_1_f.id_statek )  )   ) then
        begin

          //TGLCube(gl_base_scene_object_1_f).Material.FrontProperties.Emission.SetColor( 0, 1, 0 ); // Test. //???
          //TGLCube(gl_base_scene_object_2_f).Material.FrontProperties.Emission.SetColor( 0, 1, 0 ); // Test. //???
          //Statki_Form.Caption := Statki_Form.Caption + '*';


          statek_1_f.kolizja_oznaczenie_string_list.Add(  IntToStr( statek_2_f.id_statek ) + '|' + IntToStr( Czas_Teraz() )  );
          statek_2_f.kolizja_oznaczenie_string_list.Add(  IntToStr( statek_1_f.id_statek ) + '|' + IntToStr( Czas_Teraz() )  );

          Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_Ląd, gl_base_scene_object_1_f.AbsolutePosition.X, gl_base_scene_object_1_f.AbsolutePosition.Y, gl_base_scene_object_1_f.AbsolutePosition.Z, nil, -1, -1 );
          Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_Ląd, gl_base_scene_object_2_f.AbsolutePosition.X, gl_base_scene_object_2_f.AbsolutePosition.Y, gl_base_scene_object_2_f.AbsolutePosition.Z, nil, -1, -1 );


          // Obrażenia dla statku drugiego (zadaje statek pierwszy).
          //if gl_base_scene_object_1_f.Tag <> 1 then
          //  statek_2_f.Punkty_Życia_Zmień( -statek_2_f.punkty_życia_maksymalne * 0.1 )
          //else
          //if Abs( statek_1_f.prędkość_procent ) > kolizja_oznaczanie_prędkość_procent_c * 2 then
          if    (  gl_base_scene_object_1_f.Tag = 1  ) // Czy uderzono dziobem (częścią taranującą - wzmocnioną).
            and (  Abs( statek_1_f.prędkość_procent ) > kolizja_oznaczanie_prędkość_procent_c * 2  ) then
              statek_2_f.Punkty_Życia_Zmień
                (
                    -statek_2_f.punkty_życia_maksymalne * 0.1 // 10% z punktów życia.
                  * Abs( statek_1_f.prędkość_procent ) * 0.5 * 0.1 // 10% z połowy prędkości.
                )
          else//if    (  gl_base_scene_object_1_f.Tag = 1  ) (...)
            statek_2_f.Punkty_Życia_Zmień( -statek_2_f.punkty_życia_maksymalne * 0.1 * kąt_współczynnik_l );


          // Obrażenia dla statku pierwszego (zadaje statek drugi).
          if    (  gl_base_scene_object_2_f.Tag = 1  ) // Czy uderzono dziobem (częścią taranującą - wzmocnioną).
            and (  Abs( statek_2_f.prędkość_procent ) > kolizja_oznaczanie_prędkość_procent_c * 2  ) then
              statek_1_f.Punkty_Życia_Zmień
                (
                    -statek_1_f.punkty_życia_maksymalne * 0.1 // 10% z punktów życia.
                  * Abs( statek_2_f.prędkość_procent ) * 0.5 * 0.1 // 10% z połowy prędkości.
                )
          else//if    (  gl_base_scene_object_2_f.Tag = 1  ) (...)
            statek_1_f.Punkty_Życia_Zmień( -statek_1_f.punkty_życia_maksymalne * 0.1 * kąt_współczynnik_l );

        end;
      //---//if    (  Abs( statek_1_f.prędkość_procent ) > kolizja_oznaczanie_prędkość_procent_c  ) (...)
      {$endregion 'Oznacza kolizję, wyświetla efekt, nalicza obrażenia.'}


      // Wytraca prędkość podczas kolizji.
      if Abs( statek_1_f.prędkość_aktualna ) > 0 then
        begin

          if kąt_współczynnik_l = 1 then // Przy małym kącie kolizji nie zwalniają.
            statek_1_f.prędkość__kolizja_zwalnianie := 1.2;

        end;
      //---//if Abs( statek_1_f.prędkość_aktualna ) > 0 then


      // Przesuwanie statku, który został uderzony.
      // Jeżeli statki najdą na siebie to może wystąpić efekt ciągnięcia (statek, który próbuje się wycofać z kolizji zamiast się oddalać naciąga na siebie drugi statek). //???
      statek_2_f.Translate
        (
          statek_1_f.AbsoluteDirection.X * statek_1_f.prędkość_aktualna * kolizja_przesuwanie_siła_c * kąt_współczynnik_l,
          statek_1_f.AbsoluteDirection.Y * statek_1_f.prędkość_aktualna * kolizja_przesuwanie_siła_c * kąt_współczynnik_l,
          statek_1_f.AbsoluteDirection.Z * statek_1_f.prędkość_aktualna * kolizja_przesuwanie_siła_c * kąt_współczynnik_l
        );



      {$region 'Obraca statki do wspólnego kierunku (taki sam kąt obrotu).'}
      kąt_średni_między_statkami_l := ( statek_1_f.TurnAngle + statek_2_f.TurnAngle ) * 0.5; // Średnia kątów (środek miedzy kątami).

      // Jeżeli między kątami statków jest kąt 180 / -180 to zmienia kierunek obrotu.
      if    (  Abs( statek_1_f.TurnAngle ) > 90  )
        and (  Abs( statek_2_f.TurnAngle ) > 90  )
        and (  Sign( statek_1_f.TurnAngle ) <> Sign( statek_2_f.TurnAngle )  ) then
        ztr := -1
      else//if    (  Abs( statek_1_f.TurnAngle ) > 90  ) (...)
        ztr := 1;


      // Obraca statek pierwszy.
      if statek_2_f.TurnAngle <> kąt_średni_między_statkami_l then
        begin

          if statek_2_f.TurnAngle > kąt_średni_między_statkami_l then
            statek_2_f.TurnAngle := statek_2_f.TurnAngle - statek_2_f.skręt_prędkość * gra_współczynnik_prędkości_g * ztr // 0.3
          else//if statek_2_f.TurnAngle > kąt_współczynnik_l then
            statek_2_f.TurnAngle := statek_2_f.TurnAngle + statek_2_f.skręt_prędkość * gra_współczynnik_prędkości_g * ztr;

        end;
      //---//if statek_2_f.TurnAngle <> kąt_średni_między_statkami_l then

      // Obraca statek drugi.
      if statek_1_f.TurnAngle <> kąt_średni_między_statkami_l then
        begin

          if statek_1_f.TurnAngle > kąt_średni_między_statkami_l then
            statek_1_f.TurnAngle := statek_1_f.TurnAngle - statek_1_f.skręt_prędkość * gra_współczynnik_prędkości_g * ztr
          else//if statek_1_f.TurnAngle > kąt_współczynnik_l then
            statek_1_f.TurnAngle := statek_1_f.TurnAngle + statek_1_f.skręt_prędkość * gra_współczynnik_prędkości_g * ztr;

        end;
      //---//if statek_2_f.TurnAngle <> kąt_średni_między_statkami_l then
      {$endregion 'Obraca statki do wspólnego kierunku (taki sam kąt obrotu).'}

    end;//---//Funkcja Kolizja_Statek_Statek_Przelicz() Oznacz_Kolizję() w GLCollisionManager1Collision().

  var
    zt_statek,
    zt_statek_2
      : TStatek;
  begin//Funkcja Oznacz_Kolizję() w GLCollisionManager1Collision().

    // Zwraca prawdę gdy wykryto kolizję.

    Result := false;


    {$region 'Amunicja.'}
    // Amunicja trafia w amunicję.
    if    ( not Result )
      and ( object_1_f.Owner is TAmunicja )
      and ( object_2_f.Owner is TAmunicja )
      and ( object_1_f.Owner <> object_2_f.Owner ) // Aby nie oznaczało kolizji elementów jednej amunicji z sama sobą.
      and ( //???
               ( TAmunicja(object_1_f.Owner).czy_uzbrojona )
            or ( TAmunicja(object_2_f.Owner).czy_uzbrojona )
          )
      and ( not TAmunicja(object_1_f.Owner).czy_usunąć )
      and ( not TAmunicja(object_2_f.Owner).czy_usunąć ) then
      begin

        Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_Woda, object_1_f.AbsolutePosition.X, object_1_f.AbsolutePosition.Y, object_1_f.AbsolutePosition.Z, TAmunicja(object_1_f.Owner), -1, -1 );

        TAmunicja(object_1_f.Owner).czy_usunąć := true;
        TAmunicja(object_2_f.Owner).czy_usunąć := true;

      end;
    //---//if    ( not Result ) (...)


    // Amunicja trafia w wodę.
    if    ( not Result )
      and ( object_1_f.Owner is TAmunicja )
      and (  not ( object_2_f.Owner is TAmunicja )  )
      and ( object_2_f.Name = Woda_Kolizje_GLCube.Name )
      and ( TAmunicja(object_1_f.Owner ).czy_poza_lufą ) //???
      and ( not TAmunicja(object_1_f.Owner ).czy_efekt_wpadnięcia_do_wody )
      and ( not TAmunicja(object_1_f.Owner ).czy_pod_wodą )
      //and ( TAmunicja(object_1_f.Owner ).amunicja_rodzaj <> ar_Torpeda )
      and ( not TAmunicja(object_1_f.Owner).czy_usunąć ) then
      begin

        Result := true;

        TAmunicja(object_1_f.Owner).czy_efekt_wpadnięcia_do_wody := true;

        Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_Woda, object_1_f.AbsolutePosition.X, object_1_f.AbsolutePosition.Y, object_1_f.AbsolutePosition.Z, TAmunicja(object_1_f.Owner), -1, -1 );

      end;
    //---//if    ( not Result ) (...)


    // Amunicja trafia w ląd.
    if    ( not Result )
      and ( object_1_f.Owner is TAmunicja )
      and (  not ( object_2_f.Owner is TAmunicja )  )
      and ( TAmunicja(object_1_f.Owner ).czy_poza_lufą )
      and (
               ( object_2_f.Name = Dno_Kolizje_GLCube.Name )
            or (  Pos( 'Ląd__', object_2_f.Name ) = 1  )
          )
      and ( not TAmunicja(object_1_f.Owner).czy_usunąć ) then
      begin

        Result := true;

        Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_Ląd, object_1_f.AbsolutePosition.X, object_1_f.AbsolutePosition.Y, object_1_f.AbsolutePosition.Z, TAmunicja(object_1_f.Owner), -1, -1 );

        TAmunicja(object_1_f.Owner).czy_usunąć := true;

      end;
    //---//if    ( not Result ) (...)


    // Amunicja trafia w statek.
    if    ( not Result )
      and ( object_1_f.Owner is TAmunicja )
      and (  not ( object_2_f.Owner is TAmunicja )  )
      and ( TAmunicja(object_1_f.Owner).czy_poza_lufą )
      and ( not TAmunicja(object_1_f.Owner).czy_usunąć )
      and ( object_2_f.Name <> Woda_Kolizje_GLCube.Name ) then
      begin

        Result := true;

        //Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, object_1_f.AbsolutePosition.X, object_1_f.AbsolutePosition.Y, object_1_f.AbsolutePosition.Z );

        zt_statek := Statek_Znajdź( object_2_f.Owner );

        if    ( zt_statek <> nil )
          and ( zt_statek.statki_rozstawianie_status = srs_Brak ) then // Aby nie wykrywał kolizji ze statkami, które są w trakcie rozstawiania.
          begin

            //if not zt_statek.czy_usunąć then //???
              begin

                Trafienia_Efekt_Utwórz_Jeden( zt_statek, er_Trafienie_Statek, zt_statek.AbsoluteToLocal( object_1_f.AbsolutePosition ).X, zt_statek.AbsoluteToLocal( object_1_f.AbsolutePosition ).Y, zt_statek.AbsoluteToLocal( object_1_f.AbsolutePosition ).Z, TAmunicja(object_1_f.Owner), -1, -1 );

                if TAmunicja(object_1_f.Owner ).czy_uzbrojona then
                  zt_statek.Punkty_Życia_Zmień( -TAmunicja(object_1_f.Owner).obrażenia_zadawane * TAmunicja(object_1_f.Owner).obrażenia_zadawane_współczynnik_zmodyfikowany ); //???

              end;
            //---//if not zt_statek.czy_usunąć then

          end
        else//if    ( zt_statek <> nil ) (...)
          Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_Woda, object_1_f.AbsolutePosition.X, object_1_f.AbsolutePosition.Y, object_1_f.AbsolutePosition.Z, TAmunicja(object_1_f.Owner), -1, -1 );

        TAmunicja(object_1_f.Owner).czy_usunąć := true;

      end;
    //---//if    ( not Result ) (...)
    {$endregion 'Amunicja.'}


    {$region 'Statek.'}
    // Statek dotyka ląd.
    if    ( not Result )
      and (  not ( object_1_f.Owner is TAmunicja )  )
      and (  not ( object_2_f.Owner is TAmunicja )  )
      and ( object_1_f.Name <> Woda_Kolizje_GLCube.Name )
      and ( object_2_f.Name <> Woda_Kolizje_GLCube.Name )
      and (  Pos( 'Ląd__', object_1_f.Name ) <= 0  )
      and (
               ( object_2_f.Name = Dno_Kolizje_GLCube.Name )
            or (  Pos( 'Ląd__', object_2_f.Name ) = 1  )
          ) then
      begin

        zt_statek := Statek_Znajdź( object_1_f.Owner );

        if zt_statek <> nil then // Czy jednym z obiektów kolizji jest statek.
          begin

            if zt_statek.statki_rozstawianie_status = srs_Rozstawianie_Kolizja_Sprawdź then // Aby nie wykrywał kolizji ze statkami, które są w trakcie rozstawiania.
              begin

                Result := true;
                zt_statek.statki_rozstawianie_status := srs_Rozstawianie_Kolizja_Wykryta;

              end
            else//if zt_statek.statki_rozstawianie_status = srs_Rozstawianie_Kolizja_Sprawdź then
              begin

                if    (  Abs( zt_statek.prędkość_procent ) > kolizja_oznaczanie_prędkość_procent_c  )
                  and (  not Statki_Kolizja_Oznaczenie_Sprawdź( zt_statek.kolizja_oznaczenie_string_list, object_2_f.Name )  ) then
                  begin

                    Result := true;

                    zt_statek.kolizja_oznaczenie_string_list.Add(  object_2_f.Name + '|' + IntToStr( Czas_Teraz() )  );

                    Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_Ląd, object_1_f.AbsolutePosition.X, object_1_f.AbsolutePosition.Y, object_1_f.AbsolutePosition.Z, nil, -1, -1 );


                    if Abs( zt_statek.prędkość_procent ) > kolizja_oznaczanie_prędkość_procent_c * 2 then
                      //zt_statek.Punkty_Życia_Zmień( -zt_statek.punkty_życia_maksymalne * 0.1 * object_2_f.TagFloat ); // Koryguje ilość obrażeń o wpływ kolizji lądu. //???
                      //zt_statek.Punkty_Życia_Zmień( -zt_statek.punkty_życia_maksymalne * 0.1 );
                      zt_statek.Punkty_Życia_Zmień
                        (
                            -zt_statek.punkty_życia_maksymalne * 0.1 // 10% z punktów życia.
                          * object_2_f.TagFloat // Koryguje ilość obrażeń o wpływ kolizji lądu.
                          * Abs( zt_statek.prędkość_procent ) * 0.5 * 0.1 // 10% z połowy prędkości.
                        )

                  end;
                //---//if    (  Abs( zt_statek.prędkość_procent ) > kolizja_oznaczanie_prędkość_procent_c  ) (...)


                if Abs( zt_statek.prędkość_aktualna ) > 0 then
                  zt_statek.prędkość__kolizja_zwalnianie := object_2_f.TagFloat;

              end;
            //---//if zt_statek.statki_rozstawianie_status = srs_Rozstawianie_Kolizja_Sprawdź then

          end;
        //---//if zt_statek <> nil then

      end;
    //---//if    ( not Result ) (...)


    // Statek dotyka inny statek.
    if    ( not Result )
      and (  not ( object_1_f.Owner is TAmunicja )  )
      and (  not ( object_2_f.Owner is TAmunicja )  )
      and ( object_1_f.Name <> Woda_Kolizje_GLCube.Name )
      and ( object_2_f.Name <> Woda_Kolizje_GLCube.Name )
      and (  Pos( 'Ląd__', object_1_f.Name ) <= 0  )
      and (  Pos( 'Ląd__', object_2_f.Name ) <= 0  ) then
      begin

        zt_statek := Statek_Znajdź( object_1_f.Owner );

        if zt_statek <> nil then // Czy jednym z obiektów kolizji jest statek.
          begin

            zt_statek_2 := Statek_Znajdź( object_2_f.Owner );

            if    ( zt_statek_2 <> nil )
              and ( zt_statek <> zt_statek_2 ) then // Czy drugim z obiektów kolizji jest statek.
              begin

                Result := true;


                if    ( zt_statek.statki_rozstawianie_status = srs_Brak ) // Aby nie wykrywał kolizji ze statkami, które są w trakcie rozstawiania.
                  and ( zt_statek_2.statki_rozstawianie_status = srs_Brak ) then
                  Kolizja_Statek_Statek_Przelicz( zt_statek, zt_statek_2, object_1_f, object_2_f )
                  //Kolizja_Statek_Statek_Przelicz( zt_statek_2, zt_statek, object_2_f, object_1_f );
                else//if    ( zt_statek.statki_rozstawianie_status = srs_Brak ) (...)
                  begin

                    if zt_statek.statki_rozstawianie_status = srs_Rozstawianie_Kolizja_Sprawdź then
                      zt_statek.statki_rozstawianie_status := srs_Rozstawianie_Kolizja_Wykryta;

                    if zt_statek_2.statki_rozstawianie_status = srs_Rozstawianie_Kolizja_Sprawdź then
                      zt_statek_2.statki_rozstawianie_status := srs_Rozstawianie_Kolizja_Wykryta;

                  end;
                //---//if    ( zt_statek.statki_rozstawianie_status = srs_Brak ) (...)

              end;
            //---//if zt_statek_2 <> nil then

          end;
        //---//if zt_statek <> nil then

      end;
    //---//if    ( not Result ) (...)
    {$endregion 'Statek.'}

//    if    ( object_1_f <> nil )
//      and ( object_2_f <> nil )
//      and ( object_1_f is TAmunicja )
//      and (  not ( object_2_f is TAmunicja )  ) then
//      begin
//
//        TAmunicja(object_1_f).korpus.Material.FrontProperties.Emission.Color := clrBlue;
//        Statki_Form.Caption := Caption + '*';
//
//      end;
//    //---//


//      if not VectorEquals( TGLTorus(object_f).Material.FrontProperties.Emission.Color, clrBlue ) then // uses GLVectorGeometry.
//        TAmunicja(object_f).korpus.Material.FrontProperties.Emission.Color := clrBlue
//      else//if not VectorEquals( TGLTorus(object_f).Material.FrontProperties.Emission.Color, clrBlue ) then
//        TAmunicja(object_f).korpus.Material.FrontProperties.Emission.Color := clrGreen;

    // magiczne pociski łańcuch.
    //if    ( object_f <> nil )
    //  and ( object_f is TGLTorus )
    //  and ( Pocisk_Magiczny_GLTorus.Tag = 1 ) then
    //  if not VectorEquals( TGLTorus(object_f).Material.FrontProperties.Emission.Color, clrBlue ) then // uses GLVectorGeometry.
    //    TGLTorus(object_f).Material.FrontProperties.Emission.Color := clrBlue
    //  else//if not VectorEquals( TGLTorus(object_f).Material.FrontProperties.Emission.Color, clrBlue ) then
    //    TGLTorus(object_f).Material.FrontProperties.Emission.Color := clrGreen;

    // magiczne pociski łańcuch.
    //if    ( object_f <> nil )
    //  and ( object_f is TPocisk_Magiczny ) then
    //  if not VectorEquals( TPocisk_Magiczny(object_f).Material.FrontProperties.Emission.Color, clrRed ) then // uses GLVectorGeometry.
    //    TPocisk_Magiczny(object_f).Material.FrontProperties.Emission.Color := clrRed
    //  else//if not VectorEquals( TGLTorus(object_f).Material.FrontProperties.Emission.Color, clrRed ) then
    //    TPocisk_Magiczny(object_f).Material.FrontProperties.Emission.Color := clrYellowGreen;


  end;//---//Funkcja Oznacz_Kolizję() w GLCollisionManager1Collision().

begin//GLCollisionManager1Collision().

  if    ( object1 <> nil )
    and ( object2 <> nil )
    and ( object1.Owner <> nil )
    and ( object2.Owner <> nil ) then
    begin

      if not Oznacz_Kolizję( object1, object2 ) then
        Oznacz_Kolizję( object2, object1 );

//      if    ( object1.Owner is TAmunicja )
//        and (  not ( object2.Owner is TAmunicja )  ) then
//        Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, object1.AbsolutePosition.X, object1.AbsolutePosition.Y, object1.AbsolutePosition.Z )
//      else//if    ( object1.Owner is TAmunicja ) (...)
//      if    ( object2.Owner is TAmunicja )
//        and (  not ( object1.Owner is TAmunicja )  ) then
//        Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, object2.AbsolutePosition.X, object2.AbsolutePosition.Y, object2.AbsolutePosition.Z );

    end;
  //---//if    ( object1 <> nil ) (...)

  //Oznacz_Kolizję( object1, object2 );
  //Oznacz_Kolizję( object2, object1 );

end;//---//GLCollisionManager1Collision().

procedure TStatki_Form.GLCollisionManager2Collision(Sender: TObject; object1, object2: TGLBaseSceneObject);
begin

//    if    ( object1 <> nil )
//      and ( object2 <> nil ) then
//      begin
//
//        //Statki_Form.Caption := Caption + '*';
//        //Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, object1.AbsolutePosition.X, object1.AbsolutePosition.Y, object1.AbsolutePosition.Z );
//        Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, object2.AbsolutePosition.X, object2.AbsolutePosition.Y, object2.AbsolutePosition.Z );
//
//      end;
//    //---//
//Exit;
//    if    ( object1 <> nil )
//      and ( object2 <> nil )
//          (
//               (
//                    ( object1.Owner <> nil )
//                and ( object1.Owner is TAmunicja )
//
//                and ( object2.Owner <> nil )
//                and (  not ( object2.Owner is TAmunicja )  )
//               )
//            or (
//                    ( object2.Owner <> nil )
//                and ( object2.Owner is TAmunicja )
//
//                and ( object1.Owner <> nil )
//                and (  not ( object1.Owner is TAmunicja )  )
//               )
//          ) then
    if    ( object1 <> nil )
      and ( object2 <> nil )
      and ( object1.Owner <> nil )
      and ( object2.Owner <> nil ) then
      begin

        //TAmunicja(object1).korpus.Material.FrontProperties.Emission.Color := clrBlue;
        //Statki_Form.Caption := Caption + '*';
        //Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, 0, 2, 0 );
        //Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, object1.AbsolutePosition.X, object1.AbsolutePosition.Y, object1.AbsolutePosition.Z );


        if    ( object1.Owner is TAmunicja )
          and (  not ( object2.Owner is TAmunicja )  )then
          Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_Woda, object1.AbsolutePosition.X, object1.AbsolutePosition.Y, object1.AbsolutePosition.Z, TAmunicja(object2.Owner), -1, -1 )
        else
        if    ( object2.Owner is TAmunicja )
          and (  not ( object1.Owner is TAmunicja )  )then
          Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_Woda, object2.AbsolutePosition.X, object2.AbsolutePosition.Y, object2.AbsolutePosition.Z, TAmunicja(object1.Owner), -1, -1 );

      end;
    //---//

end;

//Czas_Bezwzględny_TimerTimer().
procedure TStatki_Form.Czas_Bezwzględny_TimerTimer( Sender: TObject );
begin

  inc( czas_bezwzględny_g );

end;//---//Czas_Bezwzględny_TimerTimer().

//PageControl1Change().
procedure TStatki_Form.PageControl1Change( Sender: TObject );
var
  zti : integer;
begin

  if PageControl1.ActivePage = Klawiatura_Konfiguracja_TabSheet then
    begin

      // Przy zmianie zakładki na Klawiatura_Konfiguracja_TabSheet zapamiętuje aktualny rozmiar i zwiększa szerokość.

      if Self.Width >= 1050 then
        zti := 1000
      else//if Self.Width >= 1050 then
      if Self.Width >= 400 then
        zti := Self.Width - 50;

      if    ( Klawiatura_Konfiguracja__Rozmiar_Zakładki_Poszerz_CheckBox.Checked )
        and ( PageControl1.Width < zti ) then
        begin

          Klawiatura_Konfiguracja__Rozmiar_Zakładki_Poszerz_CheckBox.Tag := PageControl1.Width;

          PageControl1.Width := zti;

        end;
      //---//if    ( Klawiatura_Konfiguracja__Rozmiar_Zakładki_Poszerz_CheckBox.Checked ) (...)

    end
  else//if PageControl1.ActivePage = Klawiatura_Konfiguracja_TabSheet then
    begin

      // Przy zmianie zakładki na inna niż Klawiatura_Konfiguracja_TabSheet przywraca poprzednią szerokość.

      if    ( Klawiatura_Konfiguracja__Rozmiar_Zakładki_Poszerz_CheckBox.Checked )
        and ( Klawiatura_Konfiguracja__Rozmiar_Zakładki_Poszerz_CheckBox.Tag > 0 ) then
        PageControl1.Width := Klawiatura_Konfiguracja__Rozmiar_Zakładki_Poszerz_CheckBox.Tag;


      Klawiatura_Konfiguracja__Rozmiar_Zakładki_Poszerz_CheckBox.Tag := 0;

    end;
  //---//if PageControl1.ActivePage = Klawiatura_Konfiguracja_TabSheet then

end;//---//PageControl1Change().

//Ląd__Wczytaj_Listę_BitBtnClick().
procedure TStatki_Form.Ląd__Wczytaj_Listę_BitBtnClick( Sender: TObject );
begin
  
  Ląd_Opis_Memo.Text := 'Opis mapy.';
  Wczytaj_Schemat( katalog_schematy_lista__lądy_c, -1, lądy_lista_t );
 
end;//---//Ląd__Wczytaj_Listę_BitBtnClick().

//Ląd__Odśwież_Wskazany_BitBtnClick().
procedure TStatki_Form.Ląd__Odśwież_Wskazany_BitBtnClick( Sender: TObject );
begin

  if   ( Ląd_ComboBox.Items.Count < 0 )
    or ( Ląd_ComboBox.ItemIndex < 0 )
    or (  Ląd_ComboBox.ItemIndex > Length( lądy_lista_t ) - 1  ) then
    Exit;


  Wczytaj_Schemat( katalog_schematy_lista__lądy_c, Ląd_ComboBox.ItemIndex, lądy_lista_t );

  Ląd_ComboBoxChange( Sender );
  
end;//---//Ląd__Odśwież_Wskazany_BitBtnClick().

//Ląd__Utwórz_BitBtnClick().
procedure TStatki_Form.Ląd__Utwórz_BitBtnClick( Sender: TObject );
begin

  Ląd_Zwolnij();
  Ląd_Utwórz( Ląd_ComboBox.ItemIndex );
      
end;//---//Ląd__Utwórz_BitBtnClick().

//Ląd_ComboBoxChange().
procedure TStatki_Form.Ląd_ComboBoxChange( Sender: TObject );
begin

  if   ( Ląd_ComboBox.Items.Count < 0 )
    or ( Ląd_ComboBox.ItemIndex < 0 )
    or (  Ląd_ComboBox.ItemIndex > Length( lądy_lista_t ) - 1  ) then
    Exit;


  Ląd_Opis_Memo.Text := StringReplace( lądy_lista_t[ Ląd_ComboBox.ItemIndex ].opis, '#13#10', #13#10, [ rfReplaceAll ] );

  
  Ląd_Zwolnij();
  Ląd_Utwórz( Ląd_ComboBox.ItemIndex );

end;//---//Ląd_ComboBoxChange().

//Statek__Wczytaj_Listę_BitBtnClick().
procedure TStatki_Form.Statek__Wczytaj_Listę_BitBtnClick( Sender: TObject );
begin

  Statek_Opis_Memo.Text := 'Opis statku.';
  Wczytaj_Schemat( katalog_schematy_lista__statki_c, -1, statki_lista_t );
 
end;//---//Statek__Wczytaj_Listę_BitBtnClick().

//Statek__Odśwież_Wskazany_BitBtnClick().
procedure TStatki_Form.Statek__Odśwież_Wskazany_BitBtnClick( Sender: TObject );
begin

  if   ( Statek_ComboBox.Items.Count < 0 )
    or ( Statek_ComboBox.ItemIndex < 0 )
    or (  Statek_ComboBox.ItemIndex > Length( statki_lista_t ) - 1  ) then
    Exit;


  Wczytaj_Schemat( katalog_schematy_lista__statki_c, Statek_ComboBox.ItemIndex, statki_lista_t );
  
  Statek_ComboBoxChange( Sender );

end;//---//Statek__Odśwież_Wskazany_BitBtnClick().

//Statek__Utwórz_BitBtnClick().
procedure TStatki_Form.Statek__Utwórz_BitBtnClick( Sender: TObject );
begin

  if Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked then
    Statek__Odśwież_Wskazany_BitBtnClick( Sender );


  Statki_Zwolnij( true, false );

  if Length( statki_t ) < 1  then
    SetLength( statki_t, 1 );

  statki_t[ 0 ] := TStatek.Create(  Gra_Obiekty_GLDummyCube, Statki_Form.GLCollisionManager1, 0, Statek_Odczytaj_Schemat( Statek_ComboBox.ItemIndex ), prymitywy_lista_t  );
  statki_t[ 0 ].id_grupa := 1; // Aby po odnowieniu statku (jeżeli nie trwa gra) poprawnie wczytało i ustawiło statek.
  statki_t[ 0 ].id_statek_schemat := Statek_ComboBox.ItemIndex; // Aby po odnowieniu statku (jeżeli nie trwa gra) poprawnie wczytało i ustawiło statek.
  statek_gracza := statki_t[ 0 ];

  Interfejs_Parametry_Według_Statku_Ustaw();

  if    (  not ( GLCamera1.Parent is TStatek )  )
    and ( not Statek__Komunikat_Błędu_Pomiń_CheckBox.Checked ) then
    Kamera_Przełącz( kt_Statek ); // Ustawi kamerę na statku gracza.


  Radar_Odwróć_CheckBox.Checked := false;


  Elementy_Gracza_Dostosuj_CheckBoxClick( Sender );

end;//---//Statek__Utwórz_BitBtnClick().

//Statek__Opis_BitBtnClick().
procedure TStatki_Form.Statek__Opis_BitBtnClick( Sender: TObject );
begin

  if statek_gracza <> nil then
    ShowMessage(  statek_gracza.Parametry_Odczytaj( true )  )
  else//if statek_gracza <> nil then
    Application.MessageBox( 'Należy utworzyć statek.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );

end;//---//Statek__Opis_BitBtnClick().

//Statek_ComboBoxChange().
procedure TStatki_Form.Statek_ComboBoxChange( Sender: TObject );
begin

  if   ( Statek_ComboBox.Items.Count < 0 )
    or ( Statek_ComboBox.ItemIndex < 0 )
    or (  Statek_ComboBox.ItemIndex > Length( statki_lista_t ) - 1  ) then
    Exit;


  Statek_Opis_Memo.Text := StringReplace( statki_lista_t[ Statek_ComboBox.ItemIndex ].opis, '#13#10', #13#10, [ rfReplaceAll ] );

end;//---//Statek_ComboBoxChange().

//Statek_ComboBoxKeyDown().
procedure TStatki_Form.Statek_ComboBoxKeyDown( Sender: TObject; var Key: Word; Shift: TShiftState );
begin

  // Enter.
  if Key = 13 then
    begin

      Key := 0;
      Statek__Utwórz_BitBtnClick( Sender );

    end;
  //---//if Key = 13 then

end;//---//Statek_ComboBoxKeyDown().

//Statki_Pozycje_Początkowe__Wczytaj_Listę_BitBtnClick().
procedure TStatki_Form.Statki_Pozycje_Początkowe__Wczytaj_Listę_BitBtnClick( Sender: TObject );
begin

  Statki_Pozycje_Początkowe_Opis_Memo.Text := 'Opis pozycji początkowej statków.';
  Wczytaj_Schemat( katalog_schematy_lista__statki_pozycje_początkowe_c, -1, statki_pozycje_początkowe_lista_t );

end;//---//Statki_Pozycje_Początkowe__Wczytaj_Listę_BitBtnClick().

//Statki_Pozycje_Początkowe__Odśwież_Wskazany_BitBtnClick().
procedure TStatki_Form.Statki_Pozycje_Początkowe__Odśwież_Wskazany_BitBtnClick( Sender: TObject );
begin

  if   ( Statki_Pozycje_Początkowe_ComboBox.Items.Count < 0 )
    or ( Statki_Pozycje_Początkowe_ComboBox.ItemIndex < 0 )
    or (  Statki_Pozycje_Początkowe_ComboBox.ItemIndex > Length( statki_pozycje_początkowe_lista_t ) - 1  ) then
    Exit;


  Wczytaj_Schemat( katalog_schematy_lista__statki_pozycje_początkowe_c, Statki_Pozycje_Początkowe_ComboBox.ItemIndex, statki_pozycje_początkowe_lista_t );

  Statki_Pozycje_Początkowe_ComboBoxChange( Sender );

end;//---//Statki_Pozycje_Początkowe__Odśwież_Wskazany_BitBtnClick().

//Statki_Pozycje_Początkowe__Brak_BitBtnClick().
procedure TStatki_Form.Statki_Pozycje_Początkowe__Brak_BitBtnClick( Sender: TObject );
begin

  Statki_Pozycje_Początkowe_ComboBox.ItemIndex := -1;
  Statki_Pozycje_Początkowe_Opis_Memo.Text := 'Opis pozycji początkowej statków.';

  Statki_Pozycje_Początkowe_ComboBoxChange( Sender ); // Aby podstawił wartości domyślne.

end;//---//Statki_Pozycje_Początkowe__Brak_BitBtnClick().

//Statki_Pozycje_Początkowe_ComboBoxChange().
procedure TStatki_Form.Statki_Pozycje_Początkowe_ComboBoxChange( Sender: TObject );
var
  i,
  j
    : integer;
  zt_xml_document : TXMLDocument; //uses XMLDoc
begin//Statki_Pozycje_Początkowe_ComboBoxChange().

  statki_pozycja_początkowa_parametry_t[ 1 ].korekta_obrót := 0;
  statki_pozycja_początkowa_parametry_t[ 1 ].korekta_x := 0;
  statki_pozycja_początkowa_parametry_t[ 1 ].korekta_z := 0;
  statki_pozycja_początkowa_parametry_t[ 1 ].odstęp_x := 7;
  statki_pozycja_początkowa_parametry_t[ 1 ].z := 10;
  statki_pozycja_początkowa_parametry_t[ 2 ].korekta_obrót := 180;
  statki_pozycja_początkowa_parametry_t[ 2 ].korekta_x := 0;
  statki_pozycja_początkowa_parametry_t[ 2 ].korekta_z := 0;
  statki_pozycja_początkowa_parametry_t[ 2 ].odstęp_x := 7;
  statki_pozycja_początkowa_parametry_t[ 2 ].z := -10;


  if   ( Statki_Pozycje_Początkowe_ComboBox.Items.Count < 0 )
    or ( Statki_Pozycje_Początkowe_ComboBox.ItemIndex < 0 )
    or (  Statki_Pozycje_Początkowe_ComboBox.ItemIndex > Length( statki_pozycje_początkowe_lista_t ) - 1  ) then
    begin

      Statki_Pozycje_Początkowe_Opis_Memo.Text := '';
      Exit;

    end;
  //---//if   ( Statki_Pozycje_Początkowe_ComboBox.Items.Count < 0 ) (...)


  Statki_Pozycje_Początkowe_Opis_Memo.Text := StringReplace( statki_pozycje_początkowe_lista_t[ Statki_Pozycje_Początkowe_ComboBox.ItemIndex ].opis, '#13#10', #13#10, [ rfReplaceAll ] );


  zt_xml_document := TXMLDocument.Create( Application );

  zt_xml_document.Options := zt_xml_document.Options + [ doNodeAutoIndent ]; // Domyślnie ma: doNodeAutoCreate, doAttrNull, doAutoPrefix, doNamespaceDecl.

  try
    // Serwer zgłasza błąd podczas odczytu danych o lądzie od klienta
    //   MSXML is not installed
    //   Assertion failure GLContext.pas
    // W Ląd_Zwolnij() chyba też takie coś się dzieje (inne błędy) ale z podobnego powodu.
    //
    // Udało się uniknąć błędów tak:
    //   w zdarzeniu odczytania danych o lądzie tylko włączyć Timer;
    //   w Timer.OnTimet wyłączyć Timer i wywołać zwalnianie i wczytywanie lądu.
    //
    zt_xml_document.LoadFromXML( statki_pozycje_początkowe_lista_t[ Statki_Pozycje_Początkowe_ComboBox.ItemIndex ].treść );
  except
    on E : Exception do
      Application.MessageBox(  PChar('Nieprawidłowa definicja pozycji początkowej statków.' + #13 + E.Message + ' ' + IntToStr( E.HelpContext )), 'Błąd', MB_OK + MB_ICONEXCLAMATION  );
      //Log_Wypisz(  'Nieprawidłowa definicja pozycji początkowej statków.' + #13 + #10 + E.Message + ' ' + IntToStr( E.HelpContext )  );
  end;
  //---//try

  {$region 'Odczyt danych xml.'}
  if zt_xml_document.Active then
    begin

      for i := 0 to zt_xml_document.DocumentElement.ChildNodes.Count - 1 do
        begin

          if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'grupa_1' then
            begin

              for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do
                begin

                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'korekta_obrót' then
                    statki_pozycja_początkowa_parametry_t[ 1 ].korekta_obrót := Round(  Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null )  )
                  else
                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'korekta_x' then
                    statki_pozycja_początkowa_parametry_t[ 1 ].korekta_x := Round(  Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null )  )
                  else
                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'korekta_z' then
                    statki_pozycja_początkowa_parametry_t[ 1 ].korekta_z := Round(  Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null )  )
                  else
                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'odstęp_x' then
                    statki_pozycja_początkowa_parametry_t[ 1 ].odstęp_x := Round(  Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null )  )
                  else
                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'z' then
                    statki_pozycja_początkowa_parametry_t[ 1 ].z := Round(  Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null )  );

                end;
              //---//for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do

            end
          else//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'grupa_1' then
          if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'grupa_2' then
            begin

              for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do
                begin

                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'korekta_obrót' then
                    statki_pozycja_początkowa_parametry_t[ 2 ].korekta_obrót := Round(  Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null )  )
                  else
                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'korekta_x' then
                    statki_pozycja_początkowa_parametry_t[ 2 ].korekta_x := Round(  Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null )  )
                  else
                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'korekta_z' then
                    statki_pozycja_początkowa_parametry_t[ 2 ].korekta_z := Round(  Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null )  )
                  else
                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'odstęp_x' then
                    statki_pozycja_początkowa_parametry_t[ 2 ].odstęp_x := Round(  Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null )  )
                  else
                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'z' then
                    statki_pozycja_początkowa_parametry_t[ 2 ].z := Round(  Odczytaj_Liczbę_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null )  );

                end;
              //---//for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do

            end;
          //---//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'grupa_2' then

        end;
      //---//for i := 0 to zt_xml_document.DocumentElement.ChildNodes.Count - 1 do

    end;
  //---//if zt_xml_document.Active then
  {$endregion 'Odczyt danych xml.'}


  zt_xml_document.Free();


  {$region 'Przykład xml.'}
{
<statki_pozycja_początkowa>
  <nazwa>Pozycje początkowa 01</nazwa>
  <opis><![CDATA[Opis pozycje początkowa 01.#13#10Nowa linia.]]></opis>

  <grupa_1>
    <korekta_obrót>123</korekta_obrót> <!-- Początkowy obrót statku (+) lewo (-) prawo. -->
    <korekta_x>123</korekta_x> <!-- Przesunięcie pozycji wszystkich statków w grupie (-) lewo (+) prawo. -->
    <korekta_z>123</korekta_z> <!-- Przesunięcie pozycji każdego statku w grupie osobno o wielokrotność wartości (-) przód (+) tył. -->
    <odstęp_x>123</odstęp_x> <!-- Odstęp między statkami po bokach. -->
    <z>123</z> <!-- Odstęp od środka planszy (-) przód (+) tył. -->
  </grupa_1>

  <grupa_2>
    <korekta_obrót>123</korekta_obrót>
    <korekta_x>123</korekta_x>
    <korekta_z>-123</korekta_z>
    <odstęp_x>123</odstęp_x>
    <z>-123</z>
  </grupa_2>
</statki_pozycja_początkowa>
}
  {$endregion 'Przykład xml.'}

end;//---//Statki_Pozycje_Początkowe_ComboBoxChange().

//Gra_Rozpocznij_BitBtnClick().
procedure TStatki_Form.Gra_Rozpocznij_BitBtnClick( Sender: TObject );
var
  i : integer;
  zt_id_socket_handle : TIdSocketHandle;
begin

  if czy_klient_g then
    Exit
  else//if czy_klient_g then
  if   ( czy_gra_lokalna_g )
    or ( czy_serwer_g ) then
    begin

      for i := 0 to tcp_klienci_lista_g.klienci_lista_list.Count - 1 do //??? Potem odkomentować.
        begin

          if not TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).gotowy then
            begin

              if Application.MessageBox( 'Nie wszyscy gracze są gotowi. Czy kontynuować?', 'Potwierdzenie', MB_YESNO + MB_DEFBUTTON2 + MB_ICONQUESTION ) = IDNO then
                Exit
              else//if Application.MessageBox( 'Nie wszyscy gracze są gotowi. Czy kontynuować?', 'Potwierdzenie', MB_YESNO + MB_DEFBUTTON2 + MB_ICONQUESTION ) = IDNO then
                Break; // Dalej nie sprawdza gotowości graczy.

            end;
          //---//if not TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).gotowy then

        end;
      //---//for i := 0 to tcp_klienci_lista_g.klienci_lista_list.Count - 1 do


      if czy_serwer_g then
        begin

          if not IdUDPServer1.Active then
            begin

              IdUDPServer1.DefaultPort := Serwer_Port_SpinEdit.Value;

              IdUDPServer1.Bindings.Clear();

              zt_id_socket_handle := IdUDPServer1.Bindings.Add();
              zt_id_socket_handle.IP := '0.0.0.0';
              zt_id_socket_handle.Port := Serwer_Port_SpinEdit.Value;


              IdUDPServer1.Active := true;

            end;
          //---//if not IdUDPServer1.Active then


          udp_data_czas_sprawdzanie_połączeń_ostatnie_g := Now();

          Serwer_Wysyła_Timer.Enabled := true;


          Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__gra__rozpocznij_c, -99, '' );

          Wieloosobowe__Strumień_Wyślij(  wieloosobowe__komenda__gra_współczynnik_prędkości_c, -99, IntToStr( Gra_Współczynnik_Prędkości_SpinEdit.Value )  );


          for i := 0 to Length( prymitywy_lista_t ) - 1 do
            Wieloosobowe__Strumień_Wyślij(  wieloosobowe__komenda__odbierz__prymitywy_definicja_c, -99, IntToStr( i )  );


          Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__odbierz__ląd_definicja_c, -99, '' );

        end;
      //---//if czy_serwer_g then

    end;
  //---//if   ( czy_gra_lokalna_g ) (...)


  // Gra lokalna.

  Gra_Rozpocznij_BitBtn.Enabled := false;
  Gra_Zakończ_BitBtn.Enabled := true;

  Gracz_Gotowość_Tak_BitBtn.Enabled := false;
  Gracz_Gotowość_Nie_BitBtn.Enabled := false;

  Statki_Zaprezentuj_Button.Enabled := false;
  Statki_Zaprezentuj__Zwolnij_BitBtn.Enabled := false;


  Elementy_Gry_Zwolnij();
  Elementy_Gry_Przygotuj();

  if not ( GLCamera1.Parent is TStatek ) then
    Kamera_Przełącz( kt_Statek ); // Ustawi kamerę na statku gracza.

end;//---//Gra_Rozpocznij_BitBtnClick().

//Gra_Zakończ_BitBtnClick().
procedure TStatki_Form.Gra_Zakończ_BitBtnClick( Sender: TObject );
begin

  Serwer_Wysyła_Timer.Enabled := false;


  if   ( czy_serwer_g )
    or ( czy_gra_lokalna_g ) then
    begin

      Gra_Rozpocznij_BitBtn.Enabled := true;
      Gra_Zakończ_BitBtn.Enabled := false;

      Gracz_Gotowość_BitBtnClick( Gracz_Gotowość_Nie_BitBtn );

      //Gracz_Gotowość_Tak_BitBtn.Enabled := true;
      //Gracz_Gotowość_Nie_BitBtn.Enabled := true;

      Statki_Zaprezentuj_Button.Enabled := true;
      Statki_Zaprezentuj__Zwolnij_BitBtn.Enabled := true;


      if czy_serwer_g then
        begin

          Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__gra__zakończ_c, -99, '' );

          Sleep( Klient_IdTCP_Czyta_Timer.Interval * 3 ); // Tak jest ustawiony zegar czytania klientów. //???

        end;
      //---//if czy_serwer_g then

    end;
  //---//if   ( czy_serwer_g ) (...)


  if IdUDPServer1.Active then
    IdUDPServer1.Active := false;

  IdUDPServer1.Bindings.Clear(); //???

  udp_klienci_lista_g.Usuń_Wszystkich();


  Elementy_Gry_Zwolnij();

  Ląd_Utwórz( Ląd_ComboBox.ItemIndex ); // Wczytuje pozycje początkowe statków.

  Statek__Utwórz_BitBtnClick( Sender );

  if not ( GLCamera1.Parent is TStatek ) then
    Kamera_Przełącz( kt_Statek ); // Ustawi kamerę na statku gracza.

end;//---//Gra_Zakończ_BitBtnClick().

//Gra_Współczynnik_Prędkości_SpinEditChange().
procedure TStatki_Form.Gra_Współczynnik_Prędkości_SpinEditChange( Sender: TObject );
var
  ztr : real;
begin

  ztr := Gra_Współczynnik_Prędkości_SpinEdit.Value / 100;

  if ztr <= 0 then
    ztr := 1;

  gra_współczynnik_prędkości_g := ztr;

  Gra_Współczynnik_Prędkości_Etykieta_Label.Caption := 'Prędkość gry ' + FloatToStr( gra_współczynnik_prędkości_g );

  Informacja_Dodatkowa_Dodaj( Gra_Współczynnik_Prędkości_Etykieta_Label.Caption );


  if czy_serwer_g then
    Wieloosobowe__Strumień_Wyślij(  wieloosobowe__komenda__gra_współczynnik_prędkości_c, -99, IntToStr( Gra_Współczynnik_Prędkości_SpinEdit.Value )  );

end;//---//Gra_Współczynnik_Prędkości_SpinEditChange().

//Wieloosobowe__Tryb_RadioGroupClick().
procedure TStatki_Form.Wieloosobowe__Tryb_RadioGroupClick( Sender: TObject );
begin

  if Wieloosobowe__Tryb_RadioGroup.ItemIndex = 0 then // Brak.
    begin

      Wieloosobowe_Identyfikator_Edit.Text := '';
      Wieloosobowe_Identyfikator_Gra_Label.Caption := '<brak>';

    end;
  //---//if Wieloosobowe__Tryb_RadioGroup.ItemIndex = 0 then

end;//---//Wieloosobowe__Tryb_RadioGroupClick().

//Wieloosobowe__Podłącz_BitBtnClick().
procedure TStatki_Form.Wieloosobowe__Podłącz_BitBtnClick( Sender: TObject );
begin

  case Wieloosobowe__Tryb_RadioGroup.ItemIndex of
    0 : // Gra lokalna.
      begin

        czy_gra_lokalna_g := true;

      end;
    1 : // Klient.
      begin

        czy_serwer_g := false;
        czy_klient_g := true;
        czy_gra_lokalna_g := false;

      end;
    //---// 1
    2 : // Serwer.
      begin

        czy_serwer_g := true;
        czy_klient_g := false;
        czy_gra_lokalna_g := false;
        //czy_wysyłanie_trwa_g := false;

      end;
    //---// 2

    else//case Wieloosobowe__Tryb_RadioGroup.ItemIndex of
      begin

        czy_serwer_g := false;
        czy_klient_g := false;
        czy_gra_lokalna_g := false;
        //czy_wysyłanie_trwa_g := false;

      end;
    //---//
  end;
  //---//case Wieloosobowe__Tryb_RadioGroup.ItemIndex of


  Wieloosobowe__Tryb_RadioGroup.Enabled := false;
  Wieloosobowe__Podłącz_BitBtn.Enabled := false;

  Gra_Rozpocznij_BitBtn.Enabled := true;

  Gracz_Gotowość_Nie_BitBtn.Enabled := false;
  Gracz_Gotowość_Tak_BitBtn.Enabled := true;


  if not czy_gra_lokalna_g then
    begin

      IdTCPClient1.Host := Serwer_Adres_IP_Edit.Text;
      IdTCPClient1.Port := Serwer_Port_SpinEdit.Value;
      IdTCPClient1.ReadTimeout := 5; //???
      IdTCPServer1.DefaultPort := Serwer_Port_SpinEdit.Value;

    end;
  //---//if not czy_gra_lokalna_g then


  if   ( czy_serwer_g )
    or ( czy_gra_lokalna_g ) then
    begin

      if czy_serwer_g then
        begin

          czy_wyłączanie_serwera_g := false;

          IdTCPServer1.Active := true;

        end;
      //---//if czy_serwer_g then


      tcp_klienci_lista_g.Dodaj_Aktualizuj( serwer_peer_port_c, -99 ); // Serwer ma peer_port_f i identyfikator_f = -1.
      Wieloosobowe_Identyfikator_Edit.Text := IntToStr( serwer_peer_port_c );
      Wieloosobowe_Identyfikator_Gra_Label.Caption := Wieloosobowe_Identyfikator_Edit.Text;

      Gracze_Lista_Odśwież();


      Gra_Zakończ_BitBtn.Enabled := false;
      SI_GroupBox.Enabled := true;

    end;
  //---//if   ( czy_serwer_g ) (...)


  if czy_klient_g then
    begin

      Gra_Rozpocznij_BitBtn.Enabled := false;
      Gra_Zakończ_BitBtn.Enabled := false;
      Gra_Współczynnik_Prędkości_SpinEdit.Enabled := false;
      Gra_Współczynnik_Prędkości_SpinEdit.Value := 100;
      Gracze_Lista_Rozłącz_Gracza_BitBtn.Enabled := false;

      Ląd_GroupBox.Enabled := false;
      Statek__Odśwież_Wskazany_BitBtn.Enabled := false;
      Statek__Wczytaj_Listę_BitBtn.Enabled := false;
      Statki_Pozycje_Początkowe_GroupBox.Enabled := false;


      // Nawiązanie połączenia.
      if not IdTCPClient1.Connected then
        begin

          try
            IdTCPClient1.Connect();
          except
            on E : Exception do
              begin
                Application.MessageBox(
                    PChar('Nie można nawiązać połaczenia z serwerem: ' + IdTCPClient1.Host + #13 +
                    E.Message + ' ' + IntToStr( E.HelpContext ) + '.'), 'Błąd',
                    MB_OK + MB_ICONEXCLAMATION
                  );
              end;
            //---//on E : Exception do
          end;
          //---//try


          if IdTCPClient1.Connected then
            begin

              //???Self.Caption := 'TCP UDP test ' + IntToStr( IdTCPClient1.Socket.Binding.Port );

              if Wieloosobowe_Identyfikator_Edit.Text = '' then
                Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__identyfikator__nadaj_c, -99, '' )
              else//if Wieloosobowe_Identyfikator_Edit.Text = '' then
                Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__identyfikator__przypomnij_c, -99, Wieloosobowe_Identyfikator_Edit.Text );


              Klient_IdTCP_Czyta_Timer.Enabled := true;

            end
          else//if not IdTCPClient1.Connected then
            begin

              Application.MessageBox( 'Nie udało się połączyć z serwerem.', 'Błąd', MB_OK + MB_ICONEXCLAMATION );
              Wieloosobowe__Odłącz_BitBtnClick( Sender );

            end;
          //---//if IdTCPClient1.Connected then

        end;
      //---//if not IdTCPClient1.Connected then

    end;
  //---//if czy_klient_g then

end;//---//Wieloosobowe__Podłącz_BitBtnClick().

//Wieloosobowe__Odłącz_BitBtnClick().
procedure TStatki_Form.Wieloosobowe__Odłącz_BitBtnClick( Sender: TObject );
begin

  Gra_Zakończ_BitBtnClick( Sender );

  Klient_IdTCP_Czyta_Timer.Enabled := false;
  Klient_IdUDP_Czyta_Timer.Enabled := false;
  Klient_Wysyła_Timer.Enabled := false;

  Gra_Rozpocznij_BitBtn.Enabled := true;
  Gra_Zakończ_BitBtn.Enabled := true;

  Gracz_Gotowość_BitBtnClick( Gracz_Gotowość_Nie_BitBtn );

  Gracz_Gotowość_Nie_BitBtn.Enabled := false;
  Gracz_Gotowość_Tak_BitBtn.Enabled := false;

  SI_GroupBox.Enabled := false;


  if IdUDPClient1.Connected then
    IdUDPClient1.Disconnect();

  if IdUDPServer1.Active then
    IdUDPServer1.Active := false;


  if IdTCPClient1.Connected then
    IdTCPClient1.Disconnect();

  if IdTCPServer1.Active then
    begin

      czy_wyłączanie_serwera_g := true;
      Wieloosobowe__Tekst_Wyślij( wieloosobowe__komenda__serwer_wyłącza_się_c );

      Sleep( Klient_IdTCP_Czyta_Timer.Interval * 3 ); // Tak jest ustawiony zegar czytania klientów. //???

      //IdTCPServer1.Bindings.Clear();

      //tcp_klienci_lista_g.Usuń_Wszystkich();
      udp_klienci_lista_g.Usuń_Wszystkich();


      IdTCPServer1.Active := false;
      //czy_wysyłanie_trwa_g := false;

      //Wieloosobowe_Identyfikator_Edit.Text := '';
      //Wieloosobowe_Identyfikator_Gra_Label.Caption := '<brak>';

    end;
  //---//if IdTCPServer1.Active then


  tcp_klienci_lista_g.Usuń_Wszystkich(); // Czyści również listę u klienta.
  //udp_klienci_lista_g.Usuń_Wszystkich(); // Czyści również listę u klienta.

  Wieloosobowe_Identyfikator_Edit.Text := ''; // Czyści również u klienta.
  Wieloosobowe_Identyfikator_Gra_Label.Caption := '<brak>';


  if czy_klient_g then
    begin

      Gra_Współczynnik_Prędkości_SpinEdit.Enabled := true;
      Ląd_GroupBox.Enabled := true;
      Statek__Odśwież_Wskazany_BitBtn.Enabled := true;
      Statek__Wczytaj_Listę_BitBtn.Enabled := true;
      Statki_Pozycje_Początkowe_GroupBox.Enabled := true;
      Statki_Zaprezentuj_Button.Enabled := true;
      Statki_Zaprezentuj__Zwolnij_BitBtn.Enabled := true;

    end;
  //---//if czy_klient_g then


  czy_gra_lokalna_g := false;
  czy_serwer_g := false;
  czy_klient_g := false;


  Wieloosobowe__Tryb_RadioGroup.Enabled := true;
  Wieloosobowe__Podłącz_BitBtn.Enabled := true;
  Gracze_Lista_Rozłącz_Gracza_BitBtn.Enabled := true;

  Gracze_Lista_Odśwież();

end;//---//Wieloosobowe__Odłącz_BitBtnClick().

//IdTCPServer1Connect().
procedure TStatki_Form.IdTCPServer1Connect( AContext: TIdContext );
begin

  if czy_wyłączanie_serwera_g then
    Exit;


  if 1 = 2 then
    begin

        Wieloosobowe__Log_Wypisz(
            'Połączenie od: ' + AContext.Connection.Socket.Binding.PeerIP +
            ':' + IntToStr( AContext.Connection.Socket.Binding.PeerPort ) +
            ' (ilość: ' + IntToStr( IdTCPServer1.Contexts.LockList.Count ) + ')'
          );
        //Wieloosobowe__Log_Wypisz( 'Otrzymany tekst: ' + AContext.Connection.AllData );


      IdTCPServer1.Contexts.UnlockList(); // Może to ma być tylko jeżeli wcześniej tutaj odnosi się do IdTCPServer1.Contexts (chyba tak).

    end;
  //---//if 1 = 2 then

end;//---//IdTCPServer1Connect().

//IdTCPServer1Disconnect().
procedure TStatki_Form.IdTCPServer1Disconnect( AContext: TIdContext );
var
  zt_tcp_klient_dane : TTCP_Klient_Dane;
begin

  if czy_wyłączanie_serwera_g then
    Exit;


  if 1 = 2 then
    begin

      Wieloosobowe__Log_Wypisz(
          'Odłączył się: ' + AContext.Connection.Socket.Binding.PeerIP +
          ':' + IntToStr( AContext.Connection.Socket.Binding.PeerPort ) +
          ' (ilość: ' + IntToStr( IdTCPServer1.Contexts.LockList.Count - 1 ) + ')'
        );

      IdTCPServer1.Contexts.UnlockList(); // Może to ma być tylko jeżeli wcześniej tutaj odnosi się do IdTCPServer1.Contexts (chyba tak).

    end;
  //---//if 1 = 2 then


  zt_tcp_klient_dane := tcp_klienci_lista_g.Znajdź_Peer_Port( AContext.Connection.Socket.Binding.PeerPort );

  if zt_tcp_klient_dane <> nil then
    udp_klienci_lista_g.Usuń_Peer_Port( zt_tcp_klient_dane.peer_port_udp );


  tcp_klienci_lista_g.Usuń_Peer_Port( AContext.Connection.Socket.Binding.PeerPort ); //??? rozłączenie z powodu sieci
  //tcp_klienci_lista_g.Odłączony_Peer_Port( AContext.Connection.Socket.Binding.PeerPort );


  Gracze_Lista_Odśwież();


  Serwer_Klient_Odłączenie_Timer.Enabled := true;

end;//---//IdTCPServer1Disconnect().

//IdTCPServer1Execute().
procedure TStatki_Form.IdTCPServer1Execute( AContext: TIdContext );
begin

  // Bez tego zdarzenia podczas aktywowania serwera zgłasza błąd, że brakuje tego zdarzenia.

  if czy_wyłączanie_serwera_g then
    Exit;

  //Wieloosobowe__Log_Wypisz( 'IdTCPServer1Execute' );


  Log_Wypisz(  Wieloosobowe__Odczytaj( AContext.Connection.IOHandler, '', AContext, nil )  );

end;//---//IdTCPServer1Execute().

//IdUDPServer1UDPRead().
procedure TStatki_Form.IdUDPServer1UDPRead( AThread: TIdUDPListenerThread; const AData: TIdBytes; ABinding: TIdSocketHandle );
begin

  if czy_wyłączanie_serwera_g then
    Exit;

  //Wieloosobowe__Log_Wypisz( 'IdUDPServer1UDPRead' );


  //komenda_l := IdGlobal.BytesToString( AData, IdGlobal.IndyTextEncoding_UTF8 );
  Wieloosobowe__Odczytaj(  nil, IdGlobal.BytesToString( AData, IdGlobal.IndyTextEncoding_UTF8 ), nil, ABinding  );

end;//---//IdUDPServer1UDPRead().

//Serwer_Wysyła_TimerTimer().
procedure TStatki_Form.Serwer_Wysyła_TimerTimer( Sender: TObject );
begin

  //if czy_wysyłanie_trwa_g then //???
  //  Exit;


  //Wieloosobowe__Log_Wypisz( 'Serwer_Wysyła_TimerTimer' );

  //czy_wysyłanie_trwa_g := true;

  //Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__odbierz__rekord_amunicja_c, -99, '' );
  //Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__odbierz__rekord_statki_c, -99, '' );

  Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__odbierz__rekord_amunicja_c, -99, '', true );
  Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__odbierz__rekord_statki_c, -99, '', true );
  //Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__odbierz__rekord_efekt_c, -99, '', true ); // Efekt wysyłany jako tabela.

  //czy_wysyłanie_trwa_g := false;


  if SecondsBetween( Now(), udp_data_czas_sprawdzanie_połączeń_ostatnie_g ) > udp_klient_połączenie_potwierdzanie_sekund_c * 2 then
    begin

      udp_klienci_lista_g.Usuń_Przeterminowanych();
      udp_data_czas_sprawdzanie_połączeń_ostatnie_g := Now();

    end;
  //---//if SecondsBetween( Now(), udp_data_czas_sprawdzanie_połączeń_ostatnie_g ) > udp_klient_połączenie_potwierdzanie_sekund_c * 2 then

end;//---//Serwer_Wysyła_TimerTimer().

//Klient_IdTCP_Czyta_TimerTimer().
procedure TStatki_Form.Klient_IdTCP_Czyta_TimerTimer( Sender: TObject );
var
  komenda_l : string;
begin

  if IdTCPClient1.Connected then
    try

      //check for a message from the server
      if IdTCPClient1.IOHandler.InputBufferIsEmpty then
        begin

          IdTCPClient1.IOHandler.CheckForDataOnSource( 10 );
          IdTCPClient1.IOHandler.CheckForDisconnect();

          if IdTCPClient1.IOHandler.InputBufferIsEmpty then
            Exit;

        end;
      //---//if IdTCPClient1.IOHandler.InputBufferIsEmpty then


      komenda_l := Wieloosobowe__Odczytaj( IdTCPClient1.IOHandler, '', nil, nil );


      //if Trim( komenda_l ) <> '' then
      //  Wieloosobowe__Log_Wypisz( 'Serwer TCP: ' + komenda_l );
      //Log_Wypisz( komenda_l );


      if    (  Pos( wieloosobowe__komenda__serwer_wyłącza_się_c, komenda_l ) > 0  ) // Ze względu na to, że w tym przykładzie serwer wysyła jeszcze informację do kogo wysyła tekst. //???
        and ( not czy_serwer_g ) then
        begin

          Wieloosobowe__Odłącz_BitBtnClick( Sender );
          Wieloosobowe_Identyfikator_Edit.Text := '';
          Wieloosobowe_Identyfikator_Gra_Label.Caption := '<brak>';

        end
      else//if    (  Pos( wieloosobowe__komenda__serwer_wyłącza_się_c, komenda_l ) > 0  ) (...)
        Log_Wypisz( komenda_l );

    except
      on E : Exception do
        begin

          //Application.MessageBox(  PChar(E.Message + ' ' + IntToStr( E.HelpContext )), 'Błąd', MB_OK + MB_ICONEXCLAMATION  );
          Log_Memo.Lines.Add( E.Message + ' ' + IntToStr( E.HelpContext ) );

        end;
      //---//on E : Exception do
    end;
    //---//try


  if not IdTCPClient1.Connected then
    Klient_IdTCP_Czyta_Timer.Enabled := false;

end;//---//Klient_IdTCP_Czyta_TimerTimer().

//Klient_IdUDP_Czyta_TimerTimer().
procedure TStatki_Form.Klient_IdUDP_Czyta_TimerTimer( Sender: TObject );
var
  komenda_l : string;
begin

  if IdUDPClient1.Connected then
    begin

      komenda_l := IdUDPClient1.ReceiveString( -1, IdGlobal.IndyTextEncoding_UTF8 );

      if Trim( komenda_l ) <> '' then
        komenda_l := Wieloosobowe__Odczytaj( nil, komenda_l, nil, nil );

      //if Trim( komenda_l ) <> '' then
      //  Wieloosobowe__Log_Wypisz( 'Serwer UDP: ' + komenda_l );


      // Klient przypomina, że jest nadal połączony.
      //if    ( udp_klienci_lista_g.klienci_lista_list.Count = 1 )
      //  and (  SecondsBetween( Now(), TUDP_Klient_Dane(udp_klienci_lista_g.klienci_lista_list[ 0 ]).data_czas_kontakt_ostatni ) > udp_klient_połączenie_potwierdzanie_sekund_c  ) then
      if SecondsBetween( Now(), udp_data_czas_sprawdzanie_połączeń_ostatnie_g ) > udp_klient_połączenie_potwierdzanie_sekund_c then
        begin

          Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__udp__klient_połączony_nadal_c, -99, '', true );

          udp_data_czas_sprawdzanie_połączeń_ostatnie_g := Now();
          //TUDP_Klient_Dane(udp_klienci_lista_g.klienci_lista_list[ 0 ]).data_czas_kontakt_ostatni := Now();

        end;
      //---//if SecondsBetween( Now(), udp_data_czas_sprawdzanie_połączeń_ostatnie_g ) > udp_klient_połączenie_potwierdzanie_sekund_c then

    end;
  //---//if IdUDPClient1.Connected then


  if   ( not IdTCPClient1.Connected )
    or ( not IdUDPClient1.Connected ) then
    begin

      Klient_IdUDP_Czyta_Timer.Enabled := false;
      Klient_Wysyła_Timer.Enabled := false;

    end;
  //---//if   ( not IdTCPClient1.Connected ) (...)

end;//---//Klient_IdUDP_Czyta_TimerTimer().

//Klient_Wysyła_TimerTimer().
procedure TStatki_Form.Klient_Wysyła_TimerTimer( Sender: TObject );
begin

  if statek_gracza <> nil then
    begin

      if czy_klient_g then
        begin

          // Wysyła informację o tym gdzie celuje gracz.

          wieloosobowe__statek_klawisze_obsługa_r.id_statek := statek_gracza.id_statek; //??? na początku gry
          wieloosobowe__statek_klawisze_obsługa_r.klawisz := 0;
          wieloosobowe__statek_klawisze_obsługa_r.shift := [];
          wieloosobowe__statek_klawisze_obsługa_r.mysz_przycisk := -1;
          wieloosobowe__statek_klawisze_obsługa_r.cel_współrzędne := statek_gracza.celownicza_linia.Nodes[ 1 ].AsVector;
          wieloosobowe__statek_klawisze_obsługa_r.ar_artyleria := ar_Artyleria_CheckBox.Checked;
          wieloosobowe__statek_klawisze_obsługa_r.ar_pocisk := ar_Pocisk_CheckBox.Checked;
          wieloosobowe__statek_klawisze_obsługa_r.ar_torpeda := ar_Torpeda_CheckBox.Checked;
          wieloosobowe__statek_klawisze_obsługa_r.ar_wszystkie := ar_Wszystkie_CheckBox.Checked;
          wieloosobowe__statek_klawisze_obsługa_r.polecenie_nazwa := '';

          Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__statek__klawisze_obsługa_c, -99, '' );

        end;
      //---//if czy_klient_g then

    end;
  //---//if statek_gracza <> nil then

end;//---//Klient_Wysyła_TimerTimer().

//Serwer_Klient_Odłączenie_TimerTimer().
procedure TStatki_Form.Serwer_Klient_Odłączenie_TimerTimer( Sender: TObject );
begin

  // Jeżeli wysyła informację od razu w zdarzeniu IdTCPServer1Disconnect() to serwer zgłasza błąd 'Connection Closed Gracefully'.

  Serwer_Klient_Odłączenie_Timer.Enabled := false;

  Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__gracz_lista_odśwież_c, -99, '' );

end;//---//Serwer_Klient_Odłączenie_TimerTimer().

//Pokój_Rozmów__Na_Ekranie_CheckBoxClick().
procedure TStatki_Form.Pokój_Rozmów__Na_Ekranie_CheckBoxClick( Sender: TObject );
begin

  if Pokój_Rozmów__Na_Ekranie_CheckBox.Checked then
    begin

      // Na ekranie.

      Pokój_Rozmów_GroupBox.Align := alNone;
      Pokój_Rozmów_GroupBox.Parent := Statki_Form;
      Pokój_Rozmów_GroupBox.Anchors := [ akLeft, akBottom ];
      Pokój_Rozmów_GroupBox.Left := 0;

      Pokój_Rozmów__Ukryj_Button.Caption := 'x';
      Pokój_Rozmów__Ukryj_Button.Hint := 'Ukryj.';

      Pokój_Rozmów_GroupBox.Width := Pokój_Rozmów_GroupBox.Tag;

      FormResize( Sender );

      Pokój_Rozmów_Wiadomość_Edit.SetFocus();

    end
  else//if Pokój_Rozmów__Na_Ekranie_CheckBox.Checked then
    begin

      // W zakładkach.

      Pokój_Rozmów_GroupBox.Tag := Pokój_Rozmów_GroupBox.Width;

      Pokój_Rozmów_GroupBox.Parent := Gra_ScrollBox;
      Pokój_Rozmów_GroupBox.Align := alBottom;
      Pokój_Rozmów_GroupBox.Align := alTop;

      Pokój_Rozmów__Ukryj_Button.Caption := 'e';
      Pokój_Rozmów__Ukryj_Button.Hint := 'Wyświetlaj pokój rozmów na ekranie gry.';

      //GLSceneViewer1.SetFocus();
      GLSceneViewer1MouseDown( Sender, System.UITypes.TMouseButton.mbLeft, [ System.Classes.ssHorizontal ], 0, 0 ); // Ze względu na GLSceneViewer1.Tag i ssHorizontal nie strzeli.

    end;
  //---//if Pokój_Rozmów__Na_Ekranie_CheckBox.Checked then

end;//---//Pokój_Rozmów__Na_Ekranie_CheckBoxClick().

//Pokój_Rozmów__Wyślij_Wiadomość_ButtonClick().
procedure TStatki_Form.Pokój_Rozmów__Wyślij_Wiadomość_ButtonClick( Sender: TObject );
var
  i : integer;
begin

  if Trim( Pokój_Rozmów_Wiadomość_Edit.Text ) <> '' then
    begin

      //if SecondsBetween( Now(), pokój_rozmów_ostatnia_wiadomość_wysłana_data_czas ) >= 1 then
      if MilliSecondsBetween( Now(), pokój_rozmów_ostatnia_wiadomość_wysłana_data_czas ) >= 500 then
        begin

          pokój_rozmów_ostatnia_wiadomość_wysłana_data_czas := Now();

          //Wieloosobowe__Tekst_Wyślij( Pokój_Rozmów_Wiadomość_Edit.Text );

          pokój_rozmów_r.id_nadawca := Gracz_Identyfikator();

          if pokój_rozmów_r.id_nadawca = -9999 then
            begin

              Application.MessageBox( 'Niepoprawny identyfikator nadawcy.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
              //Exit; //???

            end;
          //---//if pokój_rozmów_r.id_nadawca = -9999 then

          if   ( Pokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj_ComboBox.ItemIndex < 0 )
            or (  Pokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj_ComboBox.ItemIndex > Pokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj_ComboBox.Items.Count - 1 )
            or (  not Assigned( Pokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj_ComboBox.Items.Objects[ Pokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj_ComboBox.ItemIndex ] )  ) then
            begin

              Application.MessageBox( 'Należy wskazać adresata wiadomości.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
              Exit;

            end;
          //---//if   ( Pokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj_ComboBox.ItemIndex < 0 ) (...)


          pokój_rozmów_r.id_odbiorca := TPokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj(Pokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj_ComboBox.Items.Objects[ Pokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj_ComboBox.ItemIndex ]).id_odbiorca;
          pokój_rozmów_r.data_czas_wysłania := Now();
          pokój_rozmów_r.odbiorca_rodzaj := TPokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj(Pokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj_ComboBox.Items.Objects[ Pokój_Rozmów__Wyślij_Do__Odbiorca_Rodzaj_ComboBox.ItemIndex ]).odbiorca_rodzaj; //pror_Wszyscy
          pokój_rozmów_r.wiadomość := Pokój_Rozmów_Wiadomość_Edit.Text;


          if czy_serwer_g then
            begin

              if pokój_rozmów_r.odbiorca_rodzaj = pror_Wszyscy then
                Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c, -99, '' )
              else//if pokój_rozmów_r.odbiorca_rodzaj = pror_Wszyscy then
                begin

                  for i := 0 to tcp_klienci_lista_g.klienci_lista_list.Count - 1 do
                    if    ( pokój_rozmów_r.id_nadawca <> TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator ) // Nie wysyła wiadomości do siebie.
                      and (
                               (
                                     ( pokój_rozmów_r.odbiorca_rodzaj = pror_Gracz_Jeden )
                                 and ( pokój_rozmów_r.id_odbiorca = TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator )
                               )
                            or (
                                     ( pokój_rozmów_r.odbiorca_rodzaj = pror_Grupa_Jedna )
                                 and ( pokój_rozmów_r.id_odbiorca = TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).id_grupa )
                               )
                          ) then
                        begin

                          Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c, TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).peer_port_tcp, '' );

                          if pokój_rozmów_r.odbiorca_rodzaj = pror_Gracz_Jeden then
                            Break;

                        end;
                      //---//if    ( pokój_rozmów_r.id_nadawca <> TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator ) (...)

                end;
              //---//if pokój_rozmów_r.odbiorca_rodzaj = pror_Wszyscy then

              Pokój_Rozmów__Wyświetl_Wiadomość( pokój_rozmów_r );

            end
          else//if czy_serwer_g then
            if czy_klient_g then
              Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c, -99, '' );


          if   ( pokój_rozmów_ostatnia_wiadomości_wysłane_treść_string_list.Count <= 0 )
            or (
                     ( pokój_rozmów_ostatnia_wiadomości_wysłane_treść_string_list.Count > 0 )
                 and ( pokój_rozmów_ostatnia_wiadomości_wysłane_treść_string_list[ pokój_rozmów_ostatnia_wiadomości_wysłane_treść_string_list.Count - 1 ] <> Pokój_Rozmów_Wiadomość_Edit.Text )
               ) then
            pokój_rozmów_ostatnia_wiadomości_wysłane_treść_string_list.Add( Pokój_Rozmów_Wiadomość_Edit.Text );

          while pokój_rozmów_ostatnia_wiadomości_wysłane_treść_string_list.Count > 10 do
            pokój_rozmów_ostatnia_wiadomości_wysłane_treść_string_list.Delete( 0 );


          Pokój_Rozmów_Wiadomość_Edit.Text := '';
          Pokój_Rozmów_Wiadomość_Edit.Tag := pokój_rozmów_ostatnia_wiadomości_wysłane_treść_string_list.Count;


          pokój_rozmów_ostatnia_wiadomość_wysłana_data_czas := Now();

        end;
      //---//if MilliSecondsBetween( Now(), pokój_rozmów_ostatnia_wiadomość_wysłana_data_czas ) >= 500 then

    end
  else//if Trim( Pokój_Rozmów_Wiadomość_Edit.Text ) <> '' then
    if    ( Sender <> nil )
      and ( TComponent(Sender).Name = Pokój_Rozmów__Wyślij_Wiadomość_Button.Name ) then
    else//if    ( Sender <> nil ) (...)
      if Pokój_Rozmów__Na_Ekranie_CheckBox.Checked then
        Pokój_Rozmów__Na_Ekranie_CheckBox.Checked := false;

end;//---//Pokój_Rozmów__Wyślij_Wiadomość_ButtonClick().

//Pokój_Rozmów_Wiadomość_EditKeyDown().
procedure TStatki_Form.Pokój_Rozmów_Wiadomość_EditKeyDown( Sender: TObject; var Key: Word; Shift: TShiftState );
var
  zti : integer;
begin

  // Enter.
  if Key = 13 then
    begin

      Key := 0;
      Pokój_Rozmów__Wyślij_Wiadomość_ButtonClick( Sender );

    end;
  //---//if Key = 13 then

  // Kursor góra.
  if    ( Key = VK_UP ) // 38.
    and ( Sender <> nil )
    and ( TComponent(Sender).Name = Pokój_Rozmów_Wiadomość_Edit.Name ) then
    begin

      if Pokój_Rozmów_Wiadomość_Edit.Tag > 0 then
        Pokój_Rozmów_Wiadomość_Edit.Tag := Pokój_Rozmów_Wiadomość_Edit.Tag - 1;

      if    ( pokój_rozmów_ostatnia_wiadomości_wysłane_treść_string_list.Count > Pokój_Rozmów_Wiadomość_Edit.Tag )
        and (  Trim( pokój_rozmów_ostatnia_wiadomości_wysłane_treść_string_list[ Pokój_Rozmów_Wiadomość_Edit.Tag ] ) <> ''  ) then
        begin

          Key := 0;

          zti := Pokój_Rozmów_Wiadomość_Edit.SelStart;
          Pokój_Rozmów_Wiadomość_Edit.Text := pokój_rozmów_ostatnia_wiadomości_wysłane_treść_string_list[ Pokój_Rozmów_Wiadomość_Edit.Tag ];
          Pokój_Rozmów_Wiadomość_Edit.SelStart := zti;

        end;
      //---//if    ( pokój_rozmów_ostatnia_wiadomości_wysłane_treść_string_list.Count > Pokój_Rozmów_Wiadomość_Edit.Tag ) (...)

    end;
  //---//if    ( Key = VK_UP ) (...)

  // Kursor dół.
  if    ( Key = VK_DOWN ) // 40.
    and ( Sender <> nil )
    and ( TComponent(Sender).Name = Pokój_Rozmów_Wiadomość_Edit.Name ) then
    begin

      Key := 0;

      if Pokój_Rozmów_Wiadomość_Edit.Tag <= pokój_rozmów_ostatnia_wiadomości_wysłane_treść_string_list.Count - 1 then
        Pokój_Rozmów_Wiadomość_Edit.Tag := Pokój_Rozmów_Wiadomość_Edit.Tag + 1;

      if Pokój_Rozmów_Wiadomość_Edit.Tag = pokój_rozmów_ostatnia_wiadomości_wysłane_treść_string_list.Count then
        begin

          Pokój_Rozmów_Wiadomość_Edit.Text := '';

        end
      else//if Pokój_Rozmów_Wiadomość_Edit.Tag < pokój_rozmów_ostatnia_wiadomości_wysłane_treść_string_list.Count then
        if    ( pokój_rozmów_ostatnia_wiadomości_wysłane_treść_string_list.Count > Pokój_Rozmów_Wiadomość_Edit.Tag )
          and (  Trim( pokój_rozmów_ostatnia_wiadomości_wysłane_treść_string_list[ Pokój_Rozmów_Wiadomość_Edit.Tag ] ) <> ''  ) then
          begin

            zti := Pokój_Rozmów_Wiadomość_Edit.SelStart;
            Pokój_Rozmów_Wiadomość_Edit.Text := pokój_rozmów_ostatnia_wiadomości_wysłane_treść_string_list[ Pokój_Rozmów_Wiadomość_Edit.Tag ];
            Pokój_Rozmów_Wiadomość_Edit.SelStart := zti;

          end;
        //---//if    ( pokój_rozmów_ostatnia_wiadomości_wysłane_treść_string_list.Count > Pokój_Rozmów_Wiadomość_Edit.Tag ) (...)

    end;
  //---//if    ( Key = VK_DOWN ) (...)

end;//---//Pokój_Rozmów_Wiadomość_EditKeyDown().

//Pokój_Rozmów__Ukryj_ButtonClick().
procedure TStatki_Form.Pokój_Rozmów__Ukryj_ButtonClick( Sender: TObject );
begin

  Pokój_Rozmów__Na_Ekranie_CheckBox.Checked := not Pokój_Rozmów__Na_Ekranie_CheckBox.Checked;

end;//---//Pokój_Rozmów__Ukryj_ButtonClick().

//Pokój_Rozmów_Przyciski_PanelMouseDown().
procedure TStatki_Form.Pokój_Rozmów_Przyciski_PanelMouseDown( Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer );
begin

  pokój_rozmów__zmiana_szerokości__szerokość_początkowa_g := Pokój_Rozmów_GroupBox.Width;
  pokój_rozmów__zmiana_szerokości__wysokość_początkowa_g := Pokój_Rozmów_GroupBox.Height;
  pokój_rozmów__zmiana_szerokości__x_początkowy_g := X;
  pokój_rozmów__zmiana_szerokości__y_początkowy_g := Y;

  pokój_rozmów__zmiana_szerokości__aktywność_g := true;

end;//---//Pokój_Rozmów_Przyciski_PanelMouseDown().

//Pokój_Rozmów_Przyciski_PanelMouseMove().
procedure TStatki_Form.Pokój_Rozmów_Przyciski_PanelMouseMove( Sender: TObject; Shift: TShiftState; X, Y: Integer );
var
  zti : integer;
begin

  if pokój_rozmów__zmiana_szerokości__aktywność_g then
    begin

      if Pokój_Rozmów__Na_Ekranie_CheckBox.Checked then
        begin

          zti := pokój_rozmów__zmiana_szerokości__szerokość_początkowa_g + X - pokój_rozmów__zmiana_szerokości__x_początkowy_g;

          if zti >= 25 then
            Pokój_Rozmów_GroupBox.Width := zti;

        end;
      //---//if Pokój_Rozmów__Na_Ekranie_CheckBox.Checked then


      zti := pokój_rozmów__zmiana_szerokości__wysokość_początkowa_g + Y - pokój_rozmów__zmiana_szerokości__y_początkowy_g;

      if zti >= 50 then
        Pokój_Rozmów_GroupBox.Height := zti;

    end;
  //---//if pokój_rozmów__zmiana_szerokości__aktywność_g then

end;//---//Pokój_Rozmów_Przyciski_PanelMouseMove().

//Pokój_Rozmów_Przyciski_PanelMouseUp().
procedure TStatki_Form.Pokój_Rozmów_Przyciski_PanelMouseUp( Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer );
begin

  pokój_rozmów__zmiana_szerokości__aktywność_g := false;

  FormResize( Sender );

end;//---//Pokój_Rozmów_Przyciski_PanelMouseUp().

//Gracz_Gotowość_BitBtnClick().
procedure TStatki_Form.Gracz_Gotowość_BitBtnClick( Sender: TObject );
var
  zt_tcp_klient_dane : TTCP_Klient_Dane;
begin

  if    ( Sender <> nil )
    and ( TComponent(Sender).Name = Gracz_Gotowość_Nie_BitBtn.Name ) then
    begin

      Gracz_Gotowość_Nie_BitBtn.Enabled := false;
      Gracz_Gotowość_Tak_BitBtn.Enabled := true;

      Gracz_Grupa_SpinEdit.Enabled := true;
      Gracz_Nazwa_Edit.Enabled := true;
      Statek_GroupBox.Enabled := true;


      if czy_klient_g then
        Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__gracz_gotowość_c, -99, 'Nie' )
      else//if czy_klient_g then
        begin

          // Serwer.

          Ląd_GroupBox.Enabled := true;
          SI__Dodaj_BitBtn.Enabled := true;
          Statki_Pozycje_Początkowe_GroupBox.Enabled := true;


          zt_tcp_klient_dane := tcp_klienci_lista_g.Znajdź_Peer_Port( serwer_peer_port_c );

          if zt_tcp_klient_dane <> nil then
            zt_tcp_klient_dane.gotowy := false;

          Gracze_Lista_Odśwież();

          Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__gracz_lista_odśwież_c, -99, '' );

        end;
      //---//if czy_klient_g then

    end
  else//if    ( Sender <> nil ) (...)
    begin

      if Trim( Gracz_Nazwa_Edit.Text ) = '' then
        begin

          Application.MessageBox( 'Nazwa gracza nie może być pusta.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
          Exit;

        end;
      //---//if Trim( Gracz_Nazwa_Edit.Text ) = '' then

      if   ( Statek_ComboBox.ItemIndex < 0 )
        or (  Trim( Statek_ComboBox.Text ) = ''  ) then
        begin

          Application.MessageBox( 'Należy wybrać statek.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
          Exit;

        end;
      //---//if   ( Statek_ComboBox.ItemIndex < 0 ) (...)


      if czy_klient_g then
        Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__gracz_gotowość_c, -99, 'Tak' )
      else//if czy_klient_g then
        begin

          // Serwer.

          if not tcp_klienci_lista_g.Nazwa_Niepowtarzalna( serwer_peer_port_c, Gracz_Nazwa_Edit.Text ) then
            begin

              Application.MessageBox( 'Nazwa gracza powinna być niepowtarzalna.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
              Exit;

            end;
          //---//if not tcp_klienci_lista_g.Nazwa_Niepowtarzalna( serwer_peer_port_c, Gracz_Nazwa_Edit.Text ) then


          Gracz_Gotowość_Nie_BitBtn.Enabled := true;
          Gracz_Gotowość_Tak_BitBtn.Enabled := false;

          Gracz_Grupa_SpinEdit.Enabled := false;
          Gracz_Nazwa_Edit.Enabled := false;
          Ląd_GroupBox.Enabled := false;
          SI__Dodaj_BitBtn.Enabled := false;
          Statek_GroupBox.Enabled := false;
          Statki_Pozycje_Początkowe_GroupBox.Enabled := false;


          zt_tcp_klient_dane := tcp_klienci_lista_g.Znajdź_Peer_Port( serwer_peer_port_c );

          if zt_tcp_klient_dane <> nil then
            begin

              zt_tcp_klient_dane.id_grupa := Gracz_Grupa_SpinEdit.Value;
              zt_tcp_klient_dane.id_statek_schemat := Statek_ComboBox.ItemIndex;
              zt_tcp_klient_dane.gotowy := true;
              zt_tcp_klient_dane.nazwa := Gracz_Nazwa_Edit.Text;

            end;
          //---//if zt_tcp_klient_dane <> nil then


          Gracze_Lista_Odśwież();

          Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__gracz_lista_odśwież_c, -99, '' );

        end;
      //---//if czy_klient_g then

    end;
  //---//if    ( Sender <> nil ) (...)

end;//---//Gracz_Gotowość_BitBtnClick().

//Gracze_Lista_Odśwież_BitBtnClick().
procedure TStatki_Form.Gracze_Lista_Odśwież_BitBtnClick( Sender: TObject );
begin

  if   ( czy_serwer_g )
    or ( czy_gra_lokalna_g ) then
    Gracze_Lista_Odśwież()
  else//if   ( czy_serwer_g ) (...)
  if czy_klient_g then
    Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__gracz_lista_odśwież_c, -99, '' );

end;//---//Gracze_Lista_Odśwież_BitBtnClick().

//Gracze_Lista_Rozłącz_Gracza_BitBtnClick().
procedure TStatki_Form.Gracze_Lista_Rozłącz_Gracza_BitBtnClick( Sender: TObject );
var
  zti : integer;
  zt_tcp_klient_dane : TTCP_Klient_Dane;
begin

  if    ( not czy_gra_lokalna_g )
    and ( not czy_serwer_g ) then
    Exit;


  if Gracze_Lista_StringGrid.RowCount <= 1 then
    begin

      Application.MessageBox( 'Należy wskazać gracza.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
      Exit;

    end;
  //---//if Gracze_Lista_StringGrid.RowCount <= 1 then

  if Gracze_Lista_StringGrid.ColCount <= 3 then
    begin

      Application.MessageBox( 'Nieprawidłowa lista graczy.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
      Exit;

    end;
  //---//if Gracze_Lista_StringGrid.ColCount <= 3 then


  try
    zti := StrToInt( Gracze_Lista_StringGrid.Cells[ 1, Gracze_Lista_StringGrid.Row ] );
  except
    Application.MessageBox( 'Nie udało się odczytać identyfikatora gracza.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
    Exit;
  end;
  //---//try

  if zti = Gracz_Identyfikator() then
    begin

      Application.MessageBox( 'Nie można rozłączyć samego siebie.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
      Exit;

    end;
  //---//if zti = Gracz_Identyfikator() then


  zt_tcp_klient_dane := tcp_klienci_lista_g.Znajdź_Identyfikator( zti );

  if zt_tcp_klient_dane = nil then
    Application.MessageBox( 'Nie udało się odnaleźć gracza o zadanym identyfikatorze.', 'Informacja', MB_OK + MB_ICONEXCLAMATION )
  else//if zt_tcp_klient_dane = nil then
    begin

      if zt_tcp_klient_dane.peer_port_tcp = serwer_peer_port_c then
        begin

          Application.MessageBox( 'Nie można rozłączyć serwera.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
          Exit;

        end;
      //---//if zt_tcp_klient_dane.peer_port_tcp = serwer_peer_port_c then


      if zt_tcp_klient_dane.peer_port_tcp = si_peer_port_c then
        begin

          // Usuwa SI z listy.

          tcp_klienci_lista_g.Usuń_Identyfikator( zt_tcp_klient_dane.identyfikator );

          Gracze_Lista_Odśwież();

          Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__gracz_lista_odśwież_c, -99, '' );

        end
      else//if zt_tcp_klient_dane.peer_port_tcp = si_peer_port_c then
        Gracze_Lista_Rozłącz( zt_tcp_klient_dane.peer_port_tcp );

    end;
  //---//if zt_tcp_klient_dane = nil then

end;//---//Gracze_Lista_Rozłącz_Gracza_BitBtnClick().

//SI__Dodaj_BitBtnClick().
procedure TStatki_Form.SI__Dodaj_BitBtnClick( Sender: TObject );
var
  zt_tcp_klient_dane : TTCP_Klient_Dane;
begin

  if    ( not czy_gra_lokalna_g )
    and ( not czy_serwer_g ) then
    Exit;


  if Trim( SI__Nazwa_Edit.Text ) = '' then
    begin

      Application.MessageBox( 'Nazwa gracza nie może być pusta.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
      Exit;

    end;
  //---//if Trim( SI__Nazwa_Edit.Text ) = '' then

  if   ( SI__Statek_ComboBox.ItemIndex < 0 )
    or (  Trim( SI__Statek_ComboBox.Text ) = ''  ) then
    begin

      Application.MessageBox( 'Należy wybrać statek.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
      Exit;

    end;
  //---//if   ( SI__Statek_ComboBox.ItemIndex < 0 ) (...)

  if not tcp_klienci_lista_g.Nazwa_Niepowtarzalna( SI__Nazwa_Edit.Text ) then
    begin

      Application.MessageBox( 'Nazwa gracza powinna być niepowtarzalna.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
      Exit;

    end;
  //---//if not tcp_klienci_lista_g.Nazwa_Niepowtarzalna( si_peer_port_c, SI__Nazwa_Edit.Text ) then



  zt_tcp_klient_dane := tcp_klienci_lista_g.Dodaj_Aktualizuj( si_peer_port_c, -99 ); // Serwer ma peer_port_f i identyfikator_f = -1.

  if zt_tcp_klient_dane <> nil then
    begin

      zt_tcp_klient_dane.id_grupa := SI__Grupa_SpinEdit.Value;
      zt_tcp_klient_dane.id_statek_schemat := SI__Statek_ComboBox.ItemIndex;
      zt_tcp_klient_dane.gotowy := true;
      zt_tcp_klient_dane.nazwa := SI__Nazwa_Edit.Text;

    end;
  //---//if zt_tcp_klient_dane <> nil then


  Gracze_Lista_Odśwież();

  Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__gracz_lista_odśwież_c, -99, '' );

end;//---//SI__Dodaj_BitBtnClick().

//Edit_Jako_Spin_KeyDown().
procedure TStatki_Form.Edit_Jako_Spin_KeyDown( Sender: TObject; var Key: Word; Shift: TShiftState );
var
  kursor_pozycja : integer;
  ztr,
  pole_wartość
    : real;
  zts : string;
begin

  // Zwiększa lub zmniejsza wartość liczbową w polu tekstowym.
  //
  // Podstawowy SpinEdit pozwala tylko na liczby całkowite a nie chcę dodawać komponentów, których może nie być w podstawowych wersjach IDE.

  if   ( Sender = nil )
    or (
             ( Sender <> nil )
         and (  not ( Sender is TEdit )  )
       )
    or (
             ( Key <> VK_UP ) // Strzałka w górę.
         and ( Key <> VK_DOWN ) // Strzałka w dół.
       ) then
    Exit;


  zts := TEdit(Sender).Text;
  zts := StringReplace( zts, ' ', '', [ rfReplaceAll ] );
  zts := StringReplace( zts, '.', ',', [ rfReplaceAll ] );

  try
    pole_wartość := StrToFloat( zts );
  except
    Exit;
  end;
  //---//try


  kursor_pozycja := TEdit(Sender).SelStart; // Indeksowane od 0, zts od 1.


  if Pos( ',', zts ) < kursor_pozycja + 1 then
    ztr := 0.1
  else//if Pos( ',', zts ) < TEdit(Sender).SelStart then
    ztr := 1;


  if    ( Sender <> nil )
    and ( TComponent(Sender).Name = Amunicja__Zanurzenie_Głębokość_Zadana_Edit.Name ) then
    begin

      zts := Amunicja__Zanurzenie_Głębokość_Zadana__Skok_O_Edit.Text;
      zts := StringReplace( zts, ' ', '', [ rfReplaceAll ] );
      zts := StringReplace( zts, '.', ',', [ rfReplaceAll ] );

      try
        if StrToFloat( zts ) > 0 then
          ztr := StrToFloat( zts );
      except
      end;
      //---//try

    end;
  //---//if    ( Sender <> nil ) (...)


  // Strzałka w dół.
  if Key = VK_DOWN then
    ztr := -ztr;

  Key := 0;

  pole_wartość := pole_wartość + ztr;


  zts := FloatToStr( pole_wartość );
  zts := StringReplace( zts, ',', '.', [ rfReplaceAll ] );
  TEdit(Sender).Text := zts;


  TEdit(Sender).SelStart := kursor_pozycja;

end;//---//Edit_Jako_Spin_KeyDown().

//ScrollBoxMouseWheel().
procedure TStatki_Form.ScrollBoxMouseWheel( Sender: TObject; Shift: TShiftState; WheelDelta: Integer; MousePos: TPoint; var Handled: Boolean );
begin

  if   ( Sender = nil )
    or (
             ( Sender <> nil )
         and (  not ( Sender is TScrollBox )  )
       ) then
    Exit;


  if WheelDelta < 0 then
    TScrollBox(Sender).VertScrollBar.Position := TScrollBox(Sender).VertScrollBar.Position + TScrollBox(Sender).VertScrollBar.Increment
  else//if WheelDelta < 0 then
    TScrollBox(Sender).VertScrollBar.Position := TScrollBox(Sender).VertScrollBar.Position - TScrollBox(Sender).VertScrollBar.Increment;

end;//---//ScrollBoxMouseWheel().

//Ustawienia_Zapisz_ButtonClick().
procedure TStatki_Form.Ustawienia_Zapisz_ButtonClick( Sender: TObject );
begin

  if Application.MessageBox( 'Czy zapisać ustawienia?', 'Potwierdzenie', MB_YESNO + MB_DEFBUTTON2 + MB_ICONQUESTION ) <> IDYES then
    Exit;

  Ustawienia_Plik( true );

end;//---//Ustawienia_Zapisz_ButtonClick().

//Ustawienia_Wczytaj_ButtonClick().
procedure TStatki_Form.Ustawienia_Wczytaj_ButtonClick( Sender: TObject );
begin

  Ustawienia_Plik();

end;//---//Ustawienia_Wczytaj_ButtonClick().

//Amunicja__Zanurzenie_Głębokość_Zadana_EditChange().
procedure TStatki_Form.Amunicja__Zanurzenie_Głębokość_Zadana_EditChange( Sender: TObject );
var
  zts : string;
begin

  // Podstawowy SpinEdit pozwala tylko na liczby całkowite a nie chcę dodawać komponentów, których może nie być w podstawowych wersjach IDE.

  if    ( Sender <> nil )
    and ( TComponent(Sender).Name = Amunicja__Zanurzenie_Głębokość_Zadana__Skok_O_Edit.Name ) then
    begin

      zts := Amunicja__Zanurzenie_Głębokość_Zadana__Skok_O_Edit.Text;
      zts := StringReplace( zts, ' ', '', [ rfReplaceAll ] );
      zts := StringReplace( zts, '.', ',', [ rfReplaceAll ] );

      try
        Amunicja__Zanurzenie_Głębokość_Zadana__Skok_O_Label.Caption := Trim(   FormatFloat(  '### ### ##0.000000', StrToFloat( zts )  )   );
      except
      end;
      //---//try


    end
  else//if    ( Sender <> nil ) (...)
    begin

      zts := Amunicja__Zanurzenie_Głębokość_Zadana_Edit.Text;
      zts := StringReplace( zts, ' ', '', [ rfReplaceAll ] );
      zts := StringReplace( zts, '.', ',', [ rfReplaceAll ] );

      try
        Amunicja__Zanurzenie_Głębokość_Zadana_Label.Caption := Trim(   FormatFloat(  '### ### ##0.000000', StrToFloat( zts )  )   );
      except
      end;
      //---//try

    end;
  //---//if    ( Sender <> nil ) (...)


  Informacja_Dodatkowa_Dodaj( 'Torpeda głębokość zadana: ' + Amunicja__Zanurzenie_Głębokość_Zadana_Label.Caption + '.', informacja_dodatkowa__wyświetlanie_czas_sekund__krótki_c );

end;//---//Amunicja__Zanurzenie_Głębokość_Zadana_EditChange().

//Celowanie_Tryb_RadioGroupClick().
procedure TStatki_Form.Celowanie_Tryb_RadioGroupClick( Sender: TObject );
begin

  if Celowanie_Tryb_RadioGroup.ItemIndex = 0 then // równoległy.
    celowanie_tryb_g := ct_Linia // Namierzanie równoległe do linii celowania.
  else//if Celowanie_Tryb_RadioGroup.ItemIndex = 0 then
    celowanie_tryb_g := ct_Punkt; // Namierzanie zbieżne do punktu celowania.

end;//---//Celowanie_Tryb_RadioGroupClick().

//Celownik_Widoczność_CheckBoxClick().
procedure TStatki_Form.Celownik_Widoczność_CheckBoxClick( Sender: TObject );
begin

  Celowniczy_GLDummyCube.Visible := Celownik_Widoczność_CheckBox.Checked;

end;//---//Celownik_Widoczność_CheckBoxClick().

//Celownik_Wielkość_EditChange().
procedure TStatki_Form.Celownik_Wielkość_EditChange( Sender: TObject );
var
  zts : string;
begin

  // Podstawowy SpinEdit pozwala tylko na liczby całkowite a nie chcę dodawać komponentów, których może nie być w podstawowych wersjach IDE.

  zts := Celownik_Wielkość_Edit.Text;
  zts := StringReplace( zts, ' ', '', [ rfReplaceAll ] );
  zts := StringReplace( zts, '.', ',', [ rfReplaceAll ] );

  try
    Celowniczy_GLDummyCube.CubeSize := Abs(  StrToFloat( zts )  );
  except
  end;
  //---//try

  Celownik_Wielkość_Label.Caption := Trim(  FormatFloat( '### ### ##0.000000', Celowniczy_GLDummyCube.CubeSize )  );

end;//---//Celownik_Wielkość_EditChange().

//Kamera_Szybkość_Ruchu_EditChange().
procedure TStatki_Form.Kamera_Szybkość_Ruchu_EditChange( Sender: TObject );
var
  zts : string;
begin

  // Podstawowy SpinEdit pozwala tylko na liczby całkowite a nie chcę dodawać komponentów, których może nie być w podstawowych wersjach IDE.

  zts := Kamera_Szybkość_Ruchu_Edit.Text;
  zts := StringReplace( zts, ' ', '', [ rfReplaceAll ] );
  zts := StringReplace( zts, '.', ',', [ rfReplaceAll ] );

  try
    kamera_szybkość_ruchu_g := StrToFloat( zts );
  except
  end;
  //---//try

  Kamera_Szybkość_Ruchu_Label.Caption := Trim(  FormatFloat( '### ### ##0.000000', kamera_szybkość_ruchu_g )  );

end;//---//Kamera_Szybkość_Ruchu_EditChange().

//Mysz_Czułość_EditChange().
procedure TStatki_Form.Mysz_Czułość_EditChange( Sender: TObject );
var
  zts : string;
begin

  // Podstawowy SpinEdit pozwala tylko na liczby całkowite a nie chcę dodawać komponentów, których może nie być w podstawowych wersjach IDE.

  zts := Mysz_Czułość_Edit.Text;
  zts := StringReplace( zts, ' ', '', [ rfReplaceAll ] );
  zts := StringReplace( zts, '.', ',', [ rfReplaceAll ] );

  try
    GLUserInterface1.MouseSpeed := StrToFloat( zts );
  except
  end;
  //---//try

  mysz_czułość_g := GLUserInterface1.MouseSpeed;


  zts := Mysz_Czułość_Luneta_Edit.Text;
  zts := StringReplace( zts, ' ', '', [ rfReplaceAll ] );
  zts := StringReplace( zts, '.', ',', [ rfReplaceAll ] );

  try
    mysz_czułość_luneta_g := StrToFloat( zts );
  except
  end;
  //---//try

  Mysz_Czułość_Label.Caption := Trim(  FormatFloat( '### ### ##0.000000', GLUserInterface1.MouseSpeed )  );
  Mysz_Czułość_Luneta_Label.Caption := Trim(  FormatFloat( '### ### ##0.000000', mysz_czułość_luneta_g )  );

end;//---//Mysz_Czułość_EditChange().

//Elementy_Gracza_Dostosuj_CheckBoxClick().
procedure TStatki_Form.Elementy_Gracza_Dostosuj_CheckBoxClick( Sender: TObject );
var
  i : integer;
begin

  if statek_gracza <> nil then
    statek_gracza.Elementy_Gracza_Dostosuj( -99, Punkty_Życia_Wskaźnik__Gracz_CheckBox.Checked, false, false, Obrót_Kąt_Zablokowany_Wskaźnik_CheckBox.Checked, Obrót_Kąt_Zablokowany_Strzał_Wskaźnik_CheckBox.Checked );


  for i := 0 to Length( statki_t ) - 1 do
    if    ( statki_t[ i ] <> statek_gracza )
      and ( statki_t[ i ] <> nil ) then
      statki_t[ i ].Elementy_Gracza_Dostosuj( Gracz_Grupa_SpinEdit.Value, false, Punkty_Życia_Wskaźnik__Przeciwnik_CheckBox.Checked, Punkty_Życia_Wskaźnik__Sojusznik_CheckBox.Checked, false, false );

end;//---//Elementy_Gracza_Dostosuj_CheckBoxClick().

//Radar_Widoczność_CheckBoxClick().
procedure TStatki_Form.Radar_Widoczność_CheckBoxClick( Sender: TObject );
begin

  Radar_Panel.Visible := Radar_Widoczność_CheckBox.Checked;

  FormResize( Sender );

end;//---//Radar_Widoczność_CheckBoxClick().

//Projektowy_Tryb_CheckBoxClick().
procedure TStatki_Form.Projektowy_Tryb_CheckBoxClick( Sender: TObject );
begin

  Gra_Obiekty_GLDummyCube.Pickable := Projektowy_Tryb_CheckBox.Checked;


  if Projektowy_Tryb_CheckBox.Checked then
    projektowy_tryb__statek := statek_gracza;

end;//---//Projektowy_Tryb_CheckBoxClick().

//Informacje_Dodatkowe_TimerTimer().
procedure TStatki_Form.Informacje_Dodatkowe_TimerTimer( Sender: TObject );
var
  i : integer;
begin

  for i := informacje_dodatkowe_list.Count - 1 downto 0 do
    begin

      if SecondsBetween( Now(), TInformacje_Dodatkowe(informacje_dodatkowe_list[ i ]).utworzenie_data_czas ) > TInformacje_Dodatkowe(informacje_dodatkowe_list[ i ]).wyświetlanie_czas_sekund then
        begin

          TInformacje_Dodatkowe(informacje_dodatkowe_list[ i ]).Free();
          informacje_dodatkowe_list.Delete( i );

        end;
      //---//if SecondsBetween( Now(), TInformacje_Dodatkowe(informacje_dodatkowe_list[ i ]).utworzenie_data_czas ) > TInformacje_Dodatkowe(informacje_dodatkowe_list[ i ]).wyświetlanie_czas_sekund then

    end;
  //---//for i := informacje_dodatkowe_list.Count - 1 downto 0 do


  Informacje_Dodatkowe_GLHUDText.Text := '';


  for i := 0 to informacje_dodatkowe_list.Count - 1 do
    begin

      Informacje_Dodatkowe_GLHUDText.Text := Informacje_Dodatkowe_GLHUDText.Text + #13 + #10
        + TInformacje_Dodatkowe(informacje_dodatkowe_list[ i ]).napis;

    end;
  //---//for i := 0 to informacje_dodatkowe_list.Count - 1 do

end;//---//Informacje_Dodatkowe_TimerTimer().

//Radar_Wielkość_ButtonClick().
procedure TStatki_Form.Radar_Wielkość_ButtonClick( Sender: TObject );
begin

  if    ( Sender <> nil )
    and ( TComponent(Sender).Name = Radar_Pomniejsz_Button.Name ) then
    Radar_Panel.Tag := Radar_Panel.Tag - 10
  else//if    ( Sender <> nil ) (...)
    Radar_Panel.Tag := Radar_Panel.Tag + 10;


  if Radar_Panel.Tag < 5 then
    Radar_Panel.Tag := 5
  else//if Radar_Panel.Tag < 5 then
    if Radar_Panel.Tag > 95 then
      Radar_Panel.Tag := 95;


  FormResize( Sender );

end;//---//Radar_Wielkość_ButtonClick().

//Radar_Odwróć_CheckBoxClick().
procedure TStatki_Form.Radar_Odwróć_CheckBoxClick( Sender: TObject );
begin

  Radar_Chart.Axes.Left.Inverted := Radar_Odwróć_CheckBox.Checked;
  Radar_Chart.Axes.Bottom.Inverted := Radar_Odwróć_CheckBox.Checked;

end;//---//Radar_Odwróć_CheckBoxClick().

//Radar_TimerTimer().
procedure TStatki_Form.Radar_TimerTimer( Sender: TObject );
begin

  // Komponent dokładnie nie pilnuje zakresów.
  if Radar_Zasięg_SpinEdit.Value > Radar_Zasięg_SpinEdit.MaxValue then
    Radar_Zasięg_SpinEdit.Value := Radar_Zasięg_SpinEdit.MaxValue;


  Radio_Statki_W_Zasięgu();


  Radar_Wyczyść();

  Radar_Ląd_Rysuj();
  Radar_Statki_Rysuj();

end;//---//Radar_TimerTimer().

//Statki_Zaprezentuj_ButtonClick().
procedure TStatki_Form.Statki_Zaprezentuj_ButtonClick( Sender: TObject );
var
  i,
  zti
    : integer;
begin

  //Statki_Zwolnij(  false, Length( statki_t ) > 0  );
  Statki_Zwolnij( false, true );


  for i := 0 to Statek_ComboBox.Items.Count - 1 do
    begin

      zti := Length( statki_t );
      SetLength( statki_t, zti + 1 );
      statki_t[ zti ] := TStatek.Create(  Gra_Obiekty_GLDummyCube, Statki_Form.GLCollisionManager1, zti, Statek_Odczytaj_Schemat( i ), prymitywy_lista_t  );
      statki_t[ zti ].id_grupa := 1; // Aby po odnowieniu statku (jeżeli nie trwa gra) poprawnie wczytało i ustawiło statek.
      statki_t[ zti ].id_statek_schemat := i;
      statki_t[ zti ].obracaj_działa := false;
      statki_t[ zti ].podnoś_lufy := false;
      statki_t[ zti ].gracz__nazwa.Text := Statek_ComboBox.Items[ i ];
      statki_t[ zti ].Elementy_Gracza_Widoczność( statki_t[ zti ].id_grupa, false );

      if i = 0 then
        statki_t[ zti ].Position.SetPoint( Statki_Zaprezentuj__Pozycja_Początkowa__X_SpinEdit.Value, Statki_Zaprezentuj__Pozycja_Początkowa__Y_SpinEdit.Value, Statki_Zaprezentuj__Pozycja_Początkowa__Z_SpinEdit.Value )
      else//if i = 0 then
        if not Statki_Zaprezentuj__Kolumna_CheckBox.Checked then
          statki_t[ zti ].Position.SetPoint( statki_t[ zti - 1 ].Position.X + Statki_Zaprezentuj__Odstępy_Między_Statkami_SpinEdit.Value, statki_t[ zti - 1 ].Position.Y, statki_t[ zti - 1 ].Position.Z )
        else//if not Statki_Zaprezentuj__Kolumna_CheckBox.Checked then
          statki_t[ zti ].Position.SetPoint( statki_t[ zti - 1 ].Position.X, statki_t[ zti - 1 ].Position.Y, statki_t[ zti - 1 ].Position.Z + Statki_Zaprezentuj__Odstępy_Między_Statkami_SpinEdit.Value );

    end;
  //---//for i := 0 to Statek_ComboBox.Items.Count - 1 do

end;//---//Statki_Zaprezentuj_ButtonClick().

//Statki_Zaprezentuj__Zwolnij_BitBtnClick().
procedure TStatki_Form.Statki_Zaprezentuj__Zwolnij_BitBtnClick( Sender: TObject );
begin

  Statki_Zwolnij( false, true );

end;//---//Statki_Zaprezentuj__Zwolnij_BitBtnClick().

//Statki_ZaprezentujKeyDown().
procedure TStatki_Form.Statki_ZaprezentujKeyDown( Sender: TObject; var Key: Word; Shift: TShiftState );
begin

  // Enter.
  if Key = 13 then
    begin

      Key := 0;
      Statki_Zaprezentuj_ButtonClick( Sender );

    end;
  //---//if Key = 13 then

end;//---//Statki_ZaprezentujKeyDown().

//Klawiatura_Konfiguracja_Domyślna_ButtonClick().
procedure TStatki_Form.Klawiatura_Konfiguracja__Domyślna_ButtonClick( Sender: TObject );

  //Funkcja Klawisz_Plus_Alt_Ctrl_Shift_Zeruj_1() w Klawiatura_Konfiguracja_Domyślna_ButtonClick().
  procedure Klawisz_Plus_Alt_Ctrl_Shift_Zeruj_1( pointer_f : Pointer );
  var
    klawiatura_konfiguracja_r_w : ^TKlawiatura_Konfiguracja_r;
  begin

    Exit;

    klawiatura_konfiguracja_r_w := pointer_f;

    klawiatura_konfiguracja_r_w.plus_alt := false;
    klawiatura_konfiguracja_r_w.plus_ctrl := false;
    klawiatura_konfiguracja_r_w.plus_shift := false;

  end;//---Funkcja Klawisz_Plus_Alt_Ctrl_Shift_Zeruj_1() w Klawiatura_Konfiguracja_Domyślna_ButtonClick().

  //Funkcja Klawisz_Plus_Alt_Ctrl_Shift_Zeruj() w Klawiatura_Konfiguracja_Domyślna_ButtonClick().
  procedure Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( out klawiatura_konfiguracja_r_f : TKlawiatura_Konfiguracja_r; const klawisz_f : Word; const polecenie_nazwa_f : string; out indeks_f : integer; const czy_mysz_f : boolean = false );
  var
    klawiatura_konfiguracja_r_w : ^TKlawiatura_Konfiguracja_r;
  begin

    inc( indeks_f );
    SetLength( klawiatura_konfiguracja_r_t, indeks_f + 1 );
    klawiatura_konfiguracja_r_f.klawisz := klawisz_f;
    klawiatura_konfiguracja_r_t[ indeks_f ] := @klawiatura_konfiguracja_r_f;
    klawiatura_konfiguracja_r_t[ indeks_f ].czy_mysz := czy_mysz_f;
    klawiatura_konfiguracja_r_t[ indeks_f ].polecenie_nazwa := polecenie_nazwa_f;
    klawiatura_konfiguracja_r_t[ indeks_f ].plus_alt := false;
    klawiatura_konfiguracja_r_t[ indeks_f ].plus_ctrl := false;
    klawiatura_konfiguracja_r_t[ indeks_f ].plus_shift := false;
    TKlawisz_Konfiguracja.Create( Klawiatura_Konfiguracja_ScrollBox, klawiatura_konfiguracja_r_t[ indeks_f ] );

  end;//---Funkcja Klawisz_Plus_Alt_Ctrl_Shift_Zeruj() w Klawiatura_Konfiguracja_Domyślna_ButtonClick().

var
  zti,
  przesunięcie_w_pionie_kopia
    : integer;
begin//Klawiatura_Konfiguracja_Domyślna_ButtonClick().

  przesunięcie_w_pionie_kopia := Klawiatura_Konfiguracja_ScrollBox.VertScrollBar.Position;


  Klawisz_Konfiguracja_Zwolnij();

  SetLength( klawiatura_konfiguracja_r_t, 0 );
  zti := -1;

  //Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__, 0, '', zti ); // .

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__amunicja__zanurzenie_głębokość_zadana__minus, 0, 'Amunicja zanurzenie głębokość zadana minus', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__amunicja__zanurzenie_głębokość_zadana__plus, 0, 'Amunicja zanurzenie głębokość zadana plus', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__celowanie_tryb, 0, 'Celowanie tryb', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__celownik_widoczność, 0, 'Celownik widoczność', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__celownik_widoczność_mouse_look_active, 0, 'Celownik widoczność obracanie myszą', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__dalmierz, 0, 'Dalmierz', zti ); // .

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__obracaj_działa, 79, 'Broń obracaj', zti ); // O.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__obrót_kąt_zablokowany_wskaźnik, 0, 'Broń  obrót kąt zablokowany wskaźnik', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__obrót_kąt_zablokowany_strzał_wskaźnik, 0, 'Broń  obrót kąt zablokowany strzał wskaźnik', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__podnoś_lufy, 76, 'Broń podnoś lufy', zti ); // L.

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__gra_współczynnik_prędkości__minus, 0, 'Gra prędkości minus', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__gra_współczynnik_prędkości__normalna, 0, 'Gra prędkości normalna', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__gra_współczynnik_prędkości__plus, 0, 'Gra prędkości plus', zti ); // .

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__mouse_look_active, 32, 'Kamera obracanie myszą przełącz', zti ); // Space.

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__w_dół_obrót, 90, 'Kamera obrót w dół', zti ); // Z.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__w_górę_obrót, 67, 'Kamera obrót w górę', zti ); // C.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__w_lewo_obrót, 81, 'Kamera obrót w lewo', zti ); // Q.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__w_przawo_obrót, 69, 'Kamera obrót w prawo', zti ); // E.

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__w_dół, 70, 'Kamera ruch w dół', zti ); // F.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__w_górę, 82, 'Kamera ruch w górę', zti ); // R.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__w_lewo, 65, 'Kamera ruch w lewo', zti ); // A.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__w_przawo, 68, 'Kamera ruch w prawo', zti ); // D.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__do_przodu, 87, 'Kamera ruch w przód', zti ); // W.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__do_tyłu, 83, 'Kamera ruch w tył', zti ); // S.

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__Artyleria, 0, 'Kamera ustaw artyleryjska (jeżeli artyleria jest dostępna na statku)', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__Amunicja, 0, 'Kamera ustaw na amunicję', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__Statek, 0, 'Kamera ustaw na statek', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__Swobodna, 0, 'Kamera ustaw swobodna', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__Za_Statkiem, 0, 'Kamera ustaw za statkiem', zti ); // .

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__ląd_odśwież_wskazany, 0, 'Ląd odśwież wskazaną mapę', zti ); // .

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__opcje, VK_F1, 'Opcje', zti ); // F1.

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__pauza, 80, 'Pauza', zti ); // P.

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__pokój_rozmów__informacja_dodatkowa, 0, 'Pokój rozmów wyświetlaj dialogi na ekranie gry', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__pokój_rozmów__na_ekranie, 13, 'Pokój rozmów wyświetlaj na ekranie gry', zti ); // Enter.

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__prędkość_zadana_procent_zmień__1_plus, 0, 'Prędkość do przodu +1', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__prędkość_zadana_procent_zmień__25_plus, 104, 'Prędkość do przodu +25', zti ); // Num8.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__prędkość_zadana_procent_zmień__100_plus, 0, 'Prędkość do przodu +100', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__prędkość_zadana_procent_zmień__1_minus, 0, 'Prędkość do tyłu +1', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__prędkość_zadana_procent_zmień__25_minus, 98, 'Prędkość do tyłu +25', zti ); // Num 2.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__prędkość_zadana_procent_zmień__100_minus, 0, 'Prędkość do tyłu +100', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__prędkość_zadana_procent_zmień__zero, 101, 'Prędkość zero', zti ); // Num 5.

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__punkty_życia_wskaźnik__gracz, 0, 'Punkty życia wskaźnik gracz', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__punkty_życia_wskaźnik__przeciwnik, 0, 'Punkty życia wskaźnik przeciwnik', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__punkty_życia_wskaźnik__sojusznik, 0, 'Punkty życia wskaźnik sojusznik', zti ); // .

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__radar_widoczność, 0, 'Radar wyświetlaj na ekranie', zti ); // .

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__statek__utwórz, 0, 'Statek utwórz (ponownie) wskazany', zti ); // .

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__skręt_zadany_procent_zmień__1_lewo, 0, 'Ster lewo +1', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__skręt_zadany_procent_zmień__25_lewo, 100, 'Ster lewo +25', zti ); // Num 4.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__skręt_zadany_procent_zmień__100_lewo, 0, 'Ster lewo +100', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__skręt_zadany_procent_zmień__1_prawo, 0, 'Ster prawo +1', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__skręt_zadany_procent_zmień__25_prawo, 102, 'Ster prawo +25', zti ); // Num 6.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__skręt_zadany_procent_zmień__100_prawo, 0, 'Ster prawo +100', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__skręt_zadany_procent_zmień__zero, 96, 'Ster zero', zti ); // Num 0.

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strzał_1, 0, 'Strzał pojedynczy', zti, true ); // LPM.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strzał_2, 0, 'Strzał pojedynczy (alternatywna kombinacja klawiszy)', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strzał__wszystkie_wybrane_1, 1, 'Strzał z wszystkich broni wybranych typów', zti, true ); // PPM.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strzał__wszystkie_wybrane_2, 0, 'Strzał z wszystkich broni wybranych typów (alternatywna kombinacja klawiszy)', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strzał__wszystkie_lufy_1, 2, 'Strzał z wszystkich luf wskazanej broni', zti, true ); // SPM.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strzał__wszystkie_lufy_2, 0, 'Strzał z wszystkich luf wskazanej broni (alternatywna kombinacja klawiszy)', zti ); // .

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strzał__broń_indeks_zmieniaj, 0, 'Strzał przechodź na kolejną broń (tego samego rodzaju) po strzale', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strzał__broń_indeks_następny, 0, 'Strzał przejdź na następną broń (tego samego rodzaju)', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strzał__broń_indeks_poprzedni, 0, 'Strzał przejdź na poprzednią broń (tego samego rodzaju)', zti ); // .

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strzelaj_z__artyleria, 0, 'Strzelaj z artylerii ustaw', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strzelaj_z__pocisk, 0, 'Strzelaj z dział ustaw', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strzelaj_z__torpeda, 0, 'Strzelaj z torped ustaw', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strzelaj_z__wszystkie, 0, 'Strzelaj ze wszystkiego ustaw', zti ); // .

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__statek__przesunięcie_w_lewo, VK_LEFT, 'Projektowy tryb statek przesunięcie w lewo', zti ); // Kursor w lewo.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__statek__przesunięcie_w_prawo, VK_RIGHT, 'Projektowy tryb statek przesunięcie w prawo', zti ); // Kursor w prawo.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__statek__przesunięcie_w_przód, VK_UP, 'Projektowy tryb statek przesunięcie w przód', zti ); // Kursor w górę.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__statek__przesunięcie_w_tył, VK_DOWN, 'Projektowy tryb statek przesunięcie w tył', zti ); // Kursor w dół.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__statek__obrót_lewo, VK_DELETE, 'Projektowy tryb statek obrót lewo', zti ); // Delete.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__statek__obrót_prawo, VK_NEXT, 'Projektowy tryb statek obrót prawo', zti ); // Page Down.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__statek__przechylenie_w_lewo, VK_INSERT, 'Projektowy tryb statek przechylenie w lewo', zti ); // Insert.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__statek__przechylenie_w_prawo, VK_PRIOR, 'Projektowy tryb statek przechylenie w prawo', zti ); // Page Up.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__statek__uniesienie_przodu, VK_HOME, 'Projektowy tryb statek uniesienie przodu', zti ); // Home.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__statek__uniesienie_tyłu, VK_END, 'Projektowy tryb statek uniesienie tyłu', zti ); // End.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__statek__prędkość_zadana_0_100, 191, 'Projektowy tryb statek prędkość przełącz 0%, 100%', zti ); // /.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__statek___resetuj_obrót, 0, 'Projektowy tryb statek resetuj obrót', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__włącz_wyłącz, 0, 'Projektowy tryb włącz wyłącz', zti ); // .

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__zamknij_program, 27, 'Zamknij program', zti ); // Esc.


  Klawiatura_Konfiguracja_ScrollBox.VertScrollBar.Position := przesunięcie_w_pionie_kopia;

end;//---//Klawiatura_Konfiguracja_Domyślna_ButtonClick().

//Klawiatura_Konfiguracja__Wczytaj_ButtonClick().
procedure TStatki_Form.Klawiatura_Konfiguracja__Wczytaj_ButtonClick( Sender: TObject );
var
  i,
  j
    : integer;
  czy_błąd,
  komunikaty_pomiń
    : boolean;
  zts_1,
  zts_2,
  komunikat_treść
    : string;
  plik_tekstowy : TextFile;
  zt_klawiatura_konfiguracja_r : TKlawiatura_Konfiguracja_r;
begin

  if    ( Sender <> nil )
    and ( TComponent(Sender).Name = Klawiatura_Konfiguracja__Przyciski_Panel.Name ) then
    begin

      // Pomija pytanie.

      komunikaty_pomiń := true;

    end
  else//if    ( Sender <> nil ) (...)
    begin

      komunikaty_pomiń := false;

      if Application.MessageBox( 'Czy wczytać konfigurację klawiszy?', 'Potwierdzenie', MB_YESNO + MB_DEFBUTTON2 + MB_ICONQUESTION ) = IDNO then
        Exit;

    end;
  //---//if    ( Sender <> nil ) (...)


  zts_1 := ExtractFilePath( Application.ExeName ) + 'Klawiatura konfiguracja ' + Trim(  FormatFloat( '000', Klawiatura_Konfiguracja__Konfiguracja_Numer_SpinEdit.Value )  ) + '.txt';

  if not FileExists( zts_1 ) then
    begin

      komunikat_treść := 'Nie odnaleziono pliku konfiguracji klawiszy (' + zts_1 + ').';

      if not komunikaty_pomiń then
        Application.MessageBox( PChar(komunikat_treść), 'Informacja', MB_OK + MB_ICONEXCLAMATION )
      else//if not komunikaty_pomiń then
        Log_Wypisz( komunikat_treść );

      Exit;

    end;
  //---//if not FileExists( zts_1 ) then


  komunikat_treść := '';


  AssignFile( plik_tekstowy, zts_1 );

  Reset( plik_tekstowy );

  while not Eof( plik_tekstowy ) do
    begin

      czy_błąd := false;


      Readln( plik_tekstowy, zts_1 ); // Czyta całą linię.

      {$region 'Odczytuje wartości z tekstu.'}
      i := Pos( ';', zts_1 );

      if i > 0 then
        begin

          zts_2 := Copy( zts_1, 1, i - 1 );
          Delete( zts_1, 1, i );

          try
            i := StrToInt( zts_2 );
          except
            komunikat_treść := komunikat_treść + #13 + #10 + 'błędny kod klawisza (' + zts_2 + ')';
          end;
          //---//try

          if   ( i < 0 )
            or (  i > High( word )  ) then
            begin

              czy_błąd := true;
              komunikat_treść := komunikat_treść + #13 + #10 + 'błędny zakres kodu klawisza (' + zts_2 + ')';

            end
          else//if   ( i < 0 ) (...)
            zt_klawiatura_konfiguracja_r.klawisz := i;

        end
      else//if i > 0 then
        begin

          czy_błąd := true;
          komunikat_treść := komunikat_treść + #13 + #10 + 'brak kodu klawisza';

        end;
      //---//if i > 0 then


      i := Pos( ';', zts_1 );

      if i > 0 then
        begin

          zts_2 := Copy( zts_1, 1, i - 1 );
          Delete( zts_1, 1, i );
          zt_klawiatura_konfiguracja_r.czy_mysz := zts_2 = 'mysz';

        end
      else//if i > 0 then
        begin

          czy_błąd := true;
          komunikat_treść := komunikat_treść + #13 + #10 + 'brak rodzaju klawisza';

        end;
      //---//if i > 0 then


      i := Pos( ';', zts_1 );

      if i > 0 then
        begin

          zts_2 := Copy( zts_1, 1, i - 1 );
          Delete( zts_1, 1, i );
          zt_klawiatura_konfiguracja_r.plus_alt := zts_2 = 'alt';

        end
      else//if i > 0 then
        begin

          //czy_błąd := true;
          komunikat_treść := komunikat_treść + #13 + #10 + 'brak parametru - klawisz alt';

        end;
      //---//if i > 0 then


      i := Pos( ';', zts_1 );

      if i > 0 then
        begin

          zts_2 := Copy( zts_1, 1, i - 1 );
          Delete( zts_1, 1, i );
          zt_klawiatura_konfiguracja_r.plus_ctrl := zts_2 = 'ctrl';

        end
      else//if i > 0 then
        begin

          //czy_błąd := true;
          komunikat_treść := komunikat_treść + #13 + #10 + 'brak parametru - klawisz ctrl';

        end;
      //---//if i > 0 then


      i := Pos( ';', zts_1 );

      if i > 0 then
        begin

          zts_2 := Copy( zts_1, 1, i - 1 );
          Delete( zts_1, 1, i );
          zt_klawiatura_konfiguracja_r.plus_shift := zts_2 = 'shift';

        end
      else//if i > 0 then
        begin

          //czy_błąd := true;
          komunikat_treść := komunikat_treść + #13 + #10 + 'brak parametru - klawisz shift';

        end;
      //---//if i > 0 then


      i := Pos( ';', zts_1 );

      if i > 0 then
        begin

          zts_2 := Copy( zts_1, 1, i - 1 );
          Delete( zts_1, 1, i );
          zt_klawiatura_konfiguracja_r.polecenie_nazwa := zts_2;

        end
      else//if i > 0 then
        begin

          //czy_błąd := true;
          zt_klawiatura_konfiguracja_r.polecenie_nazwa := zts_1;
          komunikat_treść := komunikat_treść + #13 + #10 + 'brak nazwy funkcjonalności';

        end;
      //---//if i > 0 then
      {$endregion 'Odczytuje wartości z tekstu.'}

      if not czy_błąd then
        begin

          zts_2 := '?';

          for i := 0 to Length( klawiatura_konfiguracja_r_t ) - 1 do
            if klawiatura_konfiguracja_r_t[ i ].polecenie_nazwa = zt_klawiatura_konfiguracja_r.polecenie_nazwa then
              begin

                klawiatura_konfiguracja_r_t[ i ].klawisz := zt_klawiatura_konfiguracja_r.klawisz;
                klawiatura_konfiguracja_r_t[ i ].czy_mysz := zt_klawiatura_konfiguracja_r.czy_mysz;
                klawiatura_konfiguracja_r_t[ i ].plus_alt := zt_klawiatura_konfiguracja_r.plus_alt;
                klawiatura_konfiguracja_r_t[ i ].plus_ctrl := zt_klawiatura_konfiguracja_r.plus_ctrl;
                klawiatura_konfiguracja_r_t[ i ].plus_shift := zt_klawiatura_konfiguracja_r.plus_shift;

                zts_2 := '';


                for j := 0 to Klawiatura_Konfiguracja_ScrollBox.ControlCount - 1 do
                  if    ( Klawiatura_Konfiguracja_ScrollBox.Controls[ j ] is TKlawisz_Konfiguracja )
                    and ( TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.polecenie_nazwa = klawiatura_konfiguracja_r_t[ i ].polecenie_nazwa ) then
                    begin

                      zt_klawiatura_konfiguracja_r.klawisz := TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.klawisz;

                      TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).Czy_Mysz_CheckBox.Checked := TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.czy_mysz;
                      TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).Plus_Alt_CheckBox.Checked := TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.plus_alt;
                      TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).Plus_Ctrl_CheckBox.Checked := TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.plus_ctrl;
                      TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).Plus_Shift_CheckBox.Checked := TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.plus_shift;

                      // Dodatkowe sprawdzenie (nie powinny zmienić się te wartości).
                      if TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.mysz_niezdefiniowana then
                        TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.mysz_niezdefiniowana := false;

                      if TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.klawisz <> zt_klawiatura_konfiguracja_r.klawisz then
                        TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.klawisz := zt_klawiatura_konfiguracja_r.klawisz;
                      //---// Dodatkowe sprawdzenie (nie powinny zmienić się te wartości).

                      TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).Nazwa_Klawisza();


                      TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).Polecenie_Nazwa_Label.Font.Color := clWindowText; // Ustawia domyślny kolor.

                      Break;

                    end;
                  //---//if Klawiatura_Konfiguracja_ScrollBox.Controls[ j ] is TKlawisz_Konfiguracja then

                Break;

              end;
            //---//if klawiatura_konfiguracja_r_t[ i ].polecenie_nazwa = zt_klawiatura_konfiguracja_r.polecenie_nazwa then


          if zts_2 <> '' then
            komunikat_treść := komunikat_treść + #13 + #10 + 'wczytana konfiguracja klawiszy zawiera nieznane definicje funkcjonalności (' + zt_klawiatura_konfiguracja_r.polecenie_nazwa + ')';

        end;
      //---//if not czy_błąd then

    end;
  //---//while not Eof( plik_tekstowy ) do

  CloseFile( plik_tekstowy );



  if komunikat_treść <> '' then
    begin

      komunikat_treść := 'Pojawiły się następujące błędy podczas wczytywania konfiguracji klawiszy:' + #13 + #10 + komunikat_treść + '.';

      Log_Wypisz( komunikat_treść, false );

      if not komunikaty_pomiń then
        ShowMessage( komunikat_treść );

    end;
  //---//if komunikat_treść <> '' then

end;//---//Klawiatura_Konfiguracja__Wczytaj_ButtonClick().

//Klawiatura_Konfiguracja__Zapisz_ButtonClick().
procedure TStatki_Form.Klawiatura_Konfiguracja__Zapisz_ButtonClick( Sender: TObject );
var
  i : integer;
  zts : string;
  plik_tekstowy : TextFile;
begin

  if Application.MessageBox( 'Czy zapisać konfigurację klawiszy?', 'Potwierdzenie', MB_YESNO + MB_DEFBUTTON2 + MB_ICONQUESTION ) = IDNO then
    Exit;


  zts := ExtractFilePath( Application.ExeName ) + 'Klawiatura konfiguracja ' + Trim(  FormatFloat( '000', Klawiatura_Konfiguracja__Konfiguracja_Numer_SpinEdit.Value )  ) + '.txt';

  AssignFile( plik_tekstowy, zts );

  Rewrite( plik_tekstowy ); // Czyści. Nie odczyta zablokowanego pliku.


  for i := 0 to Length( klawiatura_konfiguracja_r_t ) - 1 do
    begin

      zts := IntToStr( klawiatura_konfiguracja_r_t[ i ].klawisz ) + ';';

      if klawiatura_konfiguracja_r_t[ i ].czy_mysz then
        zts := zts + 'mysz;'
      else//if klawiatura_konfiguracja_r_t[ i ].czy_mysz then
        zts := zts + 'klawisz;';

      if klawiatura_konfiguracja_r_t[ i ].plus_alt then
        zts := zts + 'alt;'
      else//if klawiatura_konfiguracja_r_t[ i ].plus_alt then
        zts := zts + ';';

      if klawiatura_konfiguracja_r_t[ i ].plus_ctrl then
        zts := zts + 'ctrl;'
      else//if klawiatura_konfiguracja_r_t[ i ].plus_ctrl then
        zts := zts + ';';

      if klawiatura_konfiguracja_r_t[ i ].plus_shift then
        zts := zts + 'shift;'
      else//if klawiatura_konfiguracja_r_t[ i ].plus_shift then
        zts := zts + ';';

      zts := zts + klawiatura_konfiguracja_r_t[ i ].polecenie_nazwa + ';';

      Writeln( plik_tekstowy, zts );

    end;
  //---//for i := 0 to Length( klawiatura_konfiguracja_r_t ) - 1 do


  CloseFile( plik_tekstowy ); // Dopiero po zamknięciu zapisuje zmiany.

end;//---//Klawiatura_Konfiguracja__Zapisz_ButtonClick().

//Klawiatura_Konfiguracja__Niepowtarzalność_Sprawdź_ButtonClick().
procedure TStatki_Form.Klawiatura_Konfiguracja__Niepowtarzalność_Sprawdź_ButtonClick( Sender: TObject );
var
  i,
  j
    : integer;
  komunikat_treść : string;
  zt_klawiatura_konfiguracja_r : TKlawiatura_Konfiguracja_r;
begin

  komunikat_treść := '';


  for i := 0 to Klawiatura_Konfiguracja_ScrollBox.ControlCount - 1 do // Tylko wizualne.
    TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).Polecenie_Nazwa_Label.Font.Color := clWindowText; // Ustawia domyślny kolor.


  for i := 0 to Klawiatura_Konfiguracja_ScrollBox.ControlCount - 1 do // Tylko wizualne.
    begin

      if TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).klawiatura_konfiguracja_r_w.mysz_niezdefiniowana then
        begin

          komunikat_treść := komunikat_treść + #13 + #10 + TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).klawiatura_konfiguracja_r_w.polecenie_nazwa
            + ' - niepełna definicja';

          TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).Polecenie_Nazwa_Label.Font.Color := clMaroon;

        end;
      //---//if TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).klawiatura_konfiguracja_r_w.mysz_niezdefiniowana then


      zt_klawiatura_konfiguracja_r.klawisz := TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).klawiatura_konfiguracja_r_w.klawisz;
      zt_klawiatura_konfiguracja_r.czy_mysz := TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).klawiatura_konfiguracja_r_w.czy_mysz;
      zt_klawiatura_konfiguracja_r.plus_alt := TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).klawiatura_konfiguracja_r_w.plus_alt;
      zt_klawiatura_konfiguracja_r.plus_ctrl := TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).klawiatura_konfiguracja_r_w.plus_ctrl;
      zt_klawiatura_konfiguracja_r.plus_shift := TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).klawiatura_konfiguracja_r_w.plus_shift;


      if    ( zt_klawiatura_konfiguracja_r.klawisz = 0 )
        and ( not zt_klawiatura_konfiguracja_r.czy_mysz )
        and (
                 ( zt_klawiatura_konfiguracja_r.plus_alt )
              or ( zt_klawiatura_konfiguracja_r.plus_ctrl )
              or ( zt_klawiatura_konfiguracja_r.plus_shift )
            ) then
        begin

          komunikat_treść := komunikat_treść + #13 + #10 + TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).klawiatura_konfiguracja_r_w.polecenie_nazwa
            + ' - niepoprawna definicja';

          TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).Polecenie_Nazwa_Label.Font.Color := clMaroon;

        end;
      //---//if    ( zt_klawiatura_konfiguracja_r.klawisz = 0 ) (...)


      if    ( zt_klawiatura_konfiguracja_r.klawisz = 0 )
        and ( not zt_klawiatura_konfiguracja_r.czy_mysz ) then
        // Brak definicji (nie sprawdzane) [Niezdefiniowane].
      else//if    ( zt_klawiatura_konfiguracja_r.klawisz = 0 ) (...)
        for j := i + 1 to Klawiatura_Konfiguracja_ScrollBox.ControlCount - 1 do // Tylko wizualne.
          begin

            if    ( zt_klawiatura_konfiguracja_r.klawisz = TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.klawisz )
              and ( zt_klawiatura_konfiguracja_r.czy_mysz = TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.czy_mysz )
              and ( zt_klawiatura_konfiguracja_r.plus_alt = TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.plus_alt )
              and ( zt_klawiatura_konfiguracja_r.plus_ctrl = TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.plus_ctrl )
              and ( zt_klawiatura_konfiguracja_r.plus_shift = TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.plus_shift ) then
              begin

                komunikat_treść := komunikat_treść + #13 + #10 +
                    TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).klawiatura_konfiguracja_r_w.polecenie_nazwa
                  + ' i ' + TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.polecenie_nazwa
                  + ' - powielona definicja';

                TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).Polecenie_Nazwa_Label.Font.Color := clRed;
                TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).Polecenie_Nazwa_Label.Font.Color := clRed;

              end;
            //---//if    ( zt_klawiatura_konfiguracja_r.klawisz = TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.klawisz ) (...)

          end;
        //---//for j := i + 1 to Klawiatura_Konfiguracja_ScrollBox.ControlCount - 1 do

    end;
  //---//for i := 0 to Klawiatura_Konfiguracja_ScrollBox.ControlCount - 1 do


  if komunikat_treść <> '' then
    begin

      komunikat_treść := 'Wykryto następujące niezgodności konfiguracji klawiszy:' + #13 + #10 + komunikat_treść + '.';

      Log_Wypisz( komunikat_treść, false );

      ShowMessageUser( komunikat_treść );

    end
  else//if komunikat_treść <> '' then
    Application.MessageBox( 'Nie wykryto niezgodności konfiguracji klawiszy.', 'Informacja', MB_OK + MB_ICONINFORMATION );

end;//---//Klawiatura_Konfiguracja__Niepowtarzalność_Sprawdź_ButtonClick().

procedure TStatki_Form.Button1Click(Sender: TObject);
var
  i : integer;
  ztsn : single;
  zt_id_socket_handle : TIdSocketHandle;
begin

  // Do testów.


//  i := Low( Single );
//  i := High( Single );
//  ztsn := statek_gracza.torpedy_wyrzutnie_t[ 0 ].celownik_linia_bez_falowania.LineWidth.MaxValue;
//  ztsn := statek_gracza.torpedy_wyrzutnie_t[ 0 ].celownik_linia_bez_falowania.LineWidth.MinValue;

  statek_gracza.torpedy_wyrzutnie_t[ 0 ].celownik_linia_bez_falowania.LineWidth :=
  statek_gracza.torpedy_wyrzutnie_t[ 0 ].celownik_linia_bez_falowania.LineWidth + 1;
//
  Caption := FloatToStr( statek_gracza.torpedy_wyrzutnie_t[ 0 ].celownik_linia_bez_falowania.LineWidth );

//statki_t[ 1 ].torpedy_wyrzutnie_t[ 0 ].celownik_linia_bez_falowania.Visible := true;
//
//  if not czy_klient_g then
//    begin
//
//      statki_t[ 1 ].torpedy_wyrzutnie_t[ 0 ].celownik_linia_bez_falowania.LineWidth :=
//      statki_t[ 1 ].torpedy_wyrzutnie_t[ 0 ].celownik_linia_bez_falowania.LineWidth + 1;
//
//
//      statki_t[ 1 ].torpedy_wyrzutnie_t[ 0 ].celownik_linia.LineWidth := statki_t[ 1 ].torpedy_wyrzutnie_t[ 0 ].celownik_linia_bez_falowania.LineWidth;
//
//    end;
//  //---//
//
//
//  Caption := FloatToStr( statki_t[ 1 ].torpedy_wyrzutnie_t[ 0 ].celownik_linia_bez_falowania.LineWidth );


  Exit;


  //if Length( statki_t ) < 2 then
    begin

      Wieloosobowe__Podłącz_BitBtnClick( Sender );

      Gracz_Nazwa_Edit.Text := 's';
      Gracz_Gotowość_BitBtnClick( Gracz_Gotowość_Tak_BitBtn );

      SI__Nazwa_Edit.Text := '1';
      SI__Statek_ComboBox.ItemIndex := 1;
      SI__Dodaj_BitBtnClick( Sender );

      SI__Nazwa_Edit.Text := '2';
      SI__Statek_ComboBox.ItemIndex := 6;
      SI__Dodaj_BitBtnClick( Sender );

      Gra_Rozpocznij_BitBtnClick( Sender );

    end;
  //---//


//  statki_t[ 1 ].celownicza_linia.Nodes[ 1 ].X := statki_t[ 1 ].celownicza_linia.Nodes[ 1 ].X + 1;
//  statki_t[ 1 ].celownicza_linia.Nodes[ 1 ].Y := statki_t[ 1 ].celownicza_linia.Nodes[ 1 ].Y + 1;
//  statki_t[ 1 ].celownicza_linia.Nodes[ 1 ].Z := statki_t[ 1 ].celownicza_linia.Nodes[ 1 ].Z + 1;



//  Statki_Rozstaw( nil );

//  statki_t[ 0 ].Position.Z := -2;
//  statki_t[ 1 ].Position.Z := 5;
//
//  statki_t[ 2 ].Position.Z := 10;
//  statki_t[ 3 ].Position.Z := 17;


  //Wieloosobowe_Identyfikator_Edit.Text := '1';

  //Serwer_Wysyła_TimerTimer( Sender );
  //Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_2_r_c, -99, '' );


  Exit;

  if statek_gracza <> nil then
    ShowMessage(  statek_gracza.Parametry_Odczytaj( 1 = 1 ) );


  if czy_serwer_g then
    begin

      if not IdUDPServer1.Active then
        begin

          //??? Sprawdzić gotowośc graczy.

          IdUDPServer1.DefaultPort := Serwer_Port_SpinEdit.Value;

          IdUDPServer1.Bindings.Clear();

          zt_id_socket_handle := IdUDPServer1.Bindings.Add();
          zt_id_socket_handle.IP := '0.0.0.0';
          zt_id_socket_handle.Port := Serwer_Port_SpinEdit.Value;


          IdUDPServer1.Active := true;

        end;
      //---//if czy_serwer_g then

      Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__odbierz__rekord_amunicja_c, -99, '', true );
      //Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__odbierz__rekord_statki_c, -99, '', true );

    end;
  //---//if czy_serwer_g then


  if czy_klient_g then
    begin

      if IdTCPClient1.Connected then
        Caption := 'P'
      else
        Caption := 'X';


      if not IdUDPClient1.Connected then
        begin

          Elementy_Gry_Zwolnij();


          IdUDPClient1.Host := Serwer_Adres_IP_Edit.Text;
          IdUDPClient1.Port := Serwer_Port_SpinEdit.Value;
          IdUDPClient1.ReceiveTimeout := 5; //???


          if not IdUDPClient1.Connected then
            IdUDPClient1.Connect();

        end;
      //---//

      Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__udp__klient_połączony_nadal_c, -99, '', true );
      Klient_IdUDP_Czyta_TimerTimer( Sender );

    end;
  //---//

  //Gracze_Lista_Rozłącz( -99 );


  //Gracze_Lista_Odśwież();
  //Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__gracz_lista_odśwież_c, -99, '' );

  Exit;

  Statki_Form.Caption := 'na';



//  Ląd_Zwolnij();
//  Ląd_Odczytaj_Z_Pliku( 'ląd 03.xml' );
//  Ląd_Utwórz();


//  Amunicja_Wystrzelona_Zwolnij_Wszystkie();
//
//  amunicja_wystrzelona_list.Clear();


//  if statek_gracza.prędkość_procent <> 0 then
//    begin
//
//      statek_gracza.prędkość_procent := 0;
//      statki_t[ 1 ].prędkość_procent := 0;
//
//    end
//  else//if statek_gracza.prędkość_procent <> 0 then
//    begin
//
//      statek_gracza.prędkość_procent := 90;
//      statki_t[ 1 ].prędkość_procent := 60;
//
//    end;
//  //---//if statek_gracza.prędkość_procent <> 0 then
//
//  statek_gracza.prędkość_zadana_procent := statek_gracza.prędkość_procent;
//  statki_t[ 1 ].prędkość_zadana_procent := statki_t[ 1 ].prędkość_procent;


//Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_Ląd, 0, 1, 0, nil, -1, -1 );
//Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_Statek, 0, 5, 0, nil, -1, -1 );
//Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_Woda, 0, 10, 0, nil, -1, -1 );
//Trafienia_Efekt_Utwórz_Jeden( statki_t[ 0 ], 0, 1, 0 );
//Statek_Przywróć_Do_Gry( statki_t[ 0 ] );
//   GLPlane1.MoveFirst();
//  Exit;
//Trafienia_Efekt_Zwolnij_Wszystkie();
//statki_t[ 1 ].czy_usunąć := true;
//  Exit;
//
//  if statki_t[ 0 ] <> nil then
//    FreeAndNil( statki_t[ 0 ] )
//  else
//    statki_t[ 0 ] := TStatek.Create( Gra_Obiekty_GLDummyCube, Statki_Form.GLCollisionManager1, 0, '', prymitywy_lista_t );
//
//  statek_gracza := statki_t[ 0 ];

//  for i := amunicja_wystrzelona_list.Count - 1 downto 0 do
//    begin
//
//      //TAmunicja(amunicja_wystrzelona_list[ i ]).Position
//      TAmunicja(amunicja_wystrzelona_list[ i ]).Free();
//      amunicja_wystrzelona_list.Delete( i );
//
//    end;
//  //---//for i := amunicja_wystrzelona_list.Count - 1 downto 0 do
//
//Exit;
//  //Statek_Przywróć_Do_Gry( statek_gracza );
//  Statek_Przywróć_Do_Gry( statki_t[ 1 ] );
//  Statek_Przywróć_Do_Gry( statki_t[ 2 ] );
//  Statek_Przywróć_Do_Gry( statki_t[ 3 ] );
//  Statek_Przywróć_Do_Gry( statki_t[ 0 ] );
  //statek_gracza.SetAbsoluteDirection( 0, 1, 0 );

  Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__odbierz__ląd_definicja_c, -99, '' );


  //Wieloosobowe__Tekst_Wyślij(  DateTimeToStr( Now() )  );
  Wieloosobowe__Tekst_Wyślij_UDP(  DateTimeToStr( Now() )  );

  //Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__odbierz__rekord_amunicja_c, -99, '', true );
  //Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__odbierz__rekord_statki_c, -99, '', true );
  Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__odbierz__rekord_efekt_c, -99, '', true );

  //Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_r_c, -99, '' );
  //Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__statek__klawisze_obsługa_c, -99, '' );
  //Wieloosobowe__Tekst_Wyślij( wieloosobowe__komenda__serwer_wyłącza_się_c, -99, '' );
  //Exit;

  pokój_rozmów_r.wiadomość := DateTimeToStr( Now() );
  Wieloosobowe__Strumień_Wyślij( wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c, -99, '' );
  Log_Memo.Lines.Add(  IntToStr( pokój_rozmów_r.id_odbiorca ) + ' ' + DateTimeToStr( Now() )   );

end;

end.

{

...

Edit1KeyDown

Nie wykrywa
  Tab
  PrtScr
  przyciski myszy


Ctrl, Shift, Alt, Win, - nie rozróżnia strony
Tab, Win, Alt, Menu myszy * wywołuja własne kacje

***

GLSceneViewer1MouseDown
  Statek_Klawisze_Obsługa()
  Klawisze_Obsługa_Zachowanie_Ciągłe();
    if Projektowy_Tryb_CheckBox.Checked then


GLSceneViewer1KeyDown
  if czy_pauza_g then Klawisze_Obsługa_Zachowanie_Ciągłe()
  Statek_Klawisze_Obsługa()
    Key : Word
    if Key = Ord( 'P' ) then
      VK_ESCAPE
      VK_SPACE
      Ord( 'P' )

GLCadencer1Progress
  Klawisze_Obsługa_Zachowanie_Ciągłe()

Wieloosobowe__Odczytaj
  Statek_Klawisze_Obsługa()



TStatki_Form.Klawisze_Obsługa_Zachowanie_Ciągłe( d : double );
  kamera ruch
//testy
  if   IsKeyDown( 'W' )
    or IsKeyDown( 'z' ) then
  moment_wciśnięcia_klawisza := Now();
  if GLSceneViewer1.Focused then
  if Projektowy_Tryb_CheckBox.Checked then
  VK_LEFT

TStatki_Form.Statek_Klawisze_Obsługa( const id_statek_f : integer; const klawisz_f : Word; const shift_f : TShiftState; const mysz_przycisk_f : SmallInt );
  if klawisz_f = Ord( 'O' ) then
  if klawisz_f = VK_NUMPAD8 then
  if ( ssShift in shift_f ) then
  mysz_przycisk_f

}
