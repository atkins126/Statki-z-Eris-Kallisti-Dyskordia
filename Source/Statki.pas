unit Statki;{18.Sty.2017}

  //
  // MIT License
  //
  // Copyright (c) 2017 Jacek Mulawka
  //
  // j.mulawka@interia.pl
  //
  // https://github.com/jacek-mulawka
  //
  //
  // W produkcji.
  //


  // Kierunki wspó³rzêdnych uk³adu g³ównego.
  //
  //     góra y
  //     przód -z
  // lewo -x
  //     ty³ z
  //

  // K¹ty na oko³o statku.
  //
  //   przód
  // lewo
  //
  //     0
  // 90  A -90
  // 180 / -180
  //

  //
  // Hierarchia obiektów (Statki_Form.Gra_GLScene.Objects zmiana na Gra_Obiekty_GLDummyCube)
  //
  // Statki_Form.Gra_GLScene.Objects
  //   Gra_Obiekty_GLDummyCube
  //
  // TStatek.Owner = Gra_Obiekty_GLDummyCube
  //        .Parent = Gra_Obiekty_GLDummyCube
  //   falowanie_dummy, punkty_¿ycia_dummy
  //        .Owner = TStatek
  //        .Parent = TStatek
  //   elementy kad³uba
  //        .Owner = falowanie_dummy
  //        .Parent = falowanie_dummy
  //   TTorpedy_Wyrzutnia.Owner = TStatek
  //                     .Parent = TStatek
  //                     .statek = TStatek
  //                     .elementy_wizualne_dummy.Owner = TTorpedy_Wyrzutnia
  //                     .elementy_wizualne_dummy.Parent = TTorpedy_Wyrzutnia;
  //     TLufa.Owner = TTorpedy_Wyrzutnia
  //          .Parent = TTorpedy_Wyrzutnia.elementy_wizualne_dummy
  //          .dzia³o = TTorpedy_Wyrzutnia
  //          .statek = TStatek
  //          TLufa.Strza³
  //            Amunicja_Wystrzelona_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, TLufa )
  //
  // TAmunicja.Owner = Gra_Obiekty_GLDummyCube - Po uzbrojeniu dla torpedy porusza siê w p³aszczyŸnie poziomej, w pozosta³ych przypadkach porusza siê jak amunicja.
  //          .Parent = TLufa, Gra_Obiekty_GLDummyCube (najpierw jest TLufa a w momencie jej opuszczenia nastêpuje zmiana rodzica na Gra_Obiekty_GLDummyCube)
  //          .statek = TStatek
  //   korpus_opadanie_obrót_dummy.Owner = TAmunicja
  //   korpus_opadanie_obrót_dummy.Parent = TAmunicja
  //   korpus_ustawienie_pocz¹tkowe_dummy.Owner = korpus_opadanie_obrót_dummy
  //   korpus_ustawienie_pocz¹tkowe_dummy.Parent = korpus_opadanie_obrót_dummy
  //
  // GLParticleFXRenderer1 - umieszczony na koñcu aby elementy gry nie przes³ania³y efektów.
  // Informacje_G³ówne_GLHUDText - umieszczony za GLParticleFXRenderer1 aby efekty nie przes³ania³y napisów na ekranie.
  //
  // Radar_GLWindowsBitmapFont - bez osobnego TGLWindowsBitmapFont dla radaru zawiesza siê IDE i gra.

  //  Wieloosobowoœæ bêdzie siê opiera³a chyba na tym, ¿e serwer bêdzie przelicza³ pociski, a klient tylko kopiowa³ obraz.
  //  Serwer otrzyma informacjê o strzale gracza i j¹ przetworzy (cel, konfiguracja strza³u)
  //  Informacje o ruchu gracza (klawisze ruchu) //???

  // *œlad torpedy na wodzie
  // *falowanie œladu torpedy na wodzie


  // 'Granie' jako obserwator.
  // kolory efektów
  // SI, SI - ka¿de dzia³o osobno celuje
  // tryb obrony twierdzy
  // Je¿e g³êbinowe.
  // ³ódŸ podwodna // £ódŸ_podwodna.
  // lotniskowiec
  //   samoloty na radarze

  // falga, symbol statku
  // lot pocisków sprawdziæ; kilwater, woda
  // ping klientów udp

  // jasna linia na górze amunicaji

  //? kierunek efektu torpedy - chyba dzia³a
  //? wspó³czynnik masy
  //? usuwanie elementów z listy efektów wieloosobowych
  //? puchylenie eleentu œrub
  //? wp³yw ruchu statku na amunicjê
  //? skasowac z listy graczy tcp roz³¹czonych wiêcej ni¿ od danego czasu

  // opis do klawiszy (P Alt to jak A + C, czego nie wykrywa)

  // kamera, wspó³rzêdne na radarze, pudelko t³a
  // mg³a
  // kilawter
  // zbioracza funkcja dla aktywacji i dezaktywacji elementów lient, gra start
  // linia celowania statku
  // pêtle w tworzeniu definicji l¹dów, statkó
  // celownik_linia_bez_falowania.Parent := AStatek ma innego rodzica i inaczej kolor wygl¹da
  // jedna funkcja do zwalnianai statków (wywolania)
  // jedna funkcja do zwalnianai efektów (wywolania)
  // l¹d na radarze
  // prêdkoœc torped rózna, pocisków
  // u klienta - odnowiony statek by³ przekrêcony
  // status statku wyœwietlaæ (wycelowanie)
  // Napis_Odœwie¿() rysowaæ nie tak czêsto
  // sortowanie listy graczy
  // l¹d punkty ¿ycia
  // obrót dzia³ - prêdkoœæ gry
  // gra_wspó³czynnik_prêdkoœci_c
  // chwilowe psudzie dzia³ steru itp po trafieniu
  // po starcie gry odczekaæ na od wszystkich graczy Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__udp__klient_po³¹czony_nadal_c, -99, '', true );
  // GLCollisionManager2Collision - usun¹æ(?)
  // dane z radia o l¹dzie(?)
  // wysy³anie danych o l¹dzie i prymitywach przy gotowoœci serwera (do³¹czaniu klientów)
  // dŸwiêki
  // po od³¹czeniu (wyrzuceniu) gracza usun¹æ jego statek ?
  // zdarzenia losowe (meteory)

  // Gdyby nie wysy³a³o upc na sieæ to ponoæ zamiast Send u¿yæ Brodcast (?).

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, GLObjects, GLScene, GLCoordinates, Vcl.ComCtrls, Vcl.Buttons,
  Vcl.Samples.Spin, Vcl.Grids, Vcl.CheckLst,

  GLNavigator, GLCadencer, GLCrossPlatform, GLBaseClasses, GLWin32Viewer,
  GLGeomObjects,
  GLKeyboard, GLHUDObjects, GLBitmapFont, GLWindowsFont, GLSkydome, GLVectorGeometry, GLColor, IdContext,
  GLState,

  GLCollision, GLFireFX, GLParticleFX, GLPerlinPFX, GLMaterial, GLSpaceText,

  IdTCPConnection, IdTCPClient, IdBaseComponent, IdComponent, IdCustomTCPServer, IdTCPServer,
  IdSocketHandle, IdUDPClient, IdUDPBase, IdUDPServer,

  System.DateUtils, Math, GLWaterPlane, Vcl.ExtCtrls, IdIOHandler, IdGlobal, Vcl.StdCtrls, Xml.XMLDoc, Xml.XMLIntf,
  pngimage, IdSync, IniFiles;


type
  TAmunicja_Rodzaj = ( ar_Brak, ar_Artyleria, ar_Pocisk, ar_Torpeda, ar_Wszystkie ); // To samo TAmunicja_Rodzaj, Amunicja_Rodzaj_Zbiór_Zwróæ().
    TAmunicja_Rodzaj_Zbiór = set of TAmunicja_Rodzaj;
  TCelowanie_Tryb = ( ct_Brak, ct_Linia, ct_Odleg³oœæ, ct_Punkt );
  TEfekt_Rodzaj = ( er_Brak, er_Trafienie_L¹d, er_Trafienie_Statek, er_Trafienie_Woda );
  TKamera_Tryb = ( kt_Brak, kt_Amunicja, kt_Artyleria, kt_Statek, kt_Swobodna, kt_Statek_Swobodna, kt_Za_Statkiem ); // kt_Statek_Swobodna - je¿eli nie ma statku gracza ustawi kamerê swobodn¹.
  TStatki_Rozstawianie_Status = ( srs_Brak, srs_Rozstawianie_Kolizja_SprawdŸ, srs_Rozstawianie_Kolizja_Wykryta );

  TPokój_Rozmów__Odbiorca_Rodzaj = ( pror_Brak, pror_Gracz_Jeden, pror_Grupa_Jedna, pror_Wszyscy );

  TArtyleria = class;
  TDzia³o = class;
  TLufa = class;
  TSter = class;
  TŒruba = class;
  TTorpedy_Wyrzutnia = class;


  TWieloosobowe_String = ShortString; //string[ 255 ]; // SizeOf( ShortString ) = 4. // Nie udaje siê poprawnie wysy³aæ i odbieraæ nieograniczonych napisów (string).

  TTCP_Klient_Dane = class
    // Serwer ma peer_port i identyfikator = -1.
    // Gracze maj¹ identyfikator od 0 narastaj¹co.
    identyfikator, // Nadawany przez serwer gry, rozpoznaje czy to ten sam gracz siê pod³¹czy³ po od³¹czeniu.
    id_grupa,
    id_statek_schemat,
    peer_port_tcp, // Nadawany przez serwer TCP.
    peer_port_udp // Nadawany przez serwer UDP.
      : integer;
    data_czas__d³¹czenia,
    data_czas__pod³¹czenia,
    data_czas__pod³¹czenia_ostatniego, // Je¿eli po roz³¹czeniu znów siê po³¹czy.
    data_czas__udp_kontakt
      : TDateTime;
    gotowy,
    od³¹czony
      : boolean;
    nazwa : TWieloosobowe_String;
  end;//---//TTCP_Klient_Dane

  TTCP_Klienci_Lista = class
  private
    { Private declarations }
    identyfikator_najmniejszy,
    identyfikator_najwiêkszy
      : integer;
    klienci_lista_list : TList;
  public
    { Public declarations }
    constructor Create();
    destructor Destroy(); override; // Bez override; siê nie wywo³uje (jedynie tak siê wywo³a tcp_klienci_lista_g.Destroy()).

    function Dodaj_Aktualizuj( const peer_port_f, identyfikator_f : integer ) : TTCP_Klient_Dane;
    procedure Usuñ( const indeks_f : integer );
    procedure Usuñ_Identyfikator( const identyfikator_f : integer );
    procedure Usuñ_Peer_Port( const peer_port_f : integer );
    procedure Usuñ_Wszystkich();

    function Nazwa_Niepowtarzalna( const peer_port_f : integer; const nazwa_f : string ) : boolean; overload;
    function Nazwa_Niepowtarzalna( const nazwa_f : string ) : boolean; overload;
    procedure Od³¹czony_Peer_Port( const peer_port_f : integer );
    function ZnajdŸ_Identyfikator( const identyfikator_f : integer ) : TTCP_Klient_Dane;
    function ZnajdŸ_Peer_Port( const peer_port_f : integer ) : TTCP_Klient_Dane;
  end;//---//TTCP_Klienci_Lista


  TUDP_Klient_Dane = class
    identyfikator,
    peer_port
      : integer;
    adres_ip
    //komenda //???
      : string;
    data_czas_kontakt_ostatni : TDateTime;
  end;//---//TUDP_Klient_Dane

  TUDP_Klienci_Lista = class
  private
    { Private declarations }
    klienci_lista_list : TList;
  public
    { Public declarations }
    constructor Create();
    destructor Destroy(); override; // Bez override; siê nie wywo³uje (jedynie tak siê wywo³a udp_klienci_lista_g.Destroy()).

    procedure Dodaj( const adres_ip_f : string; const peer_port_f : word; const identyfikator_f : integer );
    procedure Usuñ( const indeks_f : integer );
    procedure Usuñ_Peer_Port( const peer_port_f : integer );
    procedure Usuñ_Przeterminowanych();
    procedure Usuñ_Wszystkich();
    //procedure Terminy_SprawdŸ();
  end;//---//TUDP_Klienci_Lista


  TWieloosobowe_Powiadomienie = class( TIdNotify ) // uses IdSync.
  private
    wyró¿nij : boolean; // Czy ma zaznaczyæ pojawienie siê komunikatu.
    powiadomienie_treœæ : string;
  protected
    procedure DoNotify(); override;
  end;//---//TWieloosobowe_Powiadomienie


  TWieloosobowe__Wektor_4 = record
    X,
    Y,
    Z,
    W
     : single; // SizeOf( single ) = 4.
    // SizeOf( single ) = 4 * 4 = 16.
  end;//---//TWieloosobowe__Wektor_4


  TObiekty_Wieloosobowe__Lufa_r = record
    lufa_podniesienie_k¹t, // K¹t podniesienia lufy.
    lufa_pozycja_z // Dla cofania lufy w wyniku strza³u.
      : real; // SizeOf( real ) = 8.

    strza³_gotowoœæ : boolean; // Informacje do wyœwietlania dla gracza o jego statku.

    prze³adowanie_wskaŸnik__kolor,
    prze³adowanie_wskaŸnik__pozycja
      : TWieloosobowe__Wektor_4; //GLVectorGeometry.TVector
  end;//---//TObiekty_Wieloosobowe__Lufa_r

  TObiekty_Wieloosobowe__Dzia³o_r = record
    obrót_k¹t, // K¹t obrotu dzia³a.
    celownik_linia__podniesienie_k¹t
      : real; // SizeOf( real ) = 8.

    celownik_linia__szerokoœæ : single;

    celownik_linia__wzór : word; // SizeOf( word ) = 2.

    //lufa_podniesienie_k¹t_t__d³ugoœæ_tabeli : integer;

    //lufa_podniesienie_k¹t_t // Aktualny k¹t podniesienia lufy.
    //  : array of real; // SizeOf( Pointer ) = 4.

    amunicja_iloœæ, // Informacje do wyœwietlania dla gracza o jego statku.
    obiekty_wieloosobowe_lufa_r_t__d³ugoœæ_tabeli
      : integer; // SizeOf( integer ) = 4.

    czy_lot_parabol¹ : boolean;

    celownik_linia__kolor : TWieloosobowe__Wektor_4; //GLVectorGeometry.TVector

    obiekty_wieloosobowe_lufa_r_t
      : array of TObiekty_Wieloosobowe__Lufa_r; // SizeOf( Pointer ) = 4.
  end;//---//TObiekty_Wieloosobowe__Dzia³o_r

  TObiekty_Wieloosobowe__Amunicja_r = record
    id_statek : integer;
    id_wieloosobowe_amunicja : Int64;

    czy_lot_parabol¹,
    czy_poza_luf¹,
    przeliczone // Czy dane o tej amunicji zosta³y ju¿ przeliczone.
      : boolean;

    kierunek,
    pozycja,
    pozycja_celu
      : GLVectorGeometry.TVector;

    korpus__Height,
    torpeda_efekt_na_wodzie_stan // Czy widoczny jest ju¿ efekt na wodzie ( 0 - efekt jeszcze nie by³ widoczny, 1 - efekt widoczny, 2 - efektu ju¿ nie widaæ).
      : Single;

    turn_angle,
    pitch_angle,

    korpus__TopRadius,
    korpus__BottomRadius
      : real;

    amunicja_rodzaj : TAmunicja_Rodzaj;
  end;//---//TObiekty_Wieloosobowe__Amunicja_r

  TObiekty_Wieloosobowe__Efekt_r = record
    id_statek : integer;
    wys³ane : boolean;
    pozycja : GLVectorGeometry.TVector;
    czas_trwania,
    czas_trwania_efekt_dodatkowy
      : Int64;
    amunicja_rodzaj : TAmunicja_Rodzaj;
    efekt_rodzaj : TEfekt_Rodzaj;
    // si³a obra¿eñ //???
  end;//---//TObiekty_Wieloosobowe__Efekt_r

  TObiekty_Wieloosobowe__Statek_r = record
    id_grupa,
    id_statek,
    id_statek_schemat,
    artyleria_t__d³ugoœæ_tabeli,
    dzia³a_t__d³ugoœæ_tabeli,
    torpedy_wyrzutnie_t__d³ugoœæ_tabeli,
    artyleria_wygl¹d_t__d³ugoœæ_tabeli,
    dzia³a_wygl¹d_t__d³ugoœæ_tabeli,
    torpedy_wyrzutnie_wygl¹d_t__d³ugoœæ_tabeli,
    œruba_obrót_k¹t__d³ugoœæ
      : integer; // SizeOf( integer ) = 4.

    falowanie_bok_skrêt, // Iloœæ stopni wychylenia w bok z powodu skrêt (aktualnego).
    prêdkoœæ_procent, // Informacje do wyœwietlania dla gracza o jego statku.
    prêdkoœæ_zadana_procent, // Informacje do wyœwietlania dla gracza o jego statku.
    punkty_¿ycia,
    punkty_¿ycia_maksymalne,
    punkty_¿ycia_procent_zosta³o,
    skrêt_procent, // Informacje do wyœwietlania dla gracza o jego statku.
    skrêt_zadany_procent, // Informacje do wyœwietlania dla gracza o jego statku.
    ster_k¹t, // K¹t wychylenia steru.
    toniêcie__przechylenie__lewo_prawo, // Dla animacji toniêcia statku.
    toniêcie__przechylenie__przód_ty³ // Dla animacji toniêcia statku.
      : real; // SizeOf( real ) = 8.

    czy_wszystkie_lufy,
    obracaj_dzia³a,
    podnoœ_lufy,
    przeliczone // Czy dane o tym statku zosta³y ju¿ przeliczone.
      : boolean; // SizeOf( boolean ) = 1.

    gracz__nazwa : TWieloosobowe_String;

    cel_wspó³rzêdne,
    kierunek,
    pozycja
      : TWieloosobowe__Wektor_4; //GLVectorGeometry.TVector

    amunicja_rodzaj : TAmunicja_Rodzaj; // SizeOf( TAmunicja_Rodzaj ) = 1 ale SizeOf( SmallInt ) = 2. // To chyba te¿ siê traktuje jako - SizeOf( Pointer ) = 4.

    œruba_obrót_k¹t // Aktualny k¹t obrotu œruby (daje efekt obracania œrub¹).
      : array of real; // SizeOf( Pointer ) = 4.

    artyleria_t,
    dzia³a_t,
    torpedy_wyrzutnie_t,
    artyleria_wygl¹d_t, // Mo¿e tylko wygl¹d wysy³aæ.
    dzia³a_wygl¹d_t,
    torpedy_wyrzutnie_wygl¹d_t
      : array of TObiekty_Wieloosobowe__Dzia³o_r; // SizeOf( Pointer ) = 4.

    radar_id_statki_w_zasiêgu,
    radio_id_statki_w_zasiêgu
      : TWieloosobowe_String;
  end;//---//TObiekty_Wieloosobowe__Statek_r

  TObiekty_Wieloosobowe__Statek_Klawisze_Obs³uga_r = record
    id_statek
    //cel_wspó³rzêdne__x,
    //cel_wspó³rzêdne__y,
    //cel_wspó³rzêdne__z
      : integer;
    klawisz : Word;
    shift : TShiftState; // Wygl¹da na to, ¿e poprawnie przesy³a ten zbiór wartoœci.
    mysz_przycisk : SmallInt; // Nie TMouseButton, gdy¿ w tym zbiorze nie ma stanu ‘brak’ (none).
    ar_artyleria,
    ar_pocisk,
    ar_torpeda,
    ar_wszystkie
      : boolean;
    cel_wspó³rzêdne : GLVectorGeometry.TVector;
    polecenie_nazwa : TWieloosobowe_String;
  end;//---//TObiekty_Wieloosobowe__Statek_Klawisze_Obs³uga_r

  TGra_Statystyki_r = record
    identyfikator,
    amunicja_wystrzelona_iloœæ,
    // amunicja trafia w amunicjê iloœæ //???
    taranowania_iloœæ, // W tym taranowania sojuszników.
    taranowania_iloœæ_sojuszników,
    trafienia,
    zatoniêcia,
    zatopienia, // W tym zatopienia sojuszników.
    zatopienia_sojuszników
      : integer;
    amunicja_wystrzelona_obra¿enia_zadawane, // Jakie maksymalne obra¿enia mog³a zadaæ wystrzelona amunicja.
    obra¿enia_otrzymane,
    obra¿enia_zadane_amunicja, // W tym obra¿enia zadane sojusznikom.
    obra¿enia_zadane_amunicja_sojusznikom,
    obra¿enia_zadane_taranowanie, // W tym obra¿enia zadane sojusznikom.
    obra¿enia_zadane_taranowanie_sojusznikom
      : real;
  end;//---//TGra_Statystyki_r

  TPokój_Rozmów_r = record
    id_nadawca,
    id_odbiorca
    //wiadomoœæ__d³ugoœæ
      : integer;
    odbiorca_rodzaj : TPokój_Rozmów__Odbiorca_Rodzaj;
    data_czas_wys³ania : TDateTime;
    wiadomoœæ : TWieloosobowe_String; //ShortString
    //wiadomoœæ : string;
    // Nie chce mi to dzia³aæ.
    // Strumieñ siê zapisuje i odczytuje poprawnie ale podczas odczytu po wys³aniu rekord, do którego wpisywane s¹ dane psuje siê
    // (zostaje okreœlony w debugerze jako niedostêpna wartoœæ [inaccessible value], a program podczas dzia³ania zg³asza b³¹d [access violation]).
  end;//---//TPokój_Rozmów_r

  TPokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj = class
    id_odbiorca : integer;
    odbiorca_rodzaj : TPokój_Rozmów__Odbiorca_Rodzaj;
  end;//---//TPokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj_

  TPokój_Rozmów_Powiadomienie = class( TIdNotify ) // uses IdSync.
  private
    pokój_rozmów_r : TPokój_Rozmów_r;
  protected
    procedure DoNotify(); override;
  end;//---//TPokój_Rozmów_Powiadomienie


  TKomunikacja_Rekord_Testowy_r = record
    liczba_ca³kowita : integer;
    liczba_rzeczywista : real;
    data_czas : TDateTime;
    napis_krótki : TWieloosobowe_String; //ShortString
  end;//---//TKomunikacja_Rekord_Testowy_r

  TKomunikacja_Rekord_Testowy_2_r = record
    liczba_ca³kowita : integer;
    liczba_rzeczywista : real;
    data_czas : TDateTime;
    napis : string;
  end;//---//TKomunikacja_Rekord_Testowy_2_r


  TSchematy_Lista_r = record
    id,
    nazwa,
    opis,
    plik_nazwa,
    treœæ
      : string; // string TWieloosobowe_String; //ShortString
  end;//---//TSchematy_Lista_r

  TSchematy_Lista_r_t = array of TSchematy_Lista_r;


  TPozycja_Pocz¹tkowa_Parametry_r = record
    korekta_obrót,
    korekta_x,
    korekta_z,
    odstêp_x,
    z
     : integer;
  end;//---//TPozycja_Pocz¹tkowa_Parametry_r

  TWygl¹d_Kolor_Definicja_r = record
    kolor_vector : GLVectorGeometry.TVector;
    kolor_definicja_nazwa : string;
  end;//---//TWygl¹d_Kolor_Definicja_r

  TKlawiatura_Konfiguracja_r = record
    klawisz : word;
    czy_mysz,
    mysz_niezdefiniowana,
    plus_alt,
    plus_ctrl,
    plus_shift
      : boolean;
    polecenie_nazwa : string;
  end;//---//TKlawiatura_Konfiguracja_r

  TStatek = class( TGLDummyCube )
  private
    { Private declarations }
    falowanie_bok_skrêt, // Iloœæ stopni wychylenia w bok z powodu skrêtu (aktualnego).
    falowanie_bok_skrêt_zakres, // Zakres maksymalny wychylenia z powodu skrêtu (aktualnego).
    falowanie_bok_zakres, // Iloœæ stopni wychylenia w jeden bok z powodu falowania.
    falowanie_bok_wychylenie_aktualne, // Zakres wychylenia w bok wyra¿any w stopniach od 0 do 360 dla funkcji sinus.

    falowanie_góra_dó³_zakres, // Wysokoœæ unoszenia (i obni¿ania) z powodu falowania.
    falowanie_góra_dó³_wysokoœæ_aktualna, // Zakres unoszenia (i obni¿ania) z powodu falowania wyra¿any w stopniach od 0 do 360 dla funkcji sinus.

    falowanie_przód_ruch, // Iloœæ stopni wychylenia w przód z powodu prêdkoœci ruchu (aktualnego).
    falowanie_przód_zakres, // Iloœæ stopni wychylenia w przód z powodu falowania.
    falowanie_przód_wychylenie_aktualne, // Zakres wychylenia w przód wyra¿any w stopniach od 0 do 360 dla funkcji sinus.

    prêdkoœæ_aktualna, // Aktualna prêdkoœæ statku (wynika z prêdkoœæ_wspó³czynnik * prêdkoœæ_procent).
    prêdkoœæ_maksymalna, // Jak szybko p³ynie.
    prêdkoœæ_obrotu_aktualna, // Aktualna prêdkoœæ obrotu statku.
    prêdkoœæ_ograniczenie, // Do jakiej wartoœci procentowej mo¿e zmieniaæ siê prêdkoœæ statku podczas kolizji (np. tryb gry, w którym elementy otoczenia przyœpieszaj¹ statek). Do 2`500.
    prêdkoœæ_procent, // Aktualny procent prêdkoœci (od -100 do 100).
    prêdkoœæ_przyspieszanie, // Jak szybko silnik modyfikuje prêdkoœæ.    
    prêdkoœæ_zadana_procent, // Zadany procent prêdkoœci (od -100 do 100).
    prêdkoœæ_zwalnianie, // Jak szybko statek (sam) zwalnia.
    prêdkoœæ__kolizja_zwalnianie, // Jak szybko statek zwalnia w wyniku kolizji; 1 - neutralna wartoœæ, 0 - 1 spowalnia 1 - 3 odbija (im wiêksza wartoœæ tym mocniej odbija).

    skrêt_k¹t_maksymalny,
    skrêt_procent, // Aktualny procent skrêtu (od -100 do 100).
    skrêt_szybkoœæ_wychylania_steru, // Jak szybko siê zmienia.
    skrêt_prêdkoœæ, // Jak szybko skrêca (zwrotnoœæ).
    skrêt_wspó³czynnik_do_prêdkoœci, // Do jakiego procentu osi¹gniêtej prêdkoœci spowalnia skrêcanie. Je¿eli wolno p³ynie to s³abiej skrêca np. dla parametru o wartoœci 25 dopiero gdy statek osi¹gnie prêdkoœæ 25% bêdzie skrêca³ z pe³n¹ wydajnoœci¹, przy mniejszej prêdkoœci (rozpêdzanie siê) wydajnoœæ skrêtu bêdzie s³absza.
    skrêt_zadany_procent, // Zadany procent skrêtu (od -100 do 100).

    toniêcie__obrót__lewo_prawo, // Jak szybko unosz¹ / obni¿aj¹ siê boki statku.
    toniêcie__obrót__przód_ty³, // Jak szybko unosi / obni¿a siê dziób / rufa.
    toniêcie__prêdkoœæ_w_dó³, // Jak szybko statek siê zanurza.

    punkty_¿ycia, // Aktualna iloœæ punktów ¿ycia.
    punkty_¿ycia_maksymalne, // £¹czna iloœæ punktów ¿ycia (tyle ma punktów je¿eli nie zosta³ uszkodzony).
    punkty_¿ycia_procent_zosta³o // Aktualna procentowa iloœæ punktów ¿ycia.
      : real;

    id_grupa,
    id_statek, // Jest taki sam jak identyfikator gracza.
    id_statek_schemat, // Indeks schematu wygl¹du statku.
    artyleria_ostatni_strza³_indeks, // Indeks artylerii, która ostatnio wystrzeli³a.
    dzia³o_ostatni_strza³_indeks, // Indeks dzia³a, które ostatnio wystrzeli³o.
    torpedy_wyrzutnia_ostatni_strza³_indeks, // Indeks wyrzutni torped, która ostatnio wystrzeli³a.

    falowanie_opóŸnienie, // Aby falowanie statków by³o asynchroniczne bêdzie siê rozpoczynaæ z ró¿nym opóŸnieniem.

    kamera_odleg³oœæ_maksymalna, // Maksymalna odleg³oœæ kamery od statku.
    luneta_zasiêg, // Maksymalny zasiêg przybli¿enia.
    radar_zasiêg, // Maksymalny zasiêg radaru.
    radio_zasiêg, // Maksymalny zasiêg radia.
    sonar_zasiêg // Maksymalny zasiêg sonaru (0 - nieaktywny).
      : integer;

    toniêcie__czas_i // Czas, w którym rozpoczê³o siê toniêcie.
      : int64;

    broñ_indeks_zmieniaj, // Po strzale nie przechodzi na kolejn¹ broñ z danej kategorii (rodzaju) tylko ci¹gle próbuje strzelaæ t¹ sama broni¹ (tym samym dzia³em).
    obracaj_dzia³a,
    obrót_k¹t_zablokowany_wskaŸnik_widoczne, // Aby przy wywo³ywaniu funkcji dostosowuj¹cej elementy gracza nie przechodzi³ przez pêtle broni gdy nic siê nie zmieni³o w tym zakresie ustawieñ.
    obrót_k¹t_zablokowany_strza³_wskaŸnik_widoczne, // Aby przy wywo³ywaniu funkcji dostosowuj¹cej elementy gracza nie przechodzi³ przez pêtle broni gdy nic siê nie zmieni³o w tym zakresie ustawieñ.
    podnoœ_lufy,
    czy_usun¹æ_statek //???
      : boolean;

    kamera_na_statek_pozycja, // W którym miejscu ma siê ustawiæ kamera po ustawieniu widoku ze statku.
    kamera_za_statkiem_pozycja // Przesuniêcie kamery po ustawieniu widoku za statkiem.
      : TWieloosobowe__Wektor_4;

    statki_rozstawianie_status : TStatki_Rozstawianie_Status; // Aby nie wykrywa³ kolizji ze statkami, które s¹ w trakcie rozstawiania.

    wygl¹d_elementy_list : TList; // Lista elementów wygl¹du statku.

    kolizja_oznaczenie_string_list : TStringList;

    falowanie_dummy, // Dla falowania i przechy³ów aby nie zak³ócaæ ruchu statku.
    punkty_¿ycia_dummy, // Kontener na wskaŸnik punktów ¿ycia.
    punkty_¿ycia_podniesienie // Aby przechylaæ góra dó³ wskaŸnik ¿ycia do kamery. //???
      : TGLDummyCube;

    dziób,
    kad³ub,
    punkty_¿ycia__ramka
      : TGLCube;

    punkty_¿ycia__wskaŸnik
      : TGLCylinder;

    gracz__nazwa,
    punkty_¿ycia__napis
      : TGLSpaceText; // uses GLSpaceText.

    artyleria_t,
    artyleria_wygl¹d_t // Falowanie zak³óca algorytm celowania wiêc dzia³a do strzelania nie bêd¹ falowaæ a te nie bêd¹ strzelaæ tylko bêd¹ ³adnie wygl¹daæ.
      : array of TArtyleria;
    dzia³a_t,
    dzia³a_wygl¹d_t
      : array of TDzia³o;
    torpedy_wyrzutnie_t,
    torpedy_wyrzutnie_wygl¹d_t
      : array of TTorpedy_Wyrzutnia;

    ster_t : array of TSter;
    œruby_t : array of TŒruba;

    celownicza_linia : TGLLines;

    radar_id_statki_w_zasiêgu, // Statki w zasiêgu radaru. '-99, -99' - gdy brak, '-99, 1, 2, 3, -99'.
    radio_id_statki_w_zasiêgu // Statki w zasiêgu radia. '-99, -99' - gdy brak, '-99, 1, 2, 3, -99'.
      : TWieloosobowe_String;
  public
    { Public declarations }
    constructor Create( AOwner : TGLBaseSceneObject; gl_collision_mmanager_f : TGLCollisionManager; const id_statek_f : integer; const wygl¹d_definicja_f : string; const prymitywy_lista_f : TSchematy_Lista_r_t );
    destructor Destroy(); override;

    function K¹t_Obrotu_Statku() : real;

    procedure Prêdkoœæ_Zadana_Procent_Zmieñ( const zmieñ_o_f : integer );
    procedure Skrêt_Zadany_Procent_Zmieñ( const zmieñ_o_f : integer );

    procedure Prêdkoœæ_Procent_Zmieñ();
    procedure Skrêt_Procent_Zmieñ();

    procedure Broñ_Indeks_Zmieniaj_Ustaw( const amunicja_rodzaj_zbiór_f : TAmunicja_Rodzaj_Zbiór ); overload;
    procedure Broñ_Indeks_Zmieniaj_Ustaw( const czy_poprzednia_f : boolean; const amunicja_rodzaj_zbiór_f : TAmunicja_Rodzaj_Zbiór ); overload;

    function Strza³( const amunicja_rodzaj_zbiór_f : TAmunicja_Rodzaj_Zbiór; const czy_wszystkie_bronie_f, czy_wszystkie_lufy_f, obracaj_dzia³a_f, podnoœ_lufy_f : boolean; const cel_wspó³rzêdne_f : TAffineVector ) : boolean;

    procedure Elementy_Gracza_Dostosuj( const id_grupa_gracza_f : integer; const punkty_¿ycia_wskaŸnik_widoczne__gracz_f, punkty_¿ycia_wskaŸnik_widoczne__przeciwnik_f, punkty_¿ycia_wskaŸnik_widoczne__sojusznik_f, obrót_k¹t_zablokowany_wskaŸnik_widoczne_f, obrót_k¹t_zablokowany_strza³_wskaŸnik_widoczne_f : boolean );
    procedure Elementy_Gracza_Widocznoœæ( const id_grupa_gracza_f : integer; const widoczne_f : boolean );

    procedure Punkty_¯ycia_Zmieñ( const wartoœæ_f : real );
    procedure Punkty_¯ycia_WskaŸnik_Rysuj( const gl_camera_f : TGLCamera; const wartoœæ_liczbowa_f : integer );

    function Parametry_Odczytaj( const dane_wszystkie_f : boolean = false ) : string;
  end;//---//TStatek

  TLufa = class( TGLDummyCube )
  private
    { Private declarations }    
    prze³adowanie_czas_milisekundy : integer;
    //strza³_czas : TDateTime;
    strza³_czas_i : int64; // Czas wystrzelenia (do liczenia okresu prze³adowania).
    amunicja_pobrana,
    strza³_gotowoœæ, // Czy jest prze³adowana.
    czy_indeks_do_strza³u_lufa, // Oznacza, ¿e ta lufa jest aktualnie ustawione do strza³ów pojedynczych.
    czy_wycelowane_podniesienie // Czy osi¹gniêto zadany kierunek celowania podniesienia.
      : boolean;

    dzia³o : TTorpedy_Wyrzutnia;

    amunicja_rodzaj : TAmunicja_Rodzaj; // Rodzaj amunicji dzia³a.

    statek : TStatek; // Statek, na którym umiejscowiony jest obiekt (mo¿e byæ potomkiem innego obiektu ale w ramach tego statku).

    podniesienie_szybkoœæ_modyfikator, // Aby lufy podnosi³y siê z ró¿nymi prêdkoœciami.
    prze³adowanie_wskaŸnik__dystans_do_przesuniêcia,
    prze³adowanie_wskaŸnik__pozycja_wycelowany_Y // Domyœlna wysokoœæ wskaŸnika prze³adowania (je¿eli lufa nie osi¹gnie wymaganego do strza³u k¹tu to wskaŸnik siê obni¿y).
      : real;
    prze³adowanie_wskaŸnik__pozycja_roz³adowany,
    prze³adowanie_wskaŸnik__pozycja_za³adowany
      : TAffineVector;

    korpus : TGLCylinder;

    prze³adowanie_wskaŸnik,
    wylot_pozycja
      : TGLSphere;
  public
    { Public declarations }
    constructor Create( ATorpedy_Wyrzutnia : TTorpedy_Wyrzutnia; AStatek : TStatek; gl_collision_mmanager_f : TGLCollisionManager ); // TGLSceneObject
    destructor Destroy(); override;

    procedure Dodatkowe_Elementy_Lufy_Pozycja_Ustaw();
    procedure Prze³adowanie( delta_czasu_f : double );
    function Strza³( const obracaj_dzia³a_f, podnoœ_lufy_f : boolean; const cel_wspó³rzêdne_f : TAffineVector ) : boolean; // obracaj_dzia³a_f
  end;//---//TLufa

  TTorpedy_Wyrzutnia = class( TGLDummyCube )
  private
    { Private declarations }
    obrót_kierunek_zadany : GLVectorGeometry.TVector; // uses GLVectorGeometry. //TGLCoordinates;

    obrót_k¹t_zadany,
    obrót_k¹t_zadany_bezwzglêdny, // Zadany k¹t obrotu z pominiêciem wszelkich zablokowanych zakresów.

    // Przez ten k¹t nie mo¿na obracaæ.
    // Opis jest analogiczny jak dla obrót_k¹t_zablokowany_strza³_do, obrót_k¹t_zablokowany_strza³_od.
    // Gdy obie wartoœci s¹ sobie równe k¹t zablokowany jest nieaktywny (nie ma k¹ta zablokowanego).
    obrót_k¹t_zablokowany_do, // 120, -50
    obrót_k¹t_zablokowany_od, // 50, -120

    obrót_szybkoœæ, // Jak szybko siê zmienia.

    celownik_linia_szerokoœæ_obrót, // Jaka szerokoœæ linii celowania zosta³a ustalona na podstawie wycelowania obrotu broni.
    skala, // Wielkoœæ dzia³a.
    obra¿enia_zadawane,
    zasiêg
      : real;

    //indeks_w_tabeli,
    amunicja_iloœæ,
    lufa_ostatni_strza³_indeks, // Indeks lufy, która ostatnio wystrzeli³a.    
    prze³adowanie_czas_milisekundy, // Powinien byæ wiêkszy równy strza³_od_blokada_milisekundy, gdy¿ po strzale, gdy ma zadany inny k¹t obrotu ale nie mo¿e siê jeszcze obracaæ, po prze³adowaniu strzela i nadal blokuje obrót (obrót jest ci¹gle zablokowany i strzela w dawnym kierunku).
    strza³y_iloœæ // Iloœæ oddanych strza³ów, zeruje siê gdy iloœæ strza³ów równa siê iloœci luf.
      : integer;

    czy_indeks_do_strza³u, // Oznacza, ¿e to dzia³o jest aktualnie ustawione do strza³ów pojedynczych.
    //czy_lufa_podnoszona, // Czy lufa rusza siê góra dó³. // Nie wiem czy dobrze rozpoznaje jakiej klasy jest dzia³o.
    czy_wycelowany_obrót, // Czy osi¹gniêto zadany kierunek celowania obrótu.
    czy_usun¹æ_torpedy_wyrzutnia //???
      : boolean;

    //strza³_czas : TDateTime;
    strza³_czas_i, // Czas ostatniego wystrza³u.
    strza³_od_blokada_milisekundy // Ile milisekund od wystrza³u blokuje ruch dzia³a.
      : int64;

    // Wewn¹trz tych k¹tów nie mo¿na strzelaæ.
    // Obie tabela maj¹ taki sam wymiar.
    // Patrz¹c od ty³u w przód statku k¹t (TurnAngle) wynosi 0, po lewej stronie jest dodatni, po prawej stronie jest ujemny, patrz¹c w ty³ wynosi 180.
    // Zgodnie z ruchem wskazówek zegara obrót_k¹t_zablokowany_strza³_od ma byæ przed obrót_k¹t_zablokowany_strza³_do.
    // Je¿eli zakres zablokowanego k¹ta przechodzi przez œrodek rufy obrót_k¹t_zablokowany_strza³_od jest ujemny, a obrót_k¹t_zablokowany_strza³_do jest dodatni.
    obrót_k¹t_zablokowany_strza³_do, // -90, 170
    obrót_k¹t_zablokowany_strza³_od // 50, -170
      : array of real;

    amunicja_rodzaj : TAmunicja_Rodzaj; // Rodzaj amunicji dzia³a.

    statek : TStatek; // Statek, na którym umiejscowiony jest obiekt (mo¿e byæ potomkiem innego obiektu ale w ramach tego statku).

    elementy_wizualne_dummy, // Kontener na elementy wizualne dzia³a.
    k¹t_test
      : TGLDummyCube;

    korpus_przód,
    podstawa
      : TGLCylinder;
    korpus
      : TGLCube;
    lufy_t : array of TLufa;
    celownik_linia,
    celownik_linia_bez_falowania // Dla du¿ych zasiêgów koniec linii ruchomej w sporym zakresie faluje i mo¿e go byæ nie widaæ oraz trudno okreœliæ zasiêg.
      : TGLLines;

    obrót_k¹t_zablokowany_GLDisk : TGLDisk; // Wizualizuje obszar zablokowanego k¹ta obrotu.
    obrót_k¹t_zablokowany_strza³_GLDisk_t : array of TGLDisk; // Wizualizuje obszar zablokowanego k¹ta obrotu.

    dzia³o_strzelaj¹ce : TTorpedy_Wyrzutnia; // Je¿eli obiekt jest dzia³em ³adnie wygl¹daj¹cym to to wskazuje na dzia³o strzelaj¹ce, którego wygl¹d ma odwzorowywaæ.
  public
    { Public declarations }
    constructor Create( AOwner : TGLBaseSceneObject; AStatek : TStatek; gl_collision_mmanager_f : TGLCollisionManager; const lufy_iloœæ_f : integer );
    destructor Destroy(); override;

    procedure Dodatkowe_Elementy_Ustaw();
    procedure Parametry_Kopiuj_Dla_Wygl¹d( const ATorpedy_Wyrzutnia : TTorpedy_Wyrzutnia );
    procedure Parametry_Aktualizuj_Dla_Wygl¹du();

    function Obrót_K¹t_Zablokowany_SprawdŸ( k¹t_f : real ) : boolean;
    procedure Obrót_Zadany_Zmieñ( const celownik_linia_widocznoœæ_f : boolean = true );
    procedure Obrót_Kierunek_Zmieñ( const celowanie_precyzja_obrót_f : real; const broñ_nie_unosi_luf_f : boolean = false );

    function Strza³( const czy_wszystkie_lufy_f, obracaj_dzia³a_f, podnoœ_lufy_f : boolean; var wystrzeli³y_wszystkie_f : boolean; const cel_wspó³rzêdne_f : TAffineVector  ) : boolean;
    function Obrót_K¹t_Zablokowany_Strza³u_SprawdŸ() : boolean; overload;
    function Obrót_K¹t_Zablokowany_Strza³u_SprawdŸ( k¹t_f : real; const indeks_f : integer ) : boolean; overload;

    procedure Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( const celownik_linia_widocznoœæ_f : boolean = true );

    function Parametry_Odczytaj( const odstêp_f : string; const dane_wszystkie_f : boolean = false ) : string;
  end;//---//TTorpedy_Wyrzutnia

  TDzia³o = class( TTorpedy_Wyrzutnia )
  private
    { Private declarations }
    cofanie_wystrza³_odleg³oœæ,
    cofanie_wystrza³_pozycja_pocz¹tkowa,

    podniesienie_k¹t_maksymalny,
    podniesienie_k¹t_minimalny,
    podniesienie_k¹t_zadany, // Zadany k¹t podniesienia.
    podniesienie_k¹t_zadany_bezwzglêdny, // Zadany k¹t podniesienia nie ograniczany zakresem k¹ta maksymalnym i minimalnym.
    podniesienie_szybkoœæ // Jak szybko siê zmienia.
      : real;

    czy_lot_parabol¹ : boolean; // Pocisk leci po paraboli a nie wed³ug swojego kierunku.

    korpus_przód : TGLCube;
  public
    { Public declarations }
    constructor Create( AOwner : TGLBaseSceneObject; AStatek : TStatek; gl_collision_mmanager_f : TGLCollisionManager; const lufy_iloœæ_f : integer; const lufy_podniesienie_k¹t_f : real );
    destructor Destroy(); override;

    procedure Podniesienie_Zadane_Zmieñ( const celownik_linia_widocznoœæ_f : boolean = true );
    procedure Podniesienie_Kierunek_Zmieñ( const celowanie_precyzja_podniesienie_f : real );

    procedure Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( const celownik_linia_widocznoœæ_f : boolean = true );

    function Parametry_Odczytaj( const odstêp_f : string; const dane_wszystkie_f : boolean = false ) : string;
  end;//---//TDzia³o

  TArtyleria = class( TDzia³o )
  private
    { Private declarations }
    zasiêg_od_parabola // Zasiêg, od którego celowanie nie odbywa siê w punkt tylko poprzez podniesienie lufy.
      : real;
    function Parametry_Odczytaj( const odstêp_f : string; const dane_wszystkie_f : boolean = false ) : string;  
  public
    { Public declarations }
    constructor Create( AOwner : TGLBaseSceneObject; AStatek : TStatek; gl_collision_mmanager_f : TGLCollisionManager; const lufy_iloœæ_f : integer; const lufy_podniesienie_k¹t_f : real );
  end;//---//TArtyleria

  TAmunicja = class( TGLDummyCube )
  private
    { Private declarations }
    id_statek : integer; // Jest taki sam jak identyfikator gracza.
    id_amunicja : cardinal;

    cel_odleg³oœæ, // Odleg³oœæ od lufy do celu (przy zablokowanym podnoszeniu luf jest liczony wed³ug procentu uniesienia lufy i zasiêgu dzia³a).
    //dzia³o_podniesienie_k¹t_maksymalny, // Wysokoœæ i obrót dla ruchu parabol¹ - wersja 2.
    dzia³o_podniesienie_procent_k¹ta_maksymalnego, // Jaki procent z maksymalnego uniesienia luf mia³o ustawione dzia³o podczas strzelania.
    obra¿enia_zadawane,
    obra¿enia_zadawane_wspó³czynnik, // Modyfikuje obra¿enia zadawane poza skutecznym zasiêgiem (wartoœæ aktualna).
    obra¿enia_zadawane_wspó³czynnik_zmodyfikowany, // Modyfikuje obra¿enia zadawane poza skutecznym zasiêgiem.
    opadanie_obrót_korekta_o_k¹t_na_granicy_zasiêgu, // Koryguje obracanie amunicji o wartoœæ k¹ta w momencie wykraczania poza zasiêg aby podczas opadania obraca³a siê do pozycji pionowo w dó³.
    opadanie_obrót_korekta_o_ustawienie_pocz¹tkowe, // Koryguje obracanie amunicji o pocz¹tkowy k¹t lotu aby podczas opadania obraca³a siê do pozycji pionowo w dó³.
    //parabola_k¹t_lotu_pocz¹tkowy, // Wysokoœæ i obrót dla ruchu parabol¹ - wersja 1.
    //parabola_k¹t_lotu_wspó³czynnik, // Podczas strza³u ma k¹t lufy i wraz z dystansem bêdzie siê zmieniaæ o ten wspó³czynnik tak aby przy celu k¹t by³ 80 stopni (w dó³ s¹ stopnie dodatnie).  // Wysokoœæ i obrót dla ruchu parabol¹ - wersja 1.
    //parabola_równanie__a, // Parametry równania paraboli w postaci y = a * x^2 + b * x + c
    //parabola_równanie__b,
    //parabola_równanie__c,
    prêdkoœæ,
    prêdkoœæ_opadania,
    prêdkoœæ_opadania_wspó³czynnik, // Jak szybko przyrasta prêdkoœæ opadania.
    prêdkoœæ_pocz¹tkowa,
    prêdkoœæ_wytracanie_wspó³czynnik, // Jak szybko wytraca prêdkoœæ poza zasiêgiem skutecznym.
    skala, // Dzia³o mo¿e byæ skalowane. Utworzony pocisk jako potomek dzia³a przejmuje skalowanie dzia³a ale nastêpnie staje siê potomkiem sceny i skala dzia³a przestaje dotyczyæ pocisku a powinna byæ zachowana.
    strza³_od_blokada_dystans, // W jakiej odleg³oœci od wystrza³u (lufy) przesuwa i obraca amunicjê razem ze statkiem.
    statek_prêdkoœæ, // Prêdkoœæ statku w momencie strza³u, po opuszczeniu lufy jest zmniejszana do zera.
    zanurzenie_g³êbokoœæ_po_wpadniêciu_do_wody, // Do jakiej g³êbokoœci siê zanurzy po wpadniêciu do wody.
    zanurzenie_g³êbokoœæ_zadana, // Na jakiej g³êbokoœci ma p³yn¹æ.
    zasiêg // Zasiêg amunicji (mo¿e byæ trochê d³u¿szy od wyœwietlanej linii gdy¿ jest liczony od koñca lufy a nie od œrodka dzia³a).
      : real;

    czy_efekt_wpadniêcia_do_wody, // Czy wyœwietlono efekt (pierwszego) wpadniêcia do wody.
    czy_lot_parabol¹, // Pocisk leci po paraboli a nie wed³ug swojego kierunku.
    czy_pod_wod¹, // Znajduje siê poni¿ej linii wody (ustawiane na true przy pierwszym wpadniêciu do wody).
    czy_poza_luf¹, // Amunicja opuœci³a lufê (aby detekcja kolizji nie wykrywa³a kontaktu z luf¹).
    czy_poza_zasiêgiem, // Je¿eli w wyniku opadania amunicja znajdzie siê znów w zasiêgu ma byæ nadal traktowana jako poza zasiêgiem.
    //czy_statek_dane, // Czy odczytano dane ze statku, z którego wystrzelono amunicjê.
    czy_usun¹æ_amunicja,
    czy_uzbrojona,
    czy_wynurzanie // Po odpaleniu zanurzy siê pod wodê i wyp³ynie na powierzchniê.
      : boolean;

    amunicja_rodzaj : TAmunicja_Rodzaj; // Rodzaj amunicji dzia³a.

    dzia³o_pozycja_absolutna_vector : GLVectorGeometry.TVector;

    // TAmunicja TGLDummyCube -  porusza siê w linii strza³u (tylko w przód, nie obraca siê, nie obni¿a ani nie wznosi; jedynie je¿eli wynika to ze skoœnego tor lotu - wznosz¹cego lub opadaj¹cego).
    //                             Dla torped przesuwa siê w linii wody.
    korpus_opadanie_obrót_dummy, // Dla obrotu opadania (góra dó³).
    korpus_ustawienie_pocz¹tkowe_dummy, // Zapamiêtuje jak pocz¹tkowo by³a ustawiona amunicja (wychylenia).
    torpeda_efekt_na_wodzie // Aby torpeda by³a widoczna na powierzchni wody.
      : TGLDummyCube;

    korpus : TGLCylinder;
    czubek :  TGLCone;

    pozycja_celu, // Istotne dla lotu parabol¹, wyliczane na podstawie zasiêgu i procentu uniesienia luf wzglêdem maksymalnego uniesienia luf.
    pozycja_startowa, // Dla lotu parabol¹ jest od pozycji dzia³a, dla lotu zwyk³ego od koñca lufy.
    pozycja_woda // Odwzorowanie pozycji amunicji na powierzchni (mniej wiêcej) wody, wysokoœci dzia³a.
      : TGLSphere;

    statek : TStatek; // Statek, z którego wystrzelono amunicjê.
  public
    { Public declarations }
    constructor Create( AOwner : TGLBaseSceneObject; ALufa : TLufa; const obracaj_dzia³a_f : boolean; cel_wspó³rzêdne_f : TAffineVector; gl_collision_mmanager_f : TGLCollisionManager ); overload;
    //constructor Create( AAmunicja : TAmunicja ); overload; //Konstruktor kopiuj¹cy klasy TAmunicja.
    constructor Create( AObiekty_Wieloosobowe_Amunicja_r : TObiekty_Wieloosobowe__Amunicja_r; AOwner : TGLBaseSceneObject ); overload;
    destructor Destroy(); override;
  end;//---//TAmunicja

  TSter = class( TGLDummyCube )
  private
    { Private declarations }
    ster : TGLCube;
    ster_mocowanie : TGLCylinder;
  public
    { Public declarations }
    constructor Create( AOwner : TGLBaseSceneObject; gl_collision_mmanager_f : TGLCollisionManager; x_f, y_f, z_f : real );
    destructor Destroy(); override;
  end;//---//TSter

  TŒruba = class( TGLDummyCube )
  private
    { Private declarations }
    prêdkoœæ_obrotowa_aktualna_procent,
    prêdkoœæ_obrotowa_maksymalna, // Ca³kiem dobrze wychodzi gdy [œruba] prêdkoœæ_obrotowa_maksymalna / prêdkoœæ_obrotowa_przyspieszanie = [statek] prêdkoœæ_maksymalna / prêdkoœæ_przyspieszanie.
    prêdkoœæ_obrotowa_przyspieszanie // Jak szybko œruba modyfikuje prêdkoœæ obrotów.
      : real;

    czy_obrót_lewo : boolean; // Œruba obraca siê w lewo (góra œruby patrz¹c od ty³u statku).

    obrót_dummy : TGLDummyCube;

    wa³,
    wa³_³o¿ysko, // £¹czy podpórkê z wa³em.
    wa³_mocowanie, // Przez nie wychodzi wa³ z kad³uba.
    wa³_podpórka, // Podpórka przed œrub¹.
    wa³_do_wirnika // Z ³o¿yska do wirnika.
      : TGLCylinder;

    wirnik_œrodek : TGLSphere;

    wirnik_³opaty_t : array of TGLCone;

    statek : TStatek; //??? // Statek, z którego wystrzelono amunicjê.

  public
    { Public declarations }
    constructor Create( AOwner : TGLBaseSceneObject; AStatek : TStatek; const czy_obrót_lewo_f : boolean; gl_collision_mmanager_f : TGLCollisionManager );
    destructor Destroy(); override;

    procedure Œruba_Obracaj();
  end;//---//TŒruba

  TTrafienia_Efekt = class( TGLDummyCube )
  private
    { Private declarations }
    czas_trwania, // Ile milisekund efekt trwa (widaæ go).
    czas_utworzenia // Czas utworzenia efektu (od niego odmierza siê czas trwania).
      : Int64;
  public
    { Public declarations }
    constructor Create( AOwner : TGLBaseSceneObject; x_f, y_f, z_f : real );
    destructor Destroy(); override;
  end;//---//TTrafienia_Efekt

  TInformacje_Dodatkowe = class
    wyœwietlanie_czas_sekund : smallint;
    utworzenie_data_czas : TDateTime;
    napis : string;
  public
    constructor Create( const napis_f : string = '' ); overload;
    constructor Create( const napis_f : string; const wyœwietlanie_czas_sekund_f : smallint ); overload;
  end;//---//TInformacje_Dodatkowe

  TKlawisz_Konfiguracja = class( TPanel )
  private
    klawiatura_konfiguracja_r_w : ^TKlawiatura_Konfiguracja_r;
    domyœlna_konfiguracja_r : TKlawiatura_Konfiguracja_r;
    Polecenie_Nazwa_Label : TLabel;
    Klawisz_Edit : TEdit;
    Domyœlny_Button,
    Niezdefiniowane_Button
      : TButton;
    Czy_Mysz_CheckBox,
    Plus_Alt_CheckBox,
    Plus_Ctrl_CheckBox,
    Plus_Shift_CheckBox
      : TCheckBox;
  public
    constructor Create( AOwner : TComponent; pointer_f : Pointer );
    destructor Destroy(); override; // Bez override; siê nie wywo³uje (jedynie tak siê wywo³a wygl¹d_kolor_definicja.Destroy()).
  private
    function Nazwa_Klawisza() : string;
    procedure Check_Box_Click( Sender : TObject );
    procedure Edit_Exit( Sender : TObject );
    procedure Edit_Key_Down( Sender : TObject; var Key : Word; Shift : TShiftState );
    procedure Edit_Mouse_Down( Sender : TObject; Button : TMouseButton; Shift : TShiftState; X, Y : Integer );
    procedure Domyœlny_Button_Click( Sender : TObject );
    procedure Niezdefiniowane_Button_Click( Sender : TObject );
    procedure Panel_Mouse_Enter( Sender : TObject );
    procedure Panel_Mouse_Leave( Sender : TObject );
  end;//---//TKlawiatura_Konfiguracja

  TWygl¹d_Kolor_Definicja = class
    wygl¹d_kolor_definicja_t : array of TWygl¹d_Kolor_Definicja_r;
  public
    { Public declarations }
    constructor Create();
    destructor Destroy(); override; // Bez override; siê nie wywo³uje (jedynie tak siê wywo³a wygl¹d_kolor_definicja.Destroy()).

    function Definicja_Istnieje( const kolor_definicja_nazwa_f : string ) : boolean;
    procedure Dodaj_Definicjê( const czerwony_f, zielony_f, niebieski_f, przezroczystoœæ_f : real; const kolor_definicja_nazwa_f : string );
    function Odczytaj_Definicjê( const kolor_definicja_nazwa_f : string ) : GLVectorGeometry.TVector;
  end;//---//TWygl¹d_Kolor_Definicja


  TStatki_Form = class( TForm )
    Gra_GLSceneViewer: TGLSceneViewer;
    Gra_GLScene: TGLScene;
    Gra_GLCadencer: TGLCadencer;
    Gra_GLUserInterface: TGLUserInterface;
    Gra_GLNavigator: TGLNavigator;
    Gra_GLLightSource: TGLLightSource;
    Gra_GLCamera: TGLCamera;
    Zero_GLSphere: TGLSphere;
    X_Lewo_GLCube: TGLCube;
    Z_Ty³_GLCone1: TGLCone;
    Woda_GLPlane: TGLPlane;
    Informacje_G³ówne_GLHUDText: TGLHUDText;
    Gra_GLWindowsBitmapFont: TGLWindowsBitmapFont;
    GLSkyDome1: TGLSkyDome;
    GLLines1: TGLLines;
    GLLines2: TGLLines;
    GLLines3: TGLLines;
    Celownicza_GLSphere: TGLSphere;
    Celowniczy_GLDummyCube: TGLDummyCube;
    GLWaterPlane1: TGLWaterPlane;
    Czas_Bezwzglêdny_Timer: TTimer;
    IdTCPServer1: TIdTCPServer;
    IdTCPClient1: TIdTCPClient;
    Klient_IdTCP_Czyta_Timer: TTimer;
    Wieloosobowe__Tryb_RadioGroup: TRadioGroup;
    Serwer_Wysy³a_Timer: TTimer;
    Log_Memo: TMemo;
    Button1: TButton;
    Gra_GLCollisionManager: TGLCollisionManager;
    GLCollisionManager2: TGLCollisionManager;
    Efekt__Wpadniêcie_Do_Wody_0_GLFireFXManager: TGLFireFXManager;
    Efekt__Wpadniêcie_Do_Wody_GLPolygonPFXManager: TGLPolygonPFXManager;
    GLParticleFXRenderer1: TGLParticleFXRenderer;
    Woda_Kolizje_GLCube: TGLCube;
    Efekt__Ogieñ_GLFireFXManager: TGLFireFXManager;
    Efekt__Dym_GLPerlinPFXManager: TGLPerlinPFXManager;
    Efekt__Mg³a_GLPerlinPFXManager: TGLPerlinPFXManager;
    Efekt__Smuga_GLPerlinPFXManager: TGLPerlinPFXManager;
    IdUDPServer1: TIdUDPServer;
    IdUDPClient1: TIdUDPClient;
    Klient_IdUDP_Czyta_Timer: TTimer;
    Gra_Obiekty_GLDummyCube: TGLDummyCube;
    GLArrowLine_¯ó³ta: TGLArrowLine;
    GLArrowLine_Zielona: TGLArrowLine;
    Dno_GLPlane: TGLPlane;
    Dno_Kolizje_GLCube: TGLCube;
    PageControl1: TPageControl;
    Log_TabSheet: TTabSheet;
    Opcje_Pionowy_Splitter: TSplitter;
    Wieloosobowe_TabSheet: TTabSheet;
    Gra_TabSheet: TTabSheet;
    L¹d_GroupBox: TGroupBox;
    L¹d_ComboBox: TComboBox;
    L¹d__Wczytaj_Listê_BitBtn: TBitBtn;
    L¹d_Opis_Memo: TMemo;
    L¹d__Odœwie¿_Wskazany_BitBtn: TBitBtn;
    Statek_GroupBox: TGroupBox;
    Statek_ComboBox: TComboBox;
    Statek__Wczytaj_Listê_BitBtn: TBitBtn;
    Statek_Opis_Memo: TMemo;
    Statek__Odœwie¿_Wskazany_BitBtn: TBitBtn;
    L¹d__Utwórz_BitBtn: TBitBtn;
    Statek__Utwórz_BitBtn: TBitBtn;
    Gra_Wspó³czynnik_Prêdkoœci_SpinEdit: TSpinEdit;
    Gra_Wspó³czynnik_Prêdkoœci_Etykieta_Label: TLabel;
    Wieloosobowe__Pod³¹cz_BitBtn: TBitBtn;
    Wieloosobowe__Od³¹cz_BitBtn: TBitBtn;
    Wieloosobowe_GroupBox: TGroupBox;
    Pokój_Rozmów_GroupBox: TGroupBox;
    Pokój_Rozmów_Memo: TMemo;
    Pokój_Rozmów_Przyciski_Panel: TPanel;
    Pokój_Rozmów_Wiadomoœæ_Edit: TEdit;
    Pokój_Rozmów__Wyœlij_Wiadomoœæ_Button: TButton;
    Wieloosobowe_Identyfikator_Etykieta_Label: TLabel;
    Wieloosobowe_Identyfikator_Edit: TEdit;
    Pozosta³e_TabSheet: TTabSheet;
    Gracze_Lista_GroupBox: TGroupBox;
    Gracze_Lista_StringGrid: TStringGrid;
    Gracz_Nazwa_Etykieta_Label: TLabel;
    Gracz_Nazwa_Edit: TEdit;
    Gracz_Grupa_Etykieta_Label: TLabel;
    Gracz_Grupa_SpinEdit: TSpinEdit;
    Gracz_Gotowoœæ_Tak_BitBtn: TBitBtn;
    Gracz_Gotowoœæ_Nie_BitBtn: TBitBtn;
    Serwer_Klient_Od³¹czenie_Timer: TTimer;
    Gracze_Lista_Odœwie¿_BitBtn: TBitBtn;
    Gracze_Lista_Roz³¹cz_Gracza_BitBtn: TBitBtn;
    Mapa_Label: TLabel;
    Gracz_Dane_GroupBox: TGroupBox;
    SI_GroupBox: TGroupBox;
    SI__Statek_ComboBox: TComboBox;
    SI__Dodaj_BitBtn: TBitBtn;
    SI__Nazwa_Etykieta_Label: TLabel;
    SI__Grupa_Etykieta_Label: TLabel;
    SI__Nazwa_Edit: TEdit;
    SI__Grupa_SpinEdit: TSpinEdit;
    Serwer_Adres_IP_Etykieta_Label: TLabel;
    Serwer_Adres_IP_Edit: TEdit;
    Serwer_Port_SpinEdit: TSpinEdit;
    Serwer_Port_Etykieta_Label: TLabel;
    Has³o_Edit: TEdit;
    Has³o_Etykieta_Label: TLabel;
    Klient_Wysy³a_Timer: TTimer;
    Projektowy_Tryb_CheckBox: TCheckBox;
    Radar_Timer: TTimer;
    Radar_Skala_Etykieta_Label: TLabel;
    Radar_Skala_SpinEdit: TSpinEdit;
    Radar_Przyciski_Panel: TPanel;
    Radar_Panel: TPanel;
    Radar_Powiêksz_Button: TButton;
    Radar_Pomniejsz_Button: TButton;
    Statek__Opis_BitBtn: TBitBtn;
    Radar_Dane_Z_Radia_CheckBox: TCheckBox;
    Ustawienia_TabSheet: TTabSheet;
    Kamera_Odleg³oœæ_Maksymalna_Etykieta_Label: TLabel;
    Kamera_Odleg³oœæ_Maksymalna_SpinEdit: TSpinEdit;
    Punkty_¯ycia_WskaŸnik__Gracz_CheckBox: TCheckBox;
    Statki_Pozycje_Pocz¹tkowe_GroupBox: TGroupBox;
    Statki_Pozycje_Pocz¹tkowe_ComboBox: TComboBox;
    Statki_Pozycje_Pocz¹tkowe__Wczytaj_Listê_BitBtn: TBitBtn;
    Statki_Pozycje_Pocz¹tkowe_Opis_Memo: TMemo;
    Statki_Pozycje_Pocz¹tkowe__Odœwie¿_Wskazany_BitBtn: TBitBtn;
    Statki_Pozycje_Pocz¹tkowe_Label: TLabel;
    Statki_Pozycje_Pocz¹tkowe__Brak_BitBtn: TBitBtn;
    Mysz_Czu³oœæ_Etykieta_Label: TLabel;
    Mysz_Czu³oœæ_Edit: TEdit;
    Mysz_Czu³oœæ_Label: TLabel;
    Mysz_Czu³oœæ_Luneta_Etykieta_Label: TLabel;
    Mysz_Czu³oœæ_Luneta_Edit: TEdit;
    Mysz_Czu³oœæ_Luneta_Label: TLabel;
    Dalmierz_CheckBox: TCheckBox;
    Amunicja__Cel_Pozycja_Dla_Lotu_Parabol¹_Wyœwietl_CheckBox: TCheckBox;
    Amunicja__Zanurzenie_G³êbokoœæ_Zadana_Edit: TEdit;
    Amunicja__Zanurzenie_G³êbokoœæ_Zadana_Etykieta_Label: TLabel;
    Amunicja__Zanurzenie_G³êbokoœæ_Zadana_Label: TLabel;
    Amunicja_Rodzaj_GroupBox: TGroupBox;
    ar_Artyleria_CheckBox: TCheckBox;
    ar_Pocisk_CheckBox: TCheckBox;
    ar_Torpeda_CheckBox: TCheckBox;
    ar_Wszystkie_CheckBox: TCheckBox;
    L¹d__Komunikat_B³êdu_Pomiñ_CheckBox: TCheckBox;
    Statek__Komunikat_B³êdu_Pomiñ_CheckBox: TCheckBox;
    Obrót_K¹t_Zablokowany_WskaŸnik_CheckBox: TCheckBox;
    Celowanie_Tryb_RadioGroup: TRadioGroup;
    Statki_Zaprezentuj_GroupBox: TGroupBox;
    Statki_Zaprezentuj__Pozycja_Pocz¹tkowa__X_SpinEdit: TSpinEdit;
    Statki_Zaprezentuj__Pozycja_Pocz¹tkowa__Y_SpinEdit: TSpinEdit;
    Statki_Zaprezentuj__Pozycja_Pocz¹tkowa__Z_SpinEdit: TSpinEdit;
    Statki_Zaprezentuj__Odstêpy_Miêdzy_Statkami_SpinEdit: TSpinEdit;
    Statki_Zaprezentuj__Pozycja_Pocz¹tkowa_Etykieta_Label: TLabel;
    Statki_Zaprezentuj__Pozycja_Pocz¹tkowa__X_Etykieta_Label: TLabel;
    Statki_Zaprezentuj__Pozycja_Pocz¹tkowa__Y_Etykieta_Label: TLabel;
    Statki_Zaprezentuj__Pozycja_Pocz¹tkowa__Z_Etykieta_Label: TLabel;
    Statki_Zaprezentuj__Odstêpy_Miêdzy_Statkami_Etykieta_Label: TLabel;
    Statki_Zaprezentuj__Kolumna_CheckBox: TCheckBox;
    Statki_Zaprezentuj_Button: TButton;
    Statki_Zaprezentuj__Zwolnij_BitBtn: TBitBtn;
    Ustawienia_Wczytaj_Button: TButton;
    Ustawienia_Zapisz_Button: TButton;
    Kamera_Szybkoœæ_Ruchu_Etykieta_Label: TLabel;
    Kamera_Szybkoœæ_Ruchu_Label: TLabel;
    Kamera_Szybkoœæ_Ruchu_Edit: TEdit;
    Punkty_¯ycia_WskaŸnik__Przeciwnik_CheckBox: TCheckBox;
    Punkty_¯ycia_WskaŸnik__Sojusznik_CheckBox: TCheckBox;
    Klawiatura_Konfiguracja_TabSheet: TTabSheet;
    Klawiatura_Konfiguracja__Przyciski_Panel: TPanel;
    Klawiatura_Konfiguracja__Zapisz_Button: TButton;
    Klawiatura_Konfiguracja__Wczytaj_Button: TButton;
    Klawiatura_Konfiguracja__Domyœlna_Button: TButton;
    Klawiatura_Konfiguracja_ScrollBox: TScrollBox;
    Klawiatura_Konfiguracja__Niepowtarzalnoœæ_SprawdŸ_Button: TButton;
    Amunicja__Zanurzenie_G³êbokoœæ_Zadana__Skok_O_Etykieta_Label: TLabel;
    Amunicja__Zanurzenie_G³êbokoœæ_Zadana__Skok_O_Label: TLabel;
    Amunicja__Zanurzenie_G³êbokoœæ_Zadana__Skok_O_Edit: TEdit;
    Klawiatura_Konfiguracja__Konfiguracja_Numer_SpinEdit: TSpinEdit;
    Klawiatura_Konfiguracja__Rozmiar_Zak³adki_Poszerz_CheckBox: TCheckBox;
    Informacje_Dodatkowe_GLHUDText: TGLHUDText;
    Informacje_Dodatkowe_Timer: TTimer;
    Pokój_Rozmów__Informacja_Dodatkowa_CheckBox: TCheckBox;
    Ustawienia_Panel: TPanel;
    Ustawienia_ScrollBox: TScrollBox;
    Wieloosobowe_Gra_GroupBox: TGroupBox;
    Gra_Uruchamianie_Panel: TPanel;
    Gra_Rozpocznij_BitBtn: TBitBtn;
    Gra_Zakoñcz_BitBtn: TBitBtn;
    Wieloosobowe_Identyfikator_Gra_Etykieta_Label: TLabel;
    Wieloosobowe_Identyfikator_Gra_Label: TLabel;
    Pokój_Rozmów__Na_Ekranie_CheckBox: TCheckBox;
    Pokój_Rozmów__Ukryj_Button: TButton;
    Celowanie_Precyzja_Obrót_Etykieta_Label: TLabel;
    Celowanie_Precyzja_Obrót_SpinEdit: TSpinEdit;
    Celowanie_Precyzja_Podniesienie_Etykieta_Label: TLabel;
    Celowanie_Precyzja_Podniesienie_SpinEdit: TSpinEdit;
    Pokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj_ComboBox: TComboBox;
    Wieloosobowe_ScrollBox: TScrollBox;
    Gra_ScrollBox: TScrollBox;
    O_Programie_TabSheet: TTabSheet;
    O_Programie_Label: TLabel;
    Celownik_Wielkoœæ_Etykieta_Label: TLabel;
    Celownik_Wielkoœæ_Label: TLabel;
    Celownik_Wielkoœæ_Edit: TEdit;
    Celownik_Widocznoœæ_CheckBox: TCheckBox;
    Celownik_Widocznoœæ_Mouse_Look_Active_CheckBox: TCheckBox;
    Radar_Widocznoœæ_CheckBox: TCheckBox;
    Obrót_K¹t_Zablokowany_Strza³_WskaŸnik_CheckBox: TCheckBox;
    Pe³ny_Ekran_CheckBox: TCheckBox;
    Morze_Wzburzenie_Etykieta_Label: TLabel;
    Morze_Wzburzenie_SpinEdit: TSpinEdit;
    Statystyki_Wypisz_Button: TButton;
    Radar_GLSceneViewer: TGLSceneViewer;
    Radar_GLScene: TGLScene;
    Radar_GLCamera: TGLCamera;
    Radar_0_GLSphere: TGLSphere;
    Radar_GLLightSource: TGLLightSource;
    Radar_Obiekty_GLDummyCube: TGLDummyCube;
    Radar_T³o_GLPlane: TGLPlane;
    Radar_Statek_GLFrustrum: TGLFrustrum;
    Radar_Statek_GLDummyCube: TGLDummyCube;
    Radar_Zasiêg_GLDisk: TGLDisk;
    Radar_Œlady_GLDummyCube: TGLDummyCube;
    Radio_Zasiêg_GLDisk: TGLDisk;
    Radar_Czu³oœæ_Etykieta_Label: TLabel;
    Radar_Czu³oœæ_SpinEdit: TSpinEdit;
    Radar_Zmieniaj_Czu³oœæ_Wraz_Ze_Skal¹_CheckBox: TCheckBox;
    Sonar_Zasiêg_GLDisk: TGLDisk;
    Radar_Dane_Z_Sonaru_CheckBox: TCheckBox;
    Radar_L_GLCapsule: TGLCapsule;
    Radar_Rysowanie_Œladów__Statków_Sekundy_Etykieta_Label: TLabel;
    Radar_Rysowanie_Œladów__Statków_Sekundy_SpinEdit: TSpinEdit;
    Radar_Rysowanie_Œladów__Amunicji_Sekundy_Etykieta_Label: TLabel;
    Radar_Rysowanie_Œladów__Amunicji_Sekundy_SpinEdit: TSpinEdit;
    Radar_GLHUDText: TGLHUDText;
    Radar_GLWindowsBitmapFont: TGLWindowsBitmapFont;
    Radar_Wspó³rzêdne_Kursora_CheckBox: TCheckBox;
    Radar_Kamera_Kierunek_GLDisk: TGLDisk;
    Radar_Kamera_Kierunek_GLDummyCube: TGLDummyCube;
    Radar_Kamera_Kierunek_Wyœwietlaj_CheckBox: TCheckBox;
    Radar_Wspó³rzêdna_Y_CheckBox: TCheckBox;
    Radar_PN_Linia_GLLines: TGLLines;
    procedure FormShow( Sender: TObject );
    procedure FormClose( Sender: TObject; var Action: TCloseAction );
    procedure FormResize( Sender: TObject );

    procedure Gra_GLSceneViewerExit( Sender: TObject );
    procedure Gra_GLSceneViewerClick( Sender: TObject );
    procedure Gra_GLSceneViewerMouseDown( Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer );
    procedure Gra_GLSceneViewerMouseWheel( Sender: TObject; Shift: TShiftState; WheelDelta: Integer; MousePos: TPoint; var Handled: Boolean );
    procedure Gra_GLSceneViewerMouseMove( Sender: TObject; Shift: TShiftState; X, Y: Integer );
    procedure Gra_GLSceneViewerKeyDown( Sender: TObject; var Key: Word; Shift: TShiftState );
    procedure Gra_GLCadencerProgress( Sender: TObject; const deltaTime, newTime: Double );
    procedure Gra_GLCollisionManagerCollision( Sender: TObject; object1, object2: TGLBaseSceneObject );

    procedure Czas_Bezwzglêdny_TimerTimer( Sender: TObject );

    procedure PageControl1Change( Sender: TObject );

    procedure L¹d__Wczytaj_Listê_BitBtnClick( Sender: TObject );
    procedure L¹d__Odœwie¿_Wskazany_BitBtnClick( Sender: TObject );
    procedure L¹d__Utwórz_BitBtnClick( Sender: TObject );
    procedure L¹d_ComboBoxChange( Sender: TObject );

    procedure Statek__Wczytaj_Listê_BitBtnClick( Sender: TObject );
    procedure Statek__Odœwie¿_Wskazany_BitBtnClick( Sender: TObject );
    procedure Statek__Utwórz_BitBtnClick( Sender: TObject );
    procedure Statek__Opis_BitBtnClick( Sender: TObject );
    procedure Statek_ComboBoxChange( Sender: TObject );
    procedure Statek_ComboBoxKeyDown( Sender: TObject; var Key: Word; Shift: TShiftState );

    procedure Statki_Pozycje_Pocz¹tkowe__Wczytaj_Listê_BitBtnClick( Sender: TObject );
    procedure Statki_Pozycje_Pocz¹tkowe__Odœwie¿_Wskazany_BitBtnClick( Sender: TObject );
    procedure Statki_Pozycje_Pocz¹tkowe__Brak_BitBtnClick( Sender: TObject );
    procedure Statki_Pozycje_Pocz¹tkowe_ComboBoxChange( Sender: TObject );

    procedure Gra_Rozpocznij_BitBtnClick( Sender: TObject );
    procedure Gra_Zakoñcz_BitBtnClick( Sender: TObject );

    procedure Gra_Wspó³czynnik_Prêdkoœci_SpinEditChange( Sender: TObject );

    procedure Wieloosobowe__Tryb_RadioGroupClick( Sender: TObject );
    procedure Wieloosobowe__Pod³¹cz_BitBtnClick( Sender: TObject );
    procedure Wieloosobowe__Od³¹cz_BitBtnClick( Sender: TObject );

    procedure IdTCPServer1Connect( AContext: TIdContext );
    procedure IdTCPServer1Disconnect( AContext: TIdContext );
    procedure IdTCPServer1Execute( AContext: TIdContext );

    procedure IdUDPServer1UDPRead( AThread: TIdUDPListenerThread; const AData: TIdBytes; ABinding: TIdSocketHandle );

    procedure Serwer_Wysy³a_TimerTimer( Sender: TObject );
    procedure Klient_IdTCP_Czyta_TimerTimer( Sender: TObject );
    procedure Klient_IdUDP_Czyta_TimerTimer( Sender: TObject );
    procedure Klient_Wysy³a_TimerTimer( Sender: TObject );

    procedure Serwer_Klient_Od³¹czenie_TimerTimer( Sender: TObject );

    procedure Pe³ny_Ekran_CheckBoxClick( Sender: TObject );
    procedure Pokój_Rozmów__Na_Ekranie_CheckBoxClick( Sender: TObject );
    procedure Pokój_Rozmów__Wyœlij_Wiadomoœæ_ButtonClick( Sender: TObject );
    procedure Pokój_Rozmów_Wiadomoœæ_EditKeyDown( Sender: TObject; var Key: Word; Shift: TShiftState );
    procedure Pokój_Rozmów__Ukryj_ButtonClick( Sender: TObject );
    procedure Pokój_Rozmów_Przyciski_PanelMouseDown( Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer );
    procedure Pokój_Rozmów_Przyciski_PanelMouseMove( Sender: TObject; Shift: TShiftState; X, Y: Integer );
    procedure Pokój_Rozmów_Przyciski_PanelMouseUp( Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer );

    procedure Gracz_Gotowoœæ_BitBtnClick( Sender: TObject );
    procedure Gracze_Lista_Odœwie¿_BitBtnClick( Sender: TObject );
    procedure Gracze_Lista_Roz³¹cz_Gracza_BitBtnClick( Sender: TObject );

    procedure SI__Dodaj_BitBtnClick( Sender: TObject );

    procedure Edit_Jako_Spin_KeyDown( Sender: TObject; var Key: Word; Shift: TShiftState );
    procedure ScrollBoxMouseWheel( Sender: TObject; Shift: TShiftState; WheelDelta: Integer; MousePos: TPoint; var Handled: Boolean );

    procedure Ustawienia_Wczytaj_ButtonClick( Sender: TObject );
    procedure Ustawienia_Zapisz_ButtonClick( Sender: TObject );

    procedure Amunicja__Zanurzenie_G³êbokoœæ_Zadana_EditChange( Sender: TObject );
    procedure Celowanie_Tryb_RadioGroupClick( Sender: TObject );
    procedure Celownik_Widocznoœæ_CheckBoxClick( Sender: TObject );
    procedure Celownik_Wielkoœæ_EditChange( Sender: TObject );
    procedure Kamera_Szybkoœæ_Ruchu_EditChange( Sender: TObject );
    procedure Morze_Wzburzenie_SpinEditChange( Sender: TObject );
    procedure Mysz_Czu³oœæ_EditChange( Sender: TObject );
    procedure Elementy_Gracza_Dostosuj_CheckBoxClick( Sender: TObject );

    procedure Projektowy_Tryb_CheckBoxClick( Sender: TObject );
    procedure Radar_Widocznoœæ_CheckBoxClick( Sender: TObject );
    procedure Informacje_Dodatkowe_TimerTimer( Sender: TObject );

    procedure Radar_GLSceneViewerMouseMove( Sender: TObject; Shift: TShiftState; X, Y: Integer );
    procedure Radar_Wielkoœæ_ButtonClick( Sender: TObject );
    procedure Radar_TimerTimer( Sender: TObject );

    procedure Statki_Zaprezentuj_ButtonClick( Sender: TObject );
    procedure Statki_Zaprezentuj__Zwolnij_BitBtnClick( Sender: TObject );
    procedure Statki_ZaprezentujKeyDown( Sender: TObject; var Key: Word; Shift: TShiftState );
    procedure Statystyki_Wypisz_ButtonClick( Sender: TObject );

    procedure Klawiatura_Konfiguracja__Domyœlna_ButtonClick( Sender: TObject );
    procedure Klawiatura_Konfiguracja__Wczytaj_ButtonClick( Sender: TObject );
    procedure Klawiatura_Konfiguracja__Zapisz_ButtonClick( Sender: TObject );
    procedure Klawiatura_Konfiguracja__Niepowtarzalnoœæ_SprawdŸ_ButtonClick( Sender: TObject );

    procedure Button1Click(Sender: TObject);
    procedure GLCollisionManager2Collision(Sender: TObject; object1, object2: TGLBaseSceneObject);
  private
    { Private declarations }
    kamera_indeks_amunicji, // Indeks w liœcie amunicji, na którym by³a ustawiona kamera.
    pokój_rozmów__zmiana_szerokoœci__szerokoœæ_pocz¹tkowa_g,
    pokój_rozmów__zmiana_szerokoœci__wysokoœæ_pocz¹tkowa_g,
    pokój_rozmów__zmiana_szerokoœci__x_pocz¹tkowy_g,
    pokój_rozmów__zmiana_szerokoœci__y_pocz¹tkowy_g,
    wieloosobowe__statek_przywróæ_do_gry__id_statek_g
      : integer;

    gra_wspó³czynnik_prêdkoœci_g, // Modyfikuje prêdkoœæ ró¿nych przekszta³ceñ. // 1 - prêdkoœæ normalna gry.
    kamera_szybkoœæ_ruchu_g,
    mysz_czu³oœæ_g, // Czu³oœæ myszy (szybkoœæ ruchu mysz¹).
    mysz_czu³oœæ_luneta_g // Czu³oœæ myszy przy maksymalnym przybli¿eniu lunety.
      : real;
    
    czy_kamera_od_najnowszego_pocisku, // Prze³¹cza kamerê pomiêdzy pociskami w kierunku od najnowszego do najstarszego (gdy prawda). // Podpi¹æ do menu opcji.
    czy_pauza_g,
    //mouse_look_active_przed_pauz¹, // Podczas pauzy nie obraca siê kamera i po wy³¹czeniu pauzy wystêpuje skok kamery na nowe wspó³rzêdne myszy.

    czy_gra_lokalna_g,
    czy_serwer_g,
    czy_klient_g,
    czy_wy³¹czanie_serwera_g, // W trybie serwera (oznacza, ¿e serwer jest w procedurze wy³¹czania siê).
    //czy_wysy³anie_trwa_g, //??? To nie pomaga. // Je¿eli serwer TCP zacznie wysy³anie gdy poprzednie siê nie zakoñczy³o mo¿e dojœæ do zamro¿enia programu (Contexts.LockList() wywo³a siê za du¿o razy, pozak³ada wewnêtrzne blokady, które siê nie poœci¹gaj¹ - Contexts.UnlockList()).
    //kamera_obrót_mysz¹_g,
    klient_pierwsze_ustawienie_kamery_g, // Po rozpoczêciu gry ustawi kamerê gracza klienta na jego statku.
    pokój_rozmów__zmiana_szerokoœci__aktywnoœæ_g // Aktywnoœæ trybu zmiany szerokoœci pokoju rozmów.
      : boolean;

    l¹d_definicja_g : string; // Definicja l¹du w aktualnej grze (mapa gry).

    //moment_wciœniêcia_klawisza,
    pokój_rozmów_ostatnia_wiadomoœæ_wys³ana_data_czas,
    udp_data_czas_sprawdzanie_po³¹czeñ_ostatnie_g // Kiedy ostatnio: serwer - usuwa³ nieaktywne po³¹czenia z listy; klient - przypomina³, ¿e jest po³¹czony z serwerem.
      : TDateTime;

    amunicja_wystrzelona_list,
    wieloosobowe_amunicja_wystrzelona_list,

    informacje_dodatkowe_list,
    l¹d_list,
    trafienia_efekt_list
      : TList;

    pokój_rozmów_ostatnia_wiadomoœci_wys³ane_treœæ_string_list : TStringList;

    wieloosobowe_amunicja_efekt_g : TAmunicja; // Aby utworzyæ u klientów efekt na podstawie danych z amunicji i aby ci¹gle w funkcji nie tworzyæ i nie zwalniaæ instancji amunicji.

    pokój_rozmów_r : TPokój_Rozmów_r;

    statek_gracza,
    projektowy_tryb__statek
      : TStatek;

    l¹dy_lista_t,
    prymitywy_lista_t, // U klientów jest zerowane przy komendzie gra start.
    statki_lista_t,
    statki_pozycje_pocz¹tkowe_lista_t
      : TSchematy_Lista_r_t;

    tcp_klienci_lista_g : TTCP_Klienci_Lista;
    udp_klienci_lista_g : TUDP_Klienci_Lista;

    wieloosobowe__efekt_r : TObiekty_Wieloosobowe__Efekt_r;

    wspó³rzêdne_œwiata_z_radaru_affine_vector_g : TAffineVector;

    gra_statystyki_r_t : array of TGra_Statystyki_r;

    wieloosobowe__amunicja_t : array of TObiekty_Wieloosobowe__Amunicja_r;
    wieloosobowe__efekt_t : array of TObiekty_Wieloosobowe__Efekt_r;
    wieloosobowe__statki_t : array of TObiekty_Wieloosobowe__Statek_r;
    wieloosobowe__statek_klawisze_obs³uga_r : TObiekty_Wieloosobowe__Statek_Klawisze_Obs³uga_r;

    gra_pozycja_pocz¹tkowa_parametry_t,
    l¹d_pozycja_pocz¹tkowa_parametry_t,
    statki_pozycja_pocz¹tkowa_parametry_t
       : array [ 1..2 ] of TPozycja_Pocz¹tkowa_Parametry_r;

    statki_t : array of TStatek;

    komunikacja_rekord_testowy_r : TKomunikacja_Rekord_Testowy_r;
    komunikacja_rekord_testowy_2_r : TKomunikacja_Rekord_Testowy_2_r;

    {$region 'Klawisze.'}
    klawisz__amunicja__zanurzenie_g³êbokoœæ_zadana__plus,
    klawisz__amunicja__zanurzenie_g³êbokoœæ_zadana__minus,
    klawisz__celowanie_tryb,
    klawisz__celownik_widocznoœæ,
    klawisz__celownik_widocznoœæ_mouse_look_active,
    klawisz__dalmierz,
    klawisz__gra_wspó³czynnik_prêdkoœci__plus,
    klawisz__gra_wspó³czynnik_prêdkoœci__normalna,
    klawisz__gra_wspó³czynnik_prêdkoœci__minus,
    klawisz__kamera__do_ty³u,
    klawisz__kamera__do_przodu,
    klawisz__kamera__w_lewo,
    klawisz__kamera__w_przawo,
    klawisz__kamera__w_górê,
    klawisz__kamera__w_dó³,
    klawisz__kamera__w_lewo_obrót,
    klawisz__kamera__w_przawo_obrót,
    klawisz__kamera__w_górê_obrót,
    klawisz__kamera__w_dó³_obrót,
    klawisz__kamera__Amunicja,
    klawisz__kamera__Artyleria,
    klawisz__kamera__Statek,
    klawisz__kamera__Swobodna,
    klawisz__kamera__Za_Statkiem,
    klawisz__l¹d_odœwie¿_wskazany,
    klawisz__mouse_look_active,
    klawisz__obracaj_dzia³a,
    klawisz__obrót_k¹t_zablokowany_wskaŸnik,
    klawisz__obrót_k¹t_zablokowany_strza³_wskaŸnik,
    klawisz__opcje,
    klawisz__pauza,
    klawisz__pe³ny_ekran,
    klawisz__podnoœ_lufy,
    klawisz__pokój_rozmów__na_ekranie,
    klawisz__pokój_rozmów__informacja_dodatkowa,
    klawisz__prêdkoœæ_zadana_procent_zmieñ__100_plus,
    klawisz__prêdkoœæ_zadana_procent_zmieñ__25_plus,
    klawisz__prêdkoœæ_zadana_procent_zmieñ__1_plus,
    klawisz__prêdkoœæ_zadana_procent_zmieñ__zero,
    klawisz__prêdkoœæ_zadana_procent_zmieñ__1_minus,
    klawisz__prêdkoœæ_zadana_procent_zmieñ__25_minus,
    klawisz__prêdkoœæ_zadana_procent_zmieñ__100_minus,
    klawisz__projektowy_tryb__w³¹cz_wy³¹cz,
    klawisz__projektowy_tryb__statek__przesuniêcie_w_lewo,
    klawisz__projektowy_tryb__statek__przesuniêcie_w_prawo,
    klawisz__projektowy_tryb__statek__przesuniêcie_w_przód,
    klawisz__projektowy_tryb__statek__przesuniêcie_w_ty³,
    klawisz__projektowy_tryb__statek__obrót_lewo,
    klawisz__projektowy_tryb__statek__obrót_prawo,
    klawisz__projektowy_tryb__statek__przechylenie_w_lewo,
    klawisz__projektowy_tryb__statek__przechylenie_w_prawo,
    klawisz__projektowy_tryb__statek__uniesienie_przodu,
    klawisz__projektowy_tryb__statek__uniesienie_ty³u,
    klawisz__projektowy_tryb__statek__prêdkoœæ_zadana_0_100,
    klawisz__projektowy_tryb__statek___resetuj_obrót,
    klawisz__punkty_¿ycia_wskaŸnik__gracz,
    klawisz__punkty_¿ycia_wskaŸnik__przeciwnik,
    klawisz__punkty_¿ycia_wskaŸnik__sojusznik,
    klawisz__radar_widocznoœæ,
    klawisz__skrêt_zadany_procent_zmieñ__100_lewo,
    klawisz__skrêt_zadany_procent_zmieñ__25_lewo,
    klawisz__skrêt_zadany_procent_zmieñ__1_lewo,
    klawisz__skrêt_zadany_procent_zmieñ__zero,
    klawisz__skrêt_zadany_procent_zmieñ__1_prawo,
    klawisz__skrêt_zadany_procent_zmieñ__25_prawo,
    klawisz__skrêt_zadany_procent_zmieñ__100_prawo,
    klawisz__statek__utwórz,
    klawisz__strza³_1,
    klawisz__strza³_2,
    klawisz__strza³__wszystkie_lufy_1,
    klawisz__strza³__wszystkie_lufy_2,
    klawisz__strza³__wszystkie_wybrane_1,
    klawisz__strza³__wszystkie_wybrane_2,
    klawisz__strza³__broñ_indeks_zmieniaj,
    klawisz__strza³__broñ_indeks_poprzedni,
    klawisz__strza³__broñ_indeks_nastêpny,
    klawisz__strzelaj_z__artyleria,
    klawisz__strzelaj_z__pocisk,
    klawisz__strzelaj_z__torpeda,
    klawisz__strzelaj_z__wszystkie,
    klawisz__zamknij_program
      : TKlawiatura_Konfiguracja_r;
    {$endregion 'Klawisze.'}

    klawiatura_konfiguracja_r_t : array of ^TKlawiatura_Konfiguracja_r;

    function Wieloosobowe__Wektor_4__Do__Vector( const wieloosobowe__wektor_4_f : TWieloosobowe__Wektor_4 ) : GLVectorGeometry.TVector;
    function Vector__Do__Wieloosobowe__Wektor_4( const vector_f : GLVectorGeometry.TVector ) : TWieloosobowe__Wektor_4;

    function Statek_ZnajdŸ( pointer_f : Pointer ) : Pointer;

    procedure Amunicja_Wystrzelona_Utwórz_Jeden( AOwner : TGLBaseSceneObject; ALufa : TLufa; const obracaj_dzia³a_f : boolean; const cel_wspó³rzêdne_f : TAffineVector );
    procedure Amunicja_Wystrzelona_Zwolnij_Jeden( amunicja_f : TAmunicja  );
    procedure Amunicja_Wystrzelona_Zwolnij_Wszystkie();
    procedure Amunicja_Wystrzelona_Efekt_Utwórz( amunicja_f : TAmunicja; const czy_torpeda_efekt_na_wodzie_f : boolean; const czy_wieloosobowa_f : boolean = false );

    function Odczytaj_Liczbê_Z_Napisu( napis_f : string; const wartoœæ_minimalna_f : variant; const prze³¹cz_zak³adkê_f : boolean = true ) : real;

    function Wygl¹d_Elementy__Utwórz_Element( const statek_f : TStatek; const l¹d_prymityw_f : string; const w³aœciciel_gl_base_scene_object_f : TGLBaseSceneObject; const rodzic_gl_dummy_cube_f : TGLDummyCube = nil ) : TGLCustomSceneObject;
    function Wygl¹d_Elementy__Tekstura_Wczytaj( gl_custom_scene_object_f : TGLCustomSceneObject; tekstura_œcie¿ka_f : string ) : boolean;
    procedure L¹d_Utwórz( const lista_indeks_f : integer; const prymityw_indeks_f : integer = -99; const prymityw_rodzic_gl_dummy_cube_f : TGLDummyCube = nil );
    procedure L¹d_Zwolnij();

    procedure Statki_Zwolnij( const zwolnij_pierwszy_statek_f : boolean = true; zwolnij_statki_za_pierwszym_f : boolean = true );

    function Statek_Odczytaj_Schemat( const lista_indeks_f : integer ) : string;

    procedure Trafienia_Efekt_Utwórz_Jeden( AOwner : TGLBaseSceneObject; efekt_rodzaj_f : TEfekt_Rodzaj; x_f, y_f, z_f : real; amunicja_f : TAmunicja; czas_trwania_f, czas_trwania_efekt_dodatkowy_f : Int64 );
    procedure Trafienia_Efekt_Zwolnij_Jeden( trafienia_efekt_f : TTrafienia_Efekt );
    procedure Trafienia_Efekt_Zwolnij_Wszystkie();

    function Amunicja_Rodzaj_Zbiór_Zwróæ() : TAmunicja_Rodzaj_Zbiór; overload;
    function Amunicja_Rodzaj_Zbiór_Zwróæ( const ar_brak_f, ar_artyleria_f, ar_pocisk_f, ar_torpeda_f, ar_wszystkie_f : boolean ) : TAmunicja_Rodzaj_Zbiór; overload;

    function Klawisz_Wciœniêto_SprawdŸ( const klawiatura_konfiguracja_r_f : TKlawiatura_Konfiguracja_r; const klawisz_f : Word; const mysz_przycisk_f : SmallInt; const shift_f : TShiftState; const czy_z_wieloosobowe__odczytaj_f : boolean = false ) : boolean;
    procedure Statek_Klawisze_Obs³uga( const id_statek_f : integer; const klawisz_f : Word; const mysz_przycisk_f : SmallInt; const shift_f : TShiftState; const amunicja_rodzaj_zbiór_f : TAmunicja_Rodzaj_Zbiór; const czy_z_wieloosobowe__odczytaj_f : boolean = false );
    procedure Klawisze_Obs³uga_Zachowanie_Ci¹g³e( delta_czasu_f : double; const shift_f : TShiftState = []; const mysz_przycisk_f : SmallInt = -1 );
    procedure Statek_Klient_Cel_Ustaw( const id_statek_f : integer; const cel_wspó³rzêdne_f : GLVectorGeometry.TVector );

    procedure Statki_Ruch( delta_czasu_f : double );
    procedure Amunicja_Ruch( delta_czasu_f : double );
    procedure Lufy_Prze³adowanie( delta_czasu_f : double );

    function Statki_Kolizja_Oznaczenie_SprawdŸ( string_list_f : TStringList; obiekt_nazwa_f : string ) : boolean;

    procedure Trafienia_Efekt_Czas_Trwania_SprawdŸ();

    procedure Kamera_Odleg³oœæ_Kontroluj_Ustaw( delta_czasu_f : double );
    procedure Kamera_Prze³¹cz( const kamera_tryb_f : TKamera_Tryb );

    procedure Napis_Odœwie¿();

    procedure Celownicza_Kula_Zmieñ_Pozycjê();
    procedure Pauza( const czy_pauza_f : boolean );

    procedure Elementy_Gry_Przygotuj();
    procedure Elementy_Gry_Zwolnij();
    procedure Statek_Przywróæ_Do_Gry( const id_statek_f : integer ); overload;
    procedure Statek_Przywróæ_Do_Gry( const statek_f : TStatek ); overload;
    procedure Statki_Rozstaw( const statek_f : TStatek );

    procedure Ustawienia_Plik( const zapisuj_ustawienia_f : boolean = false );
    procedure Wczytaj_Schemat( const katalog_nazwa_f : string; const lista_indeks_f : integer; var schematy_lista_r_t_f : TSchematy_Lista_r_t );
    
    procedure Wieloosobowe_Amunicja_Parametry_Odczytaj();
    procedure Wieloosobowe_Amunicja_Parametry_Ustaw();

    procedure Wieloosobowe__Efekt_Odczytaj_Jeden( AOwner : TGLBaseSceneObject; efekt_rodzaj_f : TEfekt_Rodzaj; x_f, y_f, z_f : real; amunicja_f : TAmunicja; czas_trwania_f, czas_trwania_efekt_dodatkowy_f : Int64 );

    procedure Wieloosobowe_Statki_Rekord_Czyœæ();
    procedure Wieloosobowe_Statki_Utwórz();
    procedure Wieloosobowe_Statki_Parametry_Odczytaj();
    procedure Wieloosobowe_Statki_Parametry_Ustaw();

    procedure Wieloosobowe__Tekst_Wyœlij( const napis_f : string; const peer_port_f : integer = -99 );
    procedure Wieloosobowe__Tekst_Wyœlij_UDP( const napis_f : string );
    procedure Wieloosobowe__Strumieñ_Wyœlij( const komenda_f : string; const peer_port_f : integer; const wartoœæ_f : TWieloosobowe_String; const czy_udp_f : boolean = false );
    function Wieloosobowe__Odczytaj( const io_handler_f : TIdIOHandler; const komenda_udp_f : string; const id_context_f : TIdContext; const id_socket_handle_f : TIdSocketHandle ) : string; // uses IdIOHandler.

    procedure Wieloosobowe__Trafienia_Efekt_Utwórz( obiekty_wieloosobowe__efekt_r_f : TObiekty_Wieloosobowe__Efekt_r ); overload;
    procedure Wieloosobowe__Trafienia_Efekt_Utwórz( obiekty_wieloosobowe__efekt_t_f : array of TObiekty_Wieloosobowe__Efekt_r ); overload;

    procedure Wieloosobowe__Log_Wypisz( const napis_f : string; const wyró¿nij_f : boolean = false );

    function Gracz_Identyfikator() : integer;
    procedure Gracze_Lista_Odœwie¿();
    procedure Gracze_Lista_Roz³¹cz( const peer_port_f : integer );

    function Gra_Statystyki_R_Identyfikator_ZnajdŸ( const identyfikator_f : integer ) : integer;
    procedure Gra_Statystyki_Wypisz();

    procedure Informacja_Dodatkowa_Dodaj( const napis_f : string; const wyœwietlanie_czas_sekund_f : smallint = 0 );

    procedure Interfejs_Aktywnoœæ_Ustaw_Klient( const aktywne_f : boolean );
    procedure Interfejs_Parametry_Wed³ug_Statku_Ustaw();

    procedure Klawisz_Konfiguracja_Zwolnij();

    procedure Log_Wypisz( const napis_f : string; const prze³¹cz_zak³adkê_f : boolean = true );

    procedure Pokój_Rozmów__Wyœwietl_Wiadomoœæ( pokój_rozmów_r_f : TPokój_Rozmów_r );

    function Radar_Koryguj_Wielkoœæ_Obiektów() : real;
    procedure Radar_L¹d_Rysuj();
    procedure Radar_Statki_Rysuj();
    procedure Radar_Wyczyœæ( const czyœæ_wszystko_f : boolean = false );

    procedure Radio_Statki_W_Zasiêgu();
    function Radio_Dane_Wymieñ( const zt_statek_f : TStatek; id_statek_f : integer ) : boolean;

    procedure Komunikacja_Rekord_Testowy_Obs³uga( const tylko_wyœwietl_f : boolean = true );
  public
    { Public declarations }
  end;//---//TStatki_Form

const
  amunicja_prêdkoœæ_c : real = 100; //50 //???
  cofanie_wystrza³_powrót_milisekund_c : real = 250; // Po jakim czasie od wystrza³u lufa wraca na domyœln¹ pozycjê (w milisekundach). Je¿eli ten czas jest wiêkszy od czasu prze³adowania wskaŸnik prze³adowania na lufie ustawi siê w pozycji 'na³adowany' (przesunie siê poza lufê) zanim lufa wróci na domyœlna pozycje cofania.
  dno_poziom_c : single = -10;
  udp_klient_po³¹czenie_potwierdzanie_sekund_c : single = 10; // Je¿eli po up³ywie tego czasu klient siê nie odezwie uznaje siê, ¿e po³¹czenie UDP zosta³o utracone.
  kolizja_oznaczanie_prêdkoœæ_procent_c : real = 10; // Przy jakiej prêdkoœci procentowej oznaczaæ efekt kolizji.
  kolizja_przesuwanie_si³a_c : real = 5; // Z jak¹ si³¹ statek przesuwa inny statek podczas kolizji.
  lot_parabol¹__k¹ta_opadania__odleg³oœæ_od_procent_c : real = 0.6; // Od jakiego procenta dystansu amunicja zaczyna opadaæ ( lot_parabol¹__k¹ta_opadania__odleg³oœæ_od_procent_c + lot_parabol¹__k¹ta_opadania__odleg³oœæ_od_odcinek_zmiany_k¹ta_procent_c powinno byæ mniejsze od 1 (100%)).
  lot_parabol¹__k¹ta_opadania__odleg³oœæ_od_odcinek_zmiany_k¹ta_procent_c : real = 0.36; //35 // Na jakim procencie dystansu zmienia siê p³ynnie k¹t opadania (bez naprowadzania ( lot_parabol¹__k¹ta_opadania__odleg³oœæ_od_procent_c + lot_parabol¹__k¹ta_opadania__odleg³oœæ_od_odcinek_zmiany_k¹ta_procent_c powinno byæ mniejsze od 1 (100%)).
  lot_parabol¹__k¹ta_opadania__przed_namierzaniem_c : real = 80; //85 // K¹t do jakiego nale¿y pochyliæ amunicjê przed rozpoczêciem nakierowywania na cel.
  oczekiwanie_na_odnowienie_statku_czas_c : int64 = 45; // Sekundy. // 15
  statek_kolizja_oznaczenie_ponowne_czas_c : int64 = 1; // Sekundy. // 7
  woda_wspó³czynnik_t³umienia_c : real = 0.25;

  informacja_dodatkowa__wyœwietlanie_czas_sekund__domyœlny_c : smallint = 10;
  informacja_dodatkowa__wyœwietlanie_czas_sekund__krótki_c : smallint = 1;

  katalog_schematy_lista__l¹dy_c : string = 'L¹dy';
  katalog_schematy_lista__prymitywy_c : string = 'Prymitywy';
  katalog_schematy_lista__statki_c : string = 'Statki';
  katalog_schematy_lista__statki_pozycje_pocz¹tkowe_c : string = 'Statki pozycje pocz¹tkowe';

  // Powy¿ej wartoœci 7 nie widaæ ró¿nicy w szerokoœci linii celowania.
  celownik_linia_szerokoœæ_maksymalna__obrót_c : smallint = 2; // Wp³yw precyzji celowania obrotu broni na szerokoœæ linii celowania.
  celownik_linia_szerokoœæ_maksymalna__podniesienie_c : smallint = 2; // Wp³yw precyzji celowania podniesienia luf na szerokoœæ linii celowania. Je¿eli broñ nie unosi luf wartoœæ ta jest uwzglêdniana przy obliczaniu wycelowania obrotu broni.

  char_rozmiar_c = SizeOf( char );
  obiekty_wieloosobowe__amunicja_r__rozmiar_c = SizeOf( TObiekty_Wieloosobowe__Amunicja_r );
  obiekty_wieloosobowe__efekt_r__rozmiar_c = SizeOf( TObiekty_Wieloosobowe__Efekt_r );
  obiekty_wieloosobowe__gra_statystyki_r_rozmiar_c = SizeOf( TGra_Statystyki_r );
  //obiekty_wieloosobowe__dzia³o_r__rozmiar_c = SizeOf( TObiekty_Wieloosobowe__Dzia³o_r ) - SizeOf( Pointer );
  //obiekty_wieloosobowe__lufa_r__rozmiar_c = SizeOf( TObiekty_Wieloosobowe__Lufa_r );
  //obiekty_wieloosobowe__statki_r__rozmiar_c = SizeOf( TObiekty_Wieloosobowe__Statek_r ) - SizeOf( Pointer ) * ( 0 + 1 + 6 );
  obiekty_wieloosobowe__statek_klawisze_obs³uga_r__rozmiar_c = SizeOf( TObiekty_Wieloosobowe__Statek_Klawisze_Obs³uga_r );
  //pokój_rozmów_r__rozmiar_c = SizeOf( TPokój_Rozmów_r ) - SizeOf( string );
  pokój_rozmów_r__rozmiar_c = SizeOf( TPokój_Rozmów_r );
  //schematy_lista__rozmiar_c = SizeOf( TSchematy_Lista_r );
  wieloosobowe_string__rozmiar_c = SizeOf( TWieloosobowe_String );
  komunikacja_rekord_testowy_r__rozmiar_c = SizeOf( TKomunikacja_Rekord_Testowy_r );
  komunikacja_rekord_testowy_2_r__rozmiar_c = SizeOf( TKomunikacja_Rekord_Testowy_2_r ) - SizeOf( string );

  serwer_peer_port_c : integer = -1;
  si_peer_port_c : integer = -2;

  torpeda_d¹¿enie_do_zadanej_g³êbokoœci_szybkoœæ_c : real = 7; // Jak szybko torpeda próbuje siê ustawiæ na zadanej g³êbokoœci.

  radar__celownik_c = 5;
  radar__l¹d_c = 2;
  radar__statki_c = 4;
  radar__statki_kierunek_c = 3;
  radar__statki_œlady_c = 1;
  radar__statek_margines_c = 0;

  wieloosobowe__komenda__gra__rozpocznij_c = '__Gra_Rozpocznij__';
  wieloosobowe__komenda__gra__zakoñcz_c = '__Gra_Zakoñcz__';
  wieloosobowe__komenda__gra__morze_wzburzenie_c = '__Gra_Morze_Wzburzenie__';
  wieloosobowe__komenda__gra__statystyki_wyœlij_c = '__Gra_Statystyki_Wyœlij__';
  wieloosobowe__komenda__gra__wspó³czynnik_prêdkoœci_c = '__Gra_Wspó³czynnik_Prêdkoœci__';

  wieloosobowe__komenda__gracz_gotowoœæ_c = '__Gracz_Gotowoœæ__';
  wieloosobowe__komenda__gracz_lista_odœwie¿_c = '__Gracz_Lista_Odœwie¿__';

  wieloosobowe__komenda__has³o__sprawdŸ_c = '__Has³o__SprawdŸ__';

  wieloosobowe__komenda__identyfikator__nadaj_c = '__Identyfikator__Nadaj__';
  wieloosobowe__komenda__identyfikator__przypomnij_c = '__Identyfikator_Przypomnij__'; // Gdy ponownie ³¹czy siê roz³¹czony klient.
  wieloosobowe__komenda__identyfikator__zapamiêtaj_c = '__Identyfikator_Zapamiêtaj__';

  wieloosobowe__komenda__pauza_c = '__Pauza__';

  wieloosobowe__komenda__odbierz__l¹d_definicja_c = '__L¹d_Definicja__';
  wieloosobowe__komenda__odbierz__prymitywy_definicja_c = '__Prymitywy_Definicja__';
  wieloosobowe__komenda__odbierz__rekord_amunicja_c = '__Rekord_Amunicja__';
  wieloosobowe__komenda__odbierz__rekord_efekt_c = '__Rekord_Efekt__';
  wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c = '__Rekord_Pokój_Rozmów__';
  wieloosobowe__komenda__odbierz__rekord_statki_c = '__Rekord_Statki__';
  wieloosobowe__komenda__odbierz__statki_definicje_c = '__Statki_Definicje__';

  wieloosobowe__komenda__serwer_wy³¹cza_siê_c = '__Serwer_Wy³¹cza_Siê__';

  wieloosobowe__komenda__statek__klawisze_obs³uga_c = '__Rekord_Statek_Klawisze_Obs³uga__';
  wieloosobowe__komenda__statek__przywróæ_do_gry_c = '__Statek_Przywróæ_Do_Gry__';

  wieloosobowe__komenda__udp__klient_po³¹czony_nadal_c = '__udp__po³¹czony__'; // Klient informuje, ¿e nadal jest pod³¹czony (nadal nas³uchuje serwer).


  wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_r_c = '__Komunikacja_Rekord_Testowy__';
  wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_2_r_c = '__Komunikacja_Rekord_Testowy_2__';


  wygl¹d_prymityw_c : string = 'prymityw';
  wygl¹d_prymityw__kula_c : string = 'kula';
  wygl¹d_prymityw__ostros³up_c : string = 'ostros³up';
  wygl¹d_prymityw__prostopad³oœcian_c : string = 'prostopad³oœcian';
  wygl¹d_prymityw__sto¿ek_c : string = 'sto¿ek';
  wygl¹d_prymityw__walec_c : string = 'walec';

var
  Statki_Form: TStatki_Form;

  celowanie_tryb_g : TCelowanie_Tryb;
  czas_bezwzglêdny_g, // Czas up³ywaj¹cy w grze (zatrzymuje siê podczas pauzy).
  czas_bezwzglêdny_skok_milisekundy_g // Ile milisekund stanowi jednoœæ czas_bezwzglêdny_g (1 sekunda: przy 1 [skok] - 1000 [czas_bezwzglêdny_g], 10 - 100, 50 - 20, 100 - 10, 1000 - 1).
    : int64;
  id_amunicja_g : cardinal;

  function Czas_Miêdzy_W_Sekundach( const czas_poprzedni_f : int64 ) : int64;
  function Czas_Miêdzy_W_Milisekundach( const czas_poprzedni_f : int64 ) : int64;
  function Czas_Teraz() : int64;
  function Czas_Teraz_W_Milisekundach() : int64;

implementation

{$R *.dfm}

{$region 'TStatek.'}
//Konstruktor klasy TStatek.
constructor TStatek.Create( AOwner : TGLBaseSceneObject; gl_collision_mmanager_f : TGLCollisionManager; const id_statek_f : integer; const wygl¹d_definicja_f : string; const prymitywy_lista_f : TSchematy_Lista_r_t );
var
  zt_gl_base_scene_object : TGLBaseSceneObject;

  //Funkcja Wygl¹d_Elementy_Utwórz() w Konstruktor klasy TStatek.
  procedure Wygl¹d_Elementy_Utwórz( const prymityw_indeks_f : integer = -99; const prymityw_rodzic_gl_dummy_cube_f : TGLDummyCube = nil );
  var
    i,
    j,
    jj
      : integer;
    ztr_1,
    ztr_2,
    ztr_3,
    ztr_4
      : real;
    zts : string;
    zt_xml_document : TXMLDocument; //uses XMLDoc
    zt_gl_custom_scene_object : TGLCustomSceneObject;
    kolor_vector : GLVectorGeometry.TVector;
    wygl¹d_kolor_definicja : TWygl¹d_Kolor_Definicja;
  begin

    // Parametry:
    //   prymityw_indeks_f:
    //     = -99 - tworzy statek.
    //     <> -99 - tworzy prymityw.
    //   prymityw_rodzic_gl_dummy_cube_f
    //     = nil - tworzy statek.
    //     <> nil - tworzy prymityw (rodzicem tworzonych obiektów jest utworzony wczeœniej kontener TGLDummyCube).
    //

    if   ( Self.wygl¹d_elementy_list = nil )
      or (  not Assigned( Self.wygl¹d_elementy_list )  ) then
      Exit;


    if prymityw_indeks_f = -99 then
      begin

        // Tworzy statek.

        if Trim( wygl¹d_definicja_f ) = '' then
          begin

            Statki_Form.Log_Wypisz( 'Brak definicji elementów statku.', not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );
            Exit;

          end;
        //---//if Trim( wygl¹d_definicja_f ) = '' then

        zts := wygl¹d_definicja_f;

      end
    else//if prymityw_indeks_f = -99 then
      begin

        // Tworzy prymityw.

        if prymityw_indeks_f <> -99 then
          begin

            if   ( prymityw_indeks_f < 0 )
              or (  prymityw_indeks_f > Length( prymitywy_lista_f ) - 1  ) then
              begin

                Statki_Form.Log_Wypisz( 'Brak definicji prymitywu.', not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );
                Exit;

              end;
            //---//if   ( prymityw_indeks_f < 0 ) (...)

            zts := prymitywy_lista_f[ prymityw_indeks_f ].treœæ;

          end;
        //---//if prymityw_indeks_f <> -99 then

      end;
    //---//if prymityw_indeks_f = -99 then


    zt_xml_document := TXMLDocument.Create( Application );

    zt_xml_document.Options := zt_xml_document.Options + [ doNodeAutoIndent ]; // Domyœlnie ma: doNodeAutoCreate, doAttrNull, doAutoPrefix, doNamespaceDecl.

    try
      // Serwer zg³asza b³¹d podczas odczytu danych o l¹dzie od klienta
      //   MSXML is not installed
      //   Assertion failure GLContext.pas
      // W L¹d_Zwolnij() chyba te¿ takie coœ siê dzieje (inne b³êdy) ale z podobnego powodu.
      //
      // Uda³o siê unikn¹æ b³êdów tak:
      //   w zdarzeniu odczytania danych o l¹dzie tylko w³¹czyæ Timer;
      //   w Timer.OnTimet wy³¹czyæ Timer i wywo³aæ zwalnianie i wczytywanie l¹du.
      //
      zt_xml_document.LoadFromXML( zts );
    except
      on E : Exception do
        Statki_Form.Log_Wypisz(  'Nieprawid³owa definicja elementów statku. ' + #13 + #10 + E.Message + ' ' + IntToStr( E.HelpContext ), not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked  );
    end;
    //---//try

    {$region 'Odczyt danych xml.'}
    if zt_xml_document.Active then
      begin

        wygl¹d_kolor_definicja := TWygl¹d_Kolor_Definicja.Create();


        for i := 0 to zt_xml_document.DocumentElement.ChildNodes.Count - 1 do
          begin

            if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' )
              or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'dzia³o' )
              or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' )
              or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = wygl¹d_prymityw_c )
              or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'ster' )
              or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'œruba' )
              or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'torpedy_wyrzutnia' ) then
              begin

                zt_gl_custom_scene_object := nil;

                if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' then
                  begin

                    try
                      jj := zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'lufy_iloœæ' ];
                    except
                      jj := 1;
                    end;
                    //---//try

                    j := Length( Self.artyleria_t );
                    SetLength( Self.artyleria_t, j + 1 );
                    Self.artyleria_t[ j ] := TArtyleria.Create( zt_gl_base_scene_object, Self, gl_collision_mmanager_f, jj, 0 );
                    zt_gl_custom_scene_object := Self.artyleria_t[ j ];

                  end
                else//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' then
                if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'dzia³o' then
                  begin

                    try
                      jj := zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'lufy_iloœæ' ];
                    except
                      jj := 1;
                    end;
                    //---//try                  

                    j := Length( Self.dzia³a_t );
                    SetLength( Self.dzia³a_t, j + 1 );
                    Self.dzia³a_t[ j ] := TDzia³o.Create( zt_gl_base_scene_object, Self, gl_collision_mmanager_f, jj, 0 );
                    zt_gl_custom_scene_object := Self.dzia³a_t[ j ];

                  end
                else//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'dzia³o' then
                if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' )
                  or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = wygl¹d_prymityw_c ) then
                  begin

                    if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' then
                      zt_gl_custom_scene_object := Statki_Form.Wygl¹d_Elementy__Utwórz_Element(  Self, VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'typ' ] ), zt_gl_base_scene_object, prymityw_rodzic_gl_dummy_cube_f  )
                    else//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' then
                    if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = wygl¹d_prymityw_c then
                      zt_gl_custom_scene_object := Statki_Form.Wygl¹d_Elementy__Utwórz_Element( Self, wygl¹d_prymityw_c, zt_gl_base_scene_object );

                  end
                else//if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' ) (...)
                if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'ster' then
                  begin

                    j := Length( Self.ster_t );
                    SetLength( Self.ster_t, j + 1 );
                    Self.ster_t[ j ] := TSter.Create( zt_gl_base_scene_object, gl_collision_mmanager_f, 0, 0, 0 );
                    zt_gl_custom_scene_object := Self.ster_t[ j ];

                  end
                else//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'ster' then
                if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'œruba' then
                  begin

                    j := Length( Self.œruby_t );
                    SetLength( Self.œruby_t, j + 1 );
                    Self.œruby_t[ j ] := TŒruba.Create( zt_gl_base_scene_object, Self, i = 1, gl_collision_mmanager_f );
                    zt_gl_custom_scene_object := Self.œruby_t[ j ];

                  end
                else//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'œruba' then
                if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'torpedy_wyrzutnia' then
                  begin
                  
                    try
                      jj := zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'lufy_iloœæ' ];
                    except
                      jj := 1;
                    end;
                    //---//try
                    
                    j := Length( Self.torpedy_wyrzutnie_t );
                    SetLength( Self.torpedy_wyrzutnie_t, j + 1 );
                    Self.torpedy_wyrzutnie_t[ j ] := TTorpedy_Wyrzutnia.Create( zt_gl_base_scene_object, Self, gl_collision_mmanager_f, jj );
                    zt_gl_custom_scene_object := Self.torpedy_wyrzutnie_t[ j ];

                  end;
                //---//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'torpedy_wyrzutnia' then

                if zt_gl_custom_scene_object <> nil then
                  begin

                    if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' )
                      or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = wygl¹d_prymityw_c ) then
                      Self.wygl¹d_elementy_list.Add( zt_gl_custom_scene_object );


                    if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = wygl¹d_prymityw_c then
                      for j := 0 to Length( prymitywy_lista_f ) - 1 do
                        if prymitywy_lista_f[ j ].plik_nazwa = VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'nazwa' ] ) then
                          begin

                            Wygl¹d_Elementy_Utwórz( j, TGLDummyCube(zt_gl_custom_scene_object) );
                            Break;

                          end;
                        //---//if prymitywy_lista_f[ j ].plik_nazwa = VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'nazwa' ] ) then


                    for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do
                      begin

                        if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' )
                          or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'dzia³o' )
                          or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'torpedy_wyrzutnia' ) then
                          begin

                            if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' )
                              or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'dzia³o' ) then
                              begin

                                if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'podniesienie_k¹t_maksymalny' then
                                  TDzia³o(zt_gl_custom_scene_object).podniesienie_k¹t_maksymalny := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                                else
                                if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'podniesienie_k¹t_minimalny' then
                                  TDzia³o(zt_gl_custom_scene_object).podniesienie_k¹t_minimalny := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                                else
                                if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'podniesienie_szybkoœæ' then
                                  TDzia³o(zt_gl_custom_scene_object).podniesienie_szybkoœæ := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0.0001, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                              end;
                            //---//if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' ) (...)

                            if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'amunicja_iloœæ' then
                              TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).amunicja_iloœæ := Round(  Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )  )
                            else
                            if    ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' )
                              and ( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'zasiêg_od_parabola' ) then
                                TArtyleria(zt_gl_custom_scene_object).zasiêg_od_parabola := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                            else
                            if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'obra¿enia_zadawane' then
                              TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).obra¿enia_zadawane := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                            else
                            if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'obrót_k¹t_zablokowany_do' then
                              TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).obrót_k¹t_zablokowany_do := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                            else
                            if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'obrót_k¹t_zablokowany_od' then
                              TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).obrót_k¹t_zablokowany_od := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                            else
                            if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'obrót_k¹t_zablokowany_strza³_do' then
                              begin

                                jj := Length( TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).obrót_k¹t_zablokowany_strza³_do );
                                SetLength( TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).obrót_k¹t_zablokowany_strza³_do, jj + 1 );

                                TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).obrót_k¹t_zablokowany_strza³_do[ jj ] := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                              end
                            else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'obrót_k¹t_zablokowany_strza³_do' then
                            if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'obrót_szybkoœæ' then
                              TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).obrót_szybkoœæ := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0.0001, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                            else
                            if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'obrót_k¹t_zablokowany_strza³_od' then
                              begin

                                jj := Length( TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).obrót_k¹t_zablokowany_strza³_od );
                                SetLength( TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).obrót_k¹t_zablokowany_strza³_od, jj + 1 );

                                TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).obrót_k¹t_zablokowany_strza³_od[ jj ] := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                              end
                            else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'obrót_k¹t_zablokowany_strza³_od' then
                            if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'prze³adowanie_czas_milisekundy' then
                              begin

                                TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).prze³adowanie_czas_milisekundy := Round(  Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 1, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )  );

                                if TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).prze³adowanie_czas_milisekundy <= 0 then
                                  TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).prze³adowanie_czas_milisekundy := 1;

                              end
                            else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'prze³adowanie_czas_milisekundy' then
                            //if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'skala' then
                            //  TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).skala := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 1, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                            //else
                            if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'strza³_od_blokada_milisekundy' then
                              TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).strza³_od_blokada_milisekundy := Round(  Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 1, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )  )
                            else
                            if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'zasiêg' then
                              TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).zasiêg := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0.0001, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                          end;
                        //---//if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' ) (...)

                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'czy_obrót_lewo' then
                          begin

                            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'œruba' then
                              if AnsiLowerCase( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text ) = 'tak' then
                                TŒruba(zt_gl_custom_scene_object).czy_obrót_lewo := true;

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'czy_obrót_lewo' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'dziób' then
                          begin

                            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' then
                              if AnsiLowerCase( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text ) = 'tak' then
                                zt_gl_custom_scene_object.Tag := 1; // Oznacza, ¿e jest to dziób (czêœæ taranuj¹ca - wzmocniona).

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'dziób' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'kolor' then
                          begin

                            if    (   Trim(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Attributes[ 'nazwa' ] )  ) <> ''   )
                              and (   wygl¹d_kolor_definicja.Definicja_Istnieje(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Attributes[ 'nazwa' ] )  )   ) then
                              begin

                                kolor_vector := wygl¹d_kolor_definicja.Odczytaj_Definicjê(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Attributes[ 'nazwa' ] )  );

                              end
                            else//if    (   Trim(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Attributes[ 'nazwa' ] )  ) <> ''   ) (...)
                              begin

                                for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do
                                  begin

                                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'r' then
                                      ztr_1 := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                                    else
                                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'g' then
                                      ztr_2 := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                                    else
                                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'b' then
                                      ztr_3 := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                                    else
                                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'a' then
                                      ztr_4 := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                                  end;
                                //---//for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do

                                if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count > 0 then
                                  GLVectorGeometry.SetVector( kolor_vector, ztr_1, ztr_2, ztr_3, ztr_4 )
                                else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count > 0 then
                                  kolor_vector := clrGray20;

                              end;
                            //---//if    (   Trim(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Attributes[ 'nazwa' ] )  ) <> ''   ) (...)


                            if   ( zt_gl_custom_scene_object is TDzia³o )
                              or ( zt_gl_custom_scene_object is TTorpedy_Wyrzutnia ) then
                              begin

                                TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).korpus.Material.FrontProperties.Emission.Color := kolor_vector;
                                TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).korpus_przód.Material.FrontProperties.Emission.Color := kolor_vector;
                                TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).obrót_k¹t_zablokowany_GLDisk.Material.FrontProperties.Emission.Color := kolor_vector;
                                TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).podstawa.Material.FrontProperties.Emission.Color := kolor_vector;

                                for jj := 0 to Length( TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).lufy_t ) - 1 do
                                  begin

                                    TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).lufy_t[ jj ].korpus.Material.FrontProperties.Emission.Color := kolor_vector;
                                    TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).lufy_t[ jj ].wylot_pozycja.Material.FrontProperties.Emission.Color := kolor_vector;

                                  end;
                                //---//for jj := 0 to Length( TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).lufy_t ) - 1 do

                                if zt_gl_custom_scene_object is TDzia³o then
                                  begin

                                    TDzia³o(zt_gl_custom_scene_object).korpus_przód.Material.FrontProperties.Emission.Color := kolor_vector;

                                  end
                                else//if zt_gl_custom_scene_object is TTorpedy_Wyrzutnia then

                              end
                            else//if   ( zt_gl_custom_scene_object is TDzia³o ) (...)
                            if zt_gl_custom_scene_object is TŒruba then
                              begin

                                TŒruba(zt_gl_custom_scene_object).wa³.Material.FrontProperties.Emission.Color := kolor_vector;
                                TŒruba(zt_gl_custom_scene_object).wa³_³o¿ysko.Material.FrontProperties.Emission.Color := kolor_vector;
                                TŒruba(zt_gl_custom_scene_object).wa³_mocowanie.Material.FrontProperties.Emission.Color := kolor_vector;
                                TŒruba(zt_gl_custom_scene_object).wa³_podpórka.Material.FrontProperties.Emission.Color := kolor_vector;
                                TŒruba(zt_gl_custom_scene_object).wa³_do_wirnika.Material.FrontProperties.Emission.Color := kolor_vector;
                                TŒruba(zt_gl_custom_scene_object).wirnik_œrodek.Material.FrontProperties.Emission.Color := kolor_vector;

                                for jj := 0 to Length( TŒruba(zt_gl_custom_scene_object).wirnik_³opaty_t ) - 1 do
                                  TŒruba(zt_gl_custom_scene_object).wirnik_³opaty_t[ jj ].Material.FrontProperties.Emission.Color := kolor_vector;

                              end
                            else//if zt_gl_custom_scene_object is TŒruba then
                            if zt_gl_custom_scene_object is TSter then
                              begin

                                TSter(zt_gl_custom_scene_object).ster.Material.FrontProperties.Emission.Color := kolor_vector;
                                TSter(zt_gl_custom_scene_object).ster_mocowanie.Material.FrontProperties.Emission.Color := kolor_vector;

                              end
                            else//if zt_gl_custom_scene_object is TSter then
                              zt_gl_custom_scene_object.Material.FrontProperties.Emission.Color := kolor_vector;

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'kolor' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'kolor_nazwa' then
                          begin

                            zt_gl_custom_scene_object.Material.FrontProperties.Emission.Color := GLColor.ColorManager.GetColor( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text ); // Robi wyciek pamiêci. // clrGreen clrYellowGreen clrBronze2 clrGray40

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'kolor_nazwa' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'obrót__lewo_prawo' then
                          begin

                            if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' )
                              or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'dzia³o' )
                              or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'torpedy_wyrzutnia' ) then
                              TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).obrót_k¹t_zadany := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                            else//if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' ) (...)
                              zt_gl_custom_scene_object.TurnAngle := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'obrót__lewo_prawo' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'prêdkoœæ_obrotowa_maksymalna' then
                          begin

                            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'œruba' then
                              TŒruba(zt_gl_custom_scene_object).prêdkoœæ_obrotowa_maksymalna := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0.0001, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'prêdkoœæ_obrotowa_maksymalna' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'prêdkoœæ_obrotowa_przyspieszanie' then
                          begin

                            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'œruba' then
                              TŒruba(zt_gl_custom_scene_object).prêdkoœæ_obrotowa_przyspieszanie := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0.0001, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'prêdkoœæ_obrotowa_przyspieszanie' then
                        //if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'si³a_wp³ywu_kolizji' then
                        //    zt_gl_custom_scene_object.TagFloat := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0.0001, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                        //else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'si³a_wp³ywu_kolizji' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'skala' then
                          begin

                            if    ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName <> 'artyleria' )
                              and ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName <> 'dzia³o' )
                              and ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName <> 'torpedy_wyrzutnia' ) then                          
                              for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do
                                begin

                                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'x' then
                                    zt_gl_custom_scene_object.Scale.X := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0.0001, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                                  else
                                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'y' then
                                    zt_gl_custom_scene_object.Scale.Y := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0.0001, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                                  else
                                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'z' then
                                    zt_gl_custom_scene_object.Scale.Z := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0.0001, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                                end;
                              //---//for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'skala' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'skala_proporcjonalna' then
                          begin

                            if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' )
                              or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'dzia³o' )
                              or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'torpedy_wyrzutnia' ) then
                              TTorpedy_Wyrzutnia(zt_gl_custom_scene_object).skala := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0.0001, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                            else
                              zt_gl_custom_scene_object.Scale.Scale(  Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0.0001, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )  );

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'skala_proporcjonalna' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'tekstura' then
                          begin

                            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' then
                              if not Statki_Form.Wygl¹d_Elementy__Tekstura_Wczytaj( zt_gl_custom_scene_object, zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text ) then
                                Statki_Form.Log_Wypisz( 'Tworzenie elementów statku - b³¹d wczytania tekstury: ' + zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text + '.', not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'tekstura' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wartoœæ_dodatkowa_01' then
                          begin

                            if    ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' )
                              and ( zt_gl_custom_scene_object is TGLFrustrum ) then
                              TGLFrustrum(zt_gl_custom_scene_object).Height := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wartoœæ_dodatkowa_01' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wspó³rzêdne' then
                          begin

                            for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do
                              begin

                                if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'x' then
                                  zt_gl_custom_scene_object.Position.X := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                                else
                                if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'y' then
                                  zt_gl_custom_scene_object.Position.Y := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                                else
                                if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'z' then
                                  zt_gl_custom_scene_object.Position.Z := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                              end;
                            //---//for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wspó³rzêdne' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wychylenie__lewo_prawo' then
                          begin

                            zt_gl_custom_scene_object.RollAngle := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                          end
                        else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wychylenie__lewo_prawo' then
                        if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wychylenie__przód_ty³' then
                          begin
                          
                            if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' )
                              or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'dzia³o' ) then
                              begin

                                TDzia³o(zt_gl_custom_scene_object).podniesienie_k¹t_zadany := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );
                                TDzia³o(zt_gl_custom_scene_object).podniesienie_k¹t_zadany_bezwzglêdny := TDzia³o(zt_gl_custom_scene_object).podniesienie_k¹t_zadany;

                              end
                            else//if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' ) (...)
                              //if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName <> 'torpedy_wyrzutnia' then
                                zt_gl_custom_scene_object.PitchAngle := -Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                          end;
                        //---//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wychylenie__przód_ty³' then
                        
                      end;
                    //---//for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do

                  end;
                //---//if zt_gl_custom_scene_object <> nil then

              end
            else//if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'artyleria' ) (...)
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'falowanie_bok_skrêt_zakres' then
              Self.falowanie_bok_skrêt_zakres := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, null, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'falowanie_bok_zakres' then
              Self.falowanie_bok_zakres := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, null, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'falowanie_góra_dó³_zakres' then
              Self.falowanie_góra_dó³_zakres := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, null, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'falowanie_przód_zakres' then
              Self.falowanie_przód_zakres := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, null, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'kamera_na_statek_pozycja' then
              begin

                for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do
                  begin

                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'x' then
                      Self.kamera_na_statek_pozycja.X := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                    else
                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'y' then
                      Self.kamera_na_statek_pozycja.Y := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0.1, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                    else
                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'z' then
                      Self.kamera_na_statek_pozycja.Z := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                  end;
                //---//for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do

              end
            else//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'kamera_na_statek_pozycja' then
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'kamera_za_statkiem_pozycja' then
              begin

                for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do
                  begin

                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'x' then
                      Self.kamera_za_statkiem_pozycja.X := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                    else
                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'y' then
                      Self.kamera_za_statkiem_pozycja.Y := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0.1, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                    else
                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'z' then
                      Self.kamera_za_statkiem_pozycja.Z := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                  end;
                //---//for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do

              end
            else//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'kamera_za_statkiem_pozycja' then
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'kamera_odleg³oœæ_maksymalna' then
              Self.kamera_odleg³oœæ_maksymalna := Round(  Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )  )
            else
            if    ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'kolor_definicja' )
              and (   Trim(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'nazwa' ] )  ) <> ''   )
              and (   not wygl¹d_kolor_definicja.Definicja_Istnieje(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'nazwa' ] )  )   ) then
              begin

                for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do
                  begin

                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].LocalName = 'r' then
                      ztr_1 := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].Text, 0, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                    else
                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].LocalName = 'g' then
                      ztr_2 := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].Text, 0, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                    else
                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].LocalName = 'b' then
                      ztr_3 := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].Text, 0, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                    else
                    if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].LocalName = 'a' then
                      ztr_4 := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].Text, 0, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                  end;
                //---//for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do


                wygl¹d_kolor_definicja.Dodaj_Definicjê(  ztr_1, ztr_2, ztr_3, ztr_4, VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'nazwa' ] )  );

              end
            else//if    ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'kolor_definicja' ) (...)
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'luneta_zasiêg' then
              Self.luneta_zasiêg := Round(  Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )  )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'prêdkoœæ__kolizja_zwalnianie' then
              Self.prêdkoœæ__kolizja_zwalnianie := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0.0001, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'prêdkoœæ_maksymalna' then
              Self.prêdkoœæ_maksymalna := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0.0001, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'prêdkoœæ_ograniczenie' then
              Self.prêdkoœæ_ograniczenie := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0.0001, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'prêdkoœæ_przyspieszanie' then
              Self.prêdkoœæ_przyspieszanie := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0.0001, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'prêdkoœæ_zwalnianie' then
              Self.prêdkoœæ_zwalnianie := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0.0001, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'punkty_¿ycia_maksymalne' then
              begin

                Self.punkty_¿ycia_maksymalne := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0.0001, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );
                Self.punkty_¿ycia := Self.punkty_¿ycia_maksymalne;

              end
            else//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'punkty_¿ycia_maksymalne' then
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'punkty_¿ycia_wskaŸnik_wysokoœæ' then
              Self.punkty_¿ycia_dummy.Position.Y := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0.0001, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'radar_zasiêg' then
              Self.radar_zasiêg := Round(  Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )  )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'radio_zasiêg' then
              Self.radio_zasiêg := Round(  Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )  )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'sonar_zasiêg' then
              Self.sonar_zasiêg := Round(  Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )  )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'skrêt_k¹t_maksymalny' then
              Self.skrêt_k¹t_maksymalny := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0.0001, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'skrêt_prêdkoœæ' then
              Self.skrêt_prêdkoœæ := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0.0001, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'skrêt_szybkoœæ_wychylania_steru' then
              Self.skrêt_szybkoœæ_wychylania_steru := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0.0001, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
            else
            if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'skrêt_wspó³czynnik_do_prêdkoœci' then
              Self.skrêt_wspó³czynnik_do_prêdkoœci := Statki_Form.Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].Text, 0.0001, not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

          end;
        //---//for i := 0 to zt_xml_document.DocumentElement.ChildNodes.Count - 1 do


        FreeAndNil( wygl¹d_kolor_definicja );

      end;
    //---//if zt_xml_document.Active then
    {$endregion 'Odczyt danych xml.'}


    zt_xml_document.Free();


    {$region 'Przyk³ad xml.'}
  {
  <statek>
      <!-- Wymiar wynosi 1 we wszystkich g³ównych kierunkach. -->

    <nazwa>Nazwa abc</nazwa>
    <opis><![CDATA[Opis abc.#13#10Nowa linia.]]></opis>


    <kolor_definicja nazwa="kolor nazwa abc">
      <r>0,0</r>
      <g>0,5</g>
      <b>0,0</b>
      <a>0</a>
    </kolor_definicja>


    <falowanie_bok_skrêt_zakres>123,456</falowanie_bok_skrêt_zakres>
    <falowanie_bok_zakres>123,456</falowanie_bok_zakres>
    <falowanie_góra_dó³_zakres>123,456</falowanie_góra_dó³_zakres>
    <falowanie_przód_zakres>123,456</falowanie_przód_zakres>

    <kamera_odleg³oœæ_maksymalna>5</kamera_odleg³oœæ_maksymalna>

    <kamera_na_statek_pozycja>
      <x>0</x>
      <y>1</y>
      <z>0</z>
    </kamera_na_statek_pozycja>

    <kamera_za_statkiem_pozycja>
      <x>0</x>
      <y>5</y>
      <z>0</z>
    </kamera_za_statkiem_pozycja>

    <luneta_zasiêg>600</luneta_zasiêg>

    <punkty_¿ycia_maksymalne>10</punkty_¿ycia_maksymalne>
    <punkty_¿ycia_wskaŸnik_wysokoœæ>2,5</punkty_¿ycia_wskaŸnik_wysokoœæ>

    <prêdkoœæ__kolizja_zwalnianie>0</prêdkoœæ__kolizja_zwalnianie>
    <prêdkoœæ_maksymalna>2,01</prêdkoœæ_maksymalna>
    <prêdkoœæ_ograniczenie>100</prêdkoœæ_ograniczenie>
    <prêdkoœæ_przyspieszanie>1,05</prêdkoœæ_przyspieszanie>
    <prêdkoœæ_zwalnianie>0,3</prêdkoœæ_zwalnianie>

    <radar_zasiêg>100</radar_zasiêg>
    <radio_zasiêg>100</radio_zasiêg>
    <sonar_zasiêg>100</sonar_zasiêg>
        <!-- 0 - nieaktywny. -->

    <skrêt_k¹t_maksymalny>75</skrêt_k¹t_maksymalny>
    <skrêt_prêdkoœæ>20</skrêt_prêdkoœæ>
    <skrêt_szybkoœæ_wychylania_steru>0,4</skrêt_szybkoœæ_wychylania_steru>
    <skrêt_wspó³czynnik_do_prêdkoœci>25</skrêt_wspó³czynnik_do_prêdkoœci>


    <obiekt typ="kula">
      <kolor>
        <r>0</r>
        <g>1</g>
        <b>0,5</b>
        <a>0</a>
      </kolor>
        <!-- Od 0 (czarny) do 1 (bia³y), ujemne dzia³aj¹ jakoœ odwrotnie, a - nie wiem. -->
      <kolor nazwa="kolor nazwa abc"/>
      <kolor_nazwa>clrGreen</kolor_nazwa> <!-- Robi wyciek pamiêci. -->

      <skala>
        <x>1</x>
        <y>123,456</y>
        <z>123,456</z>
      </skala>
        <!-- 0 - w danym wymiarze jest jak p³aszczyzna, ujemne dzia³aj¹ jak dodatnie. -->

      <skala_proporcjonalna>2</skala_proporcjonalna>
        <!-- 0, ujemne dzia³aj¹ jak dodatnie. -->

      <wspó³rzêdne>
        <x>123,456</x>
        <y>123,456</y>
        <z>123,456</z>
      </wspó³rzêdne>

      <wychylenie__lewo_prawo>123,456</wychylenie__lewo_prawo>
      <obrót__lewo_prawo>123,456</obrót__lewo_prawo>
        <!-- Dodatnie w lewo (lewa burta). -->
      <wychylenie__przód_ty³>123,456</wychylenie__przód_ty³>
        <!-- -(minus) w dó³, +(plus) w górê. -->
        <!-- 0, ujemne dzia³aj¹, wiêksze wartoœci obni¿ane s¹ poprzez wielokrotnoœæ 180. -->

      <tekstura>K1\P_1.png</tekstura>
        <!-- Pliki 'png'. Domyœlnie œcie¿ka w katalogu 'Tekstury' w folderze z gr¹. -->

      <dziób>Tak</dziób>

    <wartoœæ_dodatkowa_01>123,456 abc</wartoœæ_dodatkowa_01>
      <!-- Dla wybranych prymitywów (bry³) dodatkowe parametry, których wartoœæ i typ wartoœci zale¿y od danego prymitywu. -->
        <!-- Dla prymitywu: ostros³up - Height - 123,456 - w zakresie od 0 do 1 - ( 0, 1 >. -->
    </obiekt>

    <œruba>
      <kolor>
        <r>0</r>
        <g>1</g>
        <b>0,5</b>
        <a>0</a>
      </kolor>
        <!-- Od 0 (czarny) do 1 (bia³y), ujemne dzia³aj¹ jakoœ odwrotnie, a - nie wiem. -->
      <kolor_nazwa>clrGreen</kolor_nazwa> <!-- Robi wyciek pamiêci. -->

      <skala>
        <x>1</x>
        <y>123,456</y>
        <z>123,456</z>
      </skala>
        <!-- 0 - w danym wymiarze jest jak p³aszczyzna, ujemne dzia³aj¹ jak dodatnie. -->

      <skala_proporcjonalna>2</skala_proporcjonalna>
        <!-- 0, ujemne dzia³aj¹ jak dodatnie. -->

      <wspó³rzêdne>
        <x>123,456</x>
        <y>123,456</y>
        <z>123,456</z>
      </wspó³rzêdne>

      <wychylenie__lewo_prawo>123,456</wychylenie__lewo_prawo>
      <obrót__lewo_prawo>123,456</obrót__lewo_prawo>
        <!-- Dodatnie w lewo (lewa burta). -->            
      <wychylenie__przód_ty³>123,456</wychylenie__przód_ty³>
        <!-- -(minus) w dó³, +(plus) w górê. -->
        <!-- 0, ujemne dzia³aj¹, wiêksze wartoœci obni¿ane s¹ poprzez wielokrotnoœæ 180. -->

      <czy_obrót_lewo>Tak</czy_obrót_lewo>
      <prêdkoœæ_obrotowa_maksymalna>8</prêdkoœæ_obrotowa_maksymalna>
      <prêdkoœæ_obrotowa_przyspieszanie>0,1</prêdkoœæ_obrotowa_przyspieszanie>
        <!-- Ca³kiem dobrze wychodzi gdy [œruba] prêdkoœæ_obrotowa_maksymalna / prêdkoœæ_obrotowa_przyspieszanie = [statek] prêdkoœæ_maksymalna / prêdkoœæ_przyspieszanie -->
    </œruba>

    <ster>
      <kolor>
        <r>0</r>
        <g>1</g>
        <b>0,5</b>
        <a>0</a>
      </kolor>
        <!-- Od 0 (czarny) do 1 (bia³y), ujemne dzia³aj¹ jakoœ odwrotnie, a - nie wiem. -->
      <kolor_nazwa>clrGreen</kolor_nazwa> <!-- Robi wyciek pamiêci. -->

      <skala>
        <x>1</x>
        <y>123,456</y>
        <z>123,456</z>
      </skala>
        <!-- 0 - w danym wymiarze jest jak p³aszczyzna, ujemne dzia³aj¹ jak dodatnie. -->

      <skala_proporcjonalna>2</skala_proporcjonalna>
        <!-- 0, ujemne dzia³aj¹ jak dodatnie. -->

      <wspó³rzêdne>
        <x>123,456</x>
        <y>123,456</y>
        <z>123,456</z>
      </wspó³rzêdne>

      <wychylenie__lewo_prawo>123,456</wychylenie__lewo_prawo>
      <obrót__lewo_prawo>123,456</obrót__lewo_prawo>
        <!-- Dodatnie w lewo (lewa burta). -->
      <wychylenie__przód_ty³>123,456</wychylenie__przód_ty³>
        <!-- -(minus) w dó³, +(plus) w górê. -->
        <!-- 0, ujemne dzia³aj¹, wiêksze wartoœci obni¿ane s¹ poprzez wielokrotnoœæ 180. -->
    </ster>

    <torpedy_wyrzutnia lufy_iloœæ="3">
      <kolor>
        <r>0</r>
        <g>1</g>
        <b>0,5</b>
        <a>0</a>
      </kolor>

      <skala_proporcjonalna>1</skala_proporcjonalna>

      <wspó³rzêdne>
        <x>-0,5</x>
        <y>0</y>
        <z>-2</z>
      </wspó³rzêdne>

      <obrót__lewo_prawo>123,456</obrót__lewo_prawo>
        <!-- Dodatnie w lewo (lewa burta). -->      
      
      <obrót_k¹t_zablokowany_do>1,1</obrót_k¹t_zablokowany_do>
      <obrót_k¹t_zablokowany_od>2,2</obrót_k¹t_zablokowany_od>

      <obrót_szybkoœæ>1,1</obrót_szybkoœæ>

      <obra¿enia_zadawane>11,3</obra¿enia_zadawane>
      <zasiêg>10,5</zasiêg>

      <amunicja_iloœæ>12</amunicja_iloœæ>
      <prze³adowanie_czas_milisekundy>3</prze³adowanie_czas_milisekundy>
      <strza³_od_blokada_milisekundy>100</strza³_od_blokada_milisekundy>

      <obrót_k¹t_zablokowany_strza³_do>1,1</obrót_k¹t_zablokowany_strza³_do>
      <obrót_k¹t_zablokowany_strza³_od>2,2</obrót_k¹t_zablokowany_strza³_od>
    </torpedy_wyrzutnia>

    <dzia³o lufy_iloœæ="2">
      <kolor>
        <r>0</r>
        <g>1</g>
        <b>0,5</b>
        <a>0</a>
      </kolor>

      <skala_proporcjonalna>0,5</skala_proporcjonalna>

      <wspó³rzêdne>
        <x>-0,5</x>
        <y>0</y>
        <z>-2</z>
      </wspó³rzêdne>

      <obrót__lewo_prawo>123,456</obrót__lewo_prawo>
        <!-- Dodatnie w lewo (lewa burta). -->      
      <wychylenie__przód_ty³>123,456</wychylenie__przód_ty³>
        <!-- -(minus) w dó³, +(plus) w górê. -->
        
      <obrót_k¹t_zablokowany_do>1,1</obrót_k¹t_zablokowany_do>
      <obrót_k¹t_zablokowany_od>2,2</obrót_k¹t_zablokowany_od>

      <obrót_szybkoœæ>1,1</obrót_szybkoœæ>

      <obra¿enia_zadawane>11,3</obra¿enia_zadawane>
      <zasiêg>10,5</zasiêg>

      <amunicja_iloœæ>12</amunicja_iloœæ>
      <prze³adowanie_czas_milisekundy>3</prze³adowanie_czas_milisekundy>
      <strza³_od_blokada_milisekundy>100</strza³_od_blokada_milisekundy>

      <obrót_k¹t_zablokowany_strza³_do>1,1</obrót_k¹t_zablokowany_strza³_do>
      <obrót_k¹t_zablokowany_strza³_od>2,2</obrót_k¹t_zablokowany_strza³_od>

      <podniesienie_k¹t_maksymalny>45,5</podniesienie_k¹t_maksymalny>
        <!-- -(minus) w dó³, +(plus) w górê. -->      
      <podniesienie_k¹t_minimalny>5,5</podniesienie_k¹t_minimalny>
        <!-- -(minus) w dó³, +(plus) w górê. -->      
      <podniesienie_szybkoœæ>1,1</podniesienie_szybkoœæ>
    </dzia³o>

    <artyleria lufy_iloœæ="1">
      <kolor>
        <r>0</r>
        <g>1</g>
        <b>0,5</b>
        <a>0</a>
      </kolor>

      <skala_proporcjonalna>2,5</skala_proporcjonalna>

      <wspó³rzêdne>
        <x>-0,5</x>
        <y>0</y>
        <z>-2</z>
      </wspó³rzêdne>

      <obrót__lewo_prawo>123,456</obrót__lewo_prawo>
        <!-- Dodatnie w lewo (lewa burta). -->      
      <wychylenie__przód_ty³>123,456</wychylenie__przód_ty³>
        <!-- -(minus) w dó³, +(plus) w górê. -->
        
      <obrót_k¹t_zablokowany_do>1,1</obrót_k¹t_zablokowany_do>
      <obrót_k¹t_zablokowany_od>2,2</obrót_k¹t_zablokowany_od>

      <obrót_szybkoœæ>1,1</obrót_szybkoœæ>

      <obra¿enia_zadawane>11,3</obra¿enia_zadawane>
      <zasiêg>10,5</zasiêg>

      <amunicja_iloœæ>12</amunicja_iloœæ>
      <prze³adowanie_czas_milisekundy>3</prze³adowanie_czas_milisekundy>
      <strza³_od_blokada_milisekundy>100</strza³_od_blokada_milisekundy>

      <obrót_k¹t_zablokowany_strza³_do>1,1</obrót_k¹t_zablokowany_strza³_do>
      <obrót_k¹t_zablokowany_strza³_od>2,2</obrót_k¹t_zablokowany_strza³_od>

      <podniesienie_k¹t_maksymalny>60,5</podniesienie_k¹t_maksymalny><!--- Dla k¹ta innego ni¿ 60 maksymalny zasiêg pocisk osi¹ga na dnie -->
      <podniesienie_k¹t_minimalny>5,5</podniesienie_k¹t_minimalny>
      <podniesienie_szybkoœæ>1,1</podniesienie_szybkoœæ>

      <zasiêg_od_parabola>10,5</zasiêg_od_parabola>
    </artyleria>

  </statek>
  }
    {$endregion 'Przyk³ad xml.'}

  end;//---//Funkcja Wygl¹d_Elementy_Utwórz() w Konstruktor klasy TStatek.

var
  i,
  j
    : integer;
begin//Konstruktor klasy TStatek.

  inherited Create( AOwner );


  Self.id_grupa := 0;
  Self.id_statek := id_statek_f;
  Self.id_statek_schemat := -1;

  Self.falowanie_bok_skrêt := 0;
  Self.falowanie_bok_skrêt_zakres := 10;
  Self.falowanie_bok_zakres := 2;
  Self.falowanie_bok_wychylenie_aktualne := 0;

  Self.falowanie_góra_dó³_zakres := 0.025;
  Self.falowanie_góra_dó³_wysokoœæ_aktualna := 0;

  Self.falowanie_przód_ruch := 0;
  Self.falowanie_przód_zakres := 1;
  Self.falowanie_przód_wychylenie_aktualne := 0;

  Self.falowanie_opóŸnienie := Random( 3000 );

  Self.wygl¹d_elementy_list := TList.Create();
  Self.kolizja_oznaczenie_string_list := TStringList.Create();

  Self.punkty_¿ycia_maksymalne := 10;
  Self.punkty_¿ycia := Self.punkty_¿ycia_maksymalne;
  Self.punkty_¿ycia_procent_zosta³o := 100;

  Self.prêdkoœæ_aktualna := 0;
  Self.prêdkoœæ_maksymalna := 2;  
  Self.prêdkoœæ_obrotu_aktualna := 0;
  Self.prêdkoœæ_ograniczenie := 100; // 100 2550
  Self.prêdkoœæ_procent := 0;
  Self.prêdkoœæ_przyspieszanie := 1.05; // Dobraæ tak aby ruch œrub odpowiada³ przyœpieszeniu statku (statek zmienia kierunek ruchu, a œruby jeszcze nie wyhamowa³y).  
  Self.prêdkoœæ_zadana_procent := 0;
  Self.prêdkoœæ_zwalnianie := Self.prêdkoœæ_przyspieszanie * 0.3;
  Self.prêdkoœæ__kolizja_zwalnianie := 0;

  Self.skrêt_k¹t_maksymalny := 75;
  Self.skrêt_procent := 0;
  Self.skrêt_szybkoœæ_wychylania_steru := 0.4;
  Self.skrêt_prêdkoœæ := 20;
  Self.skrêt_wspó³czynnik_do_prêdkoœci := 25;
  Self.skrêt_zadany_procent := 0;

  Self.toniêcie__czas_i := 0;
  Self.toniêcie__obrót__lewo_prawo := 0;
  Self.toniêcie__obrót__przód_ty³ := 0;
  Self.toniêcie__prêdkoœæ_w_dó³ := 0;

  Self.kamera_odleg³oœæ_maksymalna := 5;

  Self.luneta_zasiêg := 600;

  Self.radar_zasiêg := 100;
  Self.radio_zasiêg := 100;
  Self.sonar_zasiêg := 0;

  Self.radar_id_statki_w_zasiêgu := '-99, -99';
  Self.radio_id_statki_w_zasiêgu := '-99, -99';

  Self.artyleria_ostatni_strza³_indeks := -1;
  Self.dzia³o_ostatni_strza³_indeks := -1;
  Self.torpedy_wyrzutnia_ostatni_strza³_indeks := -1;

  Self.broñ_indeks_zmieniaj := true;

  Self.obrót_k¹t_zablokowany_wskaŸnik_widoczne := true;
  Self.obrót_k¹t_zablokowany_strza³_wskaŸnik_widoczne := true;
  Self.obracaj_dzia³a := true;
  Self.podnoœ_lufy := true;
  Self.czy_usun¹æ_statek := false;

  Self.kamera_na_statek_pozycja.X := 0;
  Self.kamera_na_statek_pozycja.Y := 1;
  Self.kamera_na_statek_pozycja.Z := 0;

  Self.kamera_za_statkiem_pozycja.X := 0;
  Self.kamera_za_statkiem_pozycja.Y := 5;
  Self.kamera_za_statkiem_pozycja.Z := 0;

  //Self.obracaj_dzia³a := false; //???
  //Self.podnoœ_lufy := false; //???

  Self.statki_rozstawianie_status := srs_Brak;

  Self.Parent := AOwner; //Gra_Obiekty_GLDummyCube
  //Self.MoveUp(); //???
  //Self.TurnAngle := 90;
  Self.Direction.SetVector( 0, 0, -1 );
  //Self.VisibleAtRunTime := true; //???
  //Self.ShowAxes := true; //???

  Self.falowanie_dummy := TGLDummyCube.Create( Self );
  Self.falowanie_dummy.Parent := Self;
  //Self.falowanie_dummy.VisibleAtRunTime := true; //???


  //zt_gl_base_scene_object := Self;
  zt_gl_base_scene_object := Self.falowanie_dummy; //???


  Self.punkty_¿ycia_dummy := TGLDummyCube.Create( Self );
  Self.punkty_¿ycia_dummy.Parent := Self;
  Self.punkty_¿ycia_dummy.Pickable := false;
  Self.punkty_¿ycia_dummy.Position.Y := 2;

  Self.punkty_¿ycia_podniesienie := TGLDummyCube.Create( Self );
  Self.punkty_¿ycia_podniesienie.Parent := punkty_¿ycia_dummy;
  Self.punkty_¿ycia_podniesienie.Pickable := false;

  Self.punkty_¿ycia__wskaŸnik := TGLCylinder.Create( Self );
  Self.punkty_¿ycia__wskaŸnik.Parent := Self.punkty_¿ycia_podniesienie; // punkty_¿ycia_dummy
  Self.punkty_¿ycia__wskaŸnik.Pickable := false;
  Self.punkty_¿ycia__wskaŸnik.RollAngle := 90;
  Self.punkty_¿ycia__wskaŸnik.BottomRadius := 0.15;
  Self.punkty_¿ycia__wskaŸnik.TopRadius := Self.punkty_¿ycia__wskaŸnik.BottomRadius;
  Self.punkty_¿ycia__wskaŸnik.Height := 1.5;
  Self.punkty_¿ycia__wskaŸnik.Material.MaterialOptions := [ GLMaterial.moNoLighting ]; // uses GLMaterial.
  Self.punkty_¿ycia__wskaŸnik.Material.FrontProperties.Diffuse.Color := clrGreen;
  Self.punkty_¿ycia__wskaŸnik.TagFloat := Self.punkty_¿ycia__wskaŸnik.Height; // Wielkoœæ z pe³nym ¿yciem.
  Self.punkty_¿ycia__wskaŸnik.Scale.Z := 0.075; // 0.075 0.3

  Self.punkty_¿ycia__ramka := TGLCube.Create( Self );
  Self.punkty_¿ycia__ramka.Parent := Self.punkty_¿ycia_podniesienie; // punkty_¿ycia_dummy
  Self.punkty_¿ycia__ramka.Pickable := false;
  Self.punkty_¿ycia__ramka.CubeHeight := Self.punkty_¿ycia__wskaŸnik.TopRadius * 2 + Self.punkty_¿ycia__wskaŸnik.TopRadius * 0.4; // Wysokoœæ. Promieñ * 2 + œrednica + 2 * 10% z ka¿dej strony (promieñ * 40%).
  Self.punkty_¿ycia__ramka.CubeWidth := Self.punkty_¿ycia__wskaŸnik.Height + Self.punkty_¿ycia__wskaŸnik.TopRadius * 2 * 0.4; // Szerokoœæ. Taki sam margines jak wy¿ej.
  Self.punkty_¿ycia__ramka.CubeDepth := 0.01; // Gruboœæ. // 0.01 0.03
  Self.punkty_¿ycia__ramka.Material.MaterialOptions := [ GLMaterial.moNoLighting ]; // uses GLMaterial.
  Self.punkty_¿ycia__ramka.Material.FrontProperties.Diffuse.Color := clrBlack;

  Self.punkty_¿ycia__napis := TGLSpaceText.Create( Self );
  Self.punkty_¿ycia__napis.Parent := Self.punkty_¿ycia_podniesienie; // punkty_¿ycia_dummy
  Self.punkty_¿ycia__napis.Pickable := false;
  Self.punkty_¿ycia__napis.TurnAngle := 180;
  Self.punkty_¿ycia__napis.Position.X := Self.punkty_¿ycia__ramka.CubeWidth * 0.475;
  Self.punkty_¿ycia__napis.Position.Y := -Self.punkty_¿ycia__ramka.CubeHeight * 0.2;
  Self.punkty_¿ycia__napis.Position.Z := -Self.punkty_¿ycia__ramka.CubeDepth * 2;
  //Self.punkty_¿ycia__napis.Scale.Scale( 0.25 );
  Self.punkty_¿ycia__napis.TextHeight := 0.2;
  Self.punkty_¿ycia__napis.Material.MaterialOptions := [ GLMaterial.moNoLighting ]; // uses GLMaterial.
  Self.punkty_¿ycia__napis.Text := 'p¿';

  Self.gracz__nazwa := TGLSpaceText.Create( Self );
  Self.gracz__nazwa.Parent := Self.punkty_¿ycia_podniesienie;
  Self.gracz__nazwa.Pickable := false;
  Self.gracz__nazwa.TurnAngle := 180;
  Self.gracz__nazwa.Position.X := Self.punkty_¿ycia__ramka.CubeWidth * 0.475;
  Self.gracz__nazwa.Position.Y := -Self.punkty_¿ycia__ramka.CubeHeight * 0.2 + Self.punkty_¿ycia__ramka.CubeHeight;
  Self.gracz__nazwa.Position.Z := -Self.punkty_¿ycia__ramka.CubeDepth * 2;
  Self.gracz__nazwa.TextHeight := 0.2;
  Self.gracz__nazwa.Material.MaterialOptions := [ GLMaterial.moNoLighting ]; // uses GLMaterial.
  Self.gracz__nazwa.Text := 'gn';
  Self.gracz__nazwa.Font.Style := [ fsBold ];
  //Self.gracz__nazwa.Extrusion := Self.gracz__nazwa.TextHeight;
  Self.gracz__nazwa.Material.BlendingMode := bmAdditive;


  Self.celownicza_linia := TGLLines.Create( Self );
  Self.celownicza_linia.Parent := Self;
  Self.celownicza_linia.Visible := false; //???
  //Self.celownicza_linia.Position.SetPoint( 0, 0, 0 );
  Self.celownicza_linia.Up.SetVector( 0, 1, 0 );
  Self.celownicza_linia.Direction.SetVector( 0, 0, -1 );
  Self.celownicza_linia.AddNode( 0, 1, 0 );
  Self.celownicza_linia.AddNode( 0, 0, 0 );
  //Self.celownicza_linia.Position.SetPoint( Self.celownicza_linia.Nodes[ 0 ].AsVector );


  if Trim( wygl¹d_definicja_f ) <> '' then
    begin

      Self.kad³ub := nil;
      Self.dziób := nil;

      SetLength( Self.artyleria_t, 0 ); // Iloœæ artylerii.
      SetLength( Self.dzia³a_t, 0 ); // Iloœæ dzia³.
      SetLength( Self.torpedy_wyrzutnie_t, 0 ); // Iloœæ wyrzutni torped.
      SetLength( Self.œruby_t, 0 ); // Iloœæ œrub.
      SetLength( Self.ster_t, 0 ); // Iloœæ sterów.

      Wygl¹d_Elementy_Utwórz();


      for i := 0 to Length( Self.artyleria_t ) - 1 do
        begin

          Self.artyleria_t[ i ].Dodatkowe_Elementy_Ustaw();

          if i = 0 then
            Self.artyleria_t[ i ].czy_indeks_do_strza³u := true;

          for j := 0 to Length( Self.artyleria_t[ i ].lufy_t ) - 1 do
            Self.artyleria_t[ i ].lufy_t[ j ].Dodatkowe_Elementy_Lufy_Pozycja_Ustaw();

        end;
      //---//for i := 0 to Length( Self.artyleria_t ) - 1 do

      for i := 0 to Length( Self.dzia³a_t ) - 1 do
        begin

          Self.dzia³a_t[ i ].Dodatkowe_Elementy_Ustaw();

          if i = 0 then
            Self.dzia³a_t[ i ].czy_indeks_do_strza³u := true;

          for j := 0 to Length( Self.dzia³a_t[ i ].lufy_t ) - 1 do
            Self.dzia³a_t[ i ].lufy_t[ j ].Dodatkowe_Elementy_Lufy_Pozycja_Ustaw();

        end;
      //---//for i := 0 to Length( Self.dzia³a_t ) - 1 do

      for i := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do
        begin

          if i = 0 then
            Self.torpedy_wyrzutnie_t[ i ].czy_indeks_do_strza³u := true;

          Self.torpedy_wyrzutnie_t[ i ].Dodatkowe_Elementy_Ustaw();

        end;
      //---//for i := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do

    end
  else//if Trim( wygl¹d_definicja_f ) <> '' then
    begin

      // Je¿eli nie podano definicji wygl¹du statku utworzy domyœlny wygl¹d.

      Self.kad³ub := TGLCube.Create( zt_gl_base_scene_object );
      Self.kad³ub.Parent := zt_gl_base_scene_object;
      Self.kad³ub.CubeHeight := 1;
      Self.kad³ub.CubeWidth := 3;
      Self.kad³ub.CubeDepth := 2;
      Self.kad³ub.TurnAngle := 90;


      Self.dziób := TGLCube.Create( zt_gl_base_scene_object );
      Self.dziób.Parent := zt_gl_base_scene_object;
      Self.dziób.TurnAngle := 45;
      Self.dziób.Position.Z := 1.5;
      Self.dziób.Tag := 1; // Oznacza, ¿e jest to dziób (czêœæ taranuj¹ca - wzmocniona).


      SetLength( Self.artyleria_t, 1 ); // Iloœæ artylerii.

      for i := 0 to Length( Self.artyleria_t ) - 1 do
        begin

          Self.artyleria_t[ i ] := TArtyleria.Create( zt_gl_base_scene_object, Self, gl_collision_mmanager_f, 3, 0 );
          //Self.artyleria_t[ i ].indeks_w_tabeli := i;
          Self.artyleria_t[ i ].Position.SetPoint( 0, 0.5, 1 );
          Self.artyleria_t[ i ].TurnAngle := 0; // Plus - lewo.
          Self.artyleria_t[ i ].skala := 2;
          Self.artyleria_t[ i ].Dodatkowe_Elementy_Ustaw();

          if i = 0 then
            Self.artyleria_t[ i ].czy_indeks_do_strza³u := true;

        end;
      //---//for i := 0 to Length( Self.artyleria_t ) - 1 do


      SetLength( Self.dzia³a_t, 1 ); // Iloœæ dzia³.

      for i := 0 to Length( Self.dzia³a_t ) - 1 do
        begin

          Self.dzia³a_t[ i ] := TDzia³o.Create( zt_gl_base_scene_object, Self, gl_collision_mmanager_f, 3, 0 );
          //Self.dzia³a_t[ i ].indeks_w_tabeli := i;
          Self.dzia³a_t[ i ].Position.SetPoint( 0, 1.25, 0.75 ); // 0, 1, 0 //???
          Self.dzia³a_t[ i ].TurnAngle := 0; // Plus - lewo.
          Self.dzia³a_t[ i ].skala := 0.5;
          Self.dzia³a_t[ i ].Dodatkowe_Elementy_Ustaw();

          if i = 0 then
            Self.dzia³a_t[ i ].czy_indeks_do_strza³u := true;

        end;
      //---//for i := 0 to Length( Self.dzia³a_t ) - 1 do


      SetLength( Self.torpedy_wyrzutnie_t, 1 ); // Iloœæ wyrzutni torped.

      for i := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do
        begin

          Self.torpedy_wyrzutnie_t[ i ] := TTorpedy_Wyrzutnia.Create( zt_gl_base_scene_object, Self, gl_collision_mmanager_f, 3 );
          //Self.torpedy_wyrzutnie_t[ i ].indeks_w_tabeli := i;
          Self.torpedy_wyrzutnie_t[ i ].Position.SetPoint( 0, 0.5, -1 ); // 0, 1, 0 //???
          Self.torpedy_wyrzutnie_t[ i ].TurnAngle := 180; // Plus - lewo.
          Self.torpedy_wyrzutnie_t[ i ].skala := 1;
          Self.torpedy_wyrzutnie_t[ i ].Dodatkowe_Elementy_Ustaw();

          if i = 0 then
            Self.torpedy_wyrzutnie_t[ i ].czy_indeks_do_strza³u := true;


          if i = 0 then //???
            begin

              SetLength( Self.torpedy_wyrzutnie_t[ i ].obrót_k¹t_zablokowany_strza³_do, 2 );
              SetLength(  Self.torpedy_wyrzutnie_t[ i ].obrót_k¹t_zablokowany_strza³_od, Length( Self.torpedy_wyrzutnie_t[ i ].obrót_k¹t_zablokowany_strza³_do )  );

              Self.torpedy_wyrzutnie_t[ i ].obrót_k¹t_zablokowany_strza³_od[ 0 ] := 50;
              Self.torpedy_wyrzutnie_t[ i ].obrót_k¹t_zablokowany_strza³_do[ 0 ] := -90;

              Self.torpedy_wyrzutnie_t[ i ].obrót_k¹t_zablokowany_strza³_od[ 1 ] := -170;
              Self.torpedy_wyrzutnie_t[ i ].obrót_k¹t_zablokowany_strza³_do[ 1 ] := 170;


              Self.torpedy_wyrzutnie_t[ i ].obrót_k¹t_zablokowany_od := 50; // 180  -90  50 -150
              Self.torpedy_wyrzutnie_t[ i ].obrót_k¹t_zablokowany_do := -50; //   90 -180 -50  150

            end;
          //---//if i = 0 then

          //Self.torpedy_wyrzutnie_t[ i ].obrót_szybkoœæ := 1; //???

        end;
      //---//for i := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do


      {$region 'Dzia³a ³adnie wygl¹daj¹ce.'}
//      SetLength(  Self.artyleria_wygl¹d_t, Length( Self.artyleria_t )  );
//
//      for i := 0 to Length( Self.artyleria_wygl¹d_t ) - 1 do
//        begin
//
//          Self.artyleria_wygl¹d_t[ i ] := TArtyleria.Create( zt_gl_base_scene_object, Self, gl_collision_mmanager_f );
//          Self.artyleria_wygl¹d_t[ i ].Parametry_Kopiuj_Dla_Wygl¹d( Self.artyleria_t[ i ] );
//
//        end;
//      //---//for i := 0 to Length( Self.artyleria_wygl¹d_t ) - 1 do
//
//
//      SetLength(  Self.dzia³a_wygl¹d_t, Length( Self.dzia³a_t )  );
//
//      for i := 0 to Length( Self.dzia³a_wygl¹d_t ) - 1 do
//        begin
//
//          Self.dzia³a_wygl¹d_t[ i ] := TDzia³o.Create( zt_gl_base_scene_object, Self, gl_collision_mmanager_f );
//          Self.dzia³a_wygl¹d_t[ i ].Parametry_Kopiuj_Dla_Wygl¹d( Self.dzia³a_t[ i ] );
//          //Self.dzia³a_wygl¹d_t[ i ].Position := Self.dzia³a_t[ i ].Position;
//          //Self.dzia³a_wygl¹d_t[ i ].skala := Self.dzia³a_t[ i ].skala;
//          //Self.dzia³a_wygl¹d_t[ i ].celownik_linia.Visible := false;
//          //Self.dzia³a_wygl¹d_t[ i ].Dodatkowe_Elementy_Ustaw();
//
//        end;
//      //---//for i := 0 to Length( Self.dzia³a_wygl¹d_t ) - 1 do
//
//
//      SetLength(  Self.torpedy_wyrzutnie_wygl¹d_t, Length( Self.torpedy_wyrzutnie_t )  );
//
//      for i := 0 to Length( Self.torpedy_wyrzutnie_wygl¹d_t ) - 1 do
//        begin
//
//          Self.torpedy_wyrzutnie_wygl¹d_t[ i ] := TTorpedy_Wyrzutnia.Create( zt_gl_base_scene_object, Self, gl_collision_mmanager_f );
//          Self.torpedy_wyrzutnie_wygl¹d_t[ i ].Parametry_Kopiuj_Dla_Wygl¹d( Self.torpedy_wyrzutnie_t[ i ] );
//
//        end;
//      //---//for i := 0 to Length( Self.torpedy_wyrzutnie_wygl¹d_t ) - 1 do
      {$endregion 'Dzia³a ³adnie wygl¹daj¹ce.'}


      SetLength( Self.œruby_t, 2 ); // Iloœæ œrub.

      for i := 0 to Length( Self.œruby_t ) - 1 do
        begin

          Self.œruby_t[ i ] := TŒruba.Create( zt_gl_base_scene_object, Self, i = 1, gl_collision_mmanager_f );
          Self.œruby_t[ i ].Position.SetPoint( 0, 0, 0 ); // 0, 1, 0 //???
          //Self.œruby_t[ i ].TurnAngle := 20 * i + 15; // Plus - lewo.
          //Self.œruby_t[ i ].TurnAngle := 90; // Plus - lewo.
          Self.œruby_t[ i ].Position.Y := -Self.kad³ub.CubeHeight;
          //Self.œruby_t[ i ].Position.Y := 2; //???

          //???
          if i = 0 then
            begin

              Self.œruby_t[ i ].Position.X := Self.kad³ub.CubeDepth * 0.3;

            end
          else//if i = 0 then
          if i = 1 then
            begin

              Self.œruby_t[ i ].Position.X := -Self.kad³ub.CubeDepth * 0.3;

            end;
          //---//if i = 1 then


          //Self.œruby_t[ i ].Position.Z := -4 + 2 * i; //???

        end;
      //---//for i := 0 to Length( Self.œruby_t ) - 1 do


      SetLength( Self.ster_t, 3 ); // Iloœæ sterów.

      for i := 0 to Length( Self.ster_t ) - 1 do
        begin

          Self.ster_t[ i ] := TSter.Create( zt_gl_base_scene_object, gl_collision_mmanager_f, 0, 0, 0 );
          Self.ster_t[ i ].Position.SetPoint( 0, 0, 0 ); // 0, 1, 0 //???
          Self.ster_t[ i ].Position.Z := -Self.kad³ub.CubeWidth * 0.5;

          //Self.ster_t[ i ].Position.Y := -Self.kad³ub.CubeHeight;
          //Self.ster_t[ i ].Position.Y := 2; //???

          //???
          if i = 0 then
            begin

              Self.ster_t[ i ].Position.X := Self.kad³ub.CubeDepth * 0.3;

            end
          else//if i = 0 then
          if i = 1 then
            begin

              Self.ster_t[ i ].Position.X := -Self.kad³ub.CubeDepth * 0.3;

            end;
          //---//if i = 1 then


          //Self.ster_t[ i ].Position.Z := -4 + 2 * i; //???

        end;
      //---//for i := 0 to Length( Self.ster_t ) - 1 do

    end;
  //---//if Trim( wygl¹d_definicja_f ) <> '' then


//  if Length( Self.artyleria_t ) > 0 then
//    Self.artyleria_ostatni_strza³_indeks := 0;
//
//  if Length( Self.dzia³a_t ) > 0 then
//    Self.dzia³o_ostatni_strza³_indeks := 0;
//
//  if Length( Self.torpedy_wyrzutnie_t ) > 0 then
//    Self.torpedy_wyrzutnia_ostatni_strza³_indeks := 0;


  if gl_collision_mmanager_f <> nil then
    begin

      if Self.dziób <> nil then
        with TGLBCollision.Create( Self.dziób.Behaviours ) do
          begin

            GroupIndex := 0;
            BoundingMode := cbmCube;
            Manager := gl_collision_mmanager_f;

          end;
        //---//with TGLBCollision.Create( Self.dziób.Behaviours ) do

      if Self.kad³ub <> nil then
        with TGLBCollision.Create( Self.kad³ub.Behaviours ) do
          begin

            GroupIndex := 0;
            BoundingMode := cbmCube;
            Manager := gl_collision_mmanager_f;

          end;
        //---//with TGLBCollision.Create( Self.kad³ub.Behaviours ) do

    end;
  //---//if gl_collision_mmanager_f <> nil then

end;//---//Konstruktor klasy TStatek.

//Destruktor klasy TStatek.
destructor TStatek.Destroy();
var
  i : integer;
begin

  Self.kolizja_oznaczenie_string_list.Clear();
  FreeAndNil( Self.kolizja_oznaczenie_string_list );


  if    ( Self.wygl¹d_elementy_list <> nil )
    and (  Assigned( Self.wygl¹d_elementy_list )  ) then
    for i := Self.wygl¹d_elementy_list.Count - 1 downto 0 do
      begin

        TGLCustomSceneObject(Self.wygl¹d_elementy_list[ i ]).Free();
        Self.wygl¹d_elementy_list.Delete( i );

      end;
    //---//for i := Self.wygl¹d_elementy_list.Count - 1 downto 0 do

  FreeAndNil( Self.wygl¹d_elementy_list );


  FreeAndNil( Self.dziób );
  FreeAndNil( Self.kad³ub );

  FreeAndNil( Self.gracz__nazwa );
  FreeAndNil( Self.punkty_¿ycia__wskaŸnik );
  FreeAndNil( Self.punkty_¿ycia__ramka );
  FreeAndNil( Self.punkty_¿ycia__napis );
  FreeAndNil( Self.punkty_¿ycia_podniesienie );
  FreeAndNil( Self.punkty_¿ycia_dummy );

  FreeAndNil( Self.celownicza_linia );


  for i := 0 to Length( Self.artyleria_t ) - 1 do
    FreeAndNil( Self.artyleria_t[ i ] );

  SetLength( Self.artyleria_t, 0 );

  for i := 0 to Length( Self.artyleria_wygl¹d_t ) - 1 do
    FreeAndNil( Self.artyleria_wygl¹d_t[ i ] );

  SetLength( Self.artyleria_wygl¹d_t, 0 );


  for i := 0 to Length( Self.dzia³a_t ) - 1 do
    FreeAndNil( Self.dzia³a_t[ i ] );

  SetLength( Self.dzia³a_t, 0 );

  for i := 0 to Length( Self.dzia³a_wygl¹d_t ) - 1 do
    FreeAndNil( Self.dzia³a_wygl¹d_t[ i ] );

  SetLength( Self.dzia³a_wygl¹d_t, 0 );


  for i := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do
    FreeAndNil( Self.torpedy_wyrzutnie_t[ i ] );

  SetLength( Self.torpedy_wyrzutnie_t, 0 );

  for i := 0 to Length( Self.torpedy_wyrzutnie_wygl¹d_t ) - 1 do
    FreeAndNil( Self.torpedy_wyrzutnie_wygl¹d_t[ i ] );

  SetLength( Self.torpedy_wyrzutnie_wygl¹d_t, 0 );


  for i := 0 to Length( Self.œruby_t ) - 1 do
    FreeAndNil( Self.œruby_t[ i ] );

  SetLength( Self.œruby_t, 0 );


  for i := 0 to Length( Self.ster_t ) - 1 do
    FreeAndNil( Self.ster_t[ i ] );

  SetLength( Self.ster_t, 0 );


  FreeAndNil( Self.falowanie_dummy );

  inherited;

end;//---//Destruktor klasy TStatek.

//Funkcja Prêdkoœæ_Zadana_Procent_Zmieñ().
function TStatek.K¹t_Obrotu_Statku() : real; //???
var
  zt_vector : GLVectorGeometry.TVector; // uses GLVectorGeometry.
begin

  //
  // Funkcja okreœla k¹t obrotu statku wzglêdem osi z w kierunku -1 (pozycja startowa kamery spogl¹da w przód = w g³¹b mapy).
  //
  //         0
  //     -45 | 45
  // -90     |     90
  //    -135 | 135
  //         |
  //        180
  //

  Result := 0;

  // Góra Prawo.
  if    ( Self.AbsoluteDirection.X >= 0 )
    and ( Self.AbsoluteDirection.Z <= 0 ) then
    Result := -Self.TurnAngle
  else
  // Góra Lewo.
  if    ( Self.AbsoluteDirection.X < 0 )
    and ( Self.AbsoluteDirection.Z <= 0 ) then
    Result := 180 + Self.TurnAngle;
  // Dó³ Prawo.
  if    ( Self.AbsoluteDirection.X >= 0 )
    and ( Self.AbsoluteDirection.Z > 0 ) then
    Result := 180 + Self.TurnAngle
  else
  // Dó³ Lewo.
  if    ( Self.AbsoluteDirection.X < 0 )
    and ( Self.AbsoluteDirection.Z > 0 ) then
    Result := -( 360 + Self.TurnAngle ); // 270 + 90

  //Statki_Form.Caption := FloatToStr( Result );

end;//---//Funkcja Prêdkoœæ_Zadana_Procent_Zmieñ().

//Funkcja Prêdkoœæ_Zadana_Procent_Zmieñ().
procedure TStatek.Prêdkoœæ_Zadana_Procent_Zmieñ( const zmieñ_o_f : integer );
begin

  //
  // Funkcja modyfikuje o podan¹ wartoœæ prêdkoœæ zadan¹ w procentach.
  //// -100 -75 -50 -25 0 25 50 75 100
  //
  // Parametry:
  //   zmieñ_o_f:
  //     < 0 - zwalnia / cofa.
  //     0 - zeruje.
  //     > 0 - przyœpiesza.
  //

  if zmieñ_o_f = 0 then
    Self.prêdkoœæ_zadana_procent := 0
  else//if zmieñ_o_f = 0 then
    Self.prêdkoœæ_zadana_procent := Self.prêdkoœæ_zadana_procent + zmieñ_o_f;

  if Self.prêdkoœæ_zadana_procent > 100 then
    Self.prêdkoœæ_zadana_procent := 100
  else
  if Self.prêdkoœæ_zadana_procent < -100 then
    Self.prêdkoœæ_zadana_procent := -100;

  //if zmieñ_o_f = 0 then
  //  Self.prêdkoœæ_zadana_procent := 0
  //else//if zmieñ_o_f = 0 then
  //if zmieñ_o_f > 0 then
  //  begin
  //
  //    // Przyœpieszanie.
  //
  //    if Self.prêdkoœæ_zadana_procent <= 75 then
  //      begin
  //
  //        if Self.prêdkoœæ_zadana_procent >= 0 then
  //          Self.prêdkoœæ_zadana_procent := Self.prêdkoœæ_zadana_procent + 25
  //        else//if Self.prêdkoœæ_zadana_procent >= 0 then
  //          Self.prêdkoœæ_zadana_procent := Self.prêdkoœæ_zadana_procent + 25; // 50 dla wariantu -100 -50 0.
  //
  //      end;
  //    //---//if Self.prêdkoœæ_zadana_procent <= 75 then
  //
  //
  //    if Self.prêdkoœæ_zadana_procent > 100 then
  //      Self.prêdkoœæ_zadana_procent := 100;
  //
  //  end
  //else//if zmieñ_o_f > 0 then
  //if zmieñ_o_f < 0 then
  //  begin
  //
  //    // Zwalnianie / cofanie.
  //
  //    if Self.prêdkoœæ_zadana_procent >= -75 then
  //      begin
  //
  //        if Self.prêdkoœæ_zadana_procent > 0 then
  //          Self.prêdkoœæ_zadana_procent := Self.prêdkoœæ_zadana_procent - 25
  //        else//if Self.prêdkoœæ_zadana_procent > 0 then
  //          Self.prêdkoœæ_zadana_procent := Self.prêdkoœæ_zadana_procent - 25; // -50 dla wariantu -100 -50 0.
  //
  //      end;
  //    //---//if Self.prêdkoœæ_zadana_procent >= -50 then
  //
  //
  //    if Self.prêdkoœæ_zadana_procent < -100 then
  //      Self.prêdkoœæ_zadana_procent := -100;
  //
  //  end;
  ////---//if zmieñ_o_f < 0 then

end;//---//Funkcja Prêdkoœæ_Zadana_Procent_Zmieñ().

//Funkcja Skrêt_Zadany_Procent_Zmieñ().
procedure TStatek.Skrêt_Zadany_Procent_Zmieñ( const zmieñ_o_f : integer );
begin

  //
  // Funkcja modyfikuje o podan¹ wartoœæ skrêt zadany w procentach.
  //// -100 -75 -50 -20 0 25 50 75 100
  //
  // Parametry:
  //   zmieñ_o_f:
  //     < 0 - lewo.
  //     0 - zeruje.
  //     > 0 - w prawo
  //

  if zmieñ_o_f = 0 then
    Self.skrêt_zadany_procent := 0
  else//if zmieñ_o_f = 0 then
    Self.skrêt_zadany_procent := Self.skrêt_zadany_procent + zmieñ_o_f;

  if Self.skrêt_zadany_procent < -100 then
    Self.skrêt_zadany_procent := -100
  else
  if Self.skrêt_zadany_procent > 100 then
    Self.skrêt_zadany_procent := 100;

  //if zmieñ_o_f = 0 then
  //  Self.skrêt_zadany_procent := 0
  //else//if zmieñ_o_f = 0 then
  //if zmieñ_o_f < 0 then
  //  begin
  //
  //    // W lewo.
  //
  //    if Self.skrêt_zadany_procent >= -75 then
  //      begin
  //
  //        Self.skrêt_zadany_procent := Self.skrêt_zadany_procent - 25;
  //
  //      end;
  //    //---//if Self.skrêt_zadany_procent >= -75 then
  //
  //
  //    if Self.skrêt_zadany_procent < -100 then
  //      Self.skrêt_zadany_procent := -100;
  //
  //  end
  //else//if zmieñ_o_f < 0 then
  //if zmieñ_o_f > 0 then
  //  begin
  //
  //    // W prawo.
  //
  //    if Self.skrêt_zadany_procent <= 75 then
  //      begin
  //
  //        Self.skrêt_zadany_procent := Self.skrêt_zadany_procent + 25;
  //
  //      end;
  //    //---//if Self.skrêt_zadany_procent <= 75 then
  //
  //
  //    if Self.skrêt_zadany_procent > 100 then
  //      Self.skrêt_zadany_procent := 100;
  //
  //  end;
  ////---//if zmieñ_o_f > 0 then

end;//---//Funkcja Skrêt_Zadany_Procent_Zmieñ().

//Funkcja Prêdkoœæ_Procent_Zmieñ().
procedure TStatek.Prêdkoœæ_Procent_Zmieñ();
begin

  //
  // Funkcja modyfikuje prêdkoœæ w procentach.
  //
  //  Zmiana prêdkoœci odbywa siê zawsze pe³n¹ moc¹ i liniowo.
  //  Moc silników wp³ywa na zmianê prêdkoœci tylko gdy zadana prêdkoœæ jest bezwzglêdnie wiêksza lub ma znak przeciwny od obecnej prêdkoœci.
  //

  if Self.punkty_¿ycia <= 0 then
    begin

      if Self.prêdkoœæ_zadana_procent <> 0 then
        Self.prêdkoœæ_zadana_procent := 0;

    end;
  //---//if Self.punkty_¿ycia <= 0 then


  // Wyhamowywanie.
  if Abs( Self.prêdkoœæ_procent ) > Self.prêdkoœæ_zwalnianie * Statki_Form.gra_wspó³czynnik_prêdkoœci_g then
    begin

      if Self.prêdkoœæ_procent > 0 then
        Self.prêdkoœæ_procent := Self.prêdkoœæ_procent - Self.prêdkoœæ_zwalnianie * Statki_Form.gra_wspó³czynnik_prêdkoœci_g
      else//if Self.prêdkoœæ_procent > 0 then
      if Self.prêdkoœæ_procent < 0 then
        Self.prêdkoœæ_procent := Self.prêdkoœæ_procent + Self.prêdkoœæ_zwalnianie * Statki_Form.gra_wspó³czynnik_prêdkoœci_g;

    end
  else//if Abs( Self.prêdkoœæ_procent ) > Self.prêdkoœæ_zwalnianie * Statki_Form.gra_wspó³czynnik_prêdkoœci_g then
    Self.prêdkoœæ_procent := 0; // Prêdkoœæ mniejsza od wspó³czynnika wyhamowywania jest zerowana.


  //if Self.prêdkoœæ_zadana_procent <> 0 then
    if Self.prêdkoœæ_procent < Self.prêdkoœæ_zadana_procent then
      begin

        // Przyœpieszanie.

        if Self.prêdkoœæ_zadana_procent > 0 then
          Self.prêdkoœæ_procent := Self.prêdkoœæ_procent + Self.prêdkoœæ_przyspieszanie * Statki_Form.gra_wspó³czynnik_prêdkoœci_g;

        if Self.prêdkoœæ_procent > Self.prêdkoœæ_zadana_procent then
         Self.prêdkoœæ_procent := Self.prêdkoœæ_zadana_procent;

      end
    else//if Self.prêdkoœæ_procent < Self.prêdkoœæ_zadana_procent then
    if Self.prêdkoœæ_procent > Self.prêdkoœæ_zadana_procent then
      begin

        // Cofanie.

        if Self.prêdkoœæ_zadana_procent < 0 then
          Self.prêdkoœæ_procent := Self.prêdkoœæ_procent - Self.prêdkoœæ_przyspieszanie * Statki_Form.gra_wspó³czynnik_prêdkoœci_g;

        if Self.prêdkoœæ_procent < Self.prêdkoœæ_zadana_procent then
         Self.prêdkoœæ_procent := Self.prêdkoœæ_zadana_procent;

      end;
    //---//if Self.prêdkoœæ_procent > Self.prêdkoœæ_zadana_procent then



  // Wyhamowywanie wynikaj¹ce z kolizji.
  if    (  Abs( Self.prêdkoœæ_procent ) > 0  )
    and ( Self.prêdkoœæ__kolizja_zwalnianie <> 0 ) then
    begin

      //Self.prêdkoœæ_procent := Self.prêdkoœæ_procent * (  100 - Abs( Self.prêdkoœæ_procent ) * Self.prêdkoœæ__kolizja_zwalnianie  ) * 0.01;
      Self.prêdkoœæ_procent :=
          Self.prêdkoœæ_procent
        * (
              (
                  100 - Abs( Self.prêdkoœæ_procent ) // Im wiêksza prêdkoœæ tym mniejsza wartoœæ (tym bardziej zmniejsza prêdkoœæ im prêdkoœæ jest wiêksza).
                * Self.prêdkoœæ__kolizja_zwalnianie
              )
            * 0.01 // Wyliczanie wartoœci procentowej (x / 100 = x%).
          ) // Prêdkoœæ jest pomniejszana o tyle procent.
        * 0.85 // Modyfikuje si³ê wp³ywu kolizji na prêdkoœæ.
        * Statki_Form.gra_wspó³czynnik_prêdkoœci_g;


      if Self.prêdkoœæ_procent > Self.prêdkoœæ_ograniczenie then
        Self.prêdkoœæ_procent := Self.prêdkoœæ_ograniczenie
      else
      if Self.prêdkoœæ_procent < -Self.prêdkoœæ_ograniczenie then
        Self.prêdkoœæ_procent := -Self.prêdkoœæ_ograniczenie;


      Self.prêdkoœæ__kolizja_zwalnianie := 0;

    end;
  //---//if Abs( Self.prêdkoœæ_procent ) > Self.prêdkoœæ_zwalnianie then

end;//---//Funkcja Prêdkoœæ_Procent_Zmieñ().

//Funkcja Skrêt_Procent_Zmieñ().
procedure TStatek.Skrêt_Procent_Zmieñ();
var
  i : integer;
begin

  //
  // Funkcja modyfikuje skrêt w procentach.
  //
  //  Zmiana skrêtu odbywa siê zawsze pe³n¹ moc¹ i liniowo.
  //

  if Self.skrêt_procent > Self.skrêt_zadany_procent then
    begin

      // Lewo.

      Self.skrêt_procent := Self.skrêt_procent - Self.skrêt_szybkoœæ_wychylania_steru * Statki_Form.gra_wspó³czynnik_prêdkoœci_g;

      if Self.skrêt_procent < Self.skrêt_zadany_procent then
       Self.skrêt_procent := Self.skrêt_zadany_procent;

    end
  else//if Self.skrêt_procent > Self.skrêt_zadany_procent then
  if Self.skrêt_procent < Self.skrêt_zadany_procent then
    begin

      // Prawo.

      Self.skrêt_procent := Self.skrêt_procent + Self.skrêt_szybkoœæ_wychylania_steru * Statki_Form.gra_wspó³czynnik_prêdkoœci_g;

      if Self.skrêt_procent > Self.skrêt_zadany_procent then
       Self.skrêt_procent := Self.skrêt_zadany_procent;

    end;
  //---//if Self.skrêt_procent < Self.skrêt_zadany_procent then


  for i := 0 to Length( Self.ster_t ) - 1 do
    begin

      if i = 0 then
        Self.ster_t[ i ].TurnAngle := Self.skrêt_k¹t_maksymalny * Self.skrêt_procent * 0.01
      else//if i = 0 then
        Self.ster_t[ i ].TurnAngle := Self.ster_t[ 0 ].TurnAngle;

    end;
  //---//for i := 0 to Length( Self.ster_t ) - 1 do

end;//---//Funkcja Skrêt_Procent_Zmieñ().

//Funkcja Broñ_Indeks_Zmieniaj_Ustaw().
procedure TStatek.Broñ_Indeks_Zmieniaj_Ustaw( const amunicja_rodzaj_zbiór_f : TAmunicja_Rodzaj_Zbiór );
begin

  //
  // Funkcja ustawia czy po strzale ustawiæ siê na nastêpn¹ broñ tego samego rodzaju czy nie.
  //


  Self.broñ_indeks_zmieniaj := not Self.broñ_indeks_zmieniaj;


  if    (
             ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
          or ( ar_Artyleria in amunicja_rodzaj_zbiór_f )
        )
    and ( Self.artyleria_ostatni_strza³_indeks < 0 )
    and (  Length( Self.artyleria_t ) > 0  ) then
    Self.artyleria_ostatni_strza³_indeks := Length( Self.artyleria_t ) - 1;


  if    (
             ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
          or ( ar_Pocisk in amunicja_rodzaj_zbiór_f )
        )
    and ( Self.dzia³o_ostatni_strza³_indeks < 0 )
    and (  Length( Self.dzia³a_t ) > 0  ) then
    Self.dzia³o_ostatni_strza³_indeks := Length( Self.dzia³a_t ) - 1;


  if    (
             ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
          or ( ar_Torpeda in amunicja_rodzaj_zbiór_f )
        )
    and ( Self.torpedy_wyrzutnia_ostatni_strza³_indeks < 0 )
    and (  Length( Self.torpedy_wyrzutnie_t ) > 0  ) then
    Self.torpedy_wyrzutnia_ostatni_strza³_indeks := Length( Self.torpedy_wyrzutnie_t ) - 1;

end;//---//Funkcja Broñ_Indeks_Zmieniaj_Ustaw().

//Funkcja Broñ_Indeks_Zmieniaj_Ustaw().
procedure TStatek.Broñ_Indeks_Zmieniaj_Ustaw( const czy_poprzednia_f : boolean; const amunicja_rodzaj_zbiór_f : TAmunicja_Rodzaj_Zbiór );

  //Funkcja Broñ_Indeks_Ustaw() w Broñ_Indeks_Zmieniaj_Ustaw().
  procedure Broñ_Indeks_Ustaw( broñ_t_f : array of TTorpedy_Wyrzutnia; var broñ_ostatni_strza³_indeks_f : integer );
  var
    i,
    zti
      : integer;
  begin

    if czy_poprzednia_f then
      begin

        dec( broñ_ostatni_strza³_indeks_f );

      end
    else//if czy_poprzednia_f then
      begin

        inc( broñ_ostatni_strza³_indeks_f );

      end;
    //---//if czy_poprzednia_f then


    if broñ_ostatni_strza³_indeks_f < 0 then
      broñ_ostatni_strza³_indeks_f := Length( broñ_t_f ) - 1;

    if broñ_ostatni_strza³_indeks_f > Length( broñ_t_f ) - 1 then
      broñ_ostatni_strza³_indeks_f := 0;


    zti := broñ_ostatni_strza³_indeks_f + 1;

    if zti > Length( broñ_t_f ) - 1 then
      zti := 0;


    for i := 0 to Length( broñ_t_f ) - 1 do
      broñ_t_f[ i ].czy_indeks_do_strza³u := i = zti;

  end;//Funkcja Broñ_Indeks_Ustaw() w Broñ_Indeks_Zmieniaj_Ustaw().

type
  TTorpedy_Wyrzutnia_t_l = array of TTorpedy_Wyrzutnia; // Tylko aby wywo³aæ funkcjê.

var
  i : integer;
begin//Funkcja Broñ_Indeks_Zmieniaj_Ustaw().

  //
  // Funkcja przestawia na kolejn¹ lub poprzedni¹ broñ tego samego rodzaju.
  //
  // Parametry:
  //   czy_poprzednia_f:
  //     false - przestawia na nastêpn¹.
  //     true - przestawia na poprzedni¹.
  //

  if    (
             ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
          or ( ar_Artyleria in amunicja_rodzaj_zbiór_f )
        )
    and ( Self.artyleria_ostatni_strza³_indeks < 0 )
    and (  Length( Self.artyleria_t ) > 0  ) then
    Self.artyleria_ostatni_strza³_indeks := Length( Self.artyleria_t ) - 1;


  if    (
             ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
          or ( ar_Pocisk in amunicja_rodzaj_zbiór_f )
        )
    and ( Self.dzia³o_ostatni_strza³_indeks < 0 )
    and (  Length( Self.dzia³a_t ) > 0  ) then
    Self.dzia³o_ostatni_strza³_indeks := Length( Self.dzia³a_t ) - 1;


  if    (
             ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
          or ( ar_Torpeda in amunicja_rodzaj_zbiór_f )
        )
    and ( Self.torpedy_wyrzutnia_ostatni_strza³_indeks < 0 )
    and (  Length( Self.torpedy_wyrzutnie_t ) > 0  ) then
    Self.torpedy_wyrzutnia_ostatni_strza³_indeks := Length( Self.torpedy_wyrzutnie_t ) - 1;



  if
       ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
    or ( ar_Artyleria in amunicja_rodzaj_zbiór_f )
    and (  Length( Self.artyleria_t ) > 0  ) then
    Broñ_Indeks_Ustaw( TTorpedy_Wyrzutnia_t_l(Self.artyleria_t), Self.artyleria_ostatni_strza³_indeks );

  if
       ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
    or ( ar_Pocisk in amunicja_rodzaj_zbiór_f )
    and (  Length( Self.dzia³a_t ) > 0  ) then
    Broñ_Indeks_Ustaw( TTorpedy_Wyrzutnia_t_l(Self.dzia³a_t), Self.dzia³o_ostatni_strza³_indeks );

  if
       ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
    or ( ar_Torpeda in amunicja_rodzaj_zbiór_f )
    and (  Length( Self.torpedy_wyrzutnie_t ) > 0  ) then
    Broñ_Indeks_Ustaw( Self.torpedy_wyrzutnie_t, Self.torpedy_wyrzutnia_ostatni_strza³_indeks );

end;//---//Funkcja Broñ_Indeks_Zmieniaj_Ustaw().

//Funkcja Strza³().
function TStatek.Strza³( const amunicja_rodzaj_zbiór_f : TAmunicja_Rodzaj_Zbiór; const czy_wszystkie_bronie_f, czy_wszystkie_lufy_f, obracaj_dzia³a_f, podnoœ_lufy_f : boolean; const cel_wspó³rzêdne_f : TAffineVector ) : boolean;
var
  wystrzeli³y_wszystkie_l : boolean;

  //Funkcja Strza³_Jedn¹_Luf¹() w Strza³().
  function Strza³_Jedn¹_Luf¹( broñ_t_f : array of TTorpedy_Wyrzutnia; var broñ_ostatni_strza³_indeks_f : integer; const czy_indeks_do_strza³u_f : boolean = true ) : boolean;
  var
    i,
    próby_strza³u_iloœæ
      : integer;

    //Funkcja Broñ_Kolejny_Egzemplarz_Do_Próby_Strza³u_Wyznacz() w Strza³_Jedn¹_Luf¹() w Strza³().
    function Broñ_Kolejny_Egzemplarz_Do_Próby_Strza³u_Wyznacz() : boolean;
    begin

      //
      // Funkcja wyznacza kolejny egzemplarz broni do próby strza³u.
      // Je¿eli do pojedynczego strza³u jest wyznaczone dzia³o, które jeszcze nie wycelowa³o (albo np. nie mo¿e wycelowaæ z powodu blokad obrotu) spróbuje strzeliæ innym dzia³em.
      //
      // Zwraca prawdê gdy nale¿y podj¹æ próbê strza³u z innego egzemplarza broni.
      //

      if not Self.broñ_indeks_zmieniaj then
        begin

          Result := false;
          Exit;

        end
      else//if not Self.broñ_indeks_zmieniaj then
        Result := true;


      inc( i );

      if i > Length( broñ_t_f ) - 1 then
        i := 0;

    end;//---//Funkcja Broñ_Kolejny_Egzemplarz_Do_Próby_Strza³u_Wyznacz() w Strza³_Jedn¹_Luf¹() w Strza³().

  begin//Funkcja Strza³_Jedn¹_Luf¹() w Strza³().

    // czy_indeks_do_strza³u_f
    //   false - próbuje strzelaæ któr¹kolwiek broni¹ danego rodzaju.
    //   true - próbuje strzelaæ tylko broni¹ wyznaczon¹ do strza³u.

    Result := false;


    próby_strza³u_iloœæ := 1;

    i := broñ_ostatni_strza³_indeks_f;

    inc( i );

    if i > Length( broñ_t_f ) - 1 then
      i := 0;


    while próby_strza³u_iloœæ <= Length( broñ_t_f ) do
      begin

        inc( próby_strza³u_iloœæ );


        if   ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
          or ( broñ_t_f[ i ].amunicja_rodzaj in amunicja_rodzaj_zbiór_f ) then
          begin

            if    (
                       ( not czy_indeks_do_strza³u_f )
                    or (
                             ( czy_indeks_do_strza³u_f )
                         and ( broñ_t_f[ i ].czy_indeks_do_strza³u )
                       )
                  )
              and (  broñ_t_f[ i ].Strza³( czy_wszystkie_lufy_f, obracaj_dzia³a_f, podnoœ_lufy_f, wystrzeli³y_wszystkie_l, cel_wspó³rzêdne_f )  ) then
              begin

                //broñ_ostatni_strza³_indeks_f := i;


                if Self.broñ_indeks_zmieniaj then
                  if wystrzeli³y_wszystkie_l then
                    begin

                      broñ_ostatni_strza³_indeks_f := i;

                      if broñ_t_f[ i ].czy_indeks_do_strza³u then
                        begin

                          broñ_t_f[ i ].czy_indeks_do_strza³u := false;


                          // Oznacza, które dzia³o bêdzie strzelaæ pojedynczo jako kolejne.
                          inc( i );

                          if i > Length( broñ_t_f ) - 1 then
                            i := 0;

                          broñ_t_f[ i ].czy_indeks_do_strza³u := true;
                          //---// Oznacza, które dzia³o bêdzie strzelaæ pojedynczo jako kolejne.

                        end;
                      //---//broñ_t_f[ i ].czy_indeks_do_strza³u

                    end;
                  //---//if wystrzeli³y_wszystkie_l then


                Result := true;

                Exit;

              end
            else//if    ( (...)
              if not Broñ_Kolejny_Egzemplarz_Do_Próby_Strza³u_Wyznacz() then
                Exit;

          end
        else//if   ( ar_Wszystkie in amunicja_rodzaj_zbiór_f ) (...)
          if not Broñ_Kolejny_Egzemplarz_Do_Próby_Strza³u_Wyznacz() then
            Exit;

      end;
    //---//while próby_strza³u_iloœæ <= Length( broñ_t_f ) do


    if    ( not Result )
      and ( czy_indeks_do_strza³u_f ) then
      Result := Strza³_Jedn¹_Luf¹( broñ_t_f, broñ_ostatni_strza³_indeks_f, false );

  end;//Funkcja Strza³_Jedn¹_Luf¹() w Strza³().

  //Funkcja Strza³_Wszystkie_Bronie_Jednego_Rodzaju() w Strza³().
  function Strza³_Wszystkie_Bronie_Jednego_Rodzaju( broñ_t_f : array of TTorpedy_Wyrzutnia; var broñ_ostatni_strza³_indeks_f : integer ) : boolean;
  var
    i : integer;
  begin

    Result := false;

    for i := 0 to Length( broñ_t_f ) - 1 do
      if    (
                 ( czy_wszystkie_bronie_f )
              or ( broñ_t_f[ i ].czy_indeks_do_strza³u )
            )
        and (
                 ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
              or ( broñ_t_f[ i ].amunicja_rodzaj in amunicja_rodzaj_zbiór_f )
            ) then
        begin

          broñ_t_f[ i ].Strza³( czy_wszystkie_lufy_f, obracaj_dzia³a_f, podnoœ_lufy_f, wystrzeli³y_wszystkie_l, cel_wspó³rzêdne_f );

          if not Result then
            Result := true;


          if    ( Self.broñ_indeks_zmieniaj )
            and ( not czy_wszystkie_bronie_f )
            and ( czy_wszystkie_lufy_f ) then
            begin

              if broñ_ostatni_strza³_indeks_f < 0 then
                broñ_ostatni_strza³_indeks_f := 0;

              inc( broñ_ostatni_strza³_indeks_f );

              if broñ_ostatni_strza³_indeks_f > Length( broñ_t_f ) - 1 then
                broñ_ostatni_strza³_indeks_f := 0;

              broñ_t_f[ i ].czy_indeks_do_strza³u := false;
              broñ_t_f[ broñ_ostatni_strza³_indeks_f ].czy_indeks_do_strza³u := true;

              Break;

            end;
          //---//if    ( Self.broñ_indeks_zmieniaj ) (...)

        end;
      //---//if    ( (...)

  end;//Funkcja Strza³_Wszystkie_Bronie_Jednego_Rodzaju() w Strza³().

type
  TTorpedy_Wyrzutnia_t_l = array of TTorpedy_Wyrzutnia; // Tylko aby wywo³aæ funkcjê.

var
  ztb : boolean;
begin//Funkcja Strza³().

  //
  // Funkcja strzela wszystkimi lufami lub ustala kolejn¹ (nastêpn¹ po poprzednim strzale) gotow¹ lufê i strzela jedn¹ luf¹.
  //
  // Zwraca prawdê gdy wystrzeli.
  //
  // Parametry:
  //   czy_wszystkie_bronie_f
  //     true - strza³ wszystkimi broniami wybranego rodzaju.
  //     false - strza³ jedn¹ broni¹ (egzemplarz) wybranego rodzaju.
  //   czy_wszystkie_lufy_f:
  //     true - strza³ wszystkimi lufami jednej (egzemplarz) broni.
  //     false - strza³ jedn¹ luf¹ jednej (egzemplarz) broni.
  //   obracaj_dzia³a_f
  //     true - strzela tylko gdy dzia³o jest wycelowane.
  //     false - je¿eli dzia³a s¹ zablokowane mo¿na strzeliæ mimo nie wycelowania.
  //

  Result := false;


  if Self.punkty_¿ycia <= 0 then
    Exit;


  if    (
             ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
          or ( ar_Artyleria in amunicja_rodzaj_zbiór_f )
        )
    and (  Length( Self.artyleria_t ) > 0  ) then
    begin

      if czy_wszystkie_bronie_f then
        ztb := Strza³_Wszystkie_Bronie_Jednego_Rodzaju( TTorpedy_Wyrzutnia_t_l(Self.artyleria_t), Self.artyleria_ostatni_strza³_indeks )
      else//if czy_wszystkie_bronie_f then
        ztb := Strza³_Jedn¹_Luf¹( TTorpedy_Wyrzutnia_t_l(Self.artyleria_t), Self.artyleria_ostatni_strza³_indeks );

      if    ( not Result )
        and ( ztb ) then
        Result := true;

    end;
  //---//if    ( (...)


  if   (
             ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
          or ( ar_Pocisk in amunicja_rodzaj_zbiór_f )
        )
    and (  Length( Self.dzia³a_t ) > 0  ) then
    begin

      if czy_wszystkie_bronie_f then
        ztb := Strza³_Wszystkie_Bronie_Jednego_Rodzaju( TTorpedy_Wyrzutnia_t_l(Self.dzia³a_t), Self.dzia³o_ostatni_strza³_indeks )
      else//if czy_wszystkie_bronie_f then
        ztb := Strza³_Jedn¹_Luf¹( TTorpedy_Wyrzutnia_t_l(Self.dzia³a_t), Self.dzia³o_ostatni_strza³_indeks );

      if    ( not Result )
        and ( ztb ) then
        Result := true;

    end;
  //---//if    ( (...)


  if   (
             ( ar_Wszystkie in amunicja_rodzaj_zbiór_f )
          or ( ar_Torpeda in amunicja_rodzaj_zbiór_f )
        )
    and (  Length( Self.torpedy_wyrzutnie_t ) > 0  ) then
    begin

      if czy_wszystkie_bronie_f then
        ztb := Strza³_Wszystkie_Bronie_Jednego_Rodzaju( Self.torpedy_wyrzutnie_t, Self.torpedy_wyrzutnia_ostatni_strza³_indeks )
      else//if czy_wszystkie_bronie_f then
        ztb := Strza³_Jedn¹_Luf¹( Self.torpedy_wyrzutnie_t, Self.torpedy_wyrzutnia_ostatni_strza³_indeks );

      if    ( not Result )
        and ( ztb ) then
        Result := true;

    end;
  //---//if    ( (...)

end;//---//Funkcja Strza³().

//Funkcja Elementy_Gracza_Dostosuj().
procedure TStatek.Elementy_Gracza_Dostosuj( const id_grupa_gracza_f : integer; const punkty_¿ycia_wskaŸnik_widoczne__gracz_f, punkty_¿ycia_wskaŸnik_widoczne__przeciwnik_f, punkty_¿ycia_wskaŸnik_widoczne__sojusznik_f, obrót_k¹t_zablokowany_wskaŸnik_widoczne_f, obrót_k¹t_zablokowany_strza³_wskaŸnik_widoczne_f : boolean );
var
  i,
  j
    : integer;
begin

  //
  // Funkcja ukrywa lub wyœwietla elementy statku, które na swoim statku gracz.
  //
  // Parametry:
  //   id_grupa_gracza_f - id grupy, do której nale¿y gracz.
  //     -99 - modyfikacje dotycz¹ statku gracza.
  //     ró¿ne od -99 - modyfikacje dotycz¹ statków innych graczy.
  //   punkty_¿ycia_wskaŸnik_widoczne__gracz_f
  //   punkty_¿ycia_wskaŸnik_widoczne__przeciwnik_f
  //   punkty_¿ycia_wskaŸnik_widoczne__sojusznik_f
  //   obrót_k¹t_zablokowany_wskaŸnik_widoczne_f
  //   obrót_k¹t_zablokowany_strza³_wskaŸnik_widoczne_f
  //

  if id_grupa_gracza_f = -99 then
    begin

      // Modyfikacje dotycz¹ statku gracza.

      Self.punkty_¿ycia_dummy.Visible := punkty_¿ycia_wskaŸnik_widoczne__gracz_f;


      if   ( Self.obrót_k¹t_zablokowany_wskaŸnik_widoczne <> obrót_k¹t_zablokowany_wskaŸnik_widoczne_f )
        or ( Self.obrót_k¹t_zablokowany_strza³_wskaŸnik_widoczne <> obrót_k¹t_zablokowany_strza³_wskaŸnik_widoczne_f )  then
        begin

          Self.obrót_k¹t_zablokowany_wskaŸnik_widoczne := obrót_k¹t_zablokowany_wskaŸnik_widoczne_f;
          Self.obrót_k¹t_zablokowany_strza³_wskaŸnik_widoczne := obrót_k¹t_zablokowany_strza³_wskaŸnik_widoczne_f;

          {$region 'Dzia³a normalne.'}
          // Je¿eli s¹ dzia³a ³adnie wygl¹daj¹ce to tych strzelaj¹cych nie pokazuje siê. //??? Niesprawdzone.
          if   ( not obrót_k¹t_zablokowany_wskaŸnik_widoczne_f )
            or (  Length( Self.artyleria_wygl¹d_t ) <= 0  )then
            for i := 0 to Length( Self.artyleria_t ) - 1 do
              begin

                Self.artyleria_t[ i ].obrót_k¹t_zablokowany_GLDisk.Visible := obrót_k¹t_zablokowany_wskaŸnik_widoczne_f;

                for j := 0 to Length( Self.artyleria_t[ i ].obrót_k¹t_zablokowany_strza³_do ) - 1 do
                  Self.artyleria_t[ i ].obrót_k¹t_zablokowany_strza³_GLDisk_t[ j ].Visible := obrót_k¹t_zablokowany_strza³_wskaŸnik_widoczne_f;

              end;
            //---//for i := 0 to Length( Self.artyleria_t ) - 1 do


          if   ( not obrót_k¹t_zablokowany_wskaŸnik_widoczne_f )
            or (  Length( Self.dzia³a_wygl¹d_t ) <= 0  )then
            for i := 0 to Length( Self.dzia³a_t ) - 1 do
              begin

                Self.dzia³a_t[ i ].obrót_k¹t_zablokowany_GLDisk.Visible := obrót_k¹t_zablokowany_wskaŸnik_widoczne_f;

                for j := 0 to Length( Self.dzia³a_t[ i ].obrót_k¹t_zablokowany_strza³_do ) - 1 do
                  Self.dzia³a_t[ i ].obrót_k¹t_zablokowany_strza³_GLDisk_t[ j ].Visible := obrót_k¹t_zablokowany_strza³_wskaŸnik_widoczne_f;

              end;
            //---//for i := 0 to Length( Self.dzia³a_t ) - 1 do


          if   ( not obrót_k¹t_zablokowany_wskaŸnik_widoczne_f )
            or (  Length( Self.torpedy_wyrzutnie_wygl¹d_t ) <= 0  )then
            for i := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do
              begin

                Self.torpedy_wyrzutnie_t[ i ].obrót_k¹t_zablokowany_GLDisk.Visible := obrót_k¹t_zablokowany_wskaŸnik_widoczne_f;

                for j := 0 to Length( Self.torpedy_wyrzutnie_t[ i ].obrót_k¹t_zablokowany_strza³_do ) - 1 do
                  Self.torpedy_wyrzutnie_t[ i ].obrót_k¹t_zablokowany_strza³_GLDisk_t[ j ].Visible := obrót_k¹t_zablokowany_strza³_wskaŸnik_widoczne_f;

              end;
            //---//for i := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do
          {$endregion 'Dzia³a normalne.'}


          {$region 'Dzia³a wygl¹d.'}
          for i := 0 to Length( Self.artyleria_wygl¹d_t ) - 1 do
            begin

              Self.artyleria_wygl¹d_t[ i ].obrót_k¹t_zablokowany_GLDisk.Visible := obrót_k¹t_zablokowany_wskaŸnik_widoczne_f;

              for j := 0 to Length( Self.artyleria_wygl¹d_t[ i ].obrót_k¹t_zablokowany_strza³_do ) - 1 do
                Self.artyleria_wygl¹d_t[ i ].obrót_k¹t_zablokowany_strza³_GLDisk_t[ j ].Visible := obrót_k¹t_zablokowany_strza³_wskaŸnik_widoczne_f;

            end;
          //---//for i := 0 to Length( Self.artyleria_wygl¹d_t ) - 1 do


          for i := 0 to Length( Self.dzia³a_wygl¹d_t ) - 1 do
            begin

              Self.dzia³a_wygl¹d_t[ i ].obrót_k¹t_zablokowany_GLDisk.Visible := obrót_k¹t_zablokowany_wskaŸnik_widoczne_f;

              for j := 0 to Length( Self.dzia³a_wygl¹d_t[ i ].obrót_k¹t_zablokowany_strza³_do ) - 1 do
                Self.dzia³a_wygl¹d_t[ i ].obrót_k¹t_zablokowany_strza³_GLDisk_t[ j ].Visible := obrót_k¹t_zablokowany_strza³_wskaŸnik_widoczne_f;

            end;
          //---//for i := 0 to Length( Self.dzia³a_wygl¹d_t ) - 1 do


          for i := 0 to Length( Self.torpedy_wyrzutnie_wygl¹d_t ) - 1 do
            begin

              Self.torpedy_wyrzutnie_wygl¹d_t[ i ].obrót_k¹t_zablokowany_GLDisk.Visible := obrót_k¹t_zablokowany_wskaŸnik_widoczne_f;

              for j := 0 to Length( Self.torpedy_wyrzutnie_wygl¹d_t[ i ].obrót_k¹t_zablokowany_strza³_do ) - 1 do
                Self.torpedy_wyrzutnie_wygl¹d_t[ i ].obrót_k¹t_zablokowany_strza³_GLDisk_t[ j ].Visible := obrót_k¹t_zablokowany_strza³_wskaŸnik_widoczne_f;

            end;
          //---//for i := 0 to Length( Self.torpedy_wyrzutnie_wygl¹d_t ) - 1 do
          {$endregion 'Dzia³a wygl¹d.'}

        end;
      //---//if   ( Self.obrót_k¹t_zablokowany_wskaŸnik_widoczne <> obrót_k¹t_zablokowany_wskaŸnik_widoczne_f ) (...)

    end
  else//if id_grupa_gracza_f = -99 then
    begin

      // Modyfikacje dotycz¹ statków innych graczy.

      if Self.id_grupa = id_grupa_gracza_f then
        begin

          Self.punkty_¿ycia_dummy.Visible := punkty_¿ycia_wskaŸnik_widoczne__sojusznik_f;

        end
      else//if Self.id_grupa = id_grupa_gracza_f then
        begin

          Self.punkty_¿ycia_dummy.Visible := punkty_¿ycia_wskaŸnik_widoczne__przeciwnik_f;

        end;
      //---//if Self.id_grupa = id_grupa_gracza_f then

    end;
  //---//if id_grupa_gracza_f = -99 then

end;//---//Funkcja Elementy_Gracza_Dostosuj().

//Funkcja Elementy_Gracza_Widocznoœæ().
procedure TStatek.Elementy_Gracza_Widocznoœæ( const id_grupa_gracza_f : integer; const widoczne_f : boolean );

  //Funkcja Tag_Widocznoœæ_Wpisz() w Elementy_Gracza_Widocznoœæ().
  function Tag_Widocznoœæ_Wpisz() : integer;
  begin

    //
    // Funkcja zamienia boolean na integer.
    //
    // Zwraca integer.
    //

    if widoczne_f then
      Result := 1
    else//if widoczne_f then
      Result := 0;

  end;//---//Funkcja Tag_Widocznoœæ_Wpisz() w Elementy_Gracza_Widocznoœæ().

var
  i,
  j
    : integer;
begin//Funkcja Elementy_Gracza_Widocznoœæ().

  //
  // Funkcja ukrywa lub wyœwietla elementy statku, które widzi tylko gracz tego statku.
  //
  // Parametry:
  //   id_grupa_gracza_f - id grupy, do której nale¿y gracz.
  //   widoczne_f:
  //     true - elementy s¹ widoczne.
  //     false - elementy nie s¹ widoczne.
  //

  Self.celownicza_linia.Visible := widoczne_f;


  if Self.id_grupa <> id_grupa_gracza_f then
    Self.punkty_¿ycia__wskaŸnik.Material.FrontProperties.Diffuse.Color := clrRed;


  {$region 'Dzia³a normalne.'}
  // Je¿eli s¹ dzia³a ³adnie wygl¹daj¹ce to tych strzelaj¹cych nie pokazuje siê. //??? Niesprawdzone.
  if   ( not widoczne_f )
    or (  Length( Self.artyleria_wygl¹d_t ) <= 0  )then
    for i := 0 to Length( Self.artyleria_t ) - 1 do
      begin

        Self.artyleria_t[ i ].celownik_linia.Visible := widoczne_f;
        Self.artyleria_t[ i ].celownik_linia_bez_falowania.Visible := Self.artyleria_t[ i ].celownik_linia.Visible;
        Self.artyleria_t[ i ].celownik_linia.Tag := Tag_Widocznoœæ_Wpisz();

        for j := 0 to Length( Self.artyleria_t[ i ].lufy_t ) - 1 do
          Self.artyleria_t[ i ].lufy_t[ j ].prze³adowanie_wskaŸnik.Visible := widoczne_f;

      end;
    //---//for i := 0 to Length( Self.artyleria_t ) - 1 do


  if   ( not widoczne_f )
    or (  Length( Self.dzia³a_wygl¹d_t ) <= 0  )then
    for i := 0 to Length( Self.dzia³a_t ) - 1 do
      begin

        Self.dzia³a_t[ i ].celownik_linia.Visible := widoczne_f;
        Self.dzia³a_t[ i ].celownik_linia_bez_falowania.Visible := Self.dzia³a_t[ i ].celownik_linia.Visible;
        Self.dzia³a_t[ i ].celownik_linia.Tag := Tag_Widocznoœæ_Wpisz();

        for j := 0 to Length( Self.dzia³a_t[ i ].lufy_t ) - 1 do
          Self.dzia³a_t[ i ].lufy_t[ j ].prze³adowanie_wskaŸnik.Visible := widoczne_f;

      end;
    //---//for i := 0 to Length( Self.dzia³a_t ) - 1 do


  if   ( not widoczne_f )
    or (  Length( Self.torpedy_wyrzutnie_wygl¹d_t ) <= 0  )then
    for i := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do
      begin

        Self.torpedy_wyrzutnie_t[ i ].celownik_linia.Visible := widoczne_f;
        Self.torpedy_wyrzutnie_t[ i ].celownik_linia_bez_falowania.Visible := Self.torpedy_wyrzutnie_t[ i ].celownik_linia.Visible;
        Self.torpedy_wyrzutnie_t[ i ].celownik_linia.Tag := Tag_Widocznoœæ_Wpisz();

        for j := 0 to Length( Self.torpedy_wyrzutnie_t[ i ].lufy_t ) - 1 do
          Self.torpedy_wyrzutnie_t[ i ].lufy_t[ j ].prze³adowanie_wskaŸnik.Visible := widoczne_f;

      end;
    //---//for i := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do
  {$endregion 'Dzia³a normalne.'}


  {$region 'Dzia³a wygl¹d.'}
  for i := 0 to Length( Self.artyleria_wygl¹d_t ) - 1 do
    begin

      Self.artyleria_wygl¹d_t[ i ].celownik_linia.Visible := widoczne_f;

      for j := 0 to Length( Self.artyleria_wygl¹d_t[ i ].lufy_t ) - 1 do
        Self.artyleria_wygl¹d_t[ i ].lufy_t[ j ].prze³adowanie_wskaŸnik.Visible := widoczne_f;

    end;
  //---//for i := 0 to Length( Self.artyleria_wygl¹d_t ) - 1 do


  for i := 0 to Length( Self.dzia³a_wygl¹d_t ) - 1 do
    begin

      Self.dzia³a_wygl¹d_t[ i ].celownik_linia.Visible := widoczne_f;

      for j := 0 to Length( Self.dzia³a_wygl¹d_t[ i ].lufy_t ) - 1 do
        Self.dzia³a_wygl¹d_t[ i ].lufy_t[ j ].prze³adowanie_wskaŸnik.Visible := widoczne_f;

    end;
  //---//for i := 0 to Length( Self.dzia³a_wygl¹d_t ) - 1 do


  for i := 0 to Length( Self.torpedy_wyrzutnie_wygl¹d_t ) - 1 do
    begin

      Self.torpedy_wyrzutnie_wygl¹d_t[ i ].celownik_linia.Visible := widoczne_f;

      for j := 0 to Length( Self.torpedy_wyrzutnie_wygl¹d_t[ i ].lufy_t ) - 1 do
        Self.torpedy_wyrzutnie_wygl¹d_t[ i ].lufy_t[ j ].prze³adowanie_wskaŸnik.Visible := widoczne_f;

    end;
  //---//for i := 0 to Length( Self.torpedy_wyrzutnie_wygl¹d_t ) - 1 do
  {$endregion 'Dzia³a wygl¹d.'}

end;//---//Funkcja Elementy_Gracza_Widocznoœæ().

//Funkcja Punkty_¯ycia_Zmieñ().
procedure TStatek.Punkty_¯ycia_Zmieñ( const wartoœæ_f : real );
begin

  //
  // Funkcja modyfikuje wartoœæ punktów ¿ycia.
  //

  if Self.punkty_¿ycia > 0 then // Gdy punkty ¿ycia s¹ zerowe nie nalicza obra¿eñ.
    Self.punkty_¿ycia := Self.punkty_¿ycia + wartoœæ_f;

  if Self.punkty_¿ycia < 0 then
    Self.punkty_¿ycia := 0;

  if Self.punkty_¿ycia > Self.punkty_¿ycia_maksymalne then //???
    Self.punkty_¿ycia := Self.punkty_¿ycia_maksymalne;

  if Self.punkty_¿ycia_maksymalne <> 0 then
    Self.punkty_¿ycia_procent_zosta³o := 100 * Self.punkty_¿ycia / Self.punkty_¿ycia_maksymalne
  else//if Self.punkty_¿ycia_maksymalne <> 0 then
    Self.punkty_¿ycia_procent_zosta³o := 0;

  //if Self.punkty_¿ycia <= 0 then
  //  Self.czy_usun¹æ_statek := true;

end;//---//Funkcja Punkty_¯ycia_Zmieñ().

//Funkcja Punkty_¯ycia_WskaŸnik_Rysuj().
procedure TStatek.Punkty_¯ycia_WskaŸnik_Rysuj( const gl_camera_f : TGLCamera; const wartoœæ_liczbowa_f : integer );
begin

  //
  // Funkcja rysuje wskaŸnik punktów ¿ycia.
  //
  // Parametry:
  //   gl_camera_f - kamera do której obracaæ wskaŸnik
  //   wartoœæ_liczbowa_f:
  //     0 - brak.
  //     1 - punkty ¿ycia.
  //     2 - punkty ¿ycia %.
  //     3 - punkty ¿ycia i punkty ¿ycia %.
  //


  if   ( gl_camera_f = nil )
    or (  not Assigned( gl_camera_f )  ) then
    Exit;

  //Self.punkty_¿ycia_dummy.VisibleAtRunTime := true; //???
  //Self.punkty_¿ycia_podniesienie.VisibleAtRunTime := true; //???

  // Obraca (lewo prawo) aby czo³o by³o równolegle do ekranu.
  Self.punkty_¿ycia_dummy.AbsoluteDirection := GLVectorGeometry.VectorMake
    (
        gl_camera_f.AbsoluteDirection.X - Self.punkty_¿ycia_dummy.Position.X
      , 0 //gl_camera_f.AbsoluteDirection.Y - Self.punkty_¿ycia_dummy.Position.Y
      , gl_camera_f.AbsoluteDirection.Z - Self.punkty_¿ycia_dummy.Position.Z
    );

  if gl_camera_f.Up.Y < 0 then // Je¿eli kamera patrz¹c w górê lub w dó³ przekrêci siê do góry nogami to wskaŸnik ¿ycia równie¿ obraca³ siê do góry nogami.
    Self.punkty_¿ycia_dummy.AbsoluteDirection := GLVectorGeometry.VectorNegate( Self.punkty_¿ycia_dummy.AbsoluteDirection );
  //---// Obraca (lewo prawo) aby czo³o by³o równolegle do ekranu.

  // Obraca (góra dó³) aby czo³o by³o równolegle do ekranu.
  Self.punkty_¿ycia_podniesienie.PitchAngle :=
    RadToDeg( // uses Math.
        AngleBetweenVectors( // uses GLVectorGeometry.
           GLVectorGeometry.VectorMake(  gl_camera_f.AbsoluteDirection.X, Abs( gl_camera_f.AbsoluteDirection.Y ), gl_camera_f.AbsoluteDirection.Z  ),
           GLVectorGeometry.VectorMake( gl_camera_f.AbsoluteDirection.X, 0, gl_camera_f.AbsoluteDirection.Z ),
           GLVectorGeometry.VectorMake( 0, 0, 0 )
         )
      );

  if gl_camera_f.AbsoluteDirection.Y < 0 then
    Self.punkty_¿ycia_podniesienie.PitchAngle := -Self.punkty_¿ycia_podniesienie.PitchAngle;
  //---// Obraca (góra dó³) aby czo³o by³o równolegle do ekranu.



  // Wersja B.
  // Wylicza dobrze ale je¿eli statek odp³ynie w bok ekranu to k¹t miêdzy kamer¹ a wskaŸnikiem zycia maleje.
  //
  // Oblicza odleg³oœæ od wskaŸnika ¿ycia do kamery w p³aszczyŸnie poziomej (kierunku wskaŸnika ¿ycia).
  //GLVectorGeometry.SetVector( zt_vector, gl_camera_f.AbsolutePosition.X, 0, gl_camera_f.AbsolutePosition.Z ); // zt_vector : GLVectorGeometry.TVector;
  ////GLVectorGeometry.SetVector( zt_vector, gl_camera_f.AbsolutePosition.X, Self.punkty_¿ycia_dummy.AbsoluteDirection.Y, gl_camera_f.AbsolutePosition.Z );
  //punkty_¿ycia_procent_zosta³o_l := Self.punkty_¿ycia_dummy.DistanceTo( zt_vector ); // Tutaj tymczasowo jako odleg³oœæ.
  //
  //// Liczy k¹t w osi X -
  ////  ze wspó³rzêdnych X, Z kamery wylicza odleg³oœæ i u¿ywa tego jako wspó³rzêdnej x;
  ////  z ró¿nicy miêdzy wysokoœci¹ kamery a wysokoœci¹ wskaŸnika ¿ycia wylicza wspó³rzêdn¹ y;
  ////  k¹t liczony w punkcie (0, 0) miedzy osi¹ x i wyliczonym punktem x, y.
  //Self.punkty_¿ycia_podniesienie.PitchAngle :=
  //  -RadToDeg( // uses Math.
  //      AngleBetweenVectors( // uses GLVectorGeometry.
  //         GLVectorGeometry.VectorMake( punkty_¿ycia_procent_zosta³o_l, gl_camera_f.AbsolutePosition.Y - Self.punkty_¿ycia_dummy.AbsolutePosition.Y, 0 ),
  //         GLVectorGeometry.VectorMake( 1, 0, 0 ),
  //         GLVectorGeometry.VectorMake( 0, 0, 0 )
  //       )
  //    );
  //
  //if gl_camera_f.AbsolutePosition.Y < Self.punkty_¿ycia_dummy.AbsolutePosition.Y then
  //  Self.punkty_¿ycia_podniesienie.PitchAngle := -Self.punkty_¿ycia_podniesienie.PitchAngle;
  //---// Wersja B.


  Self.punkty_¿ycia__wskaŸnik.Height := Self.punkty_¿ycia__wskaŸnik.TagFloat * Self.punkty_¿ycia_procent_zosta³o * 0.01;

  case wartoœæ_liczbowa_f of
      1 : Self.punkty_¿ycia__napis.Text := Trim(  FormatFloat( '### ### ##0', Self.punkty_¿ycia )  );
      2 : Self.punkty_¿ycia__napis.Text := Trim(  FormatFloat( '### ### ##0', Self.punkty_¿ycia_procent_zosta³o )  ) + '%';
      3 : Self.punkty_¿ycia__napis.Text := Trim(  FormatFloat( '### ### ##0', Self.punkty_¿ycia )  ) + ' (' + Trim(  FormatFloat( '### ### ##0', Self.punkty_¿ycia_procent_zosta³o )  ) + '%)';
      else//case wartoœæ_liczbowa_f of
        Self.punkty_¿ycia__napis.Text := '';
    end;
  //---//case wartoœæ_liczbowa_f of

end;//---//Funkcja Punkty_¯ycia_WskaŸnik_Rysuj().

//Funkcja Parametry_Odczytaj().
function TStatek.Parametry_Odczytaj( const dane_wszystkie_f : boolean = false ) : string;
var
  i : integer;
const
  odstêp_l_c : string = '   ';    
begin

  //
  // Funkcja wypisuje dane (parametry) statku.
  //
  // Zwraca napis z danymi (parametrami) statku.
  //
  // Parametry:
  //   dane_wszystkie_f:
  //     false - wypisuje tylko dane podstawowe.
  //     true - wypisujewszystkie dane.
  //

  Result := '';

  Result := Result + 
                'punkty_¿ycia_maksymalne: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.punkty_¿ycia_maksymalne )  ) +
    #13 + #10 + 'prêdkoœæ_maksymalna: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.prêdkoœæ_maksymalna )  ) +
    #13 + #10 + 'prêdkoœæ_przyspieszanie: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.prêdkoœæ_przyspieszanie )  ) +
    #13 + #10 + 'prêdkoœæ_zwalnianie: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.prêdkoœæ_zwalnianie )  ) +
    #13 + #10 + 'skrêt_k¹t_maksymalny: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.skrêt_k¹t_maksymalny )  ) +
    #13 + #10 + 'skrêt_szybkoœæ_wychylania_steru: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.skrêt_szybkoœæ_wychylania_steru )  ) +
    #13 + #10 + 'skrêt_prêdkoœæ: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.skrêt_prêdkoœæ )  ) +
    #13 + #10 + 'skrêt_wspó³czynnik_do_prêdkoœci: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.skrêt_wspó³czynnik_do_prêdkoœci )  ) +
    #13 + #10 + 'luneta_zasiêg: ' + Trim(  FormatFloat( '### ### ##0', Self.luneta_zasiêg )  ) +
    #13 + #10 + 'radar_zasiêg: ' + Trim(  FormatFloat( '### ### ##0', Self.radar_zasiêg )  ) +
    #13 + #10 + 'radio_zasiêg: ' + Trim(  FormatFloat( '### ### ##0', Self.radio_zasiêg )  ) +
    #13 + #10 + 'sonar_zasiêg: ' + Trim(  FormatFloat( '### ### ##0', Self.sonar_zasiêg )  );

  if dane_wszystkie_f then
    begin

      Result := Result +
        #13 + #10 + 'kamera_odleg³oœæ_maksymalna: ' + Trim(  FormatFloat( '### ### ##0', Self.kamera_odleg³oœæ_maksymalna )  ) +
        #13 + #10 + 'falowanie_bok_skrêt_zakres: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.falowanie_bok_skrêt_zakres )  ) +
        #13 + #10 + 'falowanie_bok_zakres: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.falowanie_bok_zakres )  ) +
        #13 + #10 + 'falowanie_góra_dó³_zakres: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.falowanie_góra_dó³_zakres )  ) +
        #13 + #10 + 'falowanie_przód_zakres: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.falowanie_przód_zakres )  ) +
        #13 + #10 + 'prêdkoœæ_ograniczenie: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.prêdkoœæ_ograniczenie )  ) +
        #13 + #10 + 'prêdkoœæ__kolizja_zwalnianie: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.prêdkoœæ__kolizja_zwalnianie )  ) +
        //#13 + #10 + 'si³a_wp³ywu_kolizji: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.TagFloat )  ) +
        #13 + #10 + 'œruby iloœæ: ' + Trim(   FormatFloat(  '### ### ##0', Length( Self.œruby_t )  )   );
    
      for i := 0 to Length( Self.œruby_t ) - 1 do
        begin

          Result := Result +
            #13 + #10 + odstêp_l_c + Trim(  FormatFloat( '### ### ##0', i + 1 )  ) +
            #13 + #10 + odstêp_l_c + 'prêdkoœæ_obrotowa_maksymalna: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.œruby_t[ i ].prêdkoœæ_obrotowa_maksymalna )  ) +
            #13 + #10 + odstêp_l_c + 'prêdkoœæ_obrotowa_przyspieszanie: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.œruby_t[ i ].prêdkoœæ_obrotowa_przyspieszanie )  ) +
            #13 + #10 + odstêp_l_c + 'czy_obrót_lewo: ';

          if Self.œruby_t[ i ].czy_obrót_lewo then
            Result := Result +
              'tak'
          else//if Self.œruby_t[ i ].czy_obrót_lewo then
            Result := Result +
              'nie';

        end;
      //---//for i := 0 to Length( Self.œruby_t ) - 1 do
  
    end;
  //---//if dane_wszystkie_f then
  
  
  Result := Result +
    #13 + #10 + 'artyleria iloœæ: ' + Trim(   FormatFloat(  '### ### ##0', Length( Self.artyleria_t )  )   );  

  for i := 0 to Length( Self.artyleria_t ) - 1 do
    begin

      Result := Result +
        #13 + #10 + odstêp_l_c + Trim(  FormatFloat( '### ### ##0', i + 1 )  ) +
        Self.artyleria_t[ i ].Parametry_Odczytaj( odstêp_l_c + odstêp_l_c, dane_wszystkie_f );

    end;
  //---//for i := 0 to Length( Self.artyleria_t ) - 1 do

  
  Result := Result +
    #13 + #10 + 'dzia³a iloœæ: ' + Trim(   FormatFloat(  '### ### ##0', Length( Self.dzia³a_t )  )   );  

  for i := 0 to Length( Self.dzia³a_t ) - 1 do
    begin

      Result := Result +
        #13 + #10 + odstêp_l_c + Trim(  FormatFloat( '### ### ##0', i + 1 )  ) +
        Self.dzia³a_t[ i ].Parametry_Odczytaj( odstêp_l_c + odstêp_l_c, dane_wszystkie_f );

    end;
  //---//for i := 0 to Length( Self.dzia³a_t ) - 1 do

  
  Result := Result +
    #13 + #10 + 'torpedy wyrzutnie iloœæ: ' + Trim(   FormatFloat(  '### ### ##0', Length( Self.torpedy_wyrzutnie_t )  )   );  

  for i := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do
    begin

      Result := Result +
        #13 + #10 + odstêp_l_c + Trim(  FormatFloat( '### ### ##0', i + 1 )  ) +
        Self.torpedy_wyrzutnie_t[ i ].Parametry_Odczytaj( odstêp_l_c + odstêp_l_c, dane_wszystkie_f );

    end;
  //---//for i := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do    

end;//---//Funkcja Parametry_Odczytaj().
{$endregion 'TStatek.'}


{$region 'TLufa.'}
//Konstruktor klasy TLufa.
constructor TLufa.Create( ATorpedy_Wyrzutnia : TTorpedy_Wyrzutnia; AStatek : TStatek; gl_collision_mmanager_f : TGLCollisionManager );
begin

  //
  // Podniesienie lufy (PitchAngle) -(minus) w górê, +(plus) w dó³.
  //

  inherited Create( ATorpedy_Wyrzutnia );

  Self.statek := AStatek;

  Self.Parent := ATorpedy_Wyrzutnia.elementy_wizualne_dummy;

  Self.dzia³o := ATorpedy_Wyrzutnia;

  Self.prze³adowanie_czas_milisekundy := ATorpedy_Wyrzutnia.prze³adowanie_czas_milisekundy;
  //Self.strza³_czas := Now();
  Self.strza³_czas_i := Czas_Teraz(); // Dla pierwszego za³adowania.
  Self.amunicja_pobrana := false;
  Self.czy_indeks_do_strza³u_lufa := false;
  Self.strza³_gotowoœæ := false;

  Self.amunicja_rodzaj := ATorpedy_Wyrzutnia.amunicja_rodzaj;

  //Self.VisibleAtRunTime := true; //???

  Self.korpus := TGLCylinder.Create( Self );
  Self.korpus.Parent := Self;
  Self.korpus.TopRadius := 0.05;
  Self.korpus.BottomRadius := Self.korpus.TopRadius;
  Self.korpus.Height := 1.25;
  //Self.korpus.Position.Y := Self.korpus_przód.Position.Y + Self.korpus.TopRadius * 2;
  Self.korpus.PitchAngle := 90;


  Self.wylot_pozycja := TGLSphere.Create( Self );
  Self.wylot_pozycja.Parent := Self.korpus;

  Self.prze³adowanie_wskaŸnik := TGLSphere.Create( Self );
  Self.prze³adowanie_wskaŸnik.Parent := Self;

  //Self.ShowAxes := true;


  if gl_collision_mmanager_f <> nil then
    with TGLBCollision.Create( Self.korpus.Behaviours ) do
      begin

        GroupIndex := 0;
        BoundingMode := cbmCube;
        Manager := gl_collision_mmanager_f;

      end;
    //---//with TGLBCollision.Create( Self.korpus.Behaviours ) do

end;//---//Konstruktor klasy TLufa.

//Destruktor klasy TLufa.
destructor TLufa.Destroy();
var
  i : integer;
begin

  for i := 0 to Self.Count - 1 do
    if Self.Children[ i ] is TAmunicja then
      begin

        // Je¿eli amunicja jest w lufie to zwalnia j¹ razem z lufa i pojawiaj¹ siê b³êdy dostêpu do pamiêci.
        TAmunicja(Self.Children[ i ]).pozycja_celu := nil;
        TAmunicja(Self.Children[ i ]).pozycja_startowa.Parent := nil; // Nie zmieniaæ tej kolejnoœci.
        TAmunicja(Self.Children[ i ]).Parent := nil; // Nie zmieniaæ tej kolejnoœci.

        TAmunicja(Self.Children[ i ]).czy_usun¹æ_amunicja := true;

      end;
    //---//if Self.Children[ i ] is TAmunicja then


  FreeAndNil( Self.prze³adowanie_wskaŸnik );
  FreeAndNil( Self.wylot_pozycja );
  FreeAndNil( Self.korpus );

  inherited;

end;//---//Destruktor klasy TLufa.

//Funkcja Dodatkowe_Elementy_Lufy_Pozycja_Ustaw().
procedure TLufa.Dodatkowe_Elementy_Lufy_Pozycja_Ustaw();
begin

  //
  // Funkcja ustawia dodatkowe elementy lufy we w³aœciwych miejscach.
  //
  // Parametry:
  //   czy_lufa_podniesienie_k¹t_ustaw_f:
  //     true - ustawi pocz¹tkowy k¹t podniesienia lufy.
  //     false - nie ustawi pocz¹tkowego k¹ta podniesienia lufy (dla wyrzutni torped).
  //

  if Self.wylot_pozycja.Parent <> nil then
    begin

      //Self.wylot_pozycja.Radius := 0.05;
      Self.wylot_pozycja.Radius := TGLCylinder(Self.wylot_pozycja.Parent).TopRadius;
      Self.wylot_pozycja.Position.Y := Self.korpus.Height * 0.5 {+ Self.wylot_pozycja.Radius * 2};

    end;
  //---//if Self.wylot_pozycja.Parent <> nil then


  if Self.prze³adowanie_wskaŸnik.Parent <> nil then
    begin

      Self.prze³adowanie_wskaŸnik.Radius := TGLCylinder(Self.wylot_pozycja.Parent).TopRadius * 0.5;
      //Self.prze³adowanie_wskaŸnik.Position.AsVector := Self.prze³adowanie_wskaŸnik.AbsoluteToLocal( Self.wylot_pozycja.AbsolutePosition );

      if Self.prze³adowanie_wskaŸnik.Parent <> nil then
        Self.prze³adowanie_wskaŸnik.Position.AsVector := Self.prze³adowanie_wskaŸnik.Parent.AbsoluteToLocal( Self.wylot_pozycja.AbsolutePosition );

      Self.prze³adowanie_wskaŸnik.Position.Y := Self.prze³adowanie_wskaŸnik.Position.Y + Self.korpus.TopRadius + Self.prze³adowanie_wskaŸnik.Radius * 0.75;

      Self.prze³adowanie_wskaŸnik__pozycja_za³adowany := Self.prze³adowanie_wskaŸnik.Position.AsAffineVector;
      Self.prze³adowanie_wskaŸnik.Move( Self.korpus.Height * 0.5 ); // Zmienia Z z minus na mniejszy minus (dodaje).
      Self.prze³adowanie_wskaŸnik__pozycja_roz³adowany := Self.prze³adowanie_wskaŸnik.Position.AsAffineVector;

    end;
  //---//if Self.prze³adowanie_wskaŸnik.Parent <> nil then


  prze³adowanie_wskaŸnik__dystans_do_przesuniêcia := Abs( Self.prze³adowanie_wskaŸnik__pozycja_za³adowany.Z ) - Abs( Self.prze³adowanie_wskaŸnik__pozycja_roz³adowany.Z );
  //prze³adowanie_wskaŸnik__dystans_do_przesuniêcia := prze³adowanie_wskaŸnik__dystans_do_przesuniêcia - prze³adowanie_wskaŸnik__dystans_do_przesuniêcia * 0.01; // Lekka korekta pomniejszaj¹ca zakres aby wskaŸnik za daleko siê nie przesun¹³.


  if    ( Self.dzia³o <> nil )
    and ( Self.dzia³o is TDzia³o ) then
    begin

      // TDzia³o.

      Self.czy_wycelowane_podniesienie := false;

      if Self.dzia³o is TArtyleria then
        Self.podniesienie_szybkoœæ_modyfikator := TDzia³o(Self.dzia³o).podniesienie_szybkoœæ * 2 * Random() // Do 20% standardowej szybkoœci - artyleria wolno siê porusza.
      else//if Self.dzia³o is TArtyleria then
        Self.podniesienie_szybkoœæ_modyfikator := TDzia³o(Self.dzia³o).podniesienie_szybkoœæ * Random( 3 ); // Do 30% standardowej szybkoœci.

    end
  else//if    ( Self.dzia³o <> nil ) (...)
    begin

      // TTorpedy_Wyrzutnia.

      Self.czy_wycelowane_podniesienie := true;

      Self.podniesienie_szybkoœæ_modyfikator := 0;

    end;
  //---//if    ( Self.dzia³o <> nil ) (...)


  Self.prze³adowanie_wskaŸnik__pozycja_wycelowany_Y := Self.prze³adowanie_wskaŸnik.Position.Y;


  if    ( Self.dzia³o <> nil )
    and ( Self.dzia³o is TDzia³o ) then
    //and ( TDzia³o(Self.dzia³o).czy_lufa_podnoszona ) then
    begin

      // TArtyleria, TDzia³o.

      // Je¿eli w schemacie wczytanym z pliku zadany k¹t podniesienia jest poza zakresem unoszenia lufy.
      if TDzia³o(Self.dzia³o).podniesienie_k¹t_zadany > TDzia³o(Self.dzia³o).podniesienie_k¹t_maksymalny then
        TDzia³o(Self.dzia³o).podniesienie_k¹t_zadany := TDzia³o(Self.dzia³o).podniesienie_k¹t_maksymalny;

      if TDzia³o(Self.dzia³o).podniesienie_k¹t_zadany < TDzia³o(Self.dzia³o).podniesienie_k¹t_minimalny then
        TDzia³o(Self.dzia³o).podniesienie_k¹t_zadany := TDzia³o(Self.dzia³o).podniesienie_k¹t_minimalny;

      // Z przeciwnym znakiem gdy¿ -(minus) w górê, +(plus) w dó³.
      Self.PitchAngle := -TDzia³o(Self.dzia³o).podniesienie_k¹t_zadany; // Potem zostanie nadpisany wartoœci¹ ustawion¹ przez 'gracza'.

      TDzia³o(Self.dzia³o).podniesienie_k¹t_zadany_bezwzglêdny := TDzia³o(Self.dzia³o).podniesienie_k¹t_zadany;

    end;
  //---//if    ( Self.dzia³o <> nil ) (...)

end;//---//Funkcja Dodatkowe_Elementy_Lufy_Pozycja_Ustaw().

//Funkcja Prze³adowanie().
procedure TLufa.Prze³adowanie( delta_czasu_f : double );
var
  milisekund_prze³adowania_l : int64;
  ztr : real;
begin

  //
  // Funkcja ³aduje lufê w odpowiednim czasie i ustawia jej gotowoœæ.
  //

  if Self.dzia³o <> nil then
    begin

      // Oznacza lufê wybran¹ do strza³u tylko na dziale, które te¿ jest wybrane do strza³u.

      if    ( Self.czy_indeks_do_strza³u_lufa )
        and ( TTorpedy_Wyrzutnia(Self.dzia³o).czy_indeks_do_strza³u ) then
        Self.prze³adowanie_wskaŸnik.Material.FrontProperties.Ambient.Color := clrGreenYellow //clrBlue clrGreenYellow
      else//if    ( Self.czy_indeks_do_strza³u_lufa ) (...)
        Self.prze³adowanie_wskaŸnik.Material.FrontProperties.Ambient.Color := clrGreen;

    end;
  //---//if Self.dzia³o <> nil then


  // Lufa osi¹gnê³a wymagany do strza³u k¹t.
  if Self.czy_wycelowane_podniesienie then
    Self.prze³adowanie_wskaŸnik.Position.Y := Self.prze³adowanie_wskaŸnik__pozycja_wycelowany_Y
  else//if Self.czy_wycelowane_podniesienie then
    Self.prze³adowanie_wskaŸnik.Position.Y := Self.prze³adowanie_wskaŸnik__pozycja_wycelowany_Y - Self.prze³adowanie_wskaŸnik.Radius;


  //sekund_prze³adowania_l := SecondsBetween( Now(), Self.strza³_czas );
  milisekund_prze³adowania_l := Round(  Czas_Miêdzy_W_Milisekundach( Self.strza³_czas_i ) * Statki_Form.gra_wspó³czynnik_prêdkoœci_g  );


  if    ( Self.dzia³o <> nil )
    and ( Self.dzia³o is TDzia³o ) then // TArtyleria, TDzia³o.
    if milisekund_prze³adowania_l < cofanie_wystrza³_powrót_milisekund_c then
      begin

        //ztr := ( milisekund_prze³adowania_l * 100 / cofanie_wystrza³_powrót_milisekund_c * 0.01 ); // Wariant z przesuwaniem wed³ug dystansu proporcjonalnie do czasu prze³adowania.
        ztr :=  ( milisekund_prze³adowania_l / cofanie_wystrza³_powrót_milisekund_c ); // Wariant z przesuwaniem wed³ug dystansu proporcjonalnie do czasu prze³adowania (uproszczone obliczenia).

        Self.korpus.Position.Z := TDzia³o(Self.dzia³o).cofanie_wystrza³_pozycja_pocz¹tkowa + TDzia³o(Self.dzia³o).cofanie_wystrza³_odleg³oœæ * ( 1 - ztr );

      end
    else//if milisekund_prze³adowania_l < cofanie_wystrza³_powrót_milisekund_c then
      begin

        Self.korpus.Position.Z := TDzia³o(Self.dzia³o).cofanie_wystrza³_pozycja_pocz¹tkowa;

      end;
    //---//if milisekund_prze³adowania_l < cofanie_wystrza³_powrót_milisekund_c then


  if Self.strza³_gotowoœæ then
    Exit;


  if not Self.amunicja_pobrana then
    if    ( Self.dzia³o <> nil )
      and ( TTorpedy_Wyrzutnia(Self.dzia³o).amunicja_iloœæ > 0 ) then
      begin

        Dec( TTorpedy_Wyrzutnia(Self.dzia³o).amunicja_iloœæ );
        Self.amunicja_pobrana := true;

      end
    else//if    ( Self.dzia³o <> nil ) (...)
      begin

        // Wskazuje brak amunicji.

        Self.prze³adowanie_wskaŸnik.Material.FrontProperties.Ambient.Color := clrRed;
        Exit;

      end;
    //---//if    ( Self.dzia³o <> nil ) (...)


  //if SecondsBetween( Now(), Self.strza³_czas ) >= prze³adowanie_czas_milisekundy then
  if milisekund_prze³adowania_l >= Self.prze³adowanie_czas_milisekundy then
    begin

      strza³_gotowoœæ := true;
      Self.prze³adowanie_wskaŸnik.Position.Z := Self.prze³adowanie_wskaŸnik__pozycja_za³adowany.Z;
      Self.prze³adowanie_wskaŸnik.Material.FrontProperties.Ambient.Color := clrGreen;

      Exit;

    end;
  //---//if milisekund_prze³adowania_l >= Self.prze³adowanie_czas_milisekundy then

  //ztr := Abs( Self.prze³adowanie_wskaŸnik__pozycja_za³adowany.Z ) - Abs( Self.prze³adowanie_wskaŸnik__pozycja_roz³adowany.Z );
  //ztr := ztr - ztr * 0.025; // Lekka korekta pomniejszaj¹ca zakres aby wskaŸnik za daleko siê nie przesun¹³


  // Przesuwa wskaŸnik za³adowania od pozycji roz³adowany do pozycji za³adowany.
  if Self.prze³adowanie_wskaŸnik.Position.Z > Self.prze³adowanie_wskaŸnik__pozycja_za³adowany.Z then
    begin

      //Self.prze³adowanie_wskaŸnik.Move( -ztr * delta_czasu_f / prze³adowanie_czas_milisekundy );
      //Self.prze³adowanie_wskaŸnik.Move( -Self.prze³adowanie_wskaŸnik__dystans_do_przesuniêcia * 1000 * delta_czasu_f / Self.prze³adowanie_czas_milisekundy ); // Wariant z przesuwaniem funkcj¹ Move().

      //ztr := ( milisekund_prze³adowania_l * 100 / Self.prze³adowanie_czas_milisekundy * 0.01 ); // Wariant z przesuwaniem wed³ug dystansu proporcjonalnie do czasu prze³adowania.
      ztr :=  ( milisekund_prze³adowania_l / Self.prze³adowanie_czas_milisekundy ); // Wariant z przesuwaniem wed³ug dystansu proporcjonalnie do czasu prze³adowania (uproszczone obliczenia).

      Self.prze³adowanie_wskaŸnik.Position.Z := Self.prze³adowanie_wskaŸnik__pozycja_roz³adowany.Z - Self.prze³adowanie_wskaŸnik__dystans_do_przesuniêcia * ztr;

    end;
  //---//if Self.prze³adowanie_wskaŸnik.Position.Z > Self.prze³adowanie_wskaŸnik__pozycja_za³adowany.Z then

  //Statki_Form.Caption := FloatToStr( delta_czasu_f ) + ' ' + FloatToStr( sekund_prze³adowania_l ) + ' ' + FloatToStr( ztr ) + ' ' + FloatToStr( Self.wylot_pozycja.Position.Z );

end;//---//Funkcja Prze³adowanie().

//Funkcja Strza³().
function TLufa.Strza³( const obracaj_dzia³a_f, podnoœ_lufy_f : boolean; const cel_wspó³rzêdne_f : TAffineVector ) : boolean;
var
  rodzic_l : TGLBaseSceneObject;
begin

  //
  // Funkcja strzela z lufy i ustawia amunicjê do lotu.
  //
  // Zwraca prawdê gdy wystrzeli.
  //

  Result := false;

  if   ( not Self.strza³_gotowoœæ )
    {or ( not Self.czy_wycelowane_podniesienie )} then
    Exit;


  if podnoœ_lufy_f then // Je¿eli lufy s¹ zablokowane mo¿na strzeliæ mimo nie wycelowania.
    if not Self.czy_wycelowane_podniesienie then
      Exit;


  Self.amunicja_pobrana := false;
  Self.strza³_gotowoœæ := false;
  //Self.strza³_czas := Now();
  Self.strza³_czas_i := Czas_Teraz();

  //Self.prze³adowanie_wskaŸnik.Move( Self.korpus.Height * 0.5 );
  Self.prze³adowanie_wskaŸnik.Position.Z := Self.prze³adowanie_wskaŸnik__pozycja_roz³adowany.Z;
  Self.prze³adowanie_wskaŸnik.Material.FrontProperties.Ambient.Color := clrYellow;

  rodzic_l := Self;

  //while rodzic_l.HasParent do // Aby rodzicem by³a scena.
  //  rodzic_l := rodzic_l.Parent;

  while ( rodzic_l.HasParent ) // Aby rodzicem by³ Gra_Obiekty_GLDummyCube.
    and ( rodzic_l.Parent.HasParent ) do
    rodzic_l := rodzic_l.Parent;

  Statki_Form.Amunicja_Wystrzelona_Utwórz_Jeden( rodzic_l, Self, obracaj_dzia³a_f, cel_wspó³rzêdne_f );
  //Statki_Form.Amunicja_Wystrzelona_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, Self );


  if    ( Self.dzia³o <> nil )
    and ( Self.dzia³o is TDzia³o ) then
    begin

      // TArtyleria, TDzia³o.

      Self.korpus.Position.Z := TDzia³o(Self.dzia³o).cofanie_wystrza³_pozycja_pocz¹tkowa + TDzia³o(Self.dzia³o).cofanie_wystrza³_odleg³oœæ;

    end;
  //---//if    ( Self.dzia³o <> nil ) (...)


  Result := true;

end;//---//Funkcja Strza³().
{$endregion 'TLufa.'}


{$region 'TTorpedy_Wyrzutnia.'}
//Konstruktor klasy TTorpedy_Wyrzutnia.
constructor TTorpedy_Wyrzutnia.Create( AOwner : TGLBaseSceneObject; AStatek : TStatek; gl_collision_mmanager_f : TGLCollisionManager; const lufy_iloœæ_f : integer );
var
  i : integer;
  ztr : real;
begin

  inherited Create( AOwner );

  Self.statek := AStatek;


  //Self.indeks_w_tabeli := -1;

  Self.obrót_kierunek_zadany.Y := 0;

  Self.obrót_k¹t_zadany := 0;

  Self.obrót_k¹t_zablokowany_do := 0;
  Self.obrót_k¹t_zablokowany_od := 0;
  Self.obrót_szybkoœæ := 0.5;

  Self.amunicja_iloœæ := 1500;
  Self.celownik_linia_szerokoœæ_obrót := 0;
  Self.lufa_ostatni_strza³_indeks := -1;
  Self.obra¿enia_zadawane := 1;
  Self.prze³adowanie_czas_milisekundy := 1000; // 7000 //???
  Self.skala := 1;
  Self.strza³_od_blokada_milisekundy := 750;
  Self.strza³y_iloœæ := 0;
  Self.zasiêg := 35; // 35 15 25 5

  Self.czy_indeks_do_strza³u := false;
  //Self.czy_lufa_podnoszona := false;
  Self.czy_usun¹æ_torpedy_wyrzutnia := false;
  Self.czy_wycelowany_obrót := false;

  SetLength( Self.obrót_k¹t_zablokowany_strza³_do, 0 );
  SetLength( Self.obrót_k¹t_zablokowany_strza³_od, 0 );

  Self.amunicja_rodzaj := ar_Torpeda;
  //Self.strza³_czas := Now();
  Self.strza³_czas_i := Czas_Teraz();

  Self.dzia³o_strzelaj¹ce := nil;

  Self.Parent := AOwner;
  Self.TurnAngle := 0;
  Self.Direction.SetVector( 0, 0, -1 );
  Self.Position.SetPoint( 0, 1, 0 );
  //Self.VisibleAtRunTime := true; //???

  Self.elementy_wizualne_dummy := TGLDummyCube.Create( Self );
  Self.elementy_wizualne_dummy.Parent := Self;
  //Self.elementy_wizualne_dummy.VisibleAtRunTime := true; //???
  //Self.elementy_wizualne_dummy.ShowAxes := true; //???

  Self.podstawa := TGLCylinder.Create( Self );
  Self.podstawa.Parent := Self.elementy_wizualne_dummy;
  Self.podstawa.TopRadius := 0.25;
  Self.podstawa.BottomRadius := Self.podstawa.TopRadius;
  Self.podstawa.Height := 0.1;
  //Self.podstawa.Position.Y := -( Self.CubeSize * 0.5 ) + Self.podstawa.Height * 0.5;
  Self.podstawa.Position.Y := Self.podstawa.Height * 0.5;

  Self.k¹t_test := TGLDummyCube.Create( Self );
  Self.k¹t_test.Parent := Self.elementy_wizualne_dummy;
  Self.k¹t_test.Position := Self.podstawa.Position;
  Self.k¹t_test.Up.SetVector( 0, 1, 0 ); //???
  //Self.k¹t_test.VisibleAtRunTime := true; //???
  //Self.k¹t_test.ShowAxes := true; //???


  Self.korpus := TGLCube.Create( Self );
  Self.korpus.Parent := Self.elementy_wizualne_dummy;
  Self.korpus.CubeDepth := Self.podstawa.TopRadius * 2;
  Self.korpus.CubeHeight := 0.1;
  Self.korpus.CubeWidth := Self.podstawa.TopRadius * 3;
  //Self.korpus.Position.Y := -( Self.CubeSize * 0.5 ) + Self.podstawa.Height * 2 - Self.korpus.CubeHeight * 0.5;
  Self.korpus.Position.Y := Self.podstawa.Position.Y + Self.podstawa.Height * 0.5 + Self.korpus.CubeHeight * 0.5;
  Self.korpus.TurnAngle := 0;

  Self.korpus_przód := TGLCylinder.Create( Self );
  Self.korpus_przód.Parent := Self.elementy_wizualne_dummy;
  Self.korpus_przód.TopRadius := 0.05;
  Self.korpus_przód.BottomRadius := Self.korpus_przód.TopRadius;
  Self.korpus_przód.Height := Self.korpus.CubeWidth + Self.korpus_przód.TopRadius * 2;
  Self.korpus_przód.PitchAngle := 90;
  Self.korpus_przód.RollAngle := 90;
  Self.korpus_przód.Position.Y := Self.korpus.Position.Y;
  Self.korpus_przód.Position.Z := -Self.korpus.CubeDepth * 0.5 - Self.korpus_przód.TopRadius * 0.5;


  i := lufy_iloœæ_f;

  if i < 1 then
    i := 1; // Iloœæ luf.

  SetLength( Self.lufy_t, i );

  if Length( Self.lufy_t ) > 0 then
    ztr := Self.korpus.CubeWidth / Length( lufy_t ) // Iloœæ miejsca na lufê.
  else//if Length( lufy_t ) > 0 then
    ztr := 0;

  for i := 0 to Length( Self.lufy_t ) - 1 do
    begin

      Self.lufy_t[ i ] := TLufa.Create( Self, Self.statek, gl_collision_mmanager_f );
      Self.lufy_t[ i ].Position.Y := Self.korpus_przód.Position.Y + Self.lufy_t[ i ].korpus.TopRadius * 2;
      Self.lufy_t[ i ].Position.X := i * ztr - Self.korpus.CubeWidth * 0.5 + ztr * 0.5 ; // Przesuniêcie o pó³ szerokoœci korpusu, wyœrodkowanie na obszarze dla lufy.
      Self.lufy_t[ i ].korpus.TopRadius := 0.05;
      Self.lufy_t[ i ].korpus.BottomRadius := Self.lufy_t[ i ].korpus.TopRadius;
      Self.lufy_t[ i ].korpus.Height := 1.25;
      Self.lufy_t[ i ].Dodatkowe_Elementy_Lufy_Pozycja_Ustaw();

      if i = 0 then
        Self.lufy_t[ i ].czy_indeks_do_strza³u_lufa := true;

    end;
  //---//for i := 0 to Length( Self.lufy_t ) - 1 do


  Self.celownik_linia := TGLLines.Create( Self );
  Self.celownik_linia.Parent := Self;
  Self.celownik_linia.Pickable := false;
  Self.celownik_linia.Tag := 1; // Oznacza, ¿e element jest widoczny (1; 0 - niewidoczny).
  Self.celownik_linia.LineWidth := 0;
  Self.celownik_linia.LineColor.Color := GLColor.clrYellow;
  Self.celownik_linia.Position := Self.elementy_wizualne_dummy.Position; //Self.podstawa.Position elementy_wizualne_dummy
  Self.celownik_linia.Position.Y := Self.podstawa.Height * 0.5; // Y - w po³owie wysokoœci podstawy.
  //Self.celownik_linia.ShowAxes := true; //???
  //Self.celownik_linia.Up.SetVector( 0, 1, 0 );
  //Self.celownik_linia.Visible := false; //???
  Self.celownik_linia.AddNode( 0, 0, 0 );
  Self.celownik_linia.AddNode( 0, 0, -Self.zasiêg ); // Zasiêg torpedy.

  if Length( Self.lufy_t ) > 0 then
    begin

      // Okreœla odleg³oœæ w jakiej uzbraja siê torpeda.
      Self.celownik_linia.Nodes[ 0 ].Z := Self.lufy_t[ 0 ].korpus.Height + Self.lufy_t[ 0 ].korpus.Height * 0.1;
      Self.celownik_linia.Nodes[ 0 ].Z := -( Self.celownik_linia.Nodes[ 0 ].Z + Self.celownik_linia.Nodes[ 0 ].Z * 0.3 ) * 2; // Tak samo wyliczyæ wskaŸnik uzbrojenia amunicji.

    end;
  //---//if Length( Self.lufy_t ) > 0 then

  Self.celownik_linia_bez_falowania := TGLLines.Create( Self );
  Self.celownik_linia_bez_falowania.Parent := AStatek;
  Self.celownik_linia_bez_falowania.Pickable := false;
  Self.celownik_linia_bez_falowania.LineWidth := Self.celownik_linia.LineWidth;
  Self.celownik_linia_bez_falowania.LineColor.Color := GLColor.clrRichBlue; //Self.celownik_linia.LineColor.Color;
  Self.celownik_linia_bez_falowania.Position := Self.elementy_wizualne_dummy.Position; //Self.podstawa.Position elementy_wizualne_dummy
  Self.celownik_linia_bez_falowania.Position.Y := Self.podstawa.Height * 0.5; // Y - w po³owie wysokoœci podstawy.
  Self.celownik_linia_bez_falowania.AddNode( 0, 0, Self.celownik_linia.Nodes[ 0 ].Z );
  Self.celownik_linia_bez_falowania.AddNode( 0, 0, -Self.zasiêg ); // Zasiêg torpedy.


  Self.obrót_k¹t_zablokowany_GLDisk := TGLDisk.Create( Self );
  Self.obrót_k¹t_zablokowany_GLDisk.Parent := AOwner;
  Self.obrót_k¹t_zablokowany_GLDisk.Pickable := false;
  Self.obrót_k¹t_zablokowany_GLDisk.Direction.SetVector( 0, 1, 0 );
  Self.obrót_k¹t_zablokowany_GLDisk.RollAngle := 180;
  Self.obrót_k¹t_zablokowany_GLDisk.OuterRadius := 0.75;
  Self.obrót_k¹t_zablokowany_GLDisk.Visible := AStatek.obrót_k¹t_zablokowany_wskaŸnik_widoczne;
  Self.obrót_k¹t_zablokowany_GLDisk.Material.BlendingMode := bmModulate;


  if gl_collision_mmanager_f <> nil then
    begin

      with TGLBCollision.Create( Self.korpus.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.korpus.Behaviours ) do

      with TGLBCollision.Create( Self.korpus_przód.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.korpus_przód.Behaviours ) do

      with TGLBCollision.Create( Self.podstawa.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.podstawa.Behaviours ) do

    end;
  //---//if gl_collision_mmanager_f <> nil then

end;//---//Konstruktor klasy TTorpedy_Wyrzutnia.

//Destruktor klasy TTorpedy_Wyrzutnia.
destructor TTorpedy_Wyrzutnia.Destroy();
var
  i : integer;
begin

  SetLength( Self.obrót_k¹t_zablokowany_strza³_do, 0 );
  SetLength( Self.obrót_k¹t_zablokowany_strza³_od, 0 );


  FreeAndNil( Self.k¹t_test );

  FreeAndNil( Self.podstawa );
  FreeAndNil( Self.korpus );
  FreeAndNil( Self.korpus_przód );


  for i := 0 to Length( Self.lufy_t ) - 1 do
    FreeAndNil( Self.lufy_t[ i ] );

  SetLength( Self.lufy_t, 0 );


  FreeAndNil( Self.elementy_wizualne_dummy );

  FreeAndNil( Self.celownik_linia );
  FreeAndNil( Self.celownik_linia_bez_falowania );

  FreeAndNil( Self.obrót_k¹t_zablokowany_GLDisk );


  for i := 0 to Length( Self.obrót_k¹t_zablokowany_strza³_GLDisk_t ) - 1 do
    FreeAndNil( Self.obrót_k¹t_zablokowany_strza³_GLDisk_t[ i ] );

  SetLength( Self.obrót_k¹t_zablokowany_strza³_GLDisk_t, 0 );


  inherited;

end;//---//Destruktor klasy TTorpedy_Wyrzutnia.

//Funkcja Dodatkowe_Elementy_Ustaw().
procedure TTorpedy_Wyrzutnia.Dodatkowe_Elementy_Ustaw();

  //Funkcja K¹t_Zablokowany_Obszar_Rysuj() w Dodatkowe_Elementy_Ustaw().
  function K¹t_Zablokowany_Obszar_Rysuj( gl_disk_f : TGLDisk; const k¹t_do_f, k¹t_od_f : real; const indeks_f : integer; const czy_obrót_k¹t_zablokowany_strza³_f : boolean ) : integer;
  var
    i : integer;
    zt_gl_sphere : TGLSphere;
  begin

    gl_disk_f.Position := Self.Position;
    gl_disk_f.Position.Y := gl_disk_f.Position.Y + Self.podstawa.Height * 0.5;

    gl_disk_f.StartAngle := k¹t_od_f;
    gl_disk_f.SweepAngle := 0;

    zt_gl_sphere := TGLSphere.Create( Self.Parent );

    zt_gl_sphere.TurnAngle := gl_disk_f.StartAngle;
    zt_gl_sphere.TurnAngle := zt_gl_sphere.TurnAngle + 1;


    if czy_obrót_k¹t_zablokowany_strza³_f then
      begin

        // K¹t zablokowany strza³.

        gl_disk_f.Position.Y := gl_disk_f.Position.Y + 0.002 + indeks_f * 0.0001 + Random( 100 ) * 0.00001; // Je¿eli jest na tym samym poziomie co inny element to migocze.


        // Sprawdza czy k¹t zablokowany strza³u rozci¹ga siê w kierunku rosn¹cym czy malej¹cym wzglêdem k¹ta obrót_k¹t_zablokowany_od.
        if Self.Obrót_K¹t_Zablokowany_Strza³u_SprawdŸ( zt_gl_sphere.TurnAngle, indeks_f ) then
          Result := 1
        else//if Self.Obrót_K¹t_Zablokowany_Strza³u_SprawdŸ( zt_gl_sphere.TurnAngle, indeks_f ) then
          Result := -1;
        //---// Sprawdza czy k¹t zablokowany strza³u rozci¹ga siê w kierunku rosn¹cym czy malej¹cym wzglêdem k¹ta obrót_k¹t_zablokowany_od.

      end
    else//if czy_obrót_k¹t_zablokowany_strza³_f then
      begin

        // K¹t zablokowany.

        gl_disk_f.Position.Y := gl_disk_f.Position.Y + 0.001 + Random( 100 ) * 0.00001; // Je¿eli jest na tym samym poziomie co inny element to migocze.


        // Sprawdza czy k¹t zablokowany rozci¹ga siê w kierunku rosn¹cym czy malej¹cym wzglêdem k¹ta obrót_k¹t_zablokowany_od.
        if Self.Obrót_K¹t_Zablokowany_SprawdŸ( zt_gl_sphere.TurnAngle ) then
          Result := 1
        else//if Self.Obrót_K¹t_Zablokowany_SprawdŸ( zt_gl_sphere.TurnAngle ) then
          Result := -1;
        //---// Sprawdza czy k¹t zablokowany rozci¹ga siê w kierunku rosn¹cym czy malej¹cym wzglêdem k¹ta obrót_k¹t_zablokowany_od.

      end;
    //---//if czy_obrót_k¹t_zablokowany_strza³_f then


    zt_gl_sphere.TurnAngle := gl_disk_f.StartAngle;

    for i := -179 to 180 do
      begin

        zt_gl_sphere.TurnAngle := zt_gl_sphere.TurnAngle + Result;


        if czy_obrót_k¹t_zablokowany_strza³_f then
          begin

            // K¹t zablokowany strza³.

            if Self.Obrót_K¹t_Zablokowany_Strza³u_SprawdŸ( zt_gl_sphere.TurnAngle, indeks_f ) then
              gl_disk_f.SweepAngle := gl_disk_f.SweepAngle + Result
            else//if Self.Obrót_K¹t_Zablokowany_Strza³u_SprawdŸ( zt_gl_sphere.TurnAngle, indeks_f ) then
              Break;

          end
        else//if czy_obrót_k¹t_zablokowany_strza³_f then
          begin

            // K¹t zablokowany.

            if Self.Obrót_K¹t_Zablokowany_SprawdŸ( zt_gl_sphere.TurnAngle ) then
              gl_disk_f.SweepAngle := gl_disk_f.SweepAngle + Result
            else//if Self.Obrót_K¹t_Zablokowany_SprawdŸ( zt_gl_sphere.TurnAngle ) then
              Break;

          end;
        //---//if czy_obrót_k¹t_zablokowany_strza³_f then

      end;
    //---//for i := -179 to 180 do


    FreeAndNil( zt_gl_sphere );


    // Zamiana znaków, gdy¿ tak siê rysuje GLDisk.
    gl_disk_f.StartAngle := -gl_disk_f.StartAngle;
    gl_disk_f.SweepAngle := -gl_disk_f.SweepAngle;

  end;//---//Funkcja K¹t_Zablokowany_Obszar_Rysuj() w Dodatkowe_Elementy_Ustaw().

var
  i,
  zti
    : integer;
  //zt_gl_sphere : TGLSphere;
begin//Funkcja Dodatkowe_Elementy_Ustaw().

  //
  // Funkcja po utworzeniu i ustawieniu parametrów dostosowuje elementy dzia³a.
  //

  // Aktualizuje dane z pliku schematu.
  Self.celownik_linia.Nodes[ 1 ].Z := -Self.zasiêg;

  for i := 0 to Length( Self.lufy_t ) - 1 do
    Self.lufy_t[ i ].prze³adowanie_czas_milisekundy := Self.prze³adowanie_czas_milisekundy;
  //---// Aktualizuje dane z pliku schematu.


  SetLength(  Self.obrót_k¹t_zablokowany_strza³_GLDisk_t, Length( Self.obrót_k¹t_zablokowany_strza³_do )  );

  for i := 0 to Length( Self.obrót_k¹t_zablokowany_strza³_do ) - 1 do
    begin

      Self.obrót_k¹t_zablokowany_strza³_GLDisk_t[ i ] := TGLDisk.Create( Self );
      Self.obrót_k¹t_zablokowany_strza³_GLDisk_t[ i ].Parent := Self.Parent;
      Self.obrót_k¹t_zablokowany_strza³_GLDisk_t[ i ].Pickable := false;
      Self.obrót_k¹t_zablokowany_strza³_GLDisk_t[ i ].Direction.SetVector( 0, 1, 0 );
      Self.obrót_k¹t_zablokowany_strza³_GLDisk_t[ i ].RollAngle := 180;
      Self.obrót_k¹t_zablokowany_strza³_GLDisk_t[ i ].OuterRadius := 0.75;
      Self.obrót_k¹t_zablokowany_strza³_GLDisk_t[ i ].Visible := Self.statek.obrót_k¹t_zablokowany_strza³_wskaŸnik_widoczne;
      Self.obrót_k¹t_zablokowany_strza³_GLDisk_t[ i ].Material.FrontProperties.Emission.Color := Self.obrót_k¹t_zablokowany_GLDisk.Material.FrontProperties.Emission.Color;
      Self.obrót_k¹t_zablokowany_strza³_GLDisk_t[ i ].Material.BlendingMode := bmModulate;

      if    ( Self.skala <> 1 )
        and ( Self.skala <> 0 ) then
        Self.obrót_k¹t_zablokowany_strza³_GLDisk_t[ i ].Scale.Scale( Self.skala );

      K¹t_Zablokowany_Obszar_Rysuj( Self.obrót_k¹t_zablokowany_strza³_GLDisk_t[ i ], Self.obrót_k¹t_zablokowany_strza³_do[ i ], Self.obrót_k¹t_zablokowany_strza³_od[ i ], i, true );

    end;
  //---//for i := 0 to Length( Self.obrót_k¹t_zablokowany_strza³_do ) - 1 do


  if    ( Self.skala <> 1 )
    and ( Self.skala <> 0 ) then
    begin

      //Self.Scale.Scale( Self.skala );
      Self.elementy_wizualne_dummy.Scale.Scale( Self.skala );
      //Self.elementy_wizualne_dummy.Position.Y := Self.elementy_wizualne_dummy.CubeSize * 0.5;

      Self.obrót_k¹t_zablokowany_GLDisk.Scale.Scale( Self.skala );

      // Zmiana hierarchii elementów nie jest ju¿ potrzebne.
      //Self.celownik_linia.Nodes[ 1 ].Z := -Self.zasiêg * ( 1 / Self.skala ); // Zasiêg torpedy - po przeskalowaniu linia zmieni swoj¹ d³ugoœæ a zasiêg nie jest skalowany.

      Self.celownik_linia.Position.Y := Self.celownik_linia.Position.Y * Self.skala;
      Self.celownik_linia.Position.Z := Self.celownik_linia.Position.Z * Self.skala;
      Self.celownik_linia.Nodes[ 0 ].Z := Self.celownik_linia.Nodes[ 0 ].Z * Self.skala;

    end;
  //---//if    ( Self.skala <> 1 ) (...)


  Self.celownik_linia_bez_falowania.Nodes[ 1 ].Z := Self.celownik_linia.Nodes[ 1 ].Z;
  //Self.celownik_linia_bez_falowania.Position.AsVector := Self.celownik_linia_bez_falowania.AbsoluteToLocal( Self.celownik_linia.AbsolutePosition );
  Self.celownik_linia_bez_falowania.Position.AsVector := Self.celownik_linia_bez_falowania.AbsoluteToLocal( Self.AbsolutePosition );


  zti := K¹t_Zablokowany_Obszar_Rysuj( Self.obrót_k¹t_zablokowany_GLDisk, Self.obrót_k¹t_zablokowany_do, Self.obrót_k¹t_zablokowany_od, -99, false );

  {$region 'Rysuje obszar zablokowanego k¹ta obrotu.'}
//  zt_gl_sphere := TGLSphere.Create( Self.Parent );
//
//  Self.obrót_k¹t_zablokowany_GLDisk.Position := Self.Position;
//  Self.obrót_k¹t_zablokowany_GLDisk.Position.Y := Self.obrót_k¹t_zablokowany_GLDisk.Position.Y + Self.podstawa.Height * 0.5;
//  Self.obrót_k¹t_zablokowany_GLDisk.Position.Y := Self.obrót_k¹t_zablokowany_GLDisk.Position.Y + 0.001; // Je¿eli jest na tym samym poziomie co inny element to migocze.
//
//  Self.obrót_k¹t_zablokowany_GLDisk.StartAngle := Self.obrót_k¹t_zablokowany_od;
//  Self.obrót_k¹t_zablokowany_GLDisk.SweepAngle := 0;
//
//
//  // Sprawdza czy k¹t zablokowany rozci¹ga siê w kierunku rosn¹cym czy malej¹cym wzglêdem k¹ta obrót_k¹t_zablokowany_od.
//  zt_gl_sphere.TurnAngle := Self.obrót_k¹t_zablokowany_GLDisk.StartAngle;
//  zt_gl_sphere.TurnAngle := zt_gl_sphere.TurnAngle + 1;
//
//  if Self.Obrót_K¹t_Zablokowany_SprawdŸ( zt_gl_sphere.TurnAngle ) then
//    zti := 1
//  else//if Self.Obrót_K¹t_Zablokowany_SprawdŸ( zt_gl_sphere.TurnAngle ) then
//    zti := -1;
//
//  zt_gl_sphere.TurnAngle := Self.obrót_k¹t_zablokowany_GLDisk.StartAngle;
//  //---// Sprawdza czy k¹t zablokowany rozci¹ga siê w kierunku rosn¹cym czy malej¹cym wzglêdem k¹ta obrót_k¹t_zablokowany_od.
//
//  for i := -179 to 180 do
//    begin
//
//      zt_gl_sphere.TurnAngle := zt_gl_sphere.TurnAngle + zti;
//
//      if Self.Obrót_K¹t_Zablokowany_SprawdŸ( zt_gl_sphere.TurnAngle ) then
//        Self.obrót_k¹t_zablokowany_GLDisk.SweepAngle := Self.obrót_k¹t_zablokowany_GLDisk.SweepAngle + zti
//      else
//        Break;
//
//    end;
//  //---//for i := -179 to 180 do
//
//  FreeAndNil( zt_gl_sphere );
//
//  // Zamiana znaków, gdy¿ tak siê rysuje GLDisk.
//  Self.obrót_k¹t_zablokowany_GLDisk.StartAngle := -Self.obrót_k¹t_zablokowany_GLDisk.StartAngle;
//  Self.obrót_k¹t_zablokowany_GLDisk.SweepAngle := -Self.obrót_k¹t_zablokowany_GLDisk.SweepAngle;
  {$endregion 'Rysuje obszar zablokowanego k¹ta obrotu.'}

    
  // Je¿eli w schemacie wczytanym z pliku zadany k¹t obrotu jest w zablokowanym zakresie.
  if Self.Obrót_K¹t_Zablokowany_SprawdŸ( Self.obrót_k¹t_zadany ) then
    if Abs( Self.obrót_k¹t_zadany - Self.obrót_k¹t_zablokowany_do ) < Abs( Self.obrót_k¹t_zadany - Self.obrót_k¹t_zablokowany_od ) then
      Self.obrót_k¹t_zadany := Self.obrót_k¹t_zablokowany_do + zti
    else//if Abs( Self.obrót_k¹t_zadany - Self.obrót_k¹t_zablokowany_do ) < Abs( Self.obrót_k¹t_zadany - Self.obrót_k¹t_zablokowany_od ) then
      Self.obrót_k¹t_zadany := Self.obrót_k¹t_zablokowany_od - zti;
      
  Self.TurnAngle := Self.obrót_k¹t_zadany;



  
//  Self.k¹t_test_obrót.Position.AsVector := Self.statek.AbsoluteToLocal( Self.podstawa.AbsolutePosition );
//
//  Self.k¹t_test_podniesienie.Position.AsVector := Self.statek.AbsoluteToLocal( Self.podstawa.AbsolutePosition );
//  Self.k¹t_test_podniesienie.Position.Y := Self.statek.AbsoluteToLocal( Self.korpus_przód.AbsolutePosition ).Y; // Dok³adniej celuje w punkt.

end;//---//Funkcja Dodatkowe_Elementy_Ustaw().

//Funkcja Parametry_Kopiuj_Dla_Wygl¹d().
procedure TTorpedy_Wyrzutnia.Parametry_Kopiuj_Dla_Wygl¹d( const ATorpedy_Wyrzutnia : TTorpedy_Wyrzutnia );
begin

  //
  // Funkcja kopiuje parametry dzia³a strzelaj¹cego do tego ³adnie wygl¹daj¹cego i dopasowuje jego wygl¹d.
  //

  if ATorpedy_Wyrzutnia = nil then
    Exit;


  Self.dzia³o_strzelaj¹ce := ATorpedy_Wyrzutnia;

  Self.Position := ATorpedy_Wyrzutnia.Position;
  //Self.Position.Y := Self.Position.Y + 1; //???

  //Self.AbsoluteDirection := ATorpedy_Wyrzutnia.AbsoluteDirection; // Z tym nieprawid³owo ustawia siê na pocz¹tku.

  Self.TurnAngle := ATorpedy_Wyrzutnia.TurnAngle;
  Self.PitchAngle := ATorpedy_Wyrzutnia.PitchAngle;
  Self.RollAngle := ATorpedy_Wyrzutnia.RollAngle;


  Self.skala := ATorpedy_Wyrzutnia.skala;

  Self.celownik_linia.Visible := false;
  Self.celownik_linia_bez_falowania.Visible := Self.celownik_linia.Visible;

  Self.Dodatkowe_Elementy_Ustaw();


  // Ukrywa dzia³o strzelaj¹ce.
  Self.dzia³o_strzelaj¹ce.elementy_wizualne_dummy.Visible := false;

//  Self.dzia³o_strzelaj¹ce.korpus.Visible := false;
//  Self.dzia³o_strzelaj¹ce.korpus_przód.Visible := false;
//  Self.dzia³o_strzelaj¹ce.podstawa.Visible := false;
//
//  for i := 0 to Length( Self.dzia³o_strzelaj¹ce.lufy_t ) - 1 do
//    Self.dzia³o_strzelaj¹ce.lufy_t[ i ].Visible := false;

end;//---//Funkcja Parametry_Kopiuj_Dla_Wygl¹d().

//Funkcja Parametry_Aktualizuj_Dla_Wygl¹du().
procedure TTorpedy_Wyrzutnia.Parametry_Aktualizuj_Dla_Wygl¹du();
var
  i : integer;
begin

  //
  // Funkcja aktualizuje parametry dzia³a ³adnie wygl¹daj¹cego na podstawie tego strzelaj¹cego.
  //

  if Self.dzia³o_strzelaj¹ce = nil then
    Exit;


  Self.TurnAngle := Self.dzia³o_strzelaj¹ce.TurnAngle;

  for i := 0 to Length( Self.dzia³o_strzelaj¹ce.lufy_t ) - 1 do
    begin

      Self.lufy_t[ i ].PitchAngle := Self.dzia³o_strzelaj¹ce.lufy_t[ i ].PitchAngle;

      Self.lufy_t[ i ].prze³adowanie_wskaŸnik.Material.FrontProperties.Ambient.Color := Self.dzia³o_strzelaj¹ce.lufy_t[ i ].prze³adowanie_wskaŸnik.Material.FrontProperties.Ambient.Color;
      Self.lufy_t[ i ].prze³adowanie_wskaŸnik.Position.Y := Self.dzia³o_strzelaj¹ce.lufy_t[ i ].prze³adowanie_wskaŸnik.Position.Y;
      Self.lufy_t[ i ].prze³adowanie_wskaŸnik.Position.Z := Self.dzia³o_strzelaj¹ce.lufy_t[ i ].prze³adowanie_wskaŸnik.Position.Z;

    end;
  //---//for i := 0 to Length( Self.dzia³o_strzelaj¹ce.lufy_t ) - 1 do

end;//---//Funkcja Parametry_Aktualizuj_Dla_Wygl¹du().

//Funkcja Obrót_K¹t_Zablokowany_SprawdŸ().
function TTorpedy_Wyrzutnia.Obrót_K¹t_Zablokowany_SprawdŸ( k¹t_f : real ) : boolean;
begin

  //
  // Funkcja sprawdza czy zadana wartoœæ k¹ta znajduje siê w zablokowanym obszarze k¹ta obrotu.
  //
  // Zwraca prawdê gdy zadana wartoœæ k¹ta znajduje siê w zablokowanym obszarze k¹ta obrotu.
  //
  // Parametry:
  //   k¹t_f - sprawdzana wartoœæ k¹ta.
  //

  // Opis jest analogiczny jak w TTorpedy_Wyrzutnia.Obrót_K¹t_Zablokowany_Strza³u_SprawdŸ().


  Result := false;

  if Self.obrót_k¹t_zablokowany_od = Self.obrót_k¹t_zablokowany_do then
    Exit;


  // Wartoœci powy¿ej 180 przechodz¹ na -180, a wartoœci poni¿ej -180 przechodz¹ na 180.
  if k¹t_f > 180 then
    k¹t_f := 180
  else//if k¹t_f > 180 then
    if k¹t_f < -180 then
      k¹t_f := -180;


  // Wartoœci 180 i -180 s¹ sobie równe.
  if    (  Abs( k¹t_f ) = 180  )
    and (
             (  Abs( Self.obrót_k¹t_zablokowany_do ) = 180  )
          or (  Abs( Self.obrót_k¹t_zablokowany_od ) = 180  )
        ) then
    begin

      Result := true;
      Exit;

    end;
  //---//if    (  Abs( k¹t_f ) = 180  ) (...)


  if Self.obrót_k¹t_zablokowany_od >= Self.obrót_k¹t_zablokowany_do then
    begin

      // Zakres k¹ta obrotu 'od do' nie przechodzi przez œrodek rufy.

      if    ( k¹t_f <= Self.obrót_k¹t_zablokowany_od )
        and ( k¹t_f >= Self.obrót_k¹t_zablokowany_do ) then
        begin

          Result := true;

        end;
      //---//if    ( k¹t_f <= Self.obrót_k¹t_zablokowany_od ) (...)

    end
  else//if Self.obrót_k¹t_od >= Self.obrót_k¹t_do then
    begin

      // Zakres k¹ta obrotu 'od do' przechodzi przez œrodek rufy.

      if   ( k¹t_f <= Self.obrót_k¹t_zablokowany_od )
        or ( k¹t_f >= Self.obrót_k¹t_zablokowany_do ) then
        begin

          Result := true;

        end;
      //---//if    ( k¹t_f <= Self.obrót_k¹t_zablokowany_od ) (...)

    end;
  //---//if Self.obrót_k¹t_od >= Self.obrót_k¹t_do then

  //if not Result then //???
  //  Statki_Form.Caption := 'OK'
  //else
  //  Statki_Form.Caption := 'x';

end;//---//Funkcja Obrót_K¹t_Zablokowany_SprawdŸ() w Obrót_Kierunek_Zmieñ().

//Funkcja Obrót_Zadany_Zmieñ().
procedure TTorpedy_Wyrzutnia.Obrót_Zadany_Zmieñ( const celownik_linia_widocznoœæ_f : boolean = true );

  //Funkcja Obrót_K¹t_Zadany_Wyznacz() w Obrót_Zadany_Zmieñ().
  function Obrót_K¹t_Zadany_Wyznacz() : real;
  var
    //statek_obrót_k¹t_l : real; // K¹t obrotu statku w poziomie (lewo prawo).
    zt_vector
    //zt_vector1
      : GLVectorGeometry.TVector; // uses GLVectorGeometry.
  begin

    //
    // Funkcja wyznacza zadany k¹t obrotu wzglêdem statku.
    //
    // Zwraca zadany k¹t obrotu wzglêdem statku.
    //

    GLVectorGeometry.SetVector( zt_vector, 0, 0, 0 ); // Najlepiej sprawdzaæ k¹t w punkcie zero.
    //GLVectorGeometry.SetVector( zt_vector1, 0, 0, -1 ); // Kierunek w przód.

    //statek_obrót_k¹t_l := RadToDeg(  AngleBetweenVectors( Self.statek.AbsoluteDirection, zt_vector1, zt_vector )  );

    //if Self.statek.AbsoluteDirection.X > 0 then
    //  statek_obrót_k¹t_l := -statek_obrót_k¹t_l;


    Result := RadToDeg(  AngleBetweenVectors( Self.statek.AbsoluteDirection, Self.obrót_kierunek_zadany, zt_vector )  );

    if Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector.X > 0 then
      Result := -Result;

    //Statki_Form.Caption := FloatToStr( Result ); //???
    //Statki_Form.Caption := FloatToStr( Self.statek.AbsoluteDirection.X ) + ' ' + FloatToStr( Self.statek.AbsoluteDirection.Z ); //???
    //Statki_Form.Caption := FloatToStr( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector.X ) + ' ' + FloatToStr( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector.Z ); //???
    //Statki_Form.Caption := FloatToStr( statek_obrót_k¹t_l );
    //Statki_Form.Caption := FloatToStr( Self.statek.TurnAngle );

  end;//---//Funkcja Obrót_K¹t_Zadany_Wyznacz() w Obrót_Zadany_Zmieñ().

var
  odleg³oœæ_k¹t_zablokowany_do_l,
  odleg³oœæ_k¹t_zablokowany_od_l
    : real;
  //zt_vector : GLVectorGeometry.TVector; // uses GLVectorGeometry.
begin//Funkcja Obrót_Zadany_Zmieñ().

  //
  // Funkcja ustawia zadany kierunek obrotu na kierunek, w którym patrzy kamera (w p³aszczyŸnie poziomej).
  //

  //Self.obrót_kierunek_zadany.Y := 0;
  //// Wartoœci absolutne maj¹ X i Z o przeciwnych znakach ni¿ kamera.
  //Self.obrót_kierunek_zadany.X := Statki_Form.Gra_GLCamera.AbsoluteDirection.X; //???
  //Self.obrót_kierunek_zadany.Z := Statki_Form.Gra_GLCamera.AbsoluteDirection.Z; //???

  if Self.Parent = nil then
    Exit;

  // Namierzanie wed³ug linii celowniczej statku.

  case celowanie_tryb_g of
      ct_Linia :
        begin

          // Namierzanie równoleg³e do linii celowania.

          Self.obrót_kierunek_zadany.X := Self.statek.celownicza_linia.Nodes[ 1 ].X; // TStatek(Self.Parent).celownicza_linia.Nodes[ 1 ].X.
          Self.obrót_kierunek_zadany.Z := Self.statek.celownicza_linia.Nodes[ 1 ].Z;

        end;
      //---//ct_Linia :

      else//case celowanie_tryb_g of
        begin

          // Namierzanie zbie¿ne do punktu celowania.

          //Self.k¹t_test.Direction.SetVector
          //  (   // Cel                 Obiekt celuj¹cy
          //      Statki_Form.Celowniczy_GLDummyCube.Position.X - Self.k¹t_test.AbsolutePosition.X
          //    , 0
          //    , Statki_Form.Celowniczy_GLDummyCube.Position.Z - Self.k¹t_test.AbsolutePosition.Z
          //  );
          // Lub.
          Self.k¹t_test.Direction.SetVector
            (   // Cel                 Obiekt celuj¹cy
                Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector ).X - Self.k¹t_test.AbsolutePosition.X
              , 0
              , Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Z - Self.k¹t_test.AbsolutePosition.Z
            );

          Self.obrót_kierunek_zadany.X := Self.k¹t_test.Direction.X;
          Self.obrót_kierunek_zadany.Z := Self.k¹t_test.Direction.Z;

        end;
      //---//case celowanie_tryb_g of
    end;
  //---//case celowanie_tryb_g of


  Self.obrót_k¹t_zadany := Obrót_K¹t_Zadany_Wyznacz();
  Self.obrót_k¹t_zadany_bezwzglêdny := Self.obrót_k¹t_zadany;


  // Je¿eli k¹t zadany jest w zakresie zablokowanego k¹ta obrotu ustali wartoœæ k¹ta zadanego na najbli¿sz¹ mu wartoœæ granicy zakresu zablokowanego k¹ta obrotu.
  if    ( Self.obrót_k¹t_zablokowany_od <> Self.obrót_k¹t_zablokowany_do )
    and (  Self.Obrót_K¹t_Zablokowany_SprawdŸ( Self.obrót_k¹t_zadany )  ) then
    begin

      odleg³oœæ_k¹t_zablokowany_od_l := Abs( Self.obrót_k¹t_zadany - Self.obrót_k¹t_zablokowany_od );
      odleg³oœæ_k¹t_zablokowany_do_l := Abs( Self.obrót_k¹t_zadany - Self.obrót_k¹t_zablokowany_do );

      // Wartoœæ k¹ta obrotu nie mo¿e byæ równa wartoœci zablokowanego zakresu ( +/- Self.obrót_szybkoœæ).
      if odleg³oœæ_k¹t_zablokowany_od_l < odleg³oœæ_k¹t_zablokowany_do_l then
        Self.obrót_k¹t_zadany := Self.obrót_k¹t_zablokowany_od + Self.obrót_szybkoœæ
      else//if odleg³oœæ_k¹t_zablokowany_od_l < odleg³oœæ_k¹t_zablokowany_do_l then
        Self.obrót_k¹t_zadany := Self.obrót_k¹t_zablokowany_do - Self.obrót_szybkoœæ;


      // Wartoœæ k¹ta obrotu nie mo¿e przekroczyæ zakresu od -180 do 180.
      if Self.obrót_k¹t_zadany > 180 then
        Self.obrót_k¹t_zadany := Self.obrót_k¹t_zadany - 360
      else//if Self.obrót_k¹t_zadany > 180 then
        if Self.obrót_k¹t_zadany < -180 then
          Self.obrót_k¹t_zadany := Self.obrót_k¹t_zadany + 360;


      //Statki_Form.Caption := FloatToStr(  Round( odleg³oœæ_k¹t_zablokowany_od_l )  ) + ' ' + FloatToStr(  Round( odleg³oœæ_k¹t_zablokowany_do_l )  ) + ' ' + FloatToStr( Self.obrót_k¹t_zadany ); //???

    end;
  //---//if    ( Self.obrót_k¹t_zablokowany_od <> Self.obrót_k¹t_zablokowany_do ) (...)


  //if Self.Parent <> nil then
  //  begin
  //
  //    GLVectorGeometry.SetVector( zt_vector, 0, 1, 0 );
  //    //RotateVector(  Self.obrót_kierunek_zadany, zt_vector, DegToRad( Self.statek.K¹t_Obrotu_Statku() )  );
  //    //RotateVector(  Self.obrót_kierunek_zadany, zt_vector, DegToRad( Self.statek.TurnAngle )  );
  //    //RotateVectorAroundY( Self.obrót_kierunek_zadany, Self.statek.K¹t_Obrotu_Statku() );
  //
  //  end;
  ////---//if Self.Parent <> nil then


  Self.Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( celownik_linia_widocznoœæ_f );

end;//---//Funkcja Obrót_Zadany_Zmieñ().

//Funkcja Obrót_Kierunek_Zmieñ().
procedure TTorpedy_Wyrzutnia.Obrót_Kierunek_Zmieñ( const celowanie_precyzja_obrót_f : real; const broñ_nie_unosi_luf_f : boolean = false );

  //Funkcja Obrót_Kierunek_Ustal() w Obrót_Kierunek_Zmieñ().
  function Obrót_Kierunek_Ustal() : real;

    //Funkcja Znak_SprawdŸ() w Obrót_Kierunek_Ustal() w Obrót_Kierunek_Zmieñ().
    function Znak_SprawdŸ( const liczba_f : real ) : SmallInt;
    begin

      //
      // Funkcja sprawdza znak liczby.
      //
      // Zwraca
      //  1 dla liczb dodatnich i zera oraz
      //  -1 dla liczb ujemnych.
      //

      if liczba_f >= 0 then
        Result := 1
      else//if liczba_f >= 0 then
        Result := -1;

    end;//---//Funkcja Znak_SprawdŸ() w Obrót_Kierunek_Ustal() w Obrót_Kierunek_Zmieñ().

  var
    odleg³oœæ_przez_0_l,
    odleg³oœæ_przez_180_l,
    do_1,
    do_2,
    od_1,
    od_2,
    ztr_l
      : real;
  begin//Funkcja Obrót_Kierunek_Ustal() w Obrót_Kierunek_Zmieñ().

    //
    // Funkcja ustala, w któr¹ stronê obracaæ aby najszybciej osi¹gn¹æ zadany k¹t obrotu
    // uwzglêdnia zablokowany obszar obrotu.
    //
    // Tutaj jest mniej kodu ale chyba trudniej go zrozumieæ.
    //
    // Zwraca
    //  1 obrotu w lewo
    //  -1 obrotu w prawo.
    //


    Result := 1;

    //Statki_Form.Caption := ''; //???

    if Znak_SprawdŸ( Self.TurnAngle ) = Znak_SprawdŸ( Self.obrót_k¹t_zadany ) then
      begin

        // Znaki s¹ takie same.

        if Self.obrót_k¹t_zadany < Self.TurnAngle then
          Result := -1;

      end
    else//if Znak_SprawdŸ( Self.TurnAngle ) = Znak_SprawdŸ( Self.obrót_k¹t_zadany ) then
      begin

        // Znaki s¹ ró¿ne.

        odleg³oœæ_przez_0_l := Abs( Self.obrót_k¹t_zadany ) + Abs( Self.TurnAngle );
        odleg³oœæ_przez_180_l := 180 - Abs( Self.obrót_k¹t_zadany ) + 180 - Abs( Self.TurnAngle );


        // Analogiczny warunek.
        if odleg³oœæ_przez_0_l <= odleg³oœæ_przez_180_l then
          Result := -1;
        
        // Korygowanie dla przeciwnej strony statku.
        if Self.obrót_k¹t_zadany >= 0 then
          Result := -Result;


        //// Analogiczny, skrócony warunek. // To skrócenie jest b³êdne.
        //if    ( odleg³oœæ_przez_0_l <= odleg³oœæ_przez_180_l )
        //  and ( Self.obrót_k¹t_zadany < 0 ) then
        //  Result := -1;

        //Statki_Form.Caption := FloatToStr( odleg³oœæ_przez_0_l ) + ' ' + FloatToStr( odleg³oœæ_przez_180_l ); //???
        //Statki_Form.Caption := 'R'; //???

      end;
    //---//if Znak_SprawdŸ( Self.TurnAngle ) = Znak_SprawdŸ( Self.obrót_k¹t_zadany ) then


    // Je¿eli ustalony kierunek obrotu przechodzi przez zablokowany zakres k¹ta obrotu zmieni kierunek obrotu.
    if Self.obrót_k¹t_zablokowany_od = Self.obrót_k¹t_zablokowany_do then
      Exit;


    //Statki_Form.Caption := ''; //???

    {$region 'Ustala zakres k¹tów przez który odbywa siê obrót.'}
    // od_1 i do_1 okreœlaj¹ zakres k¹tów z tym samym znakiem.
    // od_2 i do_2 okreœlaj¹ zakres k¹tów z przeciwnym znakiem wzglêdem od_1 i do_1,
    //   s¹ dokoñczeniem ruchu od 0 do zakres ruchu lub zakres ruchu do 180,
    //   gdy obie wartoœci s¹ równe 0 zakres nie jest aktywny.

    if    ( Self.TurnAngle >= 0 )
      and ( Result = 1 ) then
      begin

        od_1 := Self.TurnAngle;

        if Self.obrót_k¹t_zadany >= 0 then
          begin

            do_1 := Self.obrót_k¹t_zadany;

            do_2 := 0;
            od_2 := 0;

          end
        else//if Self.obrót_k¹t_zadany >= 0 then
          begin

            do_1 := 180;

            do_2 := Self.obrót_k¹t_zadany;
            od_2 := -180;

          end;
        //---//if Self.obrót_k¹t_zadany >= 0 then

      end
    else//if    ( Self.TurnAngle >= 0 ) (...)
    if    ( Self.TurnAngle >= 0 )
      and ( Result = -1 ) then
      begin

        od_1 := Self.TurnAngle;

        if Self.obrót_k¹t_zadany >= 0 then
          begin

            do_1 := Self.obrót_k¹t_zadany;

            do_2 := 0;
            od_2 := 0;

          end
        else//if Self.obrót_k¹t_zadany >= 0 then
          begin

            do_1 := 0;

            do_2 := Self.obrót_k¹t_zadany;
            od_2 := 0;

          end;
        //---//if Self.obrót_k¹t_zadany >= 0 then

      end
    else//if    ( Self.TurnAngle >= 0 ) (...)
    if    ( Self.TurnAngle < 0 )
      and ( Result = 1 ) then
      begin

        od_1 := Self.TurnAngle;

        if Self.obrót_k¹t_zadany < 0 then
          begin

            do_1 := Self.obrót_k¹t_zadany;

            do_2 := 0;
            od_2 := 0;

          end
        else//if Self.obrót_k¹t_zadany < 0 then
          begin

            do_1 := 0;

            do_2 := Self.obrót_k¹t_zadany;
            od_2 := 0;

          end;
        //---//if Self.obrót_k¹t_zadany < 0 then

      end
    else//if    ( Self.TurnAngle < 0 ) (...)
    if    ( Self.TurnAngle < 0 )
      and ( Result = -1 ) then
      begin

        od_1 := Self.TurnAngle;

        if Self.obrót_k¹t_zadany < 0 then
          begin

            do_1 := Self.obrót_k¹t_zadany;

            do_2 := 0;
            od_2 := 0;

          end
        else//if Self.obrót_k¹t_zadany < 0 then
          begin

            do_1 := -180;

            do_2 := Self.obrót_k¹t_zadany;
            od_2 := 180;

          end;
        //---//if Self.obrót_k¹t_zadany < 0 then

      end;
    //---//if    ( Self.TurnAngle < 0 ) (...)


    // Sprawdza kolejnoœæ wartoœci brzegowych odcinków aby by³a rosn¹ca.
    if od_1 > do_1 then
      begin

        ztr_l := od_1;
        od_1 := do_1;
        do_1 := ztr_l;

      end;
    //---//if od_1 > do_1 then

    if od_2 > do_2 then
      begin

        ztr_l := od_2;
        od_2 := do_2;
        do_2 := ztr_l;

      end;
    //---//if od_2 > do_2 then
    {$endregion 'Ustala zakres k¹tów przez który odbywa siê obrót.'}


    //Statki_Form.Caption := FloatToStr( Result ) + ' | ' + FloatToStr(  Round( od_1 )  ) + ' ' + FloatToStr(  Round( do_1 )  ) + ' ' + FloatToStr(  Round( od_2 )  ) + ' ' + FloatToStr(  Round( do_2 )  ); //???


    // Je¿eli obrót odbywa siê przez zablokowany zakres k¹tów odwraca kierunek obrotu.
    if   (
               ( Self.obrót_k¹t_zablokowany_do >= od_1 )
           and ( Self.obrót_k¹t_zablokowany_do <= do_1 )
         )
      or (
               ( Self.obrót_k¹t_zablokowany_od >= od_1 )
           and ( Self.obrót_k¹t_zablokowany_od <= do_1 )
         )
      or (
               ( do_2 <> od_2 )
           and (
                    (
                          ( Self.obrót_k¹t_zablokowany_do >= od_2 )
                      and ( Self.obrót_k¹t_zablokowany_do <= do_2 )
                    )
                 or (
                          ( Self.obrót_k¹t_zablokowany_od >= od_2 )
                      and ( Self.obrót_k¹t_zablokowany_od <= do_2 )
                    )
               )
         )
    then
      begin

        Result := -Result;
        //Statki_Form.Caption := 'O ' + Statki_Form.Caption; //???

      end;
    //---//if   ( (...)

  end;//---//Funkcja Obrót_Kierunek_Ustal() w Obrót_Kierunek_Zmieñ().

  //Funkcja Obrót_Kierunek_Ustal_2() w Obrót_Kierunek_Zmieñ().
  function Obrót_Kierunek_Ustal_2() : real;

    //Funkcja Znak_SprawdŸ() w Obrót_Kierunek_Ustal_2() w Obrót_Kierunek_Zmieñ().
    function Znak_SprawdŸ( const liczba_f : real ) : SmallInt;
    begin

      //
      // Funkcja sprawdza znak liczby.
      //
      // Zwraca
      //  1 dla liczb dodatnich i zera oraz
      //  -1 dla liczb ujemnych.
      //

      if liczba_f >= 0 then
        Result := 1
      else//if liczba_f >= 0 then
        Result := -1;

    end;//---//Funkcja Znak_SprawdŸ() w Obrót_Kierunek_Ustal_2() w Obrót_Kierunek_Zmieñ().

    //Funkcja Posortuj_Wartoœci() w Obrót_Kierunek_Ustal_2() w Obrót_Kierunek_Zmieñ().
    procedure Posortuj_Wartoœci( var liczba_od_f, liczba_do_f : real );
    var
      ztr_l
        : real;
    begin

      //
      // Funkcja ustawia podane liczby w kolejnoœci rosn¹cej (liczba_od_f <= liczba_do_f).
      //
      // Parametry:
      //   liczba_od_f
      //   liczba_do_f
      //

      if liczba_od_f > liczba_do_f then
        begin

          ztr_l := liczba_od_f;
          liczba_od_f := liczba_do_f;
          liczba_do_f := ztr_l;

        end;
      //---//if liczba_od_f > liczba_do_f then

    end;//---//Funkcja Posortuj_Wartoœci() w Obrót_Kierunek_Ustal_2() w Obrót_Kierunek_Zmieñ().

  var
    odleg³oœæ_przez_0_l,
    odleg³oœæ_przez_180_l,
    do_1,
    do_2,
    do_3,
    od_1,
    od_2,
    od_3
      : real;
    czy_obrót_przez_0_l, //???
    czy_obrót_przez_zablokowany_zakres_l //???
      : boolean;
  begin//Funkcja Obrót_Kierunek_Ustal_2() w Obrót_Kierunek_Zmieñ().

    //
    // Funkcja ustala, w któr¹ stronê obracaæ aby najszybciej osi¹gn¹æ zadany k¹t obrotu,
    // uwzglêdnia zablokowany obszar obrotu.
    //
    // Tutaj jest wiêcej kodu ale chyba ³atwiej go zrozumieæ.
    //
    // Zwraca
    //  1 obrotu w lewo
    //  -1 obrotu w prawo.
    //

    {$region 'Okreœla cechy wariantów obrotów.'}
    if Znak_SprawdŸ( Self.TurnAngle ) = Znak_SprawdŸ( Self.obrót_k¹t_zadany ) then
      begin

        // Znaki s¹ takie same.

        if Abs( Self.TurnAngle ) >= Abs( Self.obrót_k¹t_zadany ) then
          begin

            // K¹t zadany obrotu jest miêdzy k¹tem aktualnym a 0.

            odleg³oœæ_przez_0_l := Abs( Self.TurnAngle ) - Abs( Self.obrót_k¹t_zadany );
            odleg³oœæ_przez_180_l := 360 - odleg³oœæ_przez_0_l;


            if odleg³oœæ_przez_0_l <= odleg³oœæ_przez_180_l then
              begin

                // Zakresy przez 0.

                od_1 := Self.TurnAngle;
                do_1 := Self.obrót_k¹t_zadany;

                do_2 := 0;
                od_2 := 0;

                od_3 := 0;
                do_3 := 0;

              end
            else//if odleg³oœæ_przez_0_l <= odleg³oœæ_przez_180_l then
              begin

                // Zakresy przez 180.

                od_1 := 180;

                if Self.TurnAngle < 0 then
                  od_1 := -od_1;

                do_1 := Self.TurnAngle;


                od_2 := 0;
                do_2 := 180;

                if Self.TurnAngle >= 0 then
                  do_2 := -do_2;


                od_3 := Self.obrót_k¹t_zadany;
                do_3 := 0;

              end;
            //---//if odleg³oœæ_przez_0_l <= odleg³oœæ_przez_180_l then

          end
        else//if Abs( Self.TurnAngle ) >= Abs( Self.obrót_k¹t_zadany ) then
          begin

            // K¹t zadany obrotu jest miêdzy k¹tem aktualnym a 180 (te¿ -180).

            odleg³oœæ_przez_180_l := Abs( Self.obrót_k¹t_zadany ) - Abs( Self.TurnAngle );
            odleg³oœæ_przez_0_l := 360 - odleg³oœæ_przez_180_l;


            if odleg³oœæ_przez_0_l <= odleg³oœæ_przez_180_l then
              begin

                // Zakresy przez 0.

                od_1 := Self.TurnAngle;
                do_1 := 0;


                od_2 := 0;
                do_2 := 180;

                if Self.obrót_k¹t_zadany >= 0 then
                  do_2 := -do_2;


                od_3 := 180;

                if Self.obrót_k¹t_zadany < 0 then
                  od_3 := -od_3;

                do_3 := Self.obrót_k¹t_zadany;

              end
            else//if odleg³oœæ_przez_0_l <= odleg³oœæ_przez_180_l then
              begin

                // Zakresy przez 180.

                od_1 := Self.obrót_k¹t_zadany;
                do_1 := Self.TurnAngle;

                do_2 := 0;
                od_2 := 0;

                od_3 := 0;
                do_3 := 0;

              end;
            //---//if odleg³oœæ_przez_0_l <= odleg³oœæ_przez_180_l then

          end;
        //---//if Abs( Self.TurnAngle ) >= Abs( Self.obrót_k¹t_zadany ) then

      end
    else//if Znak_SprawdŸ( Self.TurnAngle ) = Znak_SprawdŸ( Self.obrót_k¹t_zadany ) then
      begin

        // Znaki s¹ ró¿ne.

        if Abs( Self.TurnAngle ) >= Abs( Self.obrót_k¹t_zadany ) then
          begin

            // 0 jest miêdzy k¹tem aktualnym a zadanym k¹tem obrotu.

            odleg³oœæ_przez_0_l := Abs( Self.TurnAngle ) + Abs( Self.obrót_k¹t_zadany );
            odleg³oœæ_przez_180_l := 360 - odleg³oœæ_przez_0_l;


            if odleg³oœæ_przez_0_l <= odleg³oœæ_przez_180_l then
              begin

                // Zakresy przez 0.

                od_1 := Self.TurnAngle;
                do_1 := 0;

                do_2 := 0;
                od_2 := Self.obrót_k¹t_zadany;

                od_3 := 0;
                do_3 := 0;

              end
            else//if odleg³oœæ_przez_0_l <= odleg³oœæ_przez_180_l then
              begin

                // Zakresy przez 180.

                od_1 := 180;

                if Self.TurnAngle < 0 then
                  od_1 := -od_1;

                do_1 := Self.TurnAngle;


                od_2 := 180;

                if Self.obrót_k¹t_zadany < 0 then
                  od_2 := -od_2;

                do_2 := Self.obrót_k¹t_zadany;


                od_3 := 0;
                do_3 := 0;

              end;
            //---//if odleg³oœæ_przez_0_l <= odleg³oœæ_przez_180_l then

          end
        else//if Abs( Self.TurnAngle ) >= Abs( Self.obrót_k¹t_zadany ) then
          begin

            // 180 (te¿ -180) jest miêdzy k¹tem aktualnym a zadanym k¹tem obrotu.

            odleg³oœæ_przez_0_l := Abs( Self.obrót_k¹t_zadany ) + Abs( Self.TurnAngle );
            odleg³oœæ_przez_180_l := 360 - odleg³oœæ_przez_0_l;


            if odleg³oœæ_przez_0_l <= odleg³oœæ_przez_180_l then
              begin

                // Zakresy przez 0.

                od_1 := Self.TurnAngle;
                do_1 := 0;

                do_2 := 0;
                od_2 := Self.obrót_k¹t_zadany;

                od_3 := 0;
                do_3 := 0;

              end
            else//if odleg³oœæ_przez_0_l <= odleg³oœæ_przez_180_l then
              begin

                // Zakresy przez 180.

                od_1 := 180;

                if Self.TurnAngle < 0 then
                  od_1 := -od_1;

                do_1 := Self.TurnAngle;


                od_2 := 180;

                if Self.obrót_k¹t_zadany < 0 then
                  od_2 := -od_2;

                do_2 := Self.obrót_k¹t_zadany;


                od_3 := 0;
                do_3 := 0;

              end;
            //---//if odleg³oœæ_przez_0_l <= odleg³oœæ_przez_180_l then

          end;
        //---//if Abs( Self.TurnAngle ) >= Abs( Self.obrót_k¹t_zadany ) then

      end;
    //---//if Znak_SprawdŸ( Self.TurnAngle ) = Znak_SprawdŸ( Self.obrót_k¹t_zadany ) then


    Posortuj_Wartoœci( od_1, do_1 );
    Posortuj_Wartoœci( od_2, do_2 );
    Posortuj_Wartoœci( od_3, do_3 );
    {$endregion 'Okreœla cechy wariantów obrotów.'}


    if odleg³oœæ_przez_0_l <= odleg³oœæ_przez_180_l then
      czy_obrót_przez_0_l := true
    else//if odleg³oœæ_przez_0_l <= odleg³oœæ_przez_180_l then
      czy_obrót_przez_0_l := false;


    // Je¿eli obrót odbywa siê przez zablokowany zakres k¹tów odwraca kierunek obrotu.
    if    ( Self.obrót_k¹t_zablokowany_od <> Self.obrót_k¹t_zablokowany_do )
      and (
               (
                     ( Self.obrót_k¹t_zablokowany_do >= od_1 )
                 and ( Self.obrót_k¹t_zablokowany_do <= do_1 )
               )
            or (
                     ( Self.obrót_k¹t_zablokowany_od >= od_1 )
                 and ( Self.obrót_k¹t_zablokowany_od <= do_1 )
               )
            or (
                     ( do_2 <> od_2 )
                 and (
                          (
                                ( Self.obrót_k¹t_zablokowany_do >= od_2 )
                            and ( Self.obrót_k¹t_zablokowany_do <= do_2 )
                          )
                       or (
                                ( Self.obrót_k¹t_zablokowany_od >= od_2 )
                            and ( Self.obrót_k¹t_zablokowany_od <= do_2 )
                          )
                     )
               )
            or (
                     ( do_3 <> od_3 )
                 and (
                          (
                                ( Self.obrót_k¹t_zablokowany_do >= od_3 )
                            and ( Self.obrót_k¹t_zablokowany_do <= do_3 )
                          )
                       or (
                                ( Self.obrót_k¹t_zablokowany_od >= od_3 )
                            and ( Self.obrót_k¹t_zablokowany_od <= do_3 )
                          )
                     )
               )
          )
    then
      czy_obrót_przez_zablokowany_zakres_l := true
    else//if    ( Self.obrót_k¹t_zablokowany_od <> Self.obrót_k¹t_zablokowany_do ) (...)
      czy_obrót_przez_zablokowany_zakres_l  := false;


    if Self.TurnAngle >= 0 then
      begin

        //if odleg³oœæ_przez_0_l <= odleg³oœæ_przez_180_l then
        if czy_obrót_przez_0_l then
          Result := -1
        else//if czy_obrót_przez_0_l then
          Result := 1;

      end
    else//if Self.TurnAngle >= 0 then
      begin

        //if odleg³oœæ_przez_0_l <= odleg³oœæ_przez_180_l then
        if czy_obrót_przez_0_l then
          Result := 1
        else//if czy_obrót_przez_0_l then
          Result := -1;

      end;
    //---//if Self.TurnAngle >= 0 then

    if czy_obrót_przez_zablokowany_zakres_l then
      Result := -Result;


    //if czy_obrót_przez_0_l then
    //  Statki_Form.Caption := 'P_0'
    //else//if czy_obrót_przez_0_l then
    //  Statki_Form.Caption := 'P_180';


    //if czy_obrót_przez_zablokowany_zakres_l then
    //  Statki_Form.Caption := Statki_Form.Caption + ' O ';


    //Statki_Form.Caption := Statki_Form.Caption +
    //  //FloatToStr( Result ) +
    //  ' I ' + FloatToStr(  Round( od_1 )  ) + ' ' + FloatToStr(  Round( do_1 )  ) +
    //  ' II ' + FloatToStr(  Round( od_2 )  ) + ' ' + FloatToStr(  Round( do_2 )  ) +
    //  ' III ' + FloatToStr(  Round( od_3 )  ) + ' ' + FloatToStr(  Round( do_3 )  ) +
    //  //' | ' + FloatToStr(  Round( odleg³oœæ_1_l )  ) + ' ' + FloatToStr(  Round( odleg³oœæ_2_l )  ) +
    //  ' | ' + FloatToStr(  Round( odleg³oœæ_przez_0_l )  ) + ' ' + FloatToStr(  Round( odleg³oœæ_przez_180_l )  ); //???

  end;//---//Funkcja Obrót_Kierunek_Ustal_2() w Obrót_Kierunek_Zmieñ().

var
  ztr,
  //k¹t_1,
  //k¹t_2,
  k¹t_do_k¹t_obrócenia_l,
  k¹t_do_k¹t_obrócenia_bezwzglêdny_l,
  k¹t_do_k¹t_obrócenia_odleg³oœæ_procent_l, // Okreœla jaki procent precyzji celowania stanowi aktualna ró¿nica k¹ta zadanego wzglêdem k¹ta wycelowania (wartoœæ ograniczana do zakresu 0 - 100).
  obrót_kierunek_l,
  obrót_szybkoœæ_l
    : real;
  //zt_vector : GLVectorGeometry.TVector; // uses GLVectorGeometry.
begin//Funkcja Obrót_Kierunek_Zmieñ().

  //
  // Funkcja modyfikuje obrót.
  //
  //  Zmiana obrótu odbywa siê zawsze pe³n¹ moc¹ i liniowo.
  //

  //if MilliSecondsBetween( Now(), Self.strza³_czas ) <= Self.strza³_od_blokada_milisekundy then
  if Czas_Miêdzy_W_Milisekundach( Self.strza³_czas_i ) <= Self.strza³_od_blokada_milisekundy then
    begin

      // Sygnalizuje, ¿e dzia³o jest w trakcie strza³u i nie obraca siê.

      if Self.czy_indeks_do_strza³u then
        Self.celownik_linia.LineColor.Color := GLColor.clrLightGray // Jasny szary.
      else//if Self.czy_indeks_do_strza³u then
        Self.celownik_linia.LineColor.Color := GLColor.clrBlack; // Ciemny czarny.

      Self.celownik_linia_bez_falowania.LineColor.Color := Self.celownik_linia.LineColor.Color;
      Exit;

    end;
  //---//if Czas_Miêdzy_W_Milisekundach( Self.strza³_czas_i ) <= Self.strza³_od_blokada_milisekundy then

  {$region 'Wersja 1.'}
  //GLVectorGeometry.SetVector( zt_vector, 0, 0, 0 ); // Najlepiej sprawdzaæ k¹t w punkcie zero.
  //
  //Self.k¹t_test.Up.SetVector( 0, 1, 0 ); // Je¿eli k¹t testowy jest u¿ywany do wyliczania podniesienia mo¿e go obróciæ.
  //
  //// Ustawia k¹t bry³y testowej na taki jak ma aktualnie dzia³o.
  //Self.k¹t_test.AbsoluteDirection := Self.AbsoluteDirection;
  //
  //// Sprawdza k¹t miêdzy kierunkiem zadanym a kierunkiem dzia³a.
  //k¹t_1 := 180 - RadToDeg(  AngleBetweenVectors( Self.k¹t_test.AbsoluteDirection, Self.obrót_kierunek_zadany, zt_vector )  );
  //
  ////Statki_Form.Caption := FloatToStr( k¹t_1 );
  //
  //
  //// Obraca bry³ê testow¹ i ponownie wylicza k¹t.
  ////Self.k¹t_test.Turn( Self.obrót_szybkoœæ );
  //Self.k¹t_test.TurnAngle := Self.k¹t_test.TurnAngle - Self.obrót_szybkoœæ;
  //k¹t_2 := 180 - RadToDeg(  AngleBetweenVectors( Self.k¹t_test.AbsoluteDirection, Self.obrót_kierunek_zadany, zt_vector )  );
  //
  ////Statki_Form.Caption := Statki_Form.Caption + ' ' + FloatToStr( k¹t_2 );
  //
  //// Je¿eli po obrocie k¹t siê zmniejsza obraca dzia³o w tym samym kierunki, w przeciwnym wypadku obraca w przeciwn¹ stronê.

  //if k¹t_1 < Self.obrót_szybkoœæ then // Coœ jest nie tak z ustawianiem kierunków ale obrót o same k¹ty dzia³a.
  //  Self.Direction.AsVector := Self.obrót_kierunek_zadany
  //else//if k¹t_1 < Self.obrót_szybkoœæ then
  {$endregion 'Wersja 1.'}


  k¹t_do_k¹t_obrócenia_l := Abs( Self.TurnAngle - Self.obrót_k¹t_zadany );
  k¹t_do_k¹t_obrócenia_bezwzglêdny_l := Abs( Self.TurnAngle - Self.obrót_k¹t_zadany_bezwzglêdny );


  if celowanie_precyzja_obrót_f <> 0 then
    k¹t_do_k¹t_obrócenia_odleg³oœæ_procent_l := k¹t_do_k¹t_obrócenia_l * 100 / celowanie_precyzja_obrót_f
  else//if celowanie_precyzja_obrót_f <> 0 then
    k¹t_do_k¹t_obrócenia_odleg³oœæ_procent_l := 100;


  if k¹t_do_k¹t_obrócenia_odleg³oœæ_procent_l > 100 then
    k¹t_do_k¹t_obrócenia_odleg³oœæ_procent_l := 100
  else//if k¹t_do_k¹t_obrócenia_odleg³oœæ_procent_l > 100 then
  if k¹t_do_k¹t_obrócenia_odleg³oœæ_procent_l < 0 then
    k¹t_do_k¹t_obrócenia_odleg³oœæ_procent_l := 0;

  obrót_szybkoœæ_l := Self.obrót_szybkoœæ * k¹t_do_k¹t_obrócenia_odleg³oœæ_procent_l * 0.01; // Im bli¿ej zadanego k¹ta wycelowana tym wolniej obraca bronie ale z wiêksz¹ precyzj¹.


  if k¹t_do_k¹t_obrócenia_l > obrót_szybkoœæ_l * Statki_Form.gra_wspó³czynnik_prêdkoœci_g then
    begin

      obrót_kierunek_l := Obrót_Kierunek_Ustal();


      // Powy¿ej pewnej prêdkoœci gry nie mo¿e ustawiæ w³aœciwego k¹ta (za szybko zmienia k¹t i broñ dr¿y na boki).
      ztr := obrót_szybkoœæ_l * Statki_Form.gra_wspó³czynnik_prêdkoœci_g;

      if ztr > 20 then
        ztr := 20;

      ztr := ztr * obrót_kierunek_l;


      if not Obrót_K¹t_Zablokowany_SprawdŸ( Self.TurnAngle + ztr ) then // Dodatkowe zabezpieczenie. //// Je¿eli obrót wykonuje siê po Self.obrót_k¹t_zadany_bezwzglêdny.
        Self.TurnAngle := Self.TurnAngle + ztr;


      {$region 'Wersja 1.'}
      //if k¹t_2 < k¹t_1 then
      // begin
      //
      //    //Statki_Form.Caption := Statki_Form.Caption + ' Prawo';
      //    //Self.Turn( Self.obrót_szybkoœæ ); // Prawo.
      //
      //    if not Obrót_K¹t_Zablokowany_SprawdŸ( Self.TurnAngle - Self.obrót_szybkoœæ ) then
      //      Self.TurnAngle := Self.TurnAngle - Self.obrót_szybkoœæ;
      //
      //  end
      //else//if k¹t_2 < k¹t_1 then
      //  begin
      //
      //    //Statki_Form.Caption := Statki_Form.Caption + ' Lewo';
      //    //Self.Turn( -Self.obrót_szybkoœæ ); // Lewo.
      //
      //    if not Obrót_K¹t_Zablokowany_SprawdŸ( Self.TurnAngle + Self.obrót_szybkoœæ ) then
      //      Self.TurnAngle := Self.TurnAngle + Self.obrót_szybkoœæ;
      //
      //  end;
      ////---//if k¹t_2 < k¹t_1 then
      {$endregion 'Wersja 1.'}

    end;
  //---//if k¹t_do_k¹t_obrócenia_l > obrót_szybkoœæ_l * Statki_Form.gra_wspó³czynnik_prêdkoœci_g then


  if k¹t_do_k¹t_obrócenia_bezwzglêdny_l < obrót_szybkoœæ_l + celowanie_precyzja_obrót_f then // Je¿eli wycelowano w obrêbie zablokowanego obszaru obrotu oznacza jako nie wycelowane.
    Self.czy_wycelowany_obrót := true
  else//if k¹t_do_k¹t_obrócenia_bezwzglêdny_l < obrót_szybkoœæ_l then
    Self.czy_wycelowany_obrót := false;


  if    ( Self.czy_wycelowany_obrót )
    and ( Self.Obrót_K¹t_Zablokowany_Strza³u_SprawdŸ() ) then // W martwym k¹cie nie oznacza jako wycelowane.
    Self.czy_wycelowany_obrót := false;


  if Self.czy_wycelowany_obrót then
    begin

      if Self.czy_indeks_do_strza³u then
        Self.celownik_linia.LineColor.Color := GLColor.clrGreenYellow // Jasny zielony.
      else//if Self.czy_indeks_do_strza³u then
        Self.celownik_linia.LineColor.Color := GLColor.clrGreen; // Ciemny zielony.


      if celowanie_precyzja_obrót_f <> 0 then
        begin

          // Okreœla jaki procent precyzji celowania stanowi aktualna ró¿nica k¹ta zadanego wzglêdem k¹ta wycelowania (wartoœæ ograniczana do zakresu 0 - 100).
          ztr := k¹t_do_k¹t_obrócenia_bezwzglêdny_l * 100 / celowanie_precyzja_obrót_f;

          if ztr > 100 then
            ztr := 100
          else//if ztr > 100 then
          if ztr < 0 then
            ztr := 0;
          //---// Okreœla jaki procent precyzji celowania stanowi aktualna ró¿nica k¹ta zadanego wzglêdem k¹ta wycelowania (wartoœæ ograniczana do zakresu 0 - 100).

        end
      else//if celowanie_precyzja_obrót_f <> 0 then
        ztr := 0;

      // Gruboœæ linii jest odwrotna do procenta (im mniejszy procent tym linia grubsza).
      if broñ_nie_unosi_luf_f then
        ztr := ( celownik_linia_szerokoœæ_maksymalna__obrót_c + celownik_linia_szerokoœæ_maksymalna__podniesienie_c ) * ( 100 - ztr ) * 0.01
      else//if broñ_nie_unosi_luf_f then
        ztr := celownik_linia_szerokoœæ_maksymalna__obrót_c * ( 100 - ztr ) * 0.01;


      Self.celownik_linia_szerokoœæ_obrót := ztr;

    end
  else//if Self.czy_wycelowany_obrót then
    begin

      if Self.czy_indeks_do_strza³u then
        Self.celownik_linia.LineColor.Color := GLColor.clrRed // Jasny czerwony.
      else//if Self.czy_indeks_do_strza³u then
        Self.celownik_linia.LineColor.Color := GLColor.clrDarkPurple; // Ciemny czerwony.

      Self.celownik_linia_szerokoœæ_obrót := ztr;

    end;
  //---//if Self.czy_wycelowany_obrót then


  Self.celownik_linia.LineWidth := Self.celownik_linia_szerokoœæ_obrót;

  Self.celownik_linia_bez_falowania.LineColor.Color := Self.celownik_linia.LineColor.Color;
  Self.celownik_linia_bez_falowania.LineWidth := Self.celownik_linia.LineWidth;

end;//---//Funkcja Obrót_Kierunek_Zmieñ().

//Funkcja Strza³().
function TTorpedy_Wyrzutnia.Strza³( const czy_wszystkie_lufy_f, obracaj_dzia³a_f, podnoœ_lufy_f : boolean; var wystrzeli³y_wszystkie_f : boolean; const cel_wspó³rzêdne_f : TAffineVector  ) : boolean;

  //Funkcja Strza³y_Iloœæ_SprawdŸ() w Strza³().
  procedure Strza³y_Iloœæ_SprawdŸ();
  begin

    //
    // Funkcja gdy iloœæ oddanych strza³ów równa siê iloœci luf zeruje licznik iloœci strza³ów i oznacza, ¿e wszystkie lufy mog³y strzelaæ.
    //

    inc( Self.strza³y_iloœæ );

    if Self.strza³y_iloœæ >= Length( Self.lufy_t ) then
      begin

        wystrzeli³y_wszystkie_f := true;
        Self.strza³y_iloœæ := 0;

      end;
    //---//if Self.strza³y_iloœæ >= Length( Self.lufy_t ) then

  end;//---//Funkcja Strza³y_Iloœæ_SprawdŸ() w Strza³().

var
  i,
  próby_strza³u_iloœæ
    : integer;
begin//Funkcja Strza³().

  //
  // Funkcja strzela wszystkimi lufami lub ustala kolejn¹ (nastêpn¹ po poprzednim strzale) gotow¹ lufê i strzela jedn¹ luf¹.
  //
  // Zwraca prawdê gdy wystrzeli.
  //
  // Parametry:
  //   czy_wszystkie_lufy_f:
  //     true - strza³ wszystkimi lufami.
  //     false - strza³ jedn¹ luf¹.
  //   obracaj_dzia³a_f
  //     true - strzela tylko gdy dzia³o jest wycelowane.
  //     false - je¿eli dzia³a s¹ zablokowane mo¿na strzeliæ mimo nie wycelowania.
  //  wystrzeli³y_wszystkie_f
  //     true - z dzia³a wystrzelono tyle razy ile jest luf (w strzelaniu pojedynczym oznacza ¿eby prze³¹czyæ strzelanie na inne dzia³o).
  //     false.
  //

  Result := false;
  wystrzeli³y_wszystkie_f := false;

//  if    ( not Self.czy_wycelowany_obrót )
//    and ( not obracaj_dzia³a_f ) then
//    Exit;

  if obracaj_dzia³a_f then // Je¿eli dzia³a s¹ zablokowane mo¿na strzeliæ mimo nie wycelowania.
    if not Self.czy_wycelowany_obrót then
      Exit;


  if Self.Obrót_K¹t_Zablokowany_Strza³u_SprawdŸ() then // Nie strzela w martwym k¹cie.
    Exit;


  if czy_wszystkie_lufy_f then
    begin

      // Strza³ wszystkimi lufami.

      for i := 0 to Length( Self.lufy_t ) - 1 do
        if    ( Self.lufy_t[ i ] <> nil )
          and ( Self.lufy_t[ i ].strza³_gotowoœæ )
          //and ( Self.lufy_t[ i ].czy_wycelowane_podniesienie )
          and (
                   ( not obracaj_dzia³a_f )
                or ( Self.lufy_t[ i ].czy_wycelowane_podniesienie )
              ) then
          if Self.lufy_t[ i ].Strza³( obracaj_dzia³a_f, podnoœ_lufy_f, cel_wspó³rzêdne_f ) then
            begin

              //Self.strza³_czas := Now();
              Self.strza³_czas_i := Czas_Teraz();

              Strza³y_Iloœæ_SprawdŸ();

              if not Result then
                Result := true;

            end;
          //---//if Self.lufy_t[ i ].Strza³( obracaj_dzia³a_f, podnoœ_lufy_f, cel_wspó³rzêdne_f ) then

      Self.strza³y_iloœæ := 0;

    end
  else//if czy_wszystkie_lufy_f then
    begin

      // Strza³ jedn¹ luf¹.

      próby_strza³u_iloœæ := 1;

      i := Self.lufa_ostatni_strza³_indeks;

      inc( i );

      if i > Length( Self.lufy_t ) - 1 then
        i := 0;


      while próby_strza³u_iloœæ <= Length( Self.lufy_t ) do
        begin

          inc( próby_strza³u_iloœæ );


          if    ( Self.lufy_t[ i ] <> nil )
            and ( Self.lufy_t[ i ].strza³_gotowoœæ )
            //and ( Self.lufy_t[ i ].czy_wycelowane_podniesienie )
            and (
                     ( not obracaj_dzia³a_f )
                  or ( Self.lufy_t[ i ].czy_wycelowane_podniesienie )
                ) then
            begin

              if Self.lufy_t[ i ].Strza³( obracaj_dzia³a_f, podnoœ_lufy_f, cel_wspó³rzêdne_f ) then
                begin

                  //Self.strza³_czas := Now();
                  Self.strza³_czas_i := Czas_Teraz();
                  Self.lufa_ostatni_strza³_indeks := i;

                  Result := true;

                  Strza³y_Iloœæ_SprawdŸ();

                  // Oznacza, która lufa bêdzie strzelaæ pojedynczo jako kolejna.
                  //Self.lufy_t[ i ].czy_indeks_do_strza³u_lufa := false;
                  for próby_strza³u_iloœæ := 0 to Length( Self.lufy_t ) - 1 do
                    if    ( Self.lufy_t[ próby_strza³u_iloœæ ] <> nil )
                      and ( Self.lufy_t[ próby_strza³u_iloœæ ].czy_indeks_do_strza³u_lufa ) then
                      begin

                        // Mog³a strzeliæ inna lufa ni¿ wybrana (je¿eli ta nie by³a gotowa).

                        Self.lufy_t[ próby_strza³u_iloœæ ].czy_indeks_do_strza³u_lufa := false;
                        Break;

                      end;
                    //---//if    ( Self.lufy_t[ próby_strza³u_iloœæ ] <> nil ) (...)

                  inc( i );

                  if i > Length( Self.lufy_t ) - 1 then
                    i := 0;

                  Self.lufy_t[ i ].czy_indeks_do_strza³u_lufa := true;
                  //---// Oznacza, która lufa bêdzie strzelaæ pojedynczo jako kolejna.

                  Exit;

                end;
              //---//if Self.lufy_t[ i ].Strza³( obracaj_dzia³a_f, podnoœ_lufy_f, cel_wspó³rzêdne_f ) then

            end
          else//if    ( Self.lufy_t[ i ] <> nil ) (...)
            begin

              inc( i );

              if i > Length( Self.lufy_t ) - 1 then
                i := 0;

            end;
          //---//if    ( Self.lufy_t[ i ] <> nil ) (...)

        end;
      //---//while próby_strza³u_iloœæ <= Length( Self.lufy_t ) do

    end;
  //---//if czy_wszystkie_lufy_f then

end;//---//Funkcja Strza³().

//Funkcja Obrót_K¹t_Zablokowany_Strza³u_SprawdŸ().
function TTorpedy_Wyrzutnia.Obrót_K¹t_Zablokowany_Strza³u_SprawdŸ() : boolean;
var
  i : integer;
begin

  //
  // Funkcja sprawdza czy aktualny obrót znajduje siê w zablokowanym k¹cie strza³u.
  //
  // Zwraca prawdê gdy aktualny obrót znajduje siê w zablokowanym k¹cie strza³u.
  //

  Result := false;

  if   (  Length( Self.obrót_k¹t_zablokowany_strza³_do ) <= 0  )
    or (  (  Length( Self.obrót_k¹t_zablokowany_strza³_do ) <> Length( Self.obrót_k¹t_zablokowany_strza³_od )  )  ) then
    Exit;


  for i := 0 to Length( Self.obrót_k¹t_zablokowany_strza³_do ) - 1 do
    if Obrót_K¹t_Zablokowany_Strza³u_SprawdŸ( Self.TurnAngle, i ) then
      begin

        Result := true;
        Exit;

      end;
    //---//if Obrót_K¹t_Zablokowany_Strza³u_SprawdŸ( Self.TurnAngle, i ) then

end;//---//Funkcja Obrót_K¹t_Zablokowany_Strza³u_SprawdŸ().

//Funkcja Obrót_K¹t_Zablokowany_Strza³u_SprawdŸ().
function TTorpedy_Wyrzutnia.Obrót_K¹t_Zablokowany_Strza³u_SprawdŸ( k¹t_f : real; const indeks_f : integer ) : boolean;
begin

  //
  // Funkcja sprawdza czy aktualny obrót znajduje siê w zablokowanym k¹cie strza³u.
  //
  // Zwraca prawdê gdy aktualny obrót znajduje siê w zablokowanym k¹cie strza³u.
  //

  // K¹ty na oko³o statku.
  //
  //     0
  // 90  A -90
  // 180 / -180
  //

  // Mo¿na traktowaæ jak: czy aktualna wartoœæ (k¹t) nale¿y do przedzia³u (zablokowany zakres k¹ta strza³u).
  // 180 ___ -180
  // Wtedy 'k¹t od' musi byæ wiêkszy od 'k¹ta do'.

  // W przypadku przedzia³u (zablokowany zakres k¹ta strza³u) przechodz¹cego przez ty³ (rufê)
  // 0 ___ 180 | -0 ___ -180
  // mo¿na traktowaæ jak: czy aktualna wartoœæ (k¹t) jest mniejsza od 'wartoœci od' (zablokowany zakres k¹ta strza³u od)
  // lub czy aktualna wartoœæ (k¹t) jest wiêksza od 'wartoœci do' (zablokowany zakres k¹ta strza³u do).
  //
  // Aby zachowaæ regu³ê, ¿e 'wartoœæ od' (zablokowany zakres k¹ta strza³u od) jest pierwsza wzglêdem 'wartoœci do' (zablokowany zakres k¹ta strza³u do)
  // zgodnie z kierunkiem ruchu wskazówek zegara 'wartoœæ od' (zablokowany zakres k¹ta strza³u od) jest ujemna, a 'wartoœæ do' (zablokowany zakres k¹ta strza³u do) jest dodatnia
  // i zakres przedzia³u (zablokowany zakres k¹ta strza³u) przechodzi przez œrodek ty³u (rufy) [180 / -180].


  Result := false;

  if   (  Length( Self.obrót_k¹t_zablokowany_strza³_do ) <= 0  )
    or ( indeks_f < 0 )
    or (  indeks_f > Length( Self.obrót_k¹t_zablokowany_strza³_do ) - 1  )
    or (  (  Length( Self.obrót_k¹t_zablokowany_strza³_do ) <> Length( Self.obrót_k¹t_zablokowany_strza³_od )  )  ) then
    Exit;


  // Wartoœci powy¿ej 180 przechodz¹ na -180, a wartoœci poni¿ej -180 przechodz¹ na 180.
  if k¹t_f > 180 then
    k¹t_f := 180
  else//if k¹t_f > 180 then
    if k¹t_f < -180 then
      k¹t_f := -180;


  if Self.obrót_k¹t_zablokowany_strza³_od[ indeks_f ] >= Self.obrót_k¹t_zablokowany_strza³_do[ indeks_f ] then
    begin

      // Zablokowany zakres k¹ta strza³u nie przechodzi przez œrodek rufy.

      if    ( k¹t_f <= Self.obrót_k¹t_zablokowany_strza³_od[ indeks_f ] )
        and ( k¹t_f >= Self.obrót_k¹t_zablokowany_strza³_do[ indeks_f ] ) then
        Result := true;

    end
  else//if Self.obrót_k¹t_zablokowany_strza³_od[ indeks_f ] >= Self.obrót_k¹t_zablokowany_strza³_do[ indeks_f ] then
    begin

      // Zablokowany zakres k¹ta strza³u przechodzi przez œrodek rufy.

      if   ( k¹t_f <= Self.obrót_k¹t_zablokowany_strza³_od[ indeks_f ] )
        or ( k¹t_f >= Self.obrót_k¹t_zablokowany_strza³_do[ indeks_f ] ) then
        Result := true;

    end;
  //---//if Self.obrót_k¹t_zablokowany_strza³_od[ indeks_f ] >= Self.obrót_k¹t_zablokowany_strza³_do[ i ] then

end;//---//Funkcja Obrót_K¹t_Zablokowany_Strza³u_SprawdŸ().

//Funkcja Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj().
procedure TTorpedy_Wyrzutnia.Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( const celownik_linia_widocznoœæ_f : boolean = true );
begin

  //
  // Funkcja ustawia obrót linii celowniczej nieruchomej na podstawie linii celowniczej faluj¹cej.
  //

  // Pomija wspó³rzêdna uniesienia kierunku (tylko obrót).
  //Self.celownik_linia_bez_falowania.AbsoluteDirection := Self.celownik_linia.AbsoluteDirection;
  //Self.celownik_linia_bez_falowania.Direction.Y := 0;
  Self.celownik_linia_bez_falowania.AbsoluteDirection := GLVectorGeometry.VectorMake( Self.celownik_linia.AbsoluteDirection.X, 0, Self.celownik_linia.AbsoluteDirection.Z );


  if    ( Self.amunicja_rodzaj = ar_Torpeda )
    and ( Self.celownik_linia.Tag = 1 ) then
    begin

      Self.celownik_linia.Visible := false;
      Self.celownik_linia_bez_falowania.Visible := ( not Self.celownik_linia.Visible ) and celownik_linia_widocznoœæ_f;

    end;
  //---//if    ( Self.amunicja_rodzaj = ar_Torpeda ) (...)

end;//---//Funkcja Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj().

//Funkcja Parametry_Odczytaj().
function TTorpedy_Wyrzutnia.Parametry_Odczytaj( const odstêp_f : string; const dane_wszystkie_f : boolean = false ) : string;
var
  i : integer;
begin

  //
  // Funkcja wypisuje dane (parametry).
  //
  // Zwraca napis z danymi (parametrami).
  //
  // Parametry:
  //   odstêp_f
  //   dane_wszystkie_f:
  //     false - wypisuje tylko dane podstawowe.
  //     true - wypisujewszystkie dane.
  //

  Result :=
    #13 + #10 + odstêp_f + 'lufy iloœæ: ' + Trim(   FormatFloat(  '### ### ##0', Length( Self.lufy_t )  )   ) +
    #13 + #10 + odstêp_f + 'obrót_k¹t_zablokowany_do: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.obrót_k¹t_zablokowany_do )  ) +
    #13 + #10 + odstêp_f + 'obrót_k¹t_zablokowany_od: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.obrót_k¹t_zablokowany_od )  ) +
    #13 + #10 + odstêp_f + 'obrót_szybkoœæ: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.obrót_szybkoœæ )  ) +
    #13 + #10 + odstêp_f + 'obra¿enia_zadawane: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.obra¿enia_zadawane )  ) +
    #13 + #10 + odstêp_f + 'zasiêg: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.zasiêg )  ) +
    #13 + #10 + odstêp_f + 'amunicja_iloœæ: ' + Trim(  FormatFloat( '### ### ##0', Self.amunicja_iloœæ )  ) +
    #13 + #10 + odstêp_f + 'prze³adowanie_czas_milisekundy: ' + Trim(  FormatFloat( '### ### ##0', Self.prze³adowanie_czas_milisekundy )  );


  for i := 0 to Length( Self.obrót_k¹t_zablokowany_strza³_do ) - 1 do
    Result := Result +
      #13 + #10 + odstêp_f + odstêp_f + 'obrót_k¹t_zablokowany_strza³_do ' + Trim(  FormatFloat( '### ### ##0', i + 1 )  ) + ': ' + Trim(  FormatFloat( '### ### ##0.0000', Self.obrót_k¹t_zablokowany_strza³_do[ i ] )  );
            
  for i := 0 to Length( Self.obrót_k¹t_zablokowany_strza³_od ) - 1 do
    Result := Result +
      #13 + #10 + odstêp_f + odstêp_f + 'obrót_k¹t_zablokowany_strza³_od ' + Trim(  FormatFloat( '### ### ##0', i + 1 )  ) + ': ' + Trim(  FormatFloat( '### ### ##0.0000', Self.obrót_k¹t_zablokowany_strza³_od[ i ] )  );

      
  if dane_wszystkie_f then  
    for i := 0 to Length( Self.lufy_t ) - 1 do
      Result := Result +
        #13 + #10 + odstêp_f + odstêp_f + 'prze³adowanie_czas_milisekundy lufa ' + Trim(  FormatFloat( '### ### ##0', i + 1 )  ) + ': ' + Trim(  FormatFloat( '### ### ##0', Self.lufy_t[ i ].prze³adowanie_czas_milisekundy )  );
      
end;//---//Funkcja Parametry_Odczytaj().
{$endregion 'TTorpedy_Wyrzutnia.'}


{$region 'TDzia³o.'}
//Konstruktor klasy TDzia³o.
constructor TDzia³o.Create( AOwner : TGLBaseSceneObject; AStatek : TStatek; gl_collision_mmanager_f : TGLCollisionManager; const lufy_iloœæ_f : integer; const lufy_podniesienie_k¹t_f : real );
var
  i : integer;
  ztr : real;
begin

  inherited Create( AOwner, AStatek, gl_collision_mmanager_f, lufy_iloœæ_f );

  //Self.czy_lufa_podnoszona := true;

//  Self.obrót_k¹t_maksymalny := 0;
//  Self.obrót_k¹t_minimalny := 0;
//  Self.obrót_procent := 0;
  Self.obrót_szybkoœæ := 0.75;
//  Self.obrót_zadany_procent := 0;

  Self.cofanie_wystrza³_odleg³oœæ := 0;
  Self.cofanie_wystrza³_pozycja_pocz¹tkowa := 0;

  Self.podniesienie_k¹t_maksymalny := 20; // 20
  Self.podniesienie_k¹t_minimalny := -10; // -10 //???
  Self.podniesienie_k¹t_zadany := 0; // -(minus) w dó³, +(plus) w górê.
  Self.podniesienie_k¹t_zadany_bezwzglêdny := 0;
  Self.podniesienie_szybkoœæ := 0.1; // 0.1 //???

  Self.amunicja_iloœæ := 1500;
  Self.obra¿enia_zadawane := 1;
  Self.prze³adowanie_czas_milisekundy := 1000; // 7000 //???
  Self.strza³_od_blokada_milisekundy := 250;
  Self.zasiêg := 4; // 12 20

  Self.amunicja_rodzaj := ar_Pocisk;

  Self.czy_lot_parabol¹ := false;

//  Self.Parent := AStatek;
//  Self.MoveUp();
//  Self.TurnAngle := 0;
//  Self.Direction.SetVector( 0, 0, -1 );
//  Self.Position.SetPoint( 0, 1, 1 );

  //Self.VisibleAtRunTime := true;

//  Self.podstawa := TGLCylinder.Create( Self );
//  Self.podstawa.Parent := Self;
//  Self.podstawa.TopRadius := 0.25;
//  Self.podstawa.BottomRadius := Self.podstawa.TopRadius;
//  Self.podstawa.Height := 0.1;
//  Self.podstawa.Position.Y := -( Self.CubeSize / 2 ) + Self.podstawa.Height / 2;


  Self.korpus.CubeHeight := Self.podstawa.TopRadius;
  //Self.korpus.Position.Y := -( Self.CubeSize * 0.5 ) + Self.podstawa.Height * 2;
  Self.korpus.Position.Y := Self.podstawa.Position.Y + Self.podstawa.Height * 0.5 + Self.korpus.CubeHeight * 0.5;
  //Self.korpus.Visible := false; //???

  TTorpedy_Wyrzutnia(Self).korpus_przód.Visible := false;

  Self.korpus_przód := TGLCube.Create( Self );
  Self.korpus_przód.Parent := Self.elementy_wizualne_dummy;
  Self.korpus_przód.CubeDepth := Self.podstawa.TopRadius;
  Self.korpus_przód.CubeHeight := Self.podstawa.TopRadius;
  Self.korpus_przód.CubeWidth := Self.korpus.CubeWidth;
  Self.korpus_przód.PitchAngle := 45;
  Self.korpus_przód.Position.Y := Self.korpus.Position.Y;
  Self.korpus_przód.Position.Z := -Self.korpus.CubeDepth + Self.korpus_przód.CubeDepth;
  //Self.korpus_przód.Visible := false; //???

  Self.k¹t_test.Position.Y := Self.korpus_przód.Position.Y; // Dok³adniej celuje w punkt.


  //if Length( Self.lufy_t ) > 0 then
  //  ztr := Self.korpus.CubeWidth / Length( lufy_t ) // Iloœæ miejsca na lufê.
  //else//if Length( Self.lufy_t ) > 0 then
  //  ztr := 0;

  for i := 0 to Length( Self.lufy_t ) - 1 do
    begin

      Self.lufy_t[ i ].Position.Y := Self.korpus_przód.Position.Y;
      //Self.lufy_t[ i ].Position.X := i * ztr - Self.korpus.CubeWidth * 0.5 + ztr * 0.5 ; // Przesuniêcie o pó³ szerokoœci korpusu, wyœrodkowanie na obszarze dla lufy.
      Self.lufy_t[ i ].Position.Z := Self.korpus_przód.Position.Z;
      Self.lufy_t[ i ].korpus.TopRadius := 0.05;
      Self.lufy_t[ i ].korpus.BottomRadius := Self.lufy_t[ i ].korpus.TopRadius;

      if Self is TArtyleria then
        Self.lufy_t[ i ].korpus.Height := 1.2
      else//if Self is TArtyleria then
        Self.lufy_t[ i ].korpus.Height := 0.6;

      Self.lufy_t[ i ].korpus.Position.Z := -Self.lufy_t[ i ].korpus.Height * 0.5;
      Self.lufy_t[ i ].Dodatkowe_Elementy_Lufy_Pozycja_Ustaw();

      ztr := lufy_podniesienie_k¹t_f

    end;
  //---//for i := 0 to Length( Self.lufy_t ) - 1 do


  if Length( Self.lufy_t ) > 0 then
    begin

      Self.cofanie_wystrza³_odleg³oœæ := Self.lufy_t[ 0 ].korpus.Height * 0.25;
      Self.cofanie_wystrza³_pozycja_pocz¹tkowa := Self.lufy_t[ 0 ].korpus.Position.Z;

    end;
  //---//if Length( Self.lufy_t ) > 0 then


  Self.celownik_linia.Nodes[ 1 ].Z := -Self.zasiêg; // Zasiêg dzia³a. Aktualizacja wartoœci.


  // Linia celownicza z wysokoœci luf.
  Self.celownik_linia.Position.Y := Self.podstawa.Height + Self.korpus.CubeHeight * 0.5; // Y - w po³owie wysokoœci korpusu.
  Self.celownik_linia.Position.Z := Self.korpus_przód.Position.Z; // Z - przesuniête na œrodek przodu korpusu.
  Self.celownik_linia.Nodes[ 0 ].Z := 0; // Zawsze zaczyna siê od korpusu dzia³a.
  Self.celownik_linia_bez_falowania.Nodes[ 0 ].Z := Self.celownik_linia.Nodes[ 0 ].Z;


  if gl_collision_mmanager_f <> nil then
    with TGLBCollision.Create( Self.korpus_przód.Behaviours ) do
      begin

        GroupIndex := 0;
        BoundingMode := cbmCube;
        Manager := gl_collision_mmanager_f;

      end;
    //---//with TGLBCollision.Create( Self.korpus_przód.Behaviours ) do

end;//---//Konstruktor klasy TDzia³o.

//Destruktor klasy TDzia³o.
destructor TDzia³o.Destroy();
begin

  FreeAndNil( Self.podstawa );
  FreeAndNil( Self.korpus );
  FreeAndNil( Self.korpus_przód );

  inherited;

end;//---//Destruktor klasy TDzia³o.

//Funkcja Podniesienie_Zadane_Zmieñ().
procedure TDzia³o.Podniesienie_Zadane_Zmieñ( const celownik_linia_widocznoœæ_f : boolean = true );
var
  k¹t_zakres_l,
  podniesienie_procent_l,
  odleg³oœæ_do_celu_l,
  ztr
    : real;
  zt_vector : GLVectorGeometry.TVector; // uses GLVectorGeometry.
  celowanie_tryb_l : TCelowanie_Tryb;
begin

  //
  // Funkcja ustawia zadany k¹t podniesienia na k¹t, w którym parzy kamera (w p³aszczyŸnie pionowej).
  // Od -90 (dó³) 0 (poziomo) 90 (góra).
  //

  // Self.podniesienie_k¹t_zadany; -(minus) w dó³, +(plus) w górê

  // Statki_Form.Gra_GLCamera.AbsoluteDirection.Y: -(minus) w dó³, +(plus) w górê

  //Self.podniesienie_k¹t_zadany := Statki_Form.Gra_GLCamera.AbsoluteDirection.Y * 90;

  if Self.Parent = nil then
    Exit;

  // Namierzanie wed³ug linii celowniczej statku.

  Self.k¹t_test.Up.SetVector( 0, 1, 0 ); // Je¿eli k¹t testowy jest u¿ywany do wyliczania podniesienia mo¿e go obróciæ.
  //Self.k¹t_test.Position := TTorpedy_Wyrzutnia(Self).celownik_linia.Position;


  odleg³oœæ_do_celu_l := Self.DistanceTo(  Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector )  );


  if Self.amunicja_rodzaj = ar_Artyleria then
    begin

      if odleg³oœæ_do_celu_l > TArtyleria(Self).zasiêg_od_parabola then
        celowanie_tryb_l := ct_Odleg³oœæ
      else//if odleg³oœæ_do_celu_l > TArtyleria(Self).zasiêg_od_parabola then
        celowanie_tryb_l := celowanie_tryb_g;

    end
  else//if Self.amunicja_rodzaj = ar_Artyleria then
    celowanie_tryb_l := celowanie_tryb_g;


  case celowanie_tryb_l of
      ct_Linia :
        begin

          // Namierzanie równoleg³e do linii celowania.

                         // Cel                 Obiekt celuj¹cy
          zt_vector.X := Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector ).X - Self.k¹t_test.AbsolutePosition.X;
          zt_vector.Y := Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Y - Self.k¹t_test.AbsolutePosition.Y;
          zt_vector.Z := Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Z - Self.k¹t_test.AbsolutePosition.Z;
          Self.k¹t_test.AbsoluteDirection := zt_vector;

          Self.podniesienie_k¹t_zadany := Self.k¹t_test.AbsoluteDirection.Y * 90;

        end;
      //---//ct_Linia :

      ct_Odleg³oœæ :
        begin

          // Wyznaczanie zadanego k¹ta wed³ug zasiêgu odleg³oœci namiaru.

          k¹t_zakres_l := Self.podniesienie_k¹t_maksymalny - Self.podniesienie_k¹t_minimalny; // Gdy k¹t maksymalny jest dodatni a minimalny mo¿e byæ ujemny.

          if k¹t_zakres_l = 0 then
            Exit;

          //odleg³oœæ_do_celu_l := Self.DistanceTo(  Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector )  );

          if odleg³oœæ_do_celu_l > Self.zasiêg then
            odleg³oœæ_do_celu_l := Self.zasiêg
          else
          if odleg³oœæ_do_celu_l < 0 then
            odleg³oœæ_do_celu_l := 0;


          podniesienie_procent_l := 100 * odleg³oœæ_do_celu_l / Self.zasiêg;

          Self.podniesienie_k¹t_zadany := k¹t_zakres_l * podniesienie_procent_l * 0.01 + Self.podniesienie_k¹t_minimalny;

          //Statki_Form.Caption := FloatToStr( Self.podniesienie_k¹t_zadany );
          //Statki_Form.Caption := FloatToStr( odleg³oœæ_do_celu_l ) + ' ' + FloatToStr( Self.podniesienie_k¹t_zadany );

          //Self.obrót_kierunek_zadany.X := Self.statek.celownicza_linia.Nodes[ 1 ].X;
          //Self.obrót_kierunek_zadany.Z := Self.statek.celownicza_linia.Nodes[ 1 ].Z;

        end;
      //---//ct_Odleg³oœæ :

      else//case celowanie_tryb_l of
        begin

          // Namierzanie zbie¿ne do punktu celowania.

          zt_vector.X := Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector ).X - Self.k¹t_test.AbsolutePosition.X;
          zt_vector.Y := Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Y - Self.k¹t_test.AbsolutePosition.Y;
          zt_vector.Z := Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Z - Self.k¹t_test.AbsolutePosition.Z;
          Self.k¹t_test.AbsoluteDirection := zt_vector;

          GLVectorGeometry.SetVector( zt_vector, 0, 0, 0 ); // Najlepiej sprawdzaæ k¹t w punkcie zero.

          // Sprawdza k¹t miêdzy kierunkiem zadanym a kierunkiem dzia³a.
          ztr := 180 -
            RadToDeg(
                AngleBetweenVectors(
                   Self.k¹t_test.AbsoluteDirection,
                   Self.AbsoluteDirection,
                   zt_vector
                 )
              );

          if Self.k¹t_test.AbsolutePosition.Y >= Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Y then
            Self.podniesienie_k¹t_zadany := -ztr
          else//if Self.k¹t_test.AbsolutePosition.Y >= Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Y then
            Self.podniesienie_k¹t_zadany := ztr;

        end;
      //---//case celowanie_tryb_l of
    end;
  //---//case celowanie_tryb_l of

  Self.podniesienie_k¹t_zadany_bezwzglêdny := Self.podniesienie_k¹t_zadany;

  if Self.podniesienie_k¹t_zadany > Self.podniesienie_k¹t_maksymalny then
    Self.podniesienie_k¹t_zadany := Self.podniesienie_k¹t_maksymalny
  else//if Self.podniesienie_k¹t_zadany > Self.podniesienie_k¹t_maksymalny then
  if Self.podniesienie_k¹t_zadany < Self.podniesienie_k¹t_minimalny then
    Self.podniesienie_k¹t_zadany := Self.podniesienie_k¹t_minimalny;


  Self.Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( celownik_linia_widocznoœæ_f );

  //Statki_Form.Caption := FloatToStr( podniesienie_k¹t_zadany );

end;//---//Funkcja Podniesienie_Zadane_Zmieñ().

//Funkcja Podniesienie_Kierunek_Zmieñ().
procedure TDzia³o.Podniesienie_Kierunek_Zmieñ( const celowanie_precyzja_podniesienie_f : real );

  //Funkcja Podniesienie_Kierunek_Zmieñ_Lufa() w Podniesienie_Kierunek_Zmieñ().
  function Podniesienie_Kierunek_Zmieñ_Lufa( lufa_f : TLufa ) : real;
  var
    ztr_l,
    k¹t_1,
    k¹t_podniesienia_aktualny_l,
    podniesienie_k¹t_zadany_odleg³oœæ_procent_l, // Okreœla jaki procent precyzji celowania stanowi aktualna ró¿nica k¹ta zadanego wzglêdem k¹ta wycelowania (wartoœæ ograniczana do zakresu 0 - 100).
    podniesienie_szybkoœæ_l
      : real;
  begin

    //
    // Funkcja modyfikuje podniesienie.
    //
    //  Zmiana podniesienia odbywa siê zawsze pe³n¹ moc¹ i liniowo.
    //
    // Zwraca wartoœæ szerokoœci linii celowania odzwierciedlaj¹c¹ precyzjê wycelowania podniesienia lufy.
    //
    //

    //lufa_f.PitchAngle  -(minus) w górê, +(plus) w dó³.

    //lufa_f.AbsoluteDirection.Z: -(minus) w dó³, +(plus) w górê

    ////if lufa_f.AbsoluteDirection.Z >= 0 then
    //if lufa_f.Direction.Z >= 0 then // Wariant, w którym lufa by³a samodzielnym cylindrem (bez obiektu dummy).
    //  k¹t_podniesienia_aktualny_l := -Abs( lufa_f.PitchAngle )
    //else//if lufa_f.AbsoluteDirection.Z >= 0 then
    //  k¹t_podniesienia_aktualny_l := Abs( lufa_f.PitchAngle );

    k¹t_podniesienia_aktualny_l := -lufa_f.PitchAngle;
    k¹t_1 := Abs( k¹t_podniesienia_aktualny_l - Self.podniesienie_k¹t_zadany );


    if celowanie_precyzja_podniesienie_f <> 0 then
      podniesienie_k¹t_zadany_odleg³oœæ_procent_l := Abs( k¹t_podniesienia_aktualny_l - Self.podniesienie_k¹t_zadany_bezwzglêdny ) * 100 / celowanie_precyzja_podniesienie_f
    else//if celowanie_precyzja_podniesienie_f <> 0 then
      podniesienie_k¹t_zadany_odleg³oœæ_procent_l := 100;


    if podniesienie_k¹t_zadany_odleg³oœæ_procent_l > 100 then
      podniesienie_k¹t_zadany_odleg³oœæ_procent_l := 100
    else//if podniesienie_k¹t_zadany_odleg³oœæ_procent_l > 100 then
    if podniesienie_k¹t_zadany_odleg³oœæ_procent_l < 0 then
      podniesienie_k¹t_zadany_odleg³oœæ_procent_l := 0;

    podniesienie_szybkoœæ_l := Self.podniesienie_szybkoœæ * podniesienie_k¹t_zadany_odleg³oœæ_procent_l * 0.01; // Im bli¿ej zadanego k¹ta wycelowana tym wolniej zmienia podniesienie luf ale z wiêksz¹ precyzj¹.


    //Statki_Form.Caption := FloatToStr( lufa_f.PitchAngle ) + ' ' + FloatToStr( lufa_f.AbsoluteDirection.Z ) + ' ' + FloatToStr( k¹t_podniesienia_aktualny_l );
    //Statki_Form.Caption := FloatToStr( k¹t_podniesienia_aktualny_l );
    //Statki_Form.Caption := FloatToStr( k¹t_podniesienia_aktualny_l ) + ' ' + FloatToStr( Abs( k¹t_podniesienia_aktualny_l - Self.podniesienie_k¹t_zadany ) );


    //if k¹t_1 < podniesienie_szybkoœæ_l then // Coœ jest nie tak z ustawianiem k¹tów ale podnoszenie dzia³a.
    //    begin
    //
    //      lufa_f.PitchAngle := -Self.podniesienie_k¹t_zadany;
    //
    //    end
    //else//if k¹t_1 > podniesienie_szybkoœæ_l then
    //if Abs( k¹t_podniesienia_aktualny_l - Self.podniesienie_k¹t_zadany ) > podniesienie_szybkoœæ_l then
    if k¹t_1 > podniesienie_szybkoœæ_l * Statki_Form.gra_wspó³czynnik_prêdkoœci_g then
      begin

        //lufa_f.czy_wycelowane_podniesienie := false;

        // Je¿eli k¹t jest mniejszy ni¿ zadana precyzja celowania, przyjmuje siê, ¿e lufa jest podniesiona w kierunku celu.
        if k¹t_1 < celowanie_precyzja_podniesienie_f then
          lufa_f.czy_wycelowane_podniesienie := true
        else//if k¹t_1 < celowanie_precyzja_podniesienie_f then
          lufa_f.czy_wycelowane_podniesienie := false;


        // Powy¿ej pewnej prêdkoœci gry nie mo¿e ustawiæ w³aœciwego k¹ta (za szybko zmienia k¹t i obraca lufami dooko³a).
        ztr_l := ( podniesienie_szybkoœæ_l * Statki_Form.gra_wspó³czynnik_prêdkoœci_g + lufa_f.podniesienie_szybkoœæ_modyfikator * Statki_Form.gra_wspó³czynnik_prêdkoœci_g );

        if ztr_l > 10 then
          ztr_l := 10;


        if k¹t_podniesienia_aktualny_l < Self.podniesienie_k¹t_zadany then
          begin

            // Góra.
            //lufa_f.Pitch(  -( podniesienie_szybkoœæ_l + lufa_f.podniesienie_szybkoœæ_modyfikator )  );
            lufa_f.PitchAngle := lufa_f.PitchAngle - ztr_l;

          end
        else//if k¹t_podniesienia_aktualny_l < Self.podniesienie_k¹t_zadany then
          begin

            // Dó³.
            //lufa_f.Pitch(  podniesienie_szybkoœæ_l + lufa_f.podniesienie_szybkoœæ_modyfikator );
            lufa_f.PitchAngle := lufa_f.PitchAngle + ztr_l;

          end;
        //---//if k¹t_podniesienia_aktualny_l < Self.podniesienie_k¹t_zadany then

      end
    else//if k¹t_1 > podniesienie_szybkoœæ_l * Statki_Form.gra_wspó³czynnik_prêdkoœci_g then
      lufa_f.czy_wycelowane_podniesienie := true;


    if lufa_f.czy_wycelowane_podniesienie then
      begin

        if celowanie_precyzja_podniesienie_f <> 0 then
          Result := podniesienie_k¹t_zadany_odleg³oœæ_procent_l
        else//if celowanie_precyzja_podniesienie_f <> 0 then
          Result := 0;

        // Gruboœæ linii jest odwrotna do procenta (im mniejszy procent tym linia grubsza).
        Result := celownik_linia_szerokoœæ_maksymalna__podniesienie_c * ( 100 - Result ) * 0.01;

      end
    else//if lufa_f.czy_wycelowane_podniesienie then
      Result := 0;

  end;//---//Funkcja Podniesienie_Kierunek_Zmieñ_Lufa() w Podniesienie_Kierunek_Zmieñ().

var
  i : integer;
  ztr : real;
  przynajmniej_jedna_lufa_wycelowa³a : boolean;
begin//Funkcja Podniesienie_Kierunek_Zmieñ().

  //
  // Funkcja modyfikuje podniesienie.
  //
  //  Zmiana podniesienia odbywa siê zawsze pe³n¹ moc¹ i liniowo.
  //

  //if MilliSecondsBetween( Now(), Self.strza³_czas ) <= Self.strza³_od_blokada_milisekundy then
  if Czas_Miêdzy_W_Milisekundach( Self.strza³_czas_i ) <= Self.strza³_od_blokada_milisekundy then
      begin

      // Sygnalizuje, ¿e dzia³o jest w trakcie strza³u i nie obraca siê.

      Self.celownik_linia.LineColor.Color := GLColor.clrGray50;
      Self.celownik_linia_bez_falowania.LineColor.Color := Self.celownik_linia.LineColor.Color;
      Exit;

    end;
  //---//if Czas_Miêdzy_W_Milisekundach( Self.strza³_czas_i ) <= Self.strza³_od_blokada_milisekundy then


  ztr := 0;
  przynajmniej_jedna_lufa_wycelowa³a := false;

  for i := 0 to Length( Self.lufy_t ) - 1 do
    begin

      ztr := ztr +
        Podniesienie_Kierunek_Zmieñ_Lufa( Self.lufy_t[ i ] );

      if    ( not przynajmniej_jedna_lufa_wycelowa³a )
        and ( Self.lufy_t[ i ].czy_wycelowane_podniesienie ) then
        przynajmniej_jedna_lufa_wycelowa³a := true;

    end;
  //---//for i := 0 to Length( lufy_t ) - 1 do


  // Œrednia arytmetyczna z wycelowania podniesienia wszystkich luf broni.
  if Length( Self.lufy_t ) > 0 then
    ztr := ztr / Length( Self.lufy_t );

  Self.celownik_linia.LineWidth := Self.celownik_linia_szerokoœæ_obrót + ztr;


  // Je¿eli przynajmniej jedna lufa osi¹gnê³a wymagany do strza³u k¹t to linia jest ci¹g³a.
  if not przynajmniej_jedna_lufa_wycelowa³a then
    Self.celownik_linia.LinePattern := $CCCC // Punktowana.
  else//if not przynajmniej_jedna_lufa_wycelowa³a then
    Self.celownik_linia.LinePattern := $FFFF; // Ci¹g³a.

  Self.celownik_linia_bez_falowania.LinePattern := Self.celownik_linia.LinePattern;
  Self.celownik_linia_bez_falowania.LineWidth := Self.celownik_linia.LineWidth;


  //if    ( Self.amunicja_rodzaj in [ ar_Pocisk ] )
  //  and ( Length( Self.lufy_t ) > 0 ) then
  //  Self.celownik_linia.PitchAngle := -Self.lufy_t[ 0 ].PitchAngle;

  if    ( Self.amunicja_rodzaj in [ ar_Artyleria, ar_Pocisk ] )
    and ( Length( Self.lufy_t ) > 0 ) then
    begin

      if Self.amunicja_rodzaj in [ ar_Pocisk ] then
        Self.celownik_linia.PitchAngle := Self.lufy_t[ 0 ].PitchAngle
      else//if Self.amunicja_rodzaj in [ ar_Pocisk ] then
        begin

          // Gdy lot pocisku jest liniowy lina celownicza wskazuje cel, gdy jest paraboliczny linia celownicza jest pozioma i wskazuje zasiêg.

          if Self.DistanceTo(  Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector )  ) > TArtyleria(Self).zasiêg_od_parabola then
            begin

              Self.celownik_linia.PitchAngle := 0;
              Self.czy_lot_parabol¹ := true;

            end
          else//if Self.DistanceTo(  Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector )  ) > TArtyleria(Self).zasiêg_od_parabola then
            begin

              Self.celownik_linia.PitchAngle := Self.lufy_t[ 0 ].PitchAngle;
              Self.czy_lot_parabol¹ := false;

            end
          //---//if Self.DistanceTo(  Self.statek.celownicza_linia.LocalToAbsolute( Self.statek.celownicza_linia.Nodes[ 1 ].AsAffineVector )  ) > TArtyleria(Self).zasiêg_od_parabola then

        end;
      //---//if Self.amunicja_rodzaj in [ ar_Pocisk ] then

    end;
  //---//if    ( Self.amunicja_rodzaj in [ ar_Artyleria, ar_Pocisk ] ) (..)

end;//---//Funkcja Podniesienie_Kierunek_Zmieñ().

//Funkcja Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj().
procedure TDzia³o.Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( const celownik_linia_widocznoœæ_f : boolean = true );
begin

  //
  // Funkcja ustawia k¹t podniesienia linii celowniczej nieruchomej na podstawie linii celowniczej faluj¹cej.
  //

  if not Self.czy_lot_parabol¹ then
    Self.celownik_linia_bez_falowania.Direction.Y := Self.celownik_linia.AbsoluteDirection.Y
    //Self.celownik_linia_bez_falowania.AbsoluteDirection := Self.celownik_linia.AbsoluteDirection
  else//if not Self.czy_lot_parabol¹ then
    Self.celownik_linia_bez_falowania.Direction.Y := 0; // Je¿eli nie obraca dzia³ linia siê nie wypoziomuje.


  if Self.celownik_linia.Tag = 1 then
    begin

      Self.celownik_linia.Visible := ( not Self.czy_lot_parabol¹ ) and celownik_linia_widocznoœæ_f;
      Self.celownik_linia_bez_falowania.Visible := ( not Self.celownik_linia.Visible ) and celownik_linia_widocznoœæ_f;

    end;
  //---//if Self.celownik_linia.Tag = 1 then

end;//---//Funkcja Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj().

//Funkcja Parametry_Odczytaj().
function TDzia³o.Parametry_Odczytaj( const odstêp_f : string; const dane_wszystkie_f : boolean = false ) : string;
begin

  //
  // Funkcja wypisuje dane (parametry).
  //
  // Zwraca napis z danymi (parametrami).
  //
  // Parametry:
  //   odstêp_f
  //   dane_wszystkie_f:
  //     false - wypisuje tylko dane podstawowe.
  //     true - wypisujewszystkie dane.
  //

  Result :=
    TTorpedy_Wyrzutnia(Self).Parametry_Odczytaj( odstêp_f ) +
    #13 + #10 + odstêp_f + 'podniesienie_k¹t_maksymalny: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.podniesienie_k¹t_maksymalny )  ) +
    #13 + #10 + odstêp_f + 'podniesienie_k¹t_minimalny: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.podniesienie_k¹t_minimalny )  ) +
    #13 + #10 + odstêp_f + 'podniesienie_szybkoœæ: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.podniesienie_szybkoœæ )  );
    
end;//---//Funkcja Parametry_Odczytaj().
{$endregion 'TDzia³o.'}


{$region 'TArtyleria.'}
//Konstruktor klasy TArtyleria.
constructor TArtyleria.Create( AOwner : TGLBaseSceneObject; AStatek : TStatek; gl_collision_mmanager_f : TGLCollisionManager; const lufy_iloœæ_f : integer; const lufy_podniesienie_k¹t_f : real );
begin

  inherited Create( AOwner, AStatek, gl_collision_mmanager_f, lufy_iloœæ_f, lufy_podniesienie_k¹t_f );


//  Self.obrót_k¹t_maksymalny := 0;
//  Self.obrót_k¹t_minimalny := 0;
//  Self.obrót_procent := 0;
  Self.obrót_szybkoœæ := 0.05; // 0.05
//  Self.obrót_zadany_procent := 0;

  Self.podniesienie_k¹t_maksymalny := 60; // 60 // Dla k¹ta innego ni¿ 60 maksymalny zasiêg pocisk osi¹ga na dnie.
  Self.podniesienie_k¹t_minimalny := -10;
  Self.podniesienie_k¹t_zadany := 0;
  Self.podniesienie_k¹t_zadany_bezwzglêdny := 0;
  Self.podniesienie_szybkoœæ := 0.01; // 0.01 //???

  Self.amunicja_iloœæ := 1500;
  Self.obra¿enia_zadawane := 1;
  Self.prze³adowanie_czas_milisekundy := 3000; // 7000 //???
  Self.strza³_od_blokada_milisekundy := 500;
  Self.zasiêg := 32; // 12 20
  Self.zasiêg_od_parabola := Self.zasiêg * 0.3; // 30 procent ca³kowitego zasiêgu.

  Self.amunicja_rodzaj := ar_Artyleria;

  Self.celownik_linia.Nodes[ 1 ].Z := -Self.zasiêg; // Zasiêg dzia³a. Aktualizacja wartoœci.
  Self.celownik_linia_bez_falowania.Nodes[ 1 ].Z := Self.celownik_linia.Nodes[ 1 ].Z;

end;//---//Konstruktor klasy TArtyleria.

//Funkcja Parametry_Odczytaj().
function TArtyleria.Parametry_Odczytaj( const odstêp_f : string; const dane_wszystkie_f : boolean = false ) : string;
begin

  //
  // Funkcja wypisuje dane (parametry).
  //
  // Zwraca napis z danymi (parametrami).
  //
  // Parametry:
  //   odstêp_f
  //   dane_wszystkie_f:
  //     false - wypisuje tylko dane podstawowe.
  //     true - wypisujewszystkie dane.
  //

  Result :=
    TDzia³o(Self).Parametry_Odczytaj( odstêp_f ) +
        #13 + #10 + odstêp_f + 'zasiêg_od_parabola: ' + Trim(  FormatFloat( '### ### ##0.0000', Self.zasiêg_od_parabola )  );
    
end;//---//Funkcja Parametry_Odczytaj().
{$endregion 'TArtyleria.'}


{$region 'TAmunicja.'}
//Konstruktor klasy TAmunicja.
constructor TAmunicja.Create( AOwner : TGLBaseSceneObject; ALufa : TLufa; const obracaj_dzia³a_f : boolean; cel_wspó³rzêdne_f : TAffineVector; gl_collision_mmanager_f : TGLCollisionManager );

  //Funkcja Równanie_Paraboli_3_Punkty() w Konstruktor klasy TAmunicja.
  function Równanie_Paraboli_3_Punkty( x1, y1, x2, y2, x3, y3 : real; var a, b, c : real ) : boolean;
  var
    sx1,
    sx2,
    sx3
      : real;
  begin

    Exit; // Obliczenia dla lotu parabol¹ - wersja 1. Nieu¿ywane.

    //
    // Funkcja wylicza parametry równania paraboli przechodz¹cej przez 3 punkty.
    //
    // Zwraca prawdê gdy nie napotkano b³êdów podczas wyliczania parametrów równania paraboli przechodz¹cej przez 3 punkty.
    //
    // y = a * x^2 + b * x + c
    //
    // P1( -4, 1 ), P2( -3, -2 ), P3( 1, -2 ) // P( x, y )
    //
    // 16a - 4b + c = 1 // x1^2 * a + x1 * b + c = y1
    // 9a - 3b + c = 2 // x2^2 * a + x2 * b + c = y2
    // a + b + c = -2 // x3^2 * a + x3 * b + c = y3
    //
    // y = 3/5*x^2 + 6/5*x - 19/5
    // y = 0.6 * x^2 + 1.2 * x - 3.8
    //

    Result := false;

    sx1 := Sqr( x1 );
    sx2 := Sqr( x2 );
    sx3 := Sqr( x3 );

    if   (  ( x2 - x1 ) * ( x1 - x3 ) = 0  ) // Z równania na a.
      or (  ( x2 - x1 ) * ( x1 - x3 ) = 0  )
      or (  ( sx3 - sx1 ) - ( sx1 - sx2 ) / ( x2 - x1 ) * ( x1 - x3 ) = 0  )
      or (  x2 - x1 = 0  ) then // Z równania na b.
      Exit;

    //if    (  ( x2 - x1 ) * ( x1 - x3 ) <> 0  )
    //  and (  ( x2 - x1 ) * ( x1 - x3 )  <> 0  )
    //  and (  ( sx3 - sx1 ) - ( sx1 - sx2 ) / ( x2 - x1 ) * ( x1 - x3 ) <> 0  ) then
      a := (  ( y2 - y1  ) / ( x2 - x1 ) * ( x1 - x3 ) - y1 + y3  ) / (  ( sx3 - sx1 ) - ( sx1 - sx2 ) / ( x2 - x1 ) * ( x1 - x3 )  );

    //if x2 - x1 <> 0 then
      b := (  a * ( sx1 - sx2 ) + y2 - y1  ) / ( x2 - x1 );

    c := y1 - a * sx1 - b * x1;


    Result := true;

    //Statki_Form.Caption := FloatToStr( a ) + ' ' + FloatToStr( b ) + ' ' + FloatToStr( c );

    {
    c := y1 - Sqr( x1 ) * a - x1 * b;
    b := ( y2 - Sqr( x2 ) * a - c ) / x2;
    a := ( y3 - x3 * b - c ) / Sqr( x3 );

    sx1 := Sqr( x1 );
    sx2 := Sqr( x2 );
    sx3 := Sqr( x3 );

    c := y1 - a * sx1 - b * x1;
    b := ( y2 - a * sx2 - c ) / x2;
    a := ( y3 - b * x3 - c ) / sx3;

    // Z c do b.
    b * x2 := y2 - a * sx2 - c;
    b * x2 := y2 - a * sx2 - y1 + a * sx1 + b * x1;
    b * x2 - b * x1 := a * sx1 - a * sx2 + y2 - y1;
    b * ( x2 - x1 ) := a * ( sx1 - sx2 ) + y2 - y1;
    b := (  a * ( sx1 - sx2 ) + y2 - y1  ) / ( x2 - x1 );

    // Z c do a
    a * sx3 := y3 - b * x3 - c;
    a * sx3 := y3 - b * x3 - y1 + a * sx1 + b * x1;
    a * sx3 - a * sx1 := b * x1 - b * x3 - y1 + y3;
    a * ( sx3 - sx1 ) := b * ( x1 - x3 ) - y1 + y3;

    // Z b do a (po c)
    a * ( sx3 - sx1 ) := b * ( x1 - x3 ) - y1 + y3;
    a * ( sx3 - sx1 ) := (  a * ( sx1 - sx2 ) + y2 - y1  ) / ( x2 - x1 ) * ( x1 - x3 ) - y1 + y3;

    a * ( sx3 - sx1 ) := a * ( sx1 - sx2 ) / ( x2 - x1 ) * ( x1 - x3 ) + ( y2 - y1  ) / ( x2 - x1 ) * ( x1 - x3 ) - y1 + y3;
    a * ( sx3 - sx1 ) - a * ( sx1 - sx2 ) / ( x2 - x1 ) * ( x1 - x3 ) := ( y2 - y1  ) / ( x2 - x1 ) * ( x1 - x3 ) - y1 + y3;
    a * (  ( sx3 - sx1 ) - ( sx1 - sx2 ) / ( x2 - x1 ) * ( x1 - x3 )  ) := ( y2 - y1  ) / ( x2 - x1 ) * ( x1 - x3 ) - y1 + y3;
    a := (  ( y2 - y1  ) / ( x2 - x1 ) * ( x1 - x3 ) - y1 + y3  ) / (  ( sx3 - sx1 ) - ( sx1 - sx2 ) / ( x2 - x1 ) * ( x1 - x3 )  );
    }

  end;//---//Funkcja Równanie_Paraboli_3_Punkty() w Konstruktor klasy TAmunicja.

var
  ztr,
  cel_oddalenie_l
    : real;
  //czy_lot_parabol¹_l : boolean;
begin//Konstruktor klasy TAmunicja.

  inherited Create( AOwner ); // Nie mo¿e byæ ALufa gdy¿ po zwolnieniu statku pojawiaj¹ siê b³êdy dostêpu je¿eli amunicja wystrzelona z tego statku nadal jest na scenie.


  Self.id_statek := ALufa.statek.id_statek;
  Self.statek := ALufa.statek;

  inc( id_amunicja_g ); // Po osi¹gniêciu maksymalnej wartoœci powinno ustawiæ siê na wartoœæ minimaln¹ (bez b³êdów).
  Self.id_amunicja := id_amunicja_g; //DateTimeToUnix( Now() );

  Self.cel_odleg³oœæ := ALufa.wylot_pozycja.DistanceTo( cel_wspó³rzêdne_f ); //ALufa.DistanceTo( cel_wspó³rzêdne_f )
  //Self.dzia³o_podniesienie_k¹t_maksymalny := TDzia³o(ALufa.dzia³o).podniesienie_k¹t_maksymalny;

  if TDzia³o(ALufa.dzia³o).podniesienie_k¹t_maksymalny <> TDzia³o(ALufa.dzia³o).podniesienie_k¹t_minimalny then
    Self.dzia³o_podniesienie_procent_k¹ta_maksymalnego := ( TDzia³o(ALufa.dzia³o).podniesienie_k¹t_zadany - TDzia³o(ALufa.dzia³o).podniesienie_k¹t_minimalny ) * 100 / ( TDzia³o(ALufa.dzia³o).podniesienie_k¹t_maksymalny - TDzia³o(ALufa.dzia³o).podniesienie_k¹t_minimalny )
  else//if TDzia³o(ALufa.dzia³o).podniesienie_k¹t_maksymalny <> TDzia³o(ALufa.dzia³o).podniesienie_k¹t_minimalny then
    Self.dzia³o_podniesienie_procent_k¹ta_maksymalnego := 100;

  //Statki_Form.Caption := FloatToStr( Self.dzia³o_podniesienie_procent_k¹ta_maksymalnego ); //???

  Self.obra¿enia_zadawane_wspó³czynnik := 1;
  Self.obra¿enia_zadawane_wspó³czynnik_zmodyfikowany := Self.obra¿enia_zadawane_wspó³czynnik;
  //Self.parabola_k¹t_lotu_pocz¹tkowy := 0;
  //Self.parabola_k¹t_lotu_wspó³czynnik := 0;
  Self.prêdkoœæ := amunicja_prêdkoœæ_c;
  Self.prêdkoœæ_opadania := 0; // 0.0035
  Self.prêdkoœæ_opadania_wspó³czynnik := 0.0003;
  Self.strza³_od_blokada_dystans := 250;
  Self.statek_prêdkoœæ := 0;
  //Self.zanurzenie_g³êbokoœæ_po_wpadniêciu_do_wody := -5;
  Self.zanurzenie_g³êbokoœæ_zadana := -0.3; // -0.25

  Self.czy_efekt_wpadniêcia_do_wody := false;
  Self.czy_lot_parabol¹ := false;
  Self.czy_poza_luf¹ := false;
  Self.czy_uzbrojona := false;

  Self.pozycja_celu := TGLSphere.Create( Self );
  Self.pozycja_celu.Parent := AOwner; // Aby pozycja startowa siê nie przesuwa³a.
  Self.pozycja_celu.Pickable := false;
  Self.pozycja_celu.Radius := 0.15;
  Self.pozycja_celu.Visible := false;
  Self.pozycja_celu.AbsolutePosition := ALufa.wylot_pozycja.AbsolutePosition;

  Self.pozycja_woda := TGLSphere.Create( Self );
  Self.pozycja_woda.Parent := AOwner; // Aby pozycja startowa siê nie przesuwa³a.
  Self.pozycja_woda.Pickable := false;
  Self.pozycja_woda.Radius := 0.15;
  Self.pozycja_woda.Visible := false; //???
  Self.pozycja_woda.AbsolutePosition := ALufa.wylot_pozycja.AbsolutePosition;

  Self.Tag := 0;


  if ALufa.HasParent then
    begin

      Self.skala := TTorpedy_Wyrzutnia(ALufa.dzia³o.elementy_wizualne_dummy).Scale.X; // Przy za³o¿eniu, ¿e skalowanie jest proporcjonalne.

      Self.amunicja_rodzaj := TTorpedy_Wyrzutnia(ALufa.dzia³o).amunicja_rodzaj;
      Self.obra¿enia_zadawane := TTorpedy_Wyrzutnia(ALufa.dzia³o).obra¿enia_zadawane;
      Self.zasiêg := TTorpedy_Wyrzutnia(ALufa.dzia³o).zasiêg;

      if ALufa.dzia³o is TArtyleria then
        begin

          Self.czy_lot_parabol¹ := TDzia³o(ALufa.dzia³o).czy_lot_parabol¹;

          if Self.czy_lot_parabol¹ then
            begin

              // Przy aktualnym podniesieniu lufy strza³ bêdzie oddany na procent zasiêgu.
              if    ( TDzia³o(ALufa.dzia³o).podniesienie_k¹t_maksymalny <> TDzia³o(ALufa.dzia³o).podniesienie_k¹t_minimalny )
                and (  Abs( TDzia³o(ALufa.dzia³o).podniesienie_k¹t_maksymalny - TDzia³o(ALufa.dzia³o).podniesienie_k¹t_minimalny ) <> 0  ) then
                ztr := // Procent uniesienia lufy.
                    100
                  //* ( -TDzia³o(ALufa.dzia³o).podniesienie_k¹t_minimalny + ALufa.PitchAngle )
                  * ( -TDzia³o(ALufa.dzia³o).podniesienie_k¹t_minimalny - ALufa.PitchAngle ) // Aktualny k¹t uniesienia lufy przesuniêty aby k¹t minimalny wynosi³ 0 (minus, gdy¿ tutaj podniesienie w górê ma wartoœci ujemne).
                  / (  Abs( TDzia³o(ALufa.dzia³o).podniesienie_k¹t_maksymalny - TDzia³o(ALufa.dzia³o).podniesienie_k¹t_minimalny )  ) // Zakres podnoszenia lufy.
              else//if    ( TDzia³o(ALufa.dzia³o).podniesienie_k¹t_maksymalny <> TDzia³o(ALufa.dzia³o).podniesienie_k¹t_minimalny ) (...)
                ztr := 100;

              Self.cel_odleg³oœæ := Self.zasiêg * ztr * 0.01;


              // Inicjuje pocz¹tkow¹ pozycjê wskaŸnika celu do wyliczenia pozycji celu przy opuszczaniu lufy przez amunicjê.
              //Self.pozycja_celu.Visible := true; //???
              Self.pozycja_celu.Material.FrontProperties.Emission.Color := clrGreen;
              //Self.pozycja_celu.AbsolutePosition := TDzia³o(ALufa.dzia³o).AbsolutePosition;

              Self.pozycja_celu.Parent := ALufa.dzia³o;
              Self.pozycja_celu.Position := ALufa.Position;
              Self.pozycja_celu.Position.Z := 0;

              Self.dzia³o_pozycja_absolutna_vector := Self.pozycja_celu.AbsolutePosition; // Lepiej chyba tak.

              Self.pozycja_celu.Parent := AOwner;
              Self.pozycja_celu.AbsolutePosition := Self.dzia³o_pozycja_absolutna_vector;
              //---// Inicjuje pocz¹tkow¹ pozycjê wskaŸnika celu do wyliczenia pozycji celu przy opuszczaniu lufy przez amunicjê.


              //Self.dzia³o_pozycja_absolutna_vector := TDzia³o(ALufa.dzia³o).AbsolutePosition;

              Self.pozycja_woda.Position.Y := Self.dzia³o_pozycja_absolutna_vector.Y;

            end;
          //---//if Self.czy_lot_parabol¹ then

          {$region 'Obliczenia dla lotu parabol¹ - wersja 1.'}
          //Self.zasiêg_od_parabola := TArtyleria(ALufa.dzia³o).zasiêg_od_parabola;
          //
          //czy_lot_parabol¹_l := false;
          //
          //if obracaj_dzia³a_f then // Przy zablokowanym obrocie dzia³ wyliczanie paraboli odbywa³o siê zawsze do aktualnej pozycji celu.
          //  begin
          //
          //    //cel_oddalenie_l := TDzia³o(ALufa.dzia³o).korpus.DistanceTo( cel_wspó³rzêdne_f )
          //    //cel_oddalenie_l := ALufa.DistanceTo( cel_wspó³rzêdne_f );
          //
          //    if ALufa.DistanceTo( cel_wspó³rzêdne_f ) > Self.zasiêg_od_parabola then
          //      czy_lot_parabol¹_l := true;
          //
          //  end
          //else//if obracaj_dzia³a_f then
          //  begin
          //
          //    czy_lot_parabol¹_l := true;
          //
          //    //// Przy aktualnym podniesieniu lufy strza³ bêdzie oddany na procent zasiêgu.
          //    //if TDzia³o(ALufa.dzia³o).podniesienie_k¹t_maksymalny <> TDzia³o(ALufa.dzia³o).podniesienie_k¹t_minimalny then
          //    //  cel_oddalenie_l := 100 * ALufa.PitchAngle / Abs( TDzia³o(ALufa.dzia³o).podniesienie_k¹t_maksymalny - TDzia³o(ALufa.dzia³o).podniesienie_k¹t_minimalny )
          //    //else//if TDzia³o(ALufa.dzia³o).podniesienie_k¹t_maksymalny <> TDzia³o(ALufa.dzia³o).podniesienie_k¹t_minimalny then
          //    //  cel_oddalenie_l := 0;
          //    //
          //    //cel_oddalenie_l := Self.zasiêg * cel_oddalenie_l / 100;
          //
          //    cel_wspó³rzêdne_f.Y := 0; // Aby pozycja celu nie zmienia³a parametrów.
          //
          //  end;
          ////---//if obracaj_dzia³a_f then
          //
          //// Trafia trochê za daleko.
          ////if cel_oddalenie_l > 1 then
          ////  cel_oddalenie_l := cel_oddalenie_l - 1;
          ////cel_oddalenie_l := cel_oddalenie_l - cel_oddalenie_l * 0.025;
          ////cel_wspó³rzêdne_f.Y := cel_wspó³rzêdne_f.Y - cel_wspó³rzêdne_f.Y * 0.1;
          //////w miarê dobrze //???
          //////      cel_oddalenie_l := cel_oddalenie_l - Self.zasiêg * 0.03; //0.05
          //////
          //////      if cel_oddalenie_l < 0 then
          //////        cel_oddalenie_l := 0;
          //
          //
          //
          ////if cel_oddalenie_l > Self.zasiêg_od_parabola then
          //if czy_lot_parabol¹_l then
          //  begin
          //
          //    // Ze wzglêdu na precyzjê k¹ta podniesienia dystans jest liczony wed³ug k¹ta lufy (inaczej od razu strzela na wskazany celem dystans).
          //    // Przy aktualnym podniesieniu lufy strza³ bêdzie oddany na procent zasiêgu.
          //    // Pociski mog¹ zalecieæ dalej ni¿ zasiêg w linii prostej gdy cel jest ponad wod¹ (y dodatni).
          //    // cel_oddalenie_l - tutaj tymczasowo jako procent wychylenia lufy.
          //    if TDzia³o(ALufa.dzia³o).podniesienie_k¹t_maksymalny <> 0 then
          //      //cel_oddalenie_l := 100 * ( -ALufa.PitchAngle ) / Abs( TDzia³o(ALufa.dzia³o).podniesienie_k¹t_maksymalny )
          //      cel_oddalenie_l := 100 * ( -ALufa.PitchAngle - TDzia³o(ALufa.dzia³o).podniesienie_k¹t_minimalny ) / Abs( TDzia³o(ALufa.dzia³o).podniesienie_k¹t_maksymalny - TDzia³o(ALufa.dzia³o).podniesienie_k¹t_minimalny ) // 100 * (k¹t aktualny - k¹t minimalny) / zakres k¹t
          //    else//if TDzia³o(ALufa.dzia³o).podniesienie_k¹t_maksymalny <> TDzia³o(ALufa.dzia³o).podniesienie_k¹t_minimalny then
          //      cel_oddalenie_l := 0;
          //
          //    //Statki_Form.Caption := FloatToStr( cel_oddalenie_l );
          //    cel_oddalenie_l := Self.zasiêg * cel_oddalenie_l * 0.01;
          //
          //
          //    Self.czy_lot_parabol¹ := true;
          //
          //
          //    if cel_oddalenie_l > Self.zasiêg then
          //      cel_oddalenie_l := Self.zasiêg;
          //
          //
          //    Self.parabola_k¹t_lotu_pocz¹tkowy := ALufa.PitchAngle;
          //
          //    if cel_oddalenie_l <> 0 then
          //      Self.parabola_k¹t_lotu_wspó³czynnik := Abs( 80 - ALufa.PitchAngle ) / cel_oddalenie_l; // 80 - k¹t do jakiego ma siê odchyliæ podczas opadania (w dó³ s¹ stopnie dodatnie).
          //    //Statki_Form.GLLines2.Nodes[ 1 ].Y := ALufa.wylot_pozycja.AbsolutePosition.Y;
          //
          //    ztr := ALufa.wylot_pozycja.AbsolutePosition.Y + cel_oddalenie_l * 0.4;
          //
          //    if ztr < cel_wspó³rzêdne_f.Y then // Gdy cel by³ wysoko parabola by³a wygiêta w dó³.
          //      ztr := ztr + cel_wspó³rzêdne_f.Y;
          //
          //    //Statki_Form.Caption := FloatToStr( cel_oddalenie_l );
          //
          //    if not Równanie_Paraboli_3_Punkty(
          //               0, ALufa.wylot_pozycja.AbsolutePosition.Y, // Punkt wylotu - wa¿na jest wysokoœæ (x dla paraboli to bêdzie przebyty dystans od dzia³a).
          //               cel_oddalenie_l * 0.5, ztr, // Punkt w trakcie lotu. //???
          //               cel_oddalenie_l, cel_wspó³rzêdne_f.Y, // Punkt celu (x dla paraboli to bêdzie dystans do celu).
          //               Self.parabola_równanie__a, Self.parabola_równanie__b, Self.parabola_równanie__c
          //             ) then
          //      begin
          //
          //        Self.parabola_k¹t_lotu_wspó³czynnik := 0;
          //        Self.czy_lot_parabol¹ := false;
          //        Self.parabola_równanie__a := 0;
          //        Self.parabola_równanie__b := 0;
          //        Self.parabola_równanie__c := 0;
          //
          //      end;
          //    //---//if not Równanie_Paraboli_3_Punkty( (...)
          //
          //  end;
          ////---//if czy_lot_parabol¹_l then
          {$endregion 'Obliczenia dla lotu parabol¹ - wersja 1.'}

        end;
      //---//if ALufa.dzia³o is TArtyleria then

    end
  else//if ALufa.HasParent then
    begin

      Self.amunicja_rodzaj := ar_Brak;
      Self.skala := 1;

    end;
  //---//if ALufa.HasParent then


  Self.prêdkoœæ := Self.prêdkoœæ / Self.skala; // Dzia³o mo¿e byæ skalowane. Koryguje wartoœæ o skalê dzia³a.


  //Self.statek_kierunek := 0;

  {$region 'Obliczenia dla lotu parabol¹ - wersja 1.'}
  //if not Self.czy_lot_parabol¹ then
  //  Self.prêdkoœæ_opadania_wspó³czynnik := 0.00003
  //else//if not Self.czy_lot_parabol¹ then
  //  Self.prêdkoœæ_opadania_wspó³czynnik := 0.003; // 0.003
  {$endregion 'Obliczenia dla lotu parabol¹ - wersja 1.'}

  Self.czy_pod_wod¹ := false;
  Self.czy_poza_zasiêgiem := false;
  //Self.czy_statek_dane := false;
  Self.czy_usun¹æ_amunicja := false;
  Self.czy_wynurzanie := false;


  Self.Parent := ALufa; //AOwner; // Rodzicem jest Gra_Obiekty_GLDummyCube aby kontener obiektu porusza³ siê po wspó³rzêdnych absolutnych sceny (nie lokalnych).
  //Self.Direction.AsAffineVector := TTorpedy_Wyrzutnia(ALufa.dzia³o).Direction.AsAffineVector;
  //Self.VisibleAtRunTime := true; //???
  //Self.ShowAxes := true; //???


  Self.korpus_opadanie_obrót_dummy := TGLDummyCube.Create( Self );
  Self.korpus_opadanie_obrót_dummy.Parent := Self;
  Self.korpus_opadanie_obrót_dummy.EdgeColor.Color := clrGreen;
  //Self.korpus_opadanie_obrót_dummy.VisibleAtRunTime := true; //???
  //Self.korpus_opadanie_obrót_dummy.ShowAxes := true; //???
  Self.korpus_opadanie_obrót_dummy.TagFloat := 1360;


  Self.korpus_ustawienie_pocz¹tkowe_dummy := TGLDummyCube.Create( Self );
  Self.korpus_ustawienie_pocz¹tkowe_dummy.Parent := Self.korpus_opadanie_obrót_dummy;
  Self.korpus_ustawienie_pocz¹tkowe_dummy.EdgeColor.Color := clrYellow;
  //Self.korpus_ustawienie_pocz¹tkowe_dummy.VisibleAtRunTime := true; //???
  //Self.korpus_ustawienie_pocz¹tkowe_dummy.ShowAxes := true; //???


  Self.torpeda_efekt_na_wodzie := TGLDummyCube.Create( Self );
  Self.torpeda_efekt_na_wodzie.Parent := nil;
  Self.torpeda_efekt_na_wodzie.EdgeColor.Color := clrRed;
  //Self.torpeda_efekt_na_wodzie.VisibleAtRunTime := true; //???
  //Self.torpeda_efekt_na_wodzie.ShowAxes := true; //???


  Self.korpus := TGLCylinder.Create( Self );
  Self.korpus.Parent := Self.korpus_ustawienie_pocz¹tkowe_dummy;


  if Self.amunicja_rodzaj in [ ar_Torpeda ] then
    begin

      Self.prêdkoœæ := Self.prêdkoœæ * 0.05; //???
      Self.prêdkoœæ_wytracanie_wspó³czynnik := Self.prêdkoœæ * 0.0005; //???


      Self.AbsolutePosition := ALufa.AbsolutePosition;
      Self.Position.Y := 0;

      //Self.strza³_od_blokada_dystans := Self.korpus.Height + Self.korpus.Height * 0.3; // Na pocz¹tku wykrywa dystans wiêkszy od d³ugoœci korpusu.
      Self.zanurzenie_g³êbokoœæ_po_wpadniêciu_do_wody := Self.korpus_opadanie_obrót_dummy.Position.Y * 0.5; // 0.25

      Self.korpus.Height := ALufa.korpus.Height - ALufa.korpus.Height * 0.1; // Tak samo wyliczyæ wskaŸnik uzbrojenia amunicji.


      Self.strza³_od_blokada_dystans := Self.korpus.Height - Self.korpus.Height * 0.3; // Na pocz¹tku wykrywa dystans wiêkszy od d³ugoœci korpusu.

    end
  else//if Self.amunicja_rodzaj in [ ar_Torpeda ] then
    if Self.amunicja_rodzaj in [ ar_Artyleria, ar_Pocisk ] then
      begin

        Self.prêdkoœæ_wytracanie_wspó³czynnik := Self.prêdkoœæ * 0.001; // 0.001

        Self.AbsolutePosition := ALufa.wylot_pozycja.AbsolutePosition;

        {$region 'Obliczenia dla lotu parabol¹ - wersja 1.'}
        //if Self.czy_lot_parabol¹ then // Je¿eli lot odbywa siê po paraboli to wysokoœæ modyfikuje siê ze wzoru (a nie z kierunku lotu).
        //  begin
        //
        //    Self.Direction.Y := 0;
        //    Self.korpus_opadanie_obrót_dummy.PitchAngle := -ALufa.PitchAngle;
        //
        //  end;
        ////---//if Self.czy_lot_parabol¹ then
        {$endregion 'Obliczenia dla lotu parabol¹ - wersja 1.'}


        if Self.amunicja_rodzaj in [ ar_Pocisk ] then
          begin

            Self.korpus.Height := ALufa.korpus.Height * 0.3;

          end
        else//if Self.amunicja_rodzaj in [ ar_Pocisk ] then
          Self.korpus.Height := ALufa.korpus.Height * 0.3;


        Self.strza³_od_blokada_dystans := Self.korpus.Height - Self.korpus.Height * 0.4;

      end;
    //---//if Self.amunicja_rodzaj in [ ar_Artyleria, ar_Pocisk ] then


  Self.prêdkoœæ_pocz¹tkowa := Self.prêdkoœæ;


  Self.strza³_od_blokada_dystans := Self.strza³_od_blokada_dystans * Self.skala; // Dzia³o mo¿e byæ skalowane. Koryguje wartoœæ o skalê dzia³a.


  Self.AbsoluteDirection := ALufa.AbsoluteDirection;
  Self.Direction.AsVector := GLVectorGeometry.VectorNegate( Self.Direction.AsVector ); // Lepiej dzia³a.
  Self.opadanie_obrót_korekta_o_k¹t_na_granicy_zasiêgu := 0;
  Self.opadanie_obrót_korekta_o_ustawienie_pocz¹tkowe := 0;

  Self.korpus.PitchAngle := 90; // 90


  //Self.korpus.TopRadius := ( ALufa.korpus.TopRadius - ALufa.korpus.TopRadius * 0.2 ) * skala_l;
  Self.korpus.TopRadius := ( ALufa.korpus.TopRadius - ALufa.korpus.TopRadius * 0.2 );
  Self.korpus.BottomRadius := Self.korpus.TopRadius;
  //Self.korpus.Height := 1.25;

//  Self.korpus.TopRadius := 0.05;
//  Self.korpus.BottomRadius := Self.korpus.TopRadius;
//  Self.korpus.Height := 1.25;

  Self.czubek := TGLCone.Create( Self );
  Self.czubek.Parent := Self.korpus.Parent;
  Self.czubek.BottomRadius := Self.korpus.TopRadius;
  Self.czubek.PitchAngle := -Self.korpus.PitchAngle;
  Self.czubek.Height := Self.czubek.BottomRadius;
  Self.czubek.Position.Z := ( Self.korpus.Height + Self.czubek.Height ) * 0.5;
  //Self.czubek.Position.Y := ( Self.korpus.Height + Self.czubek.Height ) * 0.5; //???


  Self.pozycja_startowa := TGLSphere.Create( Self ); //???
  Self.pozycja_startowa.Parent := Self.Parent; //Self.Parent AOwner; // Aby pozycja startowa siê nie przesuwa³a.
  Self.pozycja_startowa.Pickable := false;
  Self.pozycja_startowa.Radius := 0.15;
  Self.pozycja_startowa.Visible := false;
  Self.pozycja_startowa.AbsolutePosition := ALufa.wylot_pozycja.AbsolutePosition;
  //Self.pozycja_startowa.ShowAxes := true; //???


  // Dynamiczne dodanie zdarzenia kolizji.
  if gl_collision_mmanager_f <> nil then
    begin

      with TGLBCollision.Create( Self.korpus.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.korpus.Behaviours ) do

      with TGLBCollision.Create( Self.czubek.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.korpus.Behaviours ) do

    end;
  //---//if gl_collision_mmanager_f <> nil then

  //Self.pozycja_startowa.Position.Y := 0; // Zawsze poziom wody. // Zostanie zmodyfikowana po opuszczeniu amunicji z lufy.

  //Self.korpus.Position.Y := Self.korpus_przód.Position.Y + Self.korpus.TopRadius * 2;
  //Self.korpus.Position.AsAffineVector := Self.korpus.AbsoluteToLocal( ALufa.Position.AsAffineVector );
  //Self.korpus.AbsolutePosition := ALufa.AbsolutePosition;
  //Self.korpus.Position.Y := ALufa.AbsolutePosition.Y;


//  Self.pozycja_startowa.Position.X := 0;
//  Self.pozycja_startowa.Position.Z := 0;
//  //Self.pozycja_startowa.Position.Y := Self.pozycja_startowa.LocalToAbsolute( Self.pozycja_startowa.Position.AsAffineVector ).Y;
//  Self.pozycja_startowa.Position.Y := Self.pozycja_startowa.AbsoluteToLocal( Self.pozycja_startowa.Position.AsAffineVector ).Y;


  //Self.ShowAxes := true;
  //Self.korpus_opadanie_obrót_dummy.ShowAxes := true;
  //Self.korpus_ustawienie_pocz¹tkowe_dummy.ShowAxes := true;
  //Self.korpus.ShowAxes := true;

end;//---//Konstruktor klasy TAmunicja.

//Konstruktor klasy TAmunicja - tylko do wyœwietlenia.
constructor TAmunicja.Create( AObiekty_Wieloosobowe_Amunicja_r : TObiekty_Wieloosobowe__Amunicja_r; AOwner : TGLBaseSceneObject );
//constructor TAmunicja.Create( AAmunicja : TAmunicja );
begin

  //
  // Konstruktor utworzy kopiê obiektu amunicja w zakresie wystarczaj¹cym tylko do wyœwietlenia.
  //

  inherited Create( AOwner );


  Self.id_amunicja := AObiekty_Wieloosobowe_Amunicja_r.id_wieloosobowe_amunicja;
  Self.id_statek := AObiekty_Wieloosobowe_Amunicja_r.id_statek;
  Self.statek := nil;

  Self.cel_odleg³oœæ := 0;
  //Self.dzia³o_podniesienie_k¹t_maksymalny := 0;
  Self.dzia³o_podniesienie_procent_k¹ta_maksymalnego := 100;
  Self.obra¿enia_zadawane_wspó³czynnik := 1;
  Self.obra¿enia_zadawane_wspó³czynnik_zmodyfikowany := Self.obra¿enia_zadawane_wspó³czynnik;
  Self.opadanie_obrót_korekta_o_k¹t_na_granicy_zasiêgu := 0;
  Self.opadanie_obrót_korekta_o_ustawienie_pocz¹tkowe := 0;
  //Self.parabola_k¹t_lotu_pocz¹tkowy := 0;
  //Self.parabola_k¹t_lotu_wspó³czynnik := 0;
  Self.prêdkoœæ := 0.01;
  Self.prêdkoœæ_opadania := 0;
  Self.prêdkoœæ_opadania_wspó³czynnik := 0;
  Self.prêdkoœæ_pocz¹tkowa := Self.prêdkoœæ;
  Self.prêdkoœæ_wytracanie_wspó³czynnik := 0;
  Self.skala := 1;
  Self.statek_prêdkoœæ := 0;
  Self.zanurzenie_g³êbokoœæ_po_wpadniêciu_do_wody := -5;
  Self.zanurzenie_g³êbokoœæ_zadana := 0;

  Self.czy_efekt_wpadniêcia_do_wody := false;
  Self.czy_lot_parabol¹ := false;

  Self.amunicja_rodzaj := AObiekty_Wieloosobowe_Amunicja_r.amunicja_rodzaj;

  Self.czy_pod_wod¹ := false;
  Self.czy_poza_luf¹ := false;
  Self.czy_poza_zasiêgiem := false;
  //Self.czy_statek_dane := false;
  Self.czy_usun¹æ_amunicja := false;
  Self.czy_uzbrojona := false;
  Self.czy_wynurzanie := false;

  Self.strza³_od_blokada_dystans := 0;


  Self.Parent := AOwner; // Rodzicem jest scena aby kontener obiektu porusza³ siê po wspó³rzêdnych absolutnych sceny (nie lokalnych).
  //Self.Direction.AsAffineVector := TTorpedy_Wyrzutnia(ALufa.dzia³o).Direction.AsAffineVector;
  //Self.VisibleAtRunTime := true; //???
  Self.AbsolutePosition := AObiekty_Wieloosobowe_Amunicja_r.pozycja; //???AAmunicja.AbsolutePosition;
  Self.Direction.AsVector := AObiekty_Wieloosobowe_Amunicja_r.kierunek; //???AAmunicja.AbsoluteDirection;


  Self.korpus_opadanie_obrót_dummy := TGLDummyCube.Create( Self );
  Self.korpus_opadanie_obrót_dummy.Parent := Self;
  Self.korpus_opadanie_obrót_dummy.EdgeColor.Color := clrGreen;
  //Self.korpus_opadanie_obrót_dummy.VisibleAtRunTime := true; //???


  Self.korpus_ustawienie_pocz¹tkowe_dummy := TGLDummyCube.Create( Self );
  Self.korpus_ustawienie_pocz¹tkowe_dummy.Parent := AOwner;
  Self.korpus_ustawienie_pocz¹tkowe_dummy.EdgeColor.Color := clrYellow;
  //Self.korpus_ustawienie_pocz¹tkowe_dummy.VisibleAtRunTime := true; //???


  Self.torpeda_efekt_na_wodzie := TGLDummyCube.Create( Self );
  Self.torpeda_efekt_na_wodzie.Parent := nil;
  Self.torpeda_efekt_na_wodzie.EdgeColor.Color := clrRed;
  //Self.torpeda_efekt_na_wodzie.VisibleAtRunTime := true; //???
  //Self.torpeda_efekt_na_wodzie.ShowAxes := true; //???


  // Elementy wizualne s¹ potomkami Self.korpus_ustawienie_pocz¹tkowe_dummy i ustawiane s¹ wed³ug jego pozycji i kierunku.
  Self.korpus := TGLCylinder.Create( Self );
  Self.korpus.Parent := Self.korpus_ustawienie_pocz¹tkowe_dummy;
  Self.korpus.Height := AObiekty_Wieloosobowe_Amunicja_r.korpus__Height;

  Self.korpus.PitchAngle := 90;

  Self.korpus.TopRadius := AObiekty_Wieloosobowe_Amunicja_r.korpus__TopRadius; //???AAmunicja.korpus.TopRadius;
  Self.korpus.BottomRadius := AObiekty_Wieloosobowe_Amunicja_r.korpus__BottomRadius; //???AAmunicja.korpus.BottomRadius;

  Self.czubek := TGLCone.Create( Self );
  Self.czubek.Parent := Self.korpus.Parent;
  Self.czubek.BottomRadius := Self.korpus.TopRadius;
  Self.czubek.PitchAngle := -Self.korpus.PitchAngle;
  Self.czubek.Height := Self.czubek.BottomRadius;
  Self.czubek.Position.Z := ( Self.korpus.Height + Self.czubek.Height ) * 0.5 ;

  Self.pozycja_celu := TGLSphere.Create( Self );
  Self.pozycja_celu.Parent := AOwner; // Aby pozycja startowa siê nie przesuwa³a.
  Self.pozycja_celu.Pickable := false;
  Self.pozycja_celu.Radius := 0.15;
  Self.pozycja_celu.Visible := false;
  Self.pozycja_celu.Position.SetPoint( 0, 0, 0 );

  if AObiekty_Wieloosobowe_Amunicja_r.czy_lot_parabol¹ then
    Self.pozycja_celu.Material.FrontProperties.Emission.Color := clrGreen;


  Self.pozycja_startowa := TGLSphere.Create( Self );
  Self.pozycja_startowa.Parent := AOwner; // Aby pozycja startowa siê nie przesuwa³a.
  Self.pozycja_startowa.Pickable := false;
  Self.pozycja_startowa.Radius := 0.15;
  Self.pozycja_startowa.Visible := false;
  Self.pozycja_startowa.Position.SetPoint( 0, 0, 0 ); //???AAmunicja.pozycja_startowa.Position.AsVector;

  Self.pozycja_woda := TGLSphere.Create( Self );
  Self.pozycja_woda.Parent := AOwner; // Aby pozycja startowa siê nie przesuwa³a.
  Self.pozycja_woda.Pickable := false;
  Self.pozycja_woda.Radius := 0.15;
  Self.pozycja_woda.Visible := false;
  Self.pozycja_woda.Position.SetPoint( 0, 0, 0 );

end;//---//Konstruktor klasy TAmunicja - tylko do wyœwietlenia.

//Destruktor klasy TAmunicja.
destructor TAmunicja.Destroy();
begin

  FreeAndNil( Self.czubek );
  FreeAndNil( Self.korpus );
  FreeAndNil( Self.korpus_ustawienie_pocz¹tkowe_dummy );
  FreeAndNil( Self.korpus_opadanie_obrót_dummy );
  FreeAndNil( Self.torpeda_efekt_na_wodzie );
  FreeAndNil( Self.pozycja_celu );
  FreeAndNil( Self.pozycja_startowa );
  FreeAndNil( Self.pozycja_woda );

  inherited;

end;//---//Destruktor klasy TAmunicja.
{$endregion 'TAmunicja.'}


{$region 'TSter.'}
//Konstruktor klasy TSter.
constructor TSter.Create( AOwner : TGLBaseSceneObject; gl_collision_mmanager_f : TGLCollisionManager; x_f, y_f, z_f : real );
begin

  inherited Create( AOwner );

  Self.Parent := AOwner;
  //???Self.ster_dummy.Position.Z := -Self.kad³ub.CubeWidth * 0.5;
  //Self.ster_dummy.VisibleAtRunTime := true; //???

  Self.ster := TGLCube.Create( AOwner );
  Self.ster.Parent := Self;
  Self.ster.CubeWidth := 0.05;
  Self.ster.CubeDepth := 1;
  //Self.ster.TurnAngle := 90;
  Self.ster.Position.Z := -Self.ster.CubeDepth * 0.5;
  Self.ster.Position.Y := -Self.ster.CubeHeight * 0.5;

  Self.ster_mocowanie := TGLCylinder.Create( AOwner );
  Self.ster_mocowanie.Parent := Self;
  Self.ster_mocowanie.TopRadius := Self.ster.CubeWidth;
  Self.ster_mocowanie.BottomRadius := Self.ster_mocowanie.TopRadius;
  Self.ster_mocowanie.Height := Self.ster.CubeDepth;
  Self.ster_mocowanie.Position.Y := Self.ster.Position.Y;


  if gl_collision_mmanager_f <> nil then
    begin

      with TGLBCollision.Create( Self.ster.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.ster.Behaviours ) do

      with TGLBCollision.Create( Self.ster_mocowanie.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.ster_mocowanie.Behaviours ) do

    end;
  //---//if gl_collision_mmanager_f <> nil then

end;//---//Konstruktor klasy TSter.

//Destruktor klasy TSter.
destructor TSter.Destroy();
begin

  FreeAndNil( Self.ster );
  FreeAndNil( Self.ster_mocowanie );

  inherited;

end;//---//Destruktor klasy TSter.
{$endregion 'TSter.'}


{$region 'TŒruba.'}
//Konstruktor klasy TŒruba.
constructor TŒruba.Create( AOwner : TGLBaseSceneObject; AStatek : TStatek; const czy_obrót_lewo_f : boolean; gl_collision_mmanager_f : TGLCollisionManager );
var
  i : integer;
  ztr : real;
begin

  inherited Create( AOwner );

  Self.statek := AStatek;
  

  Self.prêdkoœæ_obrotowa_aktualna_procent := 0;
  Self.prêdkoœæ_obrotowa_maksymalna := 24;
  Self.prêdkoœæ_obrotowa_przyspieszanie := Self.statek.prêdkoœæ_przyspieszanie * 2; // Dobraæ tak aby ruch œrub odpowiada³ przyœpieszeniu statku (statek zmienia kierunek ruchu, a œruby jeszcze nie wyhamowa³y).

  //Self.czy_obrót_lewo := false;
  //Self.czy_obrót_lewo := true; //???

  Self.czy_obrót_lewo := czy_obrót_lewo_f;


  Self.Parent := AOwner;
  //Self.TurnAngle := 0;
  //Self.Direction.SetVector( 0, 0, -1 );
  //Self.Position.SetPoint( 0, 1, 0 );
  //Self.VisibleAtRunTime := true; //???
  //Self.ShowAxes := true; //???


  Self.wa³ := TGLCylinder.Create( Self );
  Self.wa³.Parent := Self;
  Self.wa³.PitchAngle := 105;
  Self.wa³.TopRadius := 0.05;
  Self.wa³.BottomRadius := Self.wa³.TopRadius;
  Self.wa³.Height := 2;
  Self.wa³.Position.Y := 0.24;

  Self.wa³_³o¿ysko := TGLCylinder.Create( Self );
  Self.wa³_³o¿ysko.Parent := Self;
  Self.wa³_³o¿ysko.PitchAngle := 90;
  Self.wa³_³o¿ysko.TopRadius := Self.wa³.TopRadius * 2.5;
  Self.wa³_³o¿ysko.BottomRadius := Self.wa³_³o¿ysko.TopRadius;
  Self.wa³_³o¿ysko.Height := Self.wa³_³o¿ysko.TopRadius * 2;
  Self.wa³_³o¿ysko.Position.Z := -Self.wa³.Height * 0.5;

  Self.wa³_podpórka := TGLCylinder.Create( Self );
  Self.wa³_podpórka.Parent := Self;
  Self.wa³_podpórka.TopRadius := Self.wa³.TopRadius;
  Self.wa³_podpórka.BottomRadius := Self.wa³_podpórka.TopRadius;
  Self.wa³_podpórka.Height := 0.5;
  Self.wa³_podpórka.Position.Y := Self.wa³_podpórka.Height * 0.5;
  Self.wa³_podpórka.Position.Z := Self.wa³_³o¿ysko.Position.Z;

  Self.wa³_do_wirnika := TGLCylinder.Create( Self );
  Self.wa³_do_wirnika.Parent := Self;
  Self.wa³_do_wirnika.PitchAngle := 90;
  Self.wa³_do_wirnika.TopRadius := Self.wa³.TopRadius;
  Self.wa³_do_wirnika.BottomRadius := Self.wa³_do_wirnika.TopRadius;


  Self.wa³_mocowanie := TGLCylinder.Create( Self );
  Self.wa³_mocowanie.Parent := Self;
  Self.wa³_mocowanie.PitchAngle := 90;
  Self.wa³_mocowanie.TopRadius := Self.wa³.TopRadius * 2;
  Self.wa³_mocowanie.BottomRadius := Self.wa³.TopRadius;
  Self.wa³_mocowanie.Height := 0.2;
  Self.wa³_mocowanie.Position.Y := Self.wa³_podpórka.Height;
  Self.wa³_mocowanie.Position.Z := Self.wa³.Height * 0.5 + Self.wa³_mocowanie.Height * 0.3;
  //Self.wa³_mocowanie.Position.Y := 0.05;



  Self.obrót_dummy := TGLDummyCube.Create( Self );
  Self.obrót_dummy.Parent := Self;
  //Self.obrót_dummy.Position.Z := -Self.wa³.Height * 0.5;
  //Self.obrót_dummy.VisibleAtRunTime := true; //???
  //Self.obrót_dummy.ShowAxes := true; //???


  Self.wirnik_œrodek := TGLSphere.Create( Self );
  Self.wirnik_œrodek.Parent := Self.obrót_dummy;
  Self.wirnik_œrodek.Radius := Self.wa³.TopRadius * 3;
  //Self.wirnik_œrodek.Position.Z := -Self.wirnik_œrodek.Radius * 1.35;

  Self.wa³_do_wirnika.Height := Self.wa³_³o¿ysko.Height + Self.wirnik_œrodek.Radius;
  Self.wa³_do_wirnika.Position.Z := Self.wa³_³o¿ysko.Position.Z + Self.wa³_³o¿ysko.Height * 0.4 - Self.wa³_do_wirnika.Height * 0.5;
  //Self.wa³_do_wirnika.Position.Y := -0.15;


  Self.obrót_dummy.Position.Z := -Self.wa³.Height * 0.5 - Self.wa³_³o¿ysko.Height * 0.25 - Self.wirnik_œrodek.Radius * 1.35;


  SetLength( Self.wirnik_³opaty_t, 4 ); // Iloœæ ³opat wirnika.

  if Length( Self.wirnik_³opaty_t ) <> 0 then
    ztr := 360 / Length( Self.wirnik_³opaty_t )
  else//if Length( Self.wirnik_³opaty_t ) <> 0 then
    ztr := 180;

  for i := 0 to Length( Self.wirnik_³opaty_t ) - 1 do
    begin

      Self.wirnik_³opaty_t[ i ] := TGLCone.Create( Self );
      Self.wirnik_³opaty_t[ i ].Parent := Self.obrót_dummy;
      Self.wirnik_³opaty_t[ i ].BottomRadius := Self.wirnik_œrodek.Radius;
      //Self.wirnik_³opaty_t[ i ].ShowAxes := true;

      Self.wirnik_³opaty_t[ i ].PitchAngle := -90;

      Self.wirnik_³opaty_t[ i ].Height := Self.wirnik_œrodek.Radius;

      Self.wirnik_³opaty_t[ i ].Position.Y := Self.wirnik_œrodek.Radius + Self.wirnik_³opaty_t[ i ].BottomRadius * 0.5;

      Self.wirnik_³opaty_t[ i ].Position.AsVector :=
        GLVectorGeometry.MoveObjectAround(
          Self.wirnik_³opaty_t[ i ].Position.AsVector,
          GLVectorGeometry.VectorMake( 0, 0, 1 ),
          Self.wirnik_œrodek.Position.AsVector, 0, i * ztr );

      // Self.wirnik_³opaty_t[ i ].RollAngle := Self.wirnik_³opaty_t[ i ].RollAngle + i * 80 / 4;

      {$region 'K¹t ³opat wirnika.'}
      {$region '£opaty 4.'}
      if Length( Self.wirnik_³opaty_t ) = 4 then
        begin

          if i = 0 then
            begin

              if Self.czy_obrót_lewo then
                begin

                  // Lewo.

                  Self.wirnik_³opaty_t[ i ].PitchAngle := -90;
                  Self.wirnik_³opaty_t[ i ].RollAngle := 40;

                end
              else//if Self.czy_obrót_lewo then
                begin

                  // Prawo.

                  Self.wirnik_³opaty_t[ i ].PitchAngle := -90;
                  Self.wirnik_³opaty_t[ i ].RollAngle := -40;

                end;
              //---//if Self.czy_obrót_lewo then

            end
          else//
          if i = 1 then
            begin

              if Self.czy_obrót_lewo then
                begin

                  // Lewo.

                  Self.wirnik_³opaty_t[ i ].PitchAngle := -130;
                  Self.wirnik_³opaty_t[ i ].RollAngle := 0;

                end
              else//if Self.czy_obrót_lewo then
                begin

                  // Prawo.

                  Self.wirnik_³opaty_t[ i ].PitchAngle := -50;
                  Self.wirnik_³opaty_t[ i ].RollAngle := 0;

                end;
              //---//if Self.czy_obrót_lewo then

            end
          else//
          if i = 2 then
            begin

              if Self.czy_obrót_lewo then
                begin

                  // Lewo.

                  Self.wirnik_³opaty_t[ i ].PitchAngle := -90;
                  Self.wirnik_³opaty_t[ i ].RollAngle := -40;

                end
              else//if Self.czy_obrót_lewo then
                begin

                  // Prawo.

                  Self.wirnik_³opaty_t[ i ].PitchAngle := -90;
                  Self.wirnik_³opaty_t[ i ].RollAngle := 40;

                end;
              //---//if Self.czy_obrót_lewo then

            end
          else//
          if i = 3 then
            begin

              if Self.czy_obrót_lewo then
                begin

                  // Lewo.

                  Self.wirnik_³opaty_t[ i ].PitchAngle := -50;
                  Self.wirnik_³opaty_t[ i ].RollAngle := 0;

                end
              else//if Self.czy_obrót_lewo then
                begin

                  // Prawo.

                  Self.wirnik_³opaty_t[ i ].PitchAngle := -130;
                  Self.wirnik_³opaty_t[ i ].RollAngle := 0;

                end;
              //---//if Self.czy_obrót_lewo then

            end;

        end;
      //---//if Length( Self.wirnik_³opaty_t ) = 4 then
      {$endregion '£opaty 4.'}
      {$endregion 'K¹t ³opat wirnika.'}

    end;
  //---//for i := 0 to Length( Self.wirnik_³opaty_t ) - 1 do


  if gl_collision_mmanager_f <> nil then
    begin

      with TGLBCollision.Create( Self.wa³.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.wa³.Behaviours ) do

      with TGLBCollision.Create( Self.wa³_³o¿ysko.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.wa³_³o¿ysko.Behaviours ) do

      with TGLBCollision.Create( Self.wa³_mocowanie.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.wa³_mocowanie.Behaviours ) do

      with TGLBCollision.Create( Self.wa³_podpórka.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.wa³_podpórka.Behaviours ) do

      with TGLBCollision.Create( Self.wa³_do_wirnika.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.wa³_do_wirnika.Behaviours ) do

      with TGLBCollision.Create( Self.wirnik_œrodek.Behaviours ) do
        begin

          GroupIndex := 0;
          BoundingMode := cbmCube;
          Manager := gl_collision_mmanager_f;

        end;
      //---//with TGLBCollision.Create( Self.wirnik_œrodek.Behaviours ) do


      for i := 0 to Length( Self.wirnik_³opaty_t ) - 1 do
        with TGLBCollision.Create( Self.wirnik_³opaty_t[ i ].Behaviours ) do
          begin

            GroupIndex := 0;
            BoundingMode := cbmCube;
            Manager := gl_collision_mmanager_f;

          end;
        //---//with TGLBCollision.Create( Self.wirnik_³opaty_t[ i ].Behaviours ) do

    end;
  //---//if gl_collision_mmanager_f <> nil then

end;//---//Konstruktor klasy TŒruba.

//Destruktor klasy TŒruba.
destructor TŒruba.Destroy();
var
  i : integer;
begin

  FreeAndNil( Self.wa³ );
  FreeAndNil( Self.wa³_³o¿ysko );
  FreeAndNil( Self.wa³_mocowanie );
  FreeAndNil( Self.wa³_podpórka );
  FreeAndNil( Self.wa³_do_wirnika );

  FreeAndNil( Self.wirnik_œrodek );


  for i := 0 to Length( Self.wirnik_³opaty_t ) - 1 do
    FreeAndNil( Self.wirnik_³opaty_t[ i ] );

  SetLength( Self.wirnik_³opaty_t, 0 );


  FreeAndNil( Self.obrót_dummy );

  inherited;

end;//---//Destruktor klasy TŒruba.

//Funkcja Œruba_Obracaj().
procedure TŒruba.Œruba_Obracaj();
begin

  if    (  Abs( Self.prêdkoœæ_obrotowa_aktualna_procent - Self.statek.prêdkoœæ_zadana_procent ) < Self.prêdkoœæ_obrotowa_przyspieszanie * Statki_Form.gra_wspó³czynnik_prêdkoœci_g  )
    and (
                   ( Self.prêdkoœæ_obrotowa_aktualna_procent >= 0 )
               and ( Self.statek.prêdkoœæ_zadana_procent >= 0 )    
          or (
                   ( Self.prêdkoœæ_obrotowa_aktualna_procent <= 0 )
               and ( Self.statek.prêdkoœæ_zadana_procent <= 0 )
             )
        ) then
    Self.prêdkoœæ_obrotowa_aktualna_procent := Self.statek.prêdkoœæ_zadana_procent
  else
  if Self.prêdkoœæ_obrotowa_aktualna_procent < ( Self.statek.prêdkoœæ_zadana_procent - Self.prêdkoœæ_obrotowa_przyspieszanie ) then
    Self.prêdkoœæ_obrotowa_aktualna_procent := Self.prêdkoœæ_obrotowa_aktualna_procent + Self.prêdkoœæ_obrotowa_przyspieszanie * Statki_Form.gra_wspó³czynnik_prêdkoœci_g
  else
  if Self.prêdkoœæ_obrotowa_aktualna_procent > ( Self.statek.prêdkoœæ_zadana_procent - Self.prêdkoœæ_obrotowa_przyspieszanie ) then
    Self.prêdkoœæ_obrotowa_aktualna_procent := Self.prêdkoœæ_obrotowa_aktualna_procent - Self.prêdkoœæ_obrotowa_przyspieszanie * Statki_Form.gra_wspó³czynnik_prêdkoœci_g;


  if Self.czy_obrót_lewo then
    Self.obrót_dummy.RollAngle := Self.obrót_dummy.RollAngle - Self.prêdkoœæ_obrotowa_aktualna_procent * Self.prêdkoœæ_obrotowa_maksymalna * 0.01 * Statki_Form.gra_wspó³czynnik_prêdkoœci_g // Lewo.
  else
    Self.obrót_dummy.RollAngle := Self.obrót_dummy.RollAngle + Self.prêdkoœæ_obrotowa_aktualna_procent * Self.prêdkoœæ_obrotowa_maksymalna * 0.01 * Statki_Form.gra_wspó³czynnik_prêdkoœci_g;

end;//---//Funkcja Œruba_Obracaj().
{$endregion 'TŒruba.'}


{$region 'TTrafienia_Efekt.'}
//Konstruktor klasy TTrafienia_Efekt.
//constructor TTrafienia_Efekt.Create( AOwner : TGLBaseSceneObject; gl_fire_fx_manager_f : TGLFireFXManager; x_f, y_f, z_f : real );
//constructor TTrafienia_Efekt.Create( AOwner : TGLBaseSceneObject; gl_cadence_able_component_f : TGLCadenceAbleComponent; x_f, y_f, z_f : real; gl_cadencer__current_time_f : double; amunicja_f : TAmunicja );
constructor TTrafienia_Efekt.Create( AOwner : TGLBaseSceneObject; x_f, y_f, z_f : real );
var
  zt_gl_base_scene_object : TGLBaseSceneObject;
begin

  //inherited Create( AOwner ); // Nie mo¿e byæ TStatek gdy¿ po zwolnieniu statku pojawiaj¹ siê b³êdy dostêpu je¿eli efekty umieszczone na tym statku nadal s¹ na scenie.

  if    ( AOwner is TStatek )
    and ( AOwner.HasParent ) then
    inherited Create( AOwner.Parent )
  else
    inherited Create( AOwner );

  Self.Parent := AOwner;
  //Self.VisibleAtRunTime := true;
  //Self.ShowAxes := true;
  Self.Position.SetPoint( x_f, y_f, z_f );

  Self.czas_trwania := Random( 10000 );
  Self.czas_utworzenia := Czas_Teraz();

  //Self.statek := AStatek; //???

  //Exit;
  //
  // Gdy elementy gry by³y tworzone bezpoœrednio na scenie jedne z nich przes³ania³y inne.
  //  Dzia³a gdy AOwner = Statki_Form.Gra_GLScene.Objects
  //
  //if   ( AOwner = nil )
  //  or (  not Assigned( AOwner )  ) then
  //  Exit;
  //
  //
  //// Aby efekt nie by³ przes³aniany przez inne obiekty.
  //zt_gl_base_scene_object := AOwner.FindChild( 'GLParticleFXRenderer1', true ); //??? Czy szukaæ po nazwie.
  //
  //if zt_gl_base_scene_object <> nil then
  //  zt_gl_base_scene_object.MoveLast();
  //
  //
  //// Aby efekt nie przes³ania³ napisów na ekranie.
  //zt_gl_base_scene_object := AOwner.FindChild( 'Informacje_G³ówne_GLHUDText', true ); //??? Czy szukaæ po nazwie.
  //
  //if zt_gl_base_scene_object <> nil then
  //  zt_gl_base_scene_object.MoveLast();

end;//---//Konstruktor klasy TTrafienia_Efekt.

//Destruktor klasy TTrafienia_Efekt.
destructor TTrafienia_Efekt.Destroy();
begin

  inherited;

end;//---//Destruktor klasy TTrafienia_Efekt.
{$endregion 'TTrafienia_Efekt.'}

{$region 'TInformacje_Dodatkowe.'}
//Konstruktor klasy TInformacje_Dodatkowe.
constructor TInformacje_Dodatkowe.Create( const napis_f : string = '' );
begin

  Self.utworzenie_data_czas := Now();
  Self.wyœwietlanie_czas_sekund := informacja_dodatkowa__wyœwietlanie_czas_sekund__domyœlny_c;
  Self.napis := napis_f;

end;//---//Konstruktor klasy TInformacje_Dodatkowe.

//Konstruktor klasy TInformacje_Dodatkowe.
constructor TInformacje_Dodatkowe.Create( const napis_f : string; const wyœwietlanie_czas_sekund_f : smallint );
begin

  Self.utworzenie_data_czas := Now();
  Self.wyœwietlanie_czas_sekund := wyœwietlanie_czas_sekund_f;
  Self.napis := napis_f;

end;//---//Konstruktor klasy TInformacje_Dodatkowe
{$endregion 'TInformacje_Dodatkowe.'}

{$region 'TKlawisz_Konfiguracja.'}
//Konstruktor klasy TKlawisz_Konfiguracja.
constructor TKlawisz_Konfiguracja.Create( AOwner : TComponent; pointer_f : Pointer );
begin

  inherited Create( AOwner );


  Self.Parent := TWinControl(AOwner);
  Self.Align := alBottom; // Aby kolejnoœæ siê nie odwraca³a.
  Self.Align := alTop;
  Self.Height := 30;

  Self.klawiatura_konfiguracja_r_w := pointer_f;

  Self.klawiatura_konfiguracja_r_w.mysz_niezdefiniowana := false;

  Self.ParentBackground := false;
  Self.Color := clWhite;
  Self.OnMouseEnter := Self.Panel_Mouse_Enter;
  Self.OnMouseLeave := Self.Panel_Mouse_Leave;

  Self.domyœlna_konfiguracja_r.klawisz := Self.klawiatura_konfiguracja_r_w.klawisz;
  Self.domyœlna_konfiguracja_r.czy_mysz := Self.klawiatura_konfiguracja_r_w.czy_mysz;
  Self.domyœlna_konfiguracja_r.plus_alt := Self.klawiatura_konfiguracja_r_w.plus_alt;
  Self.domyœlna_konfiguracja_r.plus_ctrl := Self.klawiatura_konfiguracja_r_w.plus_ctrl;
  Self.domyœlna_konfiguracja_r.plus_shift := Self.klawiatura_konfiguracja_r_w.plus_shift;


  Self.Klawisz_Edit := TEdit.Create( Self );
  Self.Klawisz_Edit.Parent := Self;
  Self.Klawisz_Edit.Left := 5;
  Self.Klawisz_Edit.Top := 5;
  Self.Klawisz_Edit.Width := 100;
  Self.Klawisz_Edit.ShowHint := true;
  Self.Klawisz_Edit.Hint := '';
  Self.Klawisz_Edit.ReadOnly := true;
  Self.Nazwa_Klawisza();
  Self.Klawisz_Edit.OnExit := Self.Edit_Exit;
  Self.Klawisz_Edit.OnKeyDown := Self.Edit_Key_Down;
  Self.Klawisz_Edit.OnMouseDown := Self.Edit_Mouse_Down;
  Self.Klawisz_Edit.OnMouseEnter := Self.Panel_Mouse_Enter;
  Self.Klawisz_Edit.OnMouseLeave := Self.Panel_Mouse_Leave;


  Self.Niezdefiniowane_Button := TButton.Create( Self );
  Self.Niezdefiniowane_Button.Parent := Self;
  Self.Niezdefiniowane_Button.Caption := 'Brak';
  Self.Niezdefiniowane_Button.Left := Self.Klawisz_Edit.Left + Self.Klawisz_Edit.Width + 15;
  Self.Niezdefiniowane_Button.Top := Self.Klawisz_Edit.Top;
  Self.Niezdefiniowane_Button.Height := 20;
  Self.Niezdefiniowane_Button.Width := 55;
  Self.Niezdefiniowane_Button.ShowHint := true;
  Self.Niezdefiniowane_Button.Hint := 'Wyczyœæ przypisany klawisz.';
  Self.Niezdefiniowane_Button.OnClick := Self.Niezdefiniowane_Button_Click;
  Self.Niezdefiniowane_Button.OnMouseEnter := Self.Panel_Mouse_Enter;
  Self.Niezdefiniowane_Button.OnMouseLeave := Self.Panel_Mouse_Leave;

  Self.Domyœlny_Button := TButton.Create( Self );
  Self.Domyœlny_Button.Parent := Self;
  Self.Domyœlny_Button.Caption := 'Domyœlny';
  Self.Domyœlny_Button.Left := Self.Niezdefiniowane_Button.Left + Self.Niezdefiniowane_Button.Width + 15;
  Self.Domyœlny_Button.Top := Self.Klawisz_Edit.Top;
  Self.Domyœlny_Button.Height := 20;
  Self.Domyœlny_Button.Width := 55;
  Self.Domyœlny_Button.ShowHint := true;
  Self.Domyœlny_Button.Hint := 'Ustaw domyœlny klawisz.';
  Self.Domyœlny_Button.OnClick := Self.Domyœlny_Button_Click;
  Self.Domyœlny_Button.OnMouseEnter := Self.Panel_Mouse_Enter;
  Self.Domyœlny_Button.OnMouseLeave := Self.Panel_Mouse_Leave;


  Self.Czy_Mysz_CheckBox := TCheckBox.Create( Self );
  Self.Czy_Mysz_CheckBox.Parent := Self;
  Self.Czy_Mysz_CheckBox.Caption := 'Mysz';
  Self.Czy_Mysz_CheckBox.Left := Self.Domyœlny_Button.Left + Self.Domyœlny_Button.Width + 15;
  Self.Czy_Mysz_CheckBox.Top := Self.Klawisz_Edit.Top;
  Self.Czy_Mysz_CheckBox.Width := 45;
  Self.Czy_Mysz_CheckBox.ShowHint := true;
  Self.Czy_Mysz_CheckBox.Hint := 'Funkcjonalnoœæ sterowana klawiszem myszy.';
  Self.Czy_Mysz_CheckBox.Checked := Self.klawiatura_konfiguracja_r_w.czy_mysz;
  Self.Czy_Mysz_CheckBox.OnClick := Self.Check_Box_Click;
  Self.Czy_Mysz_CheckBox.OnMouseEnter := Self.Panel_Mouse_Enter;
  Self.Czy_Mysz_CheckBox.OnMouseLeave := Self.Panel_Mouse_Leave;


  Self.Plus_Alt_CheckBox := TCheckBox.Create( Self );
  Self.Plus_Alt_CheckBox.Parent := Self;
  Self.Plus_Alt_CheckBox.Caption := 'Alt';
  Self.Plus_Alt_CheckBox.Left := Self.Czy_Mysz_CheckBox.Left + Self.Czy_Mysz_CheckBox.Width + 15;
  Self.Plus_Alt_CheckBox.Top := Self.Klawisz_Edit.Top;
  Self.Plus_Alt_CheckBox.Width := 30;
  Self.Plus_Alt_CheckBox.ShowHint := true;
  Self.Plus_Alt_CheckBox.Hint := 'Wskazany klawisz + Alt.';
  Self.Plus_Alt_CheckBox.Checked := Self.klawiatura_konfiguracja_r_w.plus_alt;
  //Self.klawiatura_konfiguracja_r_w.plus_alt := true;
  Self.Plus_Alt_CheckBox.OnClick := Self.Check_Box_Click;
  Self.Plus_Alt_CheckBox.OnMouseEnter := Self.Panel_Mouse_Enter;
  Self.Plus_Alt_CheckBox.OnMouseLeave := Self.Panel_Mouse_Leave;

  Self.Plus_Ctrl_CheckBox := TCheckBox.Create( Self );
  Self.Plus_Ctrl_CheckBox.Parent := Self;
  Self.Plus_Ctrl_CheckBox.Caption := 'Ctrl';
  Self.Plus_Ctrl_CheckBox.Left := Self.Plus_Alt_CheckBox.Left + Self.Plus_Alt_CheckBox.Width + 10;
  Self.Plus_Ctrl_CheckBox.Top := Self.Klawisz_Edit.Top;
  Self.Plus_Ctrl_CheckBox.Width := 35;
  Self.Plus_Ctrl_CheckBox.ShowHint := true;
  Self.Plus_Ctrl_CheckBox.Hint := 'Wskazany klawisz + Ctrl.';
  Self.Plus_Ctrl_CheckBox.Checked := Self.klawiatura_konfiguracja_r_w.plus_ctrl;
  Self.Plus_Ctrl_CheckBox.OnClick := Self.Check_Box_Click;
  Self.Plus_Ctrl_CheckBox.OnMouseEnter := Self.Panel_Mouse_Enter;
  Self.Plus_Ctrl_CheckBox.OnMouseLeave := Self.Panel_Mouse_Leave;

  Self.Plus_Shift_CheckBox := TCheckBox.Create( Self );
  Self.Plus_Shift_CheckBox.Parent := Self;
  Self.Plus_Shift_CheckBox.Caption := 'Shift';
  Self.Plus_Shift_CheckBox.Left := Self.Plus_Ctrl_CheckBox.Left + Self.Plus_Ctrl_CheckBox.Width + 10;
  Self.Plus_Shift_CheckBox.Top := Self.Klawisz_Edit.Top;
  Self.Plus_Shift_CheckBox.Width := 40;
  Self.Plus_Shift_CheckBox.ShowHint := true;
  Self.Plus_Shift_CheckBox.Hint := 'Wskazany klawisz + Shift.';
  Self.Plus_Shift_CheckBox.Checked := Self.klawiatura_konfiguracja_r_w.plus_shift;
  Self.Plus_Shift_CheckBox.OnClick := Self.Check_Box_Click;
  Self.Plus_Shift_CheckBox.OnMouseEnter := Self.Panel_Mouse_Enter;
  Self.Plus_Shift_CheckBox.OnMouseLeave := Self.Panel_Mouse_Leave;


  Self.Polecenie_Nazwa_Label := TLabel.Create( Self );
  Self.Polecenie_Nazwa_Label.Parent := Self;
  Self.Polecenie_Nazwa_Label.Caption := Self.klawiatura_konfiguracja_r_w.polecenie_nazwa;
  Self.Polecenie_Nazwa_Label.Left := Self.Plus_Shift_CheckBox.Left + Self.Plus_Shift_CheckBox.Width + 10;
  Self.Polecenie_Nazwa_Label.Top := Self.Klawisz_Edit.Top;
  Self.Polecenie_Nazwa_Label.Font.Style := [ fsBold ];
  //Self.Polecenie_Nazwa_Label.Tag := Self.Polecenie_Nazwa_Label.Left;
  //Self.Polecenie_Nazwa_Label.Tag := Self.Polecenie_Nazwa_Label.Font.Size;
  Self.Polecenie_Nazwa_Label.OnMouseEnter := Self.Panel_Mouse_Enter;
  Self.Polecenie_Nazwa_Label.OnMouseLeave := Self.Panel_Mouse_Leave;

end;//---//Konstruktor klasy TKlawisz_Konfiguracja.

//Destruktor klasy TKlawisz_Konfiguracja.
destructor TKlawisz_Konfiguracja.Destroy();
begin

  Self.klawiatura_konfiguracja_r_w := nil;

  FreeAndNil( Self.Polecenie_Nazwa_Label );
  FreeAndNil( Self.Klawisz_Edit );
  FreeAndNil( Self.Domyœlny_Button );
  FreeAndNil( Self.Niezdefiniowane_Button );
  FreeAndNil( Self.Czy_Mysz_CheckBox );
  FreeAndNil( Self.Plus_Alt_CheckBox );
  FreeAndNil( Self.Plus_Ctrl_CheckBox );
  FreeAndNil( Self.Plus_Shift_CheckBox );

  inherited;

end;//---//Destruktor klasy TKlawisz_Konfiguracja.

//Funkcja Nazwa_Klawisza().
function TKlawisz_Konfiguracja.Nazwa_Klawisza() : string;
var
  bufor : array [ 0..255 ] of Char;
begin

  if not Self.klawiatura_konfiguracja_r_w.czy_mysz then
    begin

      if Self.klawiatura_konfiguracja_r_w.klawisz = 0 then
        Result := '<brak>'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 19 then
        Result := 'Pause Break'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 33 then
        Result := 'Page Up'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 34 then
        Result := 'Page Down'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 35 then
        Result := 'End'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 36 then
        Result := 'Home'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 37 then
        Result := 'Kursor lewo'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 38 then
        Result := 'Kursor góra'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 39 then
        Result := 'Kursor prawo'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 40 then
        Result := 'Kursor dó³'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 45 then
        Result := 'Insert'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 46 then
        Result := 'Delete'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 91 then
        Result := 'Windows lewy'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 92 then
        Result := 'Windows prawy'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 93 then
        Result := 'Menu'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 111 then
        Result := 'Num /'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = 144 then
        Result := 'Num Lock'
      else
        begin

          GetKeyNameText(  MapVirtualKey( Self.klawiatura_konfiguracja_r_w.klawisz, 0  ) shl 16, bufor, 256  );
          Result := bufor;

        end;
      //---//

    end
  else//if not Self.klawiatura_konfiguracja_r_w.czy_mysz then
    begin

      if Self.klawiatura_konfiguracja_r_w.mysz_niezdefiniowana then
        Result := '<kliknij w polu przyciskiem myszy>'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = word(mbLeft) then
        Result := 'Mysz lewy'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = word(mbMiddle) then
        Result := 'Mysz œrodkowy'
      else
      if Self.klawiatura_konfiguracja_r_w.klawisz = word(mbRight) then
        Result := 'Mysz prawy'
      else
        Result := 'Mysz ' + IntToStr( Self.klawiatura_konfiguracja_r_w.klawisz );

    end;
  //---//if not Self.klawiatura_konfiguracja_r_w.czy_mysz then

  Self.Klawisz_Edit.Text := Result;
  Self.Klawisz_Edit.Hint := Self.Klawisz_Edit.Text + ' (' + IntToStr( Self.klawiatura_konfiguracja_r_w.klawisz ) + ').';

end;//---//Funkcja Nazwa_Klawisza().

//Funkcja Check_Box_Click().
procedure TKlawisz_Konfiguracja.Check_Box_Click( Sender : TObject );
var
  czy_mysz_l : boolean;
begin

  if   ( Sender = nil )
    or (  not Assigned( Sender )  )
    or (  not ( Sender is TCheckBox )  )
    or ( Self = nil )
    or (  not Assigned( Self )  ) then
    Exit;

  czy_mysz_l := Self.klawiatura_konfiguracja_r_w.czy_mysz;


  if TCheckBox(Sender).Caption = 'Mysz' then
    begin

      Self.klawiatura_konfiguracja_r_w.czy_mysz := TCheckBox(Sender).Checked;
      Self.klawiatura_konfiguracja_r_w.klawisz := 0;

      if    ( czy_mysz_l <> Self.klawiatura_konfiguracja_r_w.czy_mysz )
        and ( Self.klawiatura_konfiguracja_r_w.czy_mysz ) then
        begin

          Self.klawiatura_konfiguracja_r_w.mysz_niezdefiniowana := true;

        end
      else//if    ( czy_mysz_l <> Self.klawiatura_konfiguracja_r_w.czy_mysz ) (...)
        begin

          if Self.klawiatura_konfiguracja_r_w.mysz_niezdefiniowana then
            Self.klawiatura_konfiguracja_r_w.mysz_niezdefiniowana := false;

        end;
      //---//if    ( czy_mysz_l <> Self.klawiatura_konfiguracja_r_w.czy_mysz ) (...)

    end
  else
  if TCheckBox(Sender).Caption = 'Alt' then
    Self.klawiatura_konfiguracja_r_w.plus_alt := TCheckBox(Sender).Checked
  else
  if TCheckBox(Sender).Caption = 'Ctrl' then
    Self.klawiatura_konfiguracja_r_w.plus_ctrl := TCheckBox(Sender).Checked
  else
  if TCheckBox(Sender).Caption = 'Shift' then
    Self.klawiatura_konfiguracja_r_w.plus_shift := TCheckBox(Sender).Checked;


  Self.Nazwa_Klawisza();

end;//---//Funkcja Check_Box_Click().

//Funkcja Edit_Exit().
procedure TKlawisz_Konfiguracja.Edit_Exit( Sender : TObject );
begin

  if   ( Sender = nil )
    or (  not Assigned( Sender )  )
    or (  not ( Sender is TEdit )  )
    or ( Self = nil )
    or (  not Assigned( Self )  ) then
    Exit;

  Self.Klawisz_Edit.Tag := 0;

end;//---//Funkcja Edit_Exit().

//Funkcja Edit_Key_Down().
procedure TKlawisz_Konfiguracja.Edit_Key_Down( Sender : TObject; var Key : Word; Shift : TShiftState );
begin

  if   ( Sender = nil )
    or (  not Assigned( Sender )  )
    or (  not ( Sender is TEdit )  )
    or ( Self = nil )
    or (  not Assigned( Self )  )
    or ( Self.klawiatura_konfiguracja_r_w.czy_mysz ) then
    Exit;


  if Key = VK_MENU then // Alt.
    begin

      Self.klawiatura_konfiguracja_r_w.plus_alt := true;

    end
  else//if Key = VK_MENU then
    if Self.klawiatura_konfiguracja_r_w.klawisz = VK_MENU then
      begin

         Self.klawiatura_konfiguracja_r_w.plus_alt := false;

         if Self.klawiatura_konfiguracja_r_w.plus_ctrl then // Prawy Alt zg³asza siê jako Alt i Ctrl jednoczeœnie.
           Self.klawiatura_konfiguracja_r_w.plus_ctrl := false;

      end;
    //---//if Self.klawiatura_konfiguracja_r_w.klawisz = VK_MENU then

  if   ( Key = VK_CONTROL )
    or (
             ( ssAlt in Shift ) // Prawy Alt zg³asza siê jako Alt i Ctrl jednoczeœnie..
         and ( ssCtrl in Shift )
       ) then
    begin

      Self.klawiatura_konfiguracja_r_w.plus_ctrl := true;

    end
  else//if Key = VK_CONTROL then
    if Self.klawiatura_konfiguracja_r_w.klawisz = VK_CONTROL then
      begin

         Self.klawiatura_konfiguracja_r_w.plus_ctrl := false;

      end;
    //---//if Self.klawiatura_konfiguracja_r_w.klawisz = VK_CONTROL then

  if Key = VK_SHIFT then
    begin

      Self.klawiatura_konfiguracja_r_w.plus_shift := true;

    end
  else//if Key = VK_SHIFT then
    if Self.klawiatura_konfiguracja_r_w.klawisz = VK_SHIFT then
      begin

         Self.klawiatura_konfiguracja_r_w.plus_shift := false;

      end;
    //---//if Self.klawiatura_konfiguracja_r_w.klawisz = VK_SHIFT then


  Self.Plus_Alt_CheckBox.Checked := Self.klawiatura_konfiguracja_r_w.plus_alt;
  Self.Plus_Ctrl_CheckBox.Checked := Self.klawiatura_konfiguracja_r_w.plus_ctrl;
  Self.Plus_Shift_CheckBox.Checked := Self.klawiatura_konfiguracja_r_w.plus_shift;


  Self.klawiatura_konfiguracja_r_w.klawisz := Key;
  Self.Nazwa_Klawisza();

end;//---//Funkcja Edit_Key_Down().

//Funkcja Edit_Mouse_Down().
procedure TKlawisz_Konfiguracja.Edit_Mouse_Down( Sender : TObject; Button : TMouseButton; Shift : TShiftState; X, Y : Integer );
begin

  if   ( Sender = nil )
    or (  not Assigned( Sender )  )
    or (  not ( Sender is TEdit )  )
    or ( Self = nil )
    or (  not Assigned( Self )  )
    or ( not Self.klawiatura_konfiguracja_r_w.czy_mysz ) then
    Exit;


  if Self.Klawisz_Edit.Tag = 0 then
    begin

      // Aby pierwsze klikniêcie mysz¹ w polu (ustawienie siê w polu) nie zmienia³o definicji klawisza.

      Self.Klawisz_Edit.Tag := 1;
      Exit

    end;
  //---//if Self.Klawisz_Edit.Tag = 0 then


  if Self.klawiatura_konfiguracja_r_w.mysz_niezdefiniowana then
    Self.klawiatura_konfiguracja_r_w.mysz_niezdefiniowana := false;


  Self.klawiatura_konfiguracja_r_w.klawisz := word(Button);
  Self.Nazwa_Klawisza();

end;//---//Funkcja Edit_Mouse_Down().

//Funkcja Domyœlny_Button_Click().
procedure TKlawisz_Konfiguracja.Domyœlny_Button_Click( Sender : TObject );
begin

  if   ( Sender = nil )
    or (  not Assigned( Sender )  )
    or (  not ( Sender is TButton )  )
    or ( Self = nil )
    or (  not Assigned( Self )  ) then
    Exit;


  Self.klawiatura_konfiguracja_r_w.klawisz := Self.domyœlna_konfiguracja_r.klawisz;
  Self.klawiatura_konfiguracja_r_w.czy_mysz := Self.domyœlna_konfiguracja_r.czy_mysz;
  Self.klawiatura_konfiguracja_r_w.plus_alt := Self.domyœlna_konfiguracja_r.plus_alt;
  Self.klawiatura_konfiguracja_r_w.plus_ctrl := Self.domyœlna_konfiguracja_r.plus_ctrl;
  Self.klawiatura_konfiguracja_r_w.plus_shift := Self.domyœlna_konfiguracja_r.plus_shift;

  Self.Czy_Mysz_CheckBox.Checked := Self.domyœlna_konfiguracja_r.czy_mysz;
  Self.Plus_Alt_CheckBox.Checked := Self.domyœlna_konfiguracja_r.plus_alt;
  Self.Plus_Ctrl_CheckBox.Checked := Self.domyœlna_konfiguracja_r.plus_ctrl;
  Self.Plus_Shift_CheckBox.Checked := Self.domyœlna_konfiguracja_r.plus_shift;

  // Dodatkowe sprawdzenie (nie powinny zmieniæ siê te wartoœci).
  if Self.klawiatura_konfiguracja_r_w.mysz_niezdefiniowana then
    Self.klawiatura_konfiguracja_r_w.mysz_niezdefiniowana := false;

  if Self.klawiatura_konfiguracja_r_w.klawisz <> Self.domyœlna_konfiguracja_r.klawisz then
    Self.klawiatura_konfiguracja_r_w.klawisz := Self.domyœlna_konfiguracja_r.klawisz;
  //---// Dodatkowe sprawdzenie (nie powinny zmieniæ siê te wartoœci).

  Self.Nazwa_Klawisza();

end;//---//Funkcja Domyœlny_Button_Click().

//Funkcja Niezdefiniowane_Button_Click().
procedure TKlawisz_Konfiguracja.Niezdefiniowane_Button_Click( Sender : TObject );
begin

  if   ( Sender = nil )
    or (  not Assigned( Sender )  )
    or (  not ( Sender is TButton )  )
    or ( Self = nil )
    or (  not Assigned( Self )  ) then
    Exit;


  Self.klawiatura_konfiguracja_r_w.czy_mysz := false;
  Self.klawiatura_konfiguracja_r_w.klawisz := 0;

  Self.Czy_Mysz_CheckBox.Checked := false;
  Self.Plus_Alt_CheckBox.Checked := false;
  Self.Plus_Ctrl_CheckBox.Checked := false;
  Self.Plus_Shift_CheckBox.Checked := false;

  Self.Nazwa_Klawisza();

end;//---//Funkcja Niezdefiniowane_Button_Click().

//Funkcja Panel_Mouse_Enter().
procedure TKlawisz_Konfiguracja.Panel_Mouse_Enter( Sender : TObject );
begin

  if   ( Self = nil )
    or (  not Assigned( Self )  ) then
    Exit;


  Self.Color := $00FFDFBF; //clWhite
  //Self.Polecenie_Nazwa_Label.Font.Color := clNavy;
  //Self.Polecenie_Nazwa_Label.Left := Self.Polecenie_Nazwa_Label.Tag + 10;
  //Self.Polecenie_Nazwa_Label.Font.Size := Self.Polecenie_Nazwa_Label.Font.Size + 3;

end;//---//Funkcja Panel_Mouse_Enter().

//Funkcja Panel_Mouse_Leave().
procedure TKlawisz_Konfiguracja.Panel_Mouse_Leave( Sender : TObject );
begin

  if   ( Self = nil )
    or (  not Assigned( Self )  ) then
    Exit;


  //Self.Polecenie_Nazwa_Label.Left := Self.Polecenie_Nazwa_Label.Tag;
  //Self.Polecenie_Nazwa_Label.Font.Color := clWindowText;
  //Self.Polecenie_Nazwa_Label.Font.Size := Self.Polecenie_Nazwa_Label.Tag;
  Self.Color := clWhite; //clBtnFace

end;//---//Funkcja Panel_Mouse_Leave().
{$endregion 'TKlawisz_Konfiguracja.'}

{$region 'TWygl¹d_Kolor_Definicja.'}
//Konstruktor klasy TWygl¹d_Kolor_Definicja.
constructor TWygl¹d_Kolor_Definicja.Create();
begin

  SetLength( Self.wygl¹d_kolor_definicja_t, 0 );

end;//---//Konstruktor klasy TWygl¹d_Kolor_Definicja.

//Destruktor klasy TWygl¹d_Kolor_Definicja.
destructor TWygl¹d_Kolor_Definicja.Destroy();
begin

  SetLength( Self.wygl¹d_kolor_definicja_t, 0 );

end;//---//Destruktor klasy TWygl¹d_Kolor_Definicja.

//Funkcja Definicja_Istnieje().
function TWygl¹d_Kolor_Definicja.Definicja_Istnieje( const kolor_definicja_nazwa_f : string ) : boolean;
var
  i : integer;
begin

  //
  // Funkcja sprawdza czy definicja danego koloru ju¿ jest zapamiêtana.
  //
  // Zwraca prawdê gdy definicja danego koloru ju¿ jest zapamiêtana.
  //
  // Parametry:
  //   kolor_definicja_nazwa_f
  //

  Result := false;

  for i := 0 to Length( Self.wygl¹d_kolor_definicja_t ) - 1 do
    if Self.wygl¹d_kolor_definicja_t[ i ].kolor_definicja_nazwa = kolor_definicja_nazwa_f then
      begin

        Result := true;
        Break;

      end;
    //---//if Self.wygl¹d_kolor_definicja_t[ i ].kolor_definicja_nazwa = kolor_definicja_nazwa_f then

end;//---//Funkcja Definicja_Istnieje().

//Funkcja Dodaj_Definicjê().
procedure TWygl¹d_Kolor_Definicja.Dodaj_Definicjê( const czerwony_f, zielony_f, niebieski_f, przezroczystoœæ_f : real; const kolor_definicja_nazwa_f : string );
var
  i : integer;
begin

  //
  // Funkcja definicja danego koloru ju¿ jest zapamiêtana.
  //
  // Parametry:
  //   czerwony_f
  //   zielony_f
  //   niebieski_f
  //   przezroczystoœæ_f
  //   kolor_definicja_nazwa_f
  //

  i := Length( Self.wygl¹d_kolor_definicja_t );
  SetLength( wygl¹d_kolor_definicja_t, i + 1 );

  wygl¹d_kolor_definicja_t[ i ].kolor_definicja_nazwa := kolor_definicja_nazwa_f;
  GLVectorGeometry.SetVector( wygl¹d_kolor_definicja_t[ i ].kolor_vector, czerwony_f, zielony_f, niebieski_f, przezroczystoœæ_f );

end;//---//Funkcja Dodaj_Definicjê().

//Funkcja Odczytaj_Definicjê().
function TWygl¹d_Kolor_Definicja.Odczytaj_Definicjê( const kolor_definicja_nazwa_f : string ) : GLVectorGeometry.TVector;
var
  i : integer;
begin

  //
  // Zwraca zdefiniowany kolor.
  //
  // Parametry:
  //   kolor_definicja_nazwa_f
  //

  //GLVectorGeometry.SetVector( Result, 0, 0, 0, 1 );
  Result := clrGray20;

  for i := 0 to Length( Self.wygl¹d_kolor_definicja_t ) - 1 do
    if Self.wygl¹d_kolor_definicja_t[ i ].kolor_definicja_nazwa = kolor_definicja_nazwa_f then
      begin

        Result := Self.wygl¹d_kolor_definicja_t[ i ].kolor_vector;
        Break;

      end;
    //---//if Self.wygl¹d_kolor_definicja_t[ i ].kolor_definicja_nazwa = kolor_definicja_nazwa_f then

end;//---//Funkcja Odczytaj_Definicjê().
{$endregion 'TWygl¹d_Kolor_Definicja.'}

{$region 'TTCP_Klienci_Lista.'}
//Konstruktor klasy TTCP_Klienci_Lista.
constructor TTCP_Klienci_Lista.Create();
begin

  Self.identyfikator_najmniejszy := -1;
  Self.identyfikator_najwiêkszy := 0;

  Self.klienci_lista_list := TList.Create();

end;//---//Konstruktor klasy TTCP_Klienci_Lista.

//Destruktor klasy TTCP_Klienci_Lista.
destructor TTCP_Klienci_Lista.Destroy();
begin

  Self.Usuñ_Wszystkich();

  FreeAndNil( Self.klienci_lista_list );

end;//---//Destruktor klasy TTCP_Klienci_Lista.

//Funkcja Dodaj_Aktualizuj().
function TTCP_Klienci_Lista.Dodaj_Aktualizuj( const peer_port_f, identyfikator_f : integer ) : TTCP_Klient_Dane;
var
  i : integer;
begin

  //
  // Funkcja dodaje albo aktualizuje dane gracza.
  //
  // Zwraca prawdê gdy rekord danych gracza.
  //
  // Parametry:
  //   peer_port_f
  //   identyfikator_f:
  //

  Result := nil;

  if peer_port_f >= 0 then
    for i := Self.klienci_lista_list.Count - 1 downto 0 do
      if TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).identyfikator = identyfikator_f then
        begin

          // Sprawdza czy klient, który siê po³¹czy³ jest na liœcie.

          Result := TTCP_Klient_Dane(Self.klienci_lista_list[ i ]);
          Result.peer_port_tcp := peer_port_f;
          Result.data_czas__d³¹czenia := 0;
          Result.data_czas__pod³¹czenia_ostatniego := Now();
          Result.od³¹czony := false;

          Exit;

        end;
      //---//if TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).identyfikator = identyfikator_f then


  if identyfikator_f > 0 then
    Exit; // Wskazanego identyfikatora nie ma na liœcie.


  Result := TTCP_Klient_Dane.Create();
  Result.peer_port_tcp := peer_port_f;
  Result.peer_port_udp := 0;
  Result.data_czas__d³¹czenia := 0;
  Result.data_czas__pod³¹czenia := Now();
  Result.data_czas__pod³¹czenia_ostatniego := Result.data_czas__pod³¹czenia;
  Result.data_czas__udp_kontakt := 0;
  Result.gotowy := false;
  Result.od³¹czony := false;

  if Self.klienci_lista_list.Count <= 0 then
    begin

      // Dodaje do listy serwer.

      if peer_port_f >= 0 then
        Result.identyfikator := 1
      else//if peer_port_f >= 0 then
        Result.identyfikator := peer_port_f;

    end
  else//if Self.klienci_lista_list.Count <= 0 then
    if peer_port_f >= 0 then
      begin

        // Dodaje do listy gracza.

        Self.identyfikator_najwiêkszy := Self.identyfikator_najwiêkszy + 1;
        Result.identyfikator := Self.identyfikator_najwiêkszy;

      end
    else//if Self.klienci_lista_list.Count <= 0 then
      begin

        // Dodaje do listy SI.

        Result.gotowy := true;

        Self.identyfikator_najmniejszy := Self.identyfikator_najmniejszy - 1;
        Result.identyfikator := Self.identyfikator_najmniejszy;

      end;
    //---//if Self.klienci_lista_list.Count <= 0 then


  Self.klienci_lista_list.Add( Result );

end;//---//Funkcja Dodaj_Aktualizuj().

//Funkcja Usuñ().
procedure TTCP_Klienci_Lista.Usuñ( const indeks_f : integer );
begin

  if   ( indeks_f < 0 )
    or ( indeks_f > Self.klienci_lista_list.Count - 1 ) then
    Exit;

  TTCP_Klient_Dane(Self.klienci_lista_list[ indeks_f ]).Free();
  Self.klienci_lista_list.Delete( indeks_f );

end;//---//Funkcja Usuñ().

//Funkcja Usuñ_Identyfikator().
procedure TTCP_Klienci_Lista.Usuñ_Identyfikator( const identyfikator_f : integer );
var
  i : integer;
begin

  for i := Self.klienci_lista_list.Count - 1 downto 0 do
    if TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).identyfikator = identyfikator_f then
      begin

        Usuñ( i );
        Exit;

      end;
    //---//if TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).identyfikator = identyfikator_f then

end;//---//Funkcja Usuñ_Identyfikator().

//Funkcja Usuñ_Peer_Port().
procedure TTCP_Klienci_Lista.Usuñ_Peer_Port( const peer_port_f : integer );
var
  i : integer;
begin

  for i := Self.klienci_lista_list.Count - 1 downto 0 do
    if TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).peer_port_tcp = peer_port_f then
      begin

        Usuñ( i );
        Exit;

      end;
    //---//if TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).peer_port_tcp = peer_port_f then

end;//---//Funkcja Usuñ_Peer_Port().

//Funkcja Usuñ_Wszystkich().
procedure TTCP_Klienci_Lista.Usuñ_Wszystkich();
var
  i : integer;
begin

  for i := Self.klienci_lista_list.Count - 1 downto 0 do
    Self.Usuñ( i );


  Self.identyfikator_najmniejszy := -1;
  Self.identyfikator_najwiêkszy := 0;

end;//---//Funkcja Usuñ_Wszystkich().

//Funkcja Nazwa_Niepowtarzalna().
function TTCP_Klienci_Lista.Nazwa_Niepowtarzalna( const peer_port_f : integer; const nazwa_f : string ) : boolean;
var
  i : integer;
begin

  //
  // Funkcja sprawdza czy podana nazwa gracza jest niepowtarzalna.
  //
  // Zwraca prawdê gdy podana nazwa gracza jest niepowtarzalna.
  //
  // Parametry:
  //   peer_port_f - gracz, którego nazwa jest sprawdzana (aby nie porównywaæ gracza z samym sob¹).
  //   nazwa_f - sprawdzana nazwa.
  //

  Result := true;

  for i := 0 to Self.klienci_lista_list.Count - 1 do
    if    ( TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).peer_port_tcp <> peer_port_f )
      and (  AnsiLowerCase( TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).nazwa ) = AnsiLowerCase( nazwa_f )  ) then
      begin

        Result := false;
        Exit;

      end;
    //---//if    ( TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).peer_port_tcp <> peer_port_f ) (...)

end;//---//Funkcja Nazwa_Niepowtarzalna().

//Funkcja Nazwa_Niepowtarzalna().
function TTCP_Klienci_Lista.Nazwa_Niepowtarzalna( const nazwa_f : string ) : boolean;
var
  i : integer;
begin

  //
  // Funkcja sprawdza czy podana nazwa gracza jest niepowtarzalna.
  //
  // Zwraca prawdê gdy podana nazwa gracza jest niepowtarzalna.
  //
  // Parametry:
  //   nazwa_f - sprawdzana nazwa.
  //

  Result := true;

  for i := 0 to Self.klienci_lista_list.Count - 1 do
    if AnsiLowerCase( TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).nazwa ) = AnsiLowerCase( nazwa_f ) then
      begin

        Result := false;
        Exit;

      end;
    //---//if AnsiLowerCase( TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).nazwa ) = AnsiLowerCase( nazwa_f ) then

end;//---//Funkcja Nazwa_Niepowtarzalna().

//Funkcja Od³¹czony_Peer_Port().
procedure TTCP_Klienci_Lista.Od³¹czony_Peer_Port( const peer_port_f : integer );
var
  i : integer;
begin

  for i := Self.klienci_lista_list.Count - 1 downto 0 do
    if TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).peer_port_tcp = peer_port_f then
      begin

        TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).data_czas__d³¹czenia := Now();
        TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).od³¹czony := true;
        Exit;

      end;
    //---//if TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).peer_port_tcp = peer_port_f then

end;//---//Funkcja Od³¹czony_Peer_Port().

//Funkcja ZnajdŸ_Identyfikator().
function TTCP_Klienci_Lista.ZnajdŸ_Identyfikator( const identyfikator_f : integer ) : TTCP_Klient_Dane;
var
  i : integer;
begin

  Result := nil;

  for i := 0 to Self.klienci_lista_list.Count - 1 do
    if TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).identyfikator = identyfikator_f then
      begin

        Result := TTCP_Klient_Dane(Self.klienci_lista_list[ i ]);
        Exit;

      end;
    //---//if TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).identyfikator = identyfikator_f then

end;//---//Funkcja ZnajdŸ_Identyfikator().

//Funkcja ZnajdŸ_Peer_Port().
function TTCP_Klienci_Lista.ZnajdŸ_Peer_Port( const peer_port_f : integer ) : TTCP_Klient_Dane;
var
  i : integer;
begin

  Result := nil;

  for i := 0 to Self.klienci_lista_list.Count - 1 do
    if TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).peer_port_tcp = peer_port_f then
      begin

        Result := TTCP_Klient_Dane(Self.klienci_lista_list[ i ]);
        Exit;

      end;
    //---//if TTCP_Klient_Dane(Self.klienci_lista_list[ i ]).peer_port_tcp = peer_port_f then

end;//---//Funkcja ZnajdŸ_Peer_Port().
{$endregion 'TTCP_Klienci_Lista.'}

{$region 'TUDP_Klienci_Lista.'}
//Konstruktor klasy TUDP_Klienci_Lista.
constructor TUDP_Klienci_Lista.Create();
begin

  Self.klienci_lista_list := TList.Create();

end;//---//Konstruktor klasy TUDP_Klienci_Lista.

//Destruktor klasy TUDP_Klienci_Lista.
destructor TUDP_Klienci_Lista.Destroy();
begin

  Self.Usuñ_Wszystkich();

  FreeAndNil( Self.klienci_lista_list );

end;//---//Destruktor klasy TUDP_Klienci_Lista.

//Funkcja Dodaj().
procedure TUDP_Klienci_Lista.Dodaj( const adres_ip_f : string; const peer_port_f : word; const identyfikator_f : integer );
var
  i : integer;
  zt_udp_klient_dane : TUDP_Klient_Dane;
begin

  for i := Self.klienci_lista_list.Count - 1 downto 0 do
    if    ( TUDP_Klient_Dane(Self.klienci_lista_list[ i ]).adres_ip = adres_ip_f )
      and ( TUDP_Klient_Dane(Self.klienci_lista_list[ i ]).peer_port = peer_port_f )
      and ( TUDP_Klient_Dane(Self.klienci_lista_list[ i ]).identyfikator = identyfikator_f ) then
      begin

        // Sprawdza czy klient, który siê odezwa³ jest na liœcie. //???
        // Odœwie¿a czas ostatniego kontaktu.
        // Sprawdza czy dla danego klienta zosta³a wyznaczona komenda czynnoœci.


        TUDP_Klient_Dane(Self.klienci_lista_list[ i ]).data_czas_kontakt_ostatni := Now();

        Exit;

      end;
    //---//if    ( TUDP_Klient_Dane(Self.klienci_lista_list[ i ]).adres_ip = adres_ip_f ) (...)


  zt_udp_klient_dane := TUDP_Klient_Dane.Create();
  zt_udp_klient_dane.adres_ip := adres_ip_f;
  zt_udp_klient_dane.data_czas_kontakt_ostatni := Now();
  zt_udp_klient_dane.identyfikator := identyfikator_f;
  zt_udp_klient_dane.peer_port := peer_port_f;
  //zt_udp_klient_dane.komenda := '';

  Self.klienci_lista_list.Add( zt_udp_klient_dane );

end;//---//Funkcja Dodaj().

//Funkcja Usuñ().
procedure TUDP_Klienci_Lista.Usuñ( const indeks_f : integer );
begin

  if   ( indeks_f < 0 )
    or ( indeks_f > Self.klienci_lista_list.Count - 1 ) then
    Exit;

  TUDP_Klient_Dane(Self.klienci_lista_list[ indeks_f ]).Free();
  Self.klienci_lista_list.Delete( indeks_f );

end;//---//Funkcja Usuñ().

//Funkcja Usuñ_Peer_Port().
procedure TUDP_Klienci_Lista.Usuñ_Peer_Port( const peer_port_f : integer );
var
  i : integer;
begin

  for i := Self.klienci_lista_list.Count - 1 downto 0 do
    if TUDP_Klient_Dane(Self.klienci_lista_list[ i ]).peer_port = peer_port_f then
      begin

        Usuñ( i );
        Exit;

      end;
    //---//if TUDP_Klient_Dane(Self.klienci_lista_list[ i ]).peer_port = peer_port_f then

end;//---//Funkcja Usuñ_Peer_Port().

//Funkcja Usuñ_Przeterminowanych().
procedure TUDP_Klienci_Lista.Usuñ_Przeterminowanych();
var
  i : integer;
begin

  for i := Self.klienci_lista_list.Count - 1 downto 0 do
    if SecondsBetween( Now(), TUDP_Klient_Dane(Self.klienci_lista_list[ i ]).data_czas_kontakt_ostatni ) > udp_klient_po³¹czenie_potwierdzanie_sekund_c  + udp_klient_po³¹czenie_potwierdzanie_sekund_c * 0.5 then
      Self.Usuñ( i );

end;//---//Funkcja Usuñ_Przeterminowanych().

//Funkcja Usuñ_Wszystkich().
procedure TUDP_Klienci_Lista.Usuñ_Wszystkich();
var
  i : integer;
begin

  for i := Self.klienci_lista_list.Count - 1 downto 0 do
    Self.Usuñ( i );

end;//---//Funkcja Usuñ_Wszystkich().
{$endregion 'TUDP_Klienci_Lista.'}

//Funkcja DoNotify().
procedure TWieloosobowe_Powiadomienie.DoNotify();
begin

  Statki_Form.Log_Memo.Lines.Add(  DateTimeToStr( Now() )  );
  Statki_Form.Log_Memo.Lines.Add( Self.powiadomienie_treœæ );

  if Self.wyró¿nij then
    Statki_Form.PageControl1.ActivePage := Statki_Form.Log_TabSheet;

end;//---//Funkcja DoNotify().

//Funkcja DoNotify().
procedure TPokój_Rozmów_Powiadomienie.DoNotify();
var
  i : integer;
  zts : string;
begin

  //
  // Funkcja wypisuje treœæ wiadomoœci.
  //

  //Pokój_Rozmów_Memo.Lines.Add(  IntToStr( Self.pokój_rozmów_r.id_nadawca ) + ': ' + Self.pokój_rozmów_r.wiadomoœæ  );

  zts :=  IntToStr( Self.pokój_rozmów_r.id_nadawca );

  for i := 0 to Statki_Form.tcp_klienci_lista_g.klienci_lista_list.Count - 1 do
    if TTCP_Klient_Dane(Statki_Form.tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator = Self.pokój_rozmów_r.id_nadawca then
      begin

        zts := TTCP_Klient_Dane(Statki_Form.tcp_klienci_lista_g.klienci_lista_list[ i ]).nazwa + ' (' + zts + '):';
        Break;

      end;
    //---//if TTCP_Klient_Dane(Statki_Form.tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator = Self.pokój_rozmów_r.id_nadawca then

  Statki_Form.Pokój_Rozmów_Memo.Lines.Add( zts );
  Statki_Form.Pokój_Rozmów_Memo.Lines.Add(  '   ' + Self.pokój_rozmów_r.wiadomoœæ  );


  if Statki_Form.Pokój_Rozmów__Informacja_Dodatkowa_CheckBox.Checked then
    Statki_Form.Informacja_Dodatkowa_Dodaj( zts + '   ' + Self.pokój_rozmów_r.wiadomoœæ );

end;//---//Funkcja DoNotify().


//      ***      Funkcje      ***      //

//Funkcja Czas_Miêdzy_W_Sekundach().
function Czas_Miêdzy_W_Sekundach( const czas_poprzedni_f : int64 ) : int64;
begin

  //
  // Funkcja wylicza iloœæ sekund bezwzglêdnego czasu gry jaka up³ynê³a od podanego czasu do chwili obecnej.
  //
  // Zwraca iloœæ sekund bezwzglêdnego czasu gry.
  //
  // Parametry:
  //   czas_poprzedni_f - moment czasu gry, od którego liczyæ up³yw czasu.
  //

  Result := Round(  Czas_Miêdzy_W_Milisekundach( czas_poprzedni_f ) * 0.001  );

end;//---//Funkcja Czas_Miêdzy_W_Sekundach().

//Funkcja Czas_Miêdzy_W_Milisekundach().
function Czas_Miêdzy_W_Milisekundach( const czas_poprzedni_f : int64 ) : int64;
begin

  //
  // Funkcja wylicza iloœæ milisekund bezwzglêdnego czasu gry jaka up³ynê³a od podanego czasu do chwili obecnej.
  //
  // Zwraca iloœæ milisekund bezwzglêdnego czasu gry.
  //
  // Parametry:
  //   czas_poprzedni_f - moment czasu gry, od którego liczyæ up³yw czasu.
  //

  Result := Abs( czas_bezwzglêdny_g - czas_poprzedni_f ) * czas_bezwzglêdny_skok_milisekundy_g;

end;//---//Funkcja Czas_Miêdzy_W_Milisekundach().

//Funkcja Czas_Teraz().
function Czas_Teraz() : int64;
begin

  //
  // Funkcja zwraca aktualny bezwzglêdny czas gry.
  //  Ze wzglêdu na pauzowanie gdy nie mo¿na wyliczaæ na podstawie czasu systemowego
  //
  // Zwraca aktualny bezwzglêdny czas gry.
  //

  Result := czas_bezwzglêdny_g;

end;//---//Funkcja Czas_Teraz().

//Funkcja Czas_Teraz_W_Milisekundach().
function Czas_Teraz_W_Milisekundach() : int64;
begin

  //
  // Funkcja zwraca aktualny bezwzglêdny czas gry w milisekundach.
  //
  // Zwraca aktualny bezwzglêdny czas gry w milisekundach.
  //

  Result := Czas_Teraz() * czas_bezwzglêdny_skok_milisekundy_g;

end;//---//Funkcja Czas_Teraz_W_Milisekundach().

//Funkcja Wieloosobowe__Wektor_4__Do__Vector().
function TStatki_Form.Wieloosobowe__Wektor_4__Do__Vector( const wieloosobowe__wektor_4_f : TWieloosobowe__Wektor_4 ) : GLVectorGeometry.TVector;
begin

  //
  // Funkcja podstawia wartoœci z typu TWieloosobowe__Wektor_4 do typu GLVectorGeometry.TVector.
  //
  // Zwraca GLVectorGeometry.TVector.
  //

  Result.X := wieloosobowe__wektor_4_f.X;
  Result.Y := wieloosobowe__wektor_4_f.Y;
  Result.Z := wieloosobowe__wektor_4_f.Z;
  Result.W := wieloosobowe__wektor_4_f.W;

end;//---//Funkcja Wieloosobowe__Wektor_4__Do__Vector().

//Funkcja Vector__Do__Wieloosobowe__Wektor_4().
function TStatki_Form.Vector__Do__Wieloosobowe__Wektor_4( const vector_f : GLVectorGeometry.TVector ) : TWieloosobowe__Wektor_4;
begin

  //
  // Funkcja podstawia wartoœci z typu GLVectorGeometry.TVector do typu TWieloosobowe__Wektor_4.
  //
  // Zwraca TWieloosobowe__Wektor_4.
  //

  Result.X := vector_f.X;
  Result.Y := vector_f.Y;
  Result.Z := vector_f.Z;
  Result.W := vector_f.W;

end;//---//Funkcja Vector__Do__Wieloosobowe__Wektor_4().

//Funkcja Statek_ZnajdŸ().
function TStatki_Form.Statek_ZnajdŸ( pointer_f : Pointer ) : Pointer;
begin

  //
  // Funkcja próbuje znaleŸæ statek, w który trafiono.
  //
  // Zwraca wskaŸnik na statek, w który trafiono.
  //
  // Parametry:
  //   pointer_f
  //

  Result := nil;

  if pointer_f = nil then
    Exit
  else//if pointer_f = nil then
    if TComponent(pointer_f) is TStatek then
      begin

        Result := pointer_f;
        Exit;

      end
    else//if TComponent(pointer_f) is TStatek then
      if TComponent(pointer_f).Owner <> nil then
        Result := Statek_ZnajdŸ( TComponent(pointer_f).Owner );

end;//---//Funkcja Statek_ZnajdŸ().

//Funkcja Amunicja_Wystrzelona_Utwórz_Jeden().
procedure TStatki_Form.Amunicja_Wystrzelona_Utwórz_Jeden( AOwner : TGLBaseSceneObject; ALufa : TLufa; const obracaj_dzia³a_f : boolean; const cel_wspó³rzêdne_f : TAffineVector );
var
  zt_amunicja : TAmunicja;
begin

  if   ( amunicja_wystrzelona_list = nil )
    or (  not Assigned( amunicja_wystrzelona_list )  ) then
    Exit;

  zt_amunicja := TAmunicja.Create( AOwner, ALufa, obracaj_dzia³a_f, cel_wspó³rzêdne_f, Statki_Form.Gra_GLCollisionManager );

  Amunicja_Wystrzelona_Efekt_Utwórz( zt_amunicja, false );

//  if MilliSecondsBetween( Now(), pociski_magiczne_ostatni_strza³ ) < 500 then
//    Exit;
//
//  pociski_magiczne_ostatni_strza³ := Now();
//
//  zt_amunicja := TPocisk_Magiczny.Create( Application );
//  //zt_amunicja := TGLTorus.Create( nil );
//
//  zt_amunicja.Parent := Gra_GLScene.Objects;
//
//  zt_amunicja.Position := Gra_GLCamera.Position;
//  zt_amunicja.Direction := Gra_GLCamera.Direction;
//  zt_amunicja.Tag := 1;
//
//  // Dynamiczne dodanie zdarzenia kolizji.
//  with TGLBCollision.Create( zt_amunicja.Behaviours ) do
//    begin
//
//      GroupIndex := 0;
//      BoundingMode := cbmCube;
//      Manager := Gra_GLCollisionManager;
//
//    end;
//  //---//with TGLBCollision.Create( Pocisk_Magiczny_GLTorus.Behaviours ) do
//
//  // Dynamiczne dodanie efektu.
//  with TGLBFireFX.Create( zt_amunicja.Effects ) do
//    begin
//
//      Manager := GLFireFXManager1;
//
//    end;
//  //---//with TGLBFireFX.Create( zt_amunicja.Effects ) do
//  // Lub.
//  //TGLBFireFX(zt_amunicja.AddNewEffect(TGLBFireFX)).Manager := GLFireFXManager1;

  amunicja_wystrzelona_list.Add( zt_amunicja );

end;//---//Funkcja Amunicja_Wystrzelona_Utwórz_Jeden().

//Funkcja Amunicja_Wystrzelona_Zwolnij_Jeden().
procedure TStatki_Form.Amunicja_Wystrzelona_Zwolnij_Jeden( amunicja_f : TAmunicja  );
begin

  // Usuwaæ tylko w jednym miejscu. !!!
  // Wywo³anie tej funkcji w kliku miejscach mo¿e coœ zepsuæ.

  if   ( amunicja_wystrzelona_list = nil )
    or (  not Assigned( amunicja_wystrzelona_list )  )
    or ( amunicja_f = nil ) then
    Exit;

  //pociski_magiczne_blokada := true;


  if Gra_GLCamera <> nil then
    if Gra_GLCamera.Parent = amunicja_f then
      if amunicja_wystrzelona_list.Count > 1 then
        Kamera_Prze³¹cz( kt_Amunicja ) // Prze³¹cza na kolejn¹ wystrzelon¹ amunicjê.
      else//if amunicja_wystrzelona_list.Count > 1 then
        Kamera_Prze³¹cz( kt_Statek );

  // Aby nie zwolni³o kamery wraz z amunicj¹.
  while Gra_GLCamera.Parent = amunicja_f do
    Kamera_Prze³¹cz( kt_Statek_Swobodna );


  amunicja_wystrzelona_list.Remove( amunicja_f );
  FreeAndNil( amunicja_f );

end;//---//Funkcja Amunicja_Wystrzelona_Zwolnij_Jeden()

//Funkcja Amunicja_Wystrzelona_Zwolnij_Wszystkie().
procedure TStatki_Form.Amunicja_Wystrzelona_Zwolnij_Wszystkie();
var
  i : integer;
begin

  if   ( amunicja_wystrzelona_list = nil )
    or (  not Assigned( amunicja_wystrzelona_list )  ) then
    Exit;


  if    ( Gra_GLCamera <> nil )
    and ( Gra_GLCamera.Parent is TAmunicja ) then
    Kamera_Prze³¹cz( kt_Statek_Swobodna );


  for i := amunicja_wystrzelona_list.Count - 1 downto 0 do
    begin

      TAmunicja(amunicja_wystrzelona_list[ i ]).Free();
      amunicja_wystrzelona_list.Delete( i );

    end;
  //---//for i := amunicja_wystrzelona_list.Count - 1 downto 0 do

end;//---//Funkcja Amunicja_Wystrzelona_Zwolnij_Wszystkie().

//Funkcja Amunicja_Wystrzelona_Efekt_Utwórz().
procedure TStatki_Form.Amunicja_Wystrzelona_Efekt_Utwórz( amunicja_f : TAmunicja; const czy_torpeda_efekt_na_wodzie_f : boolean; const czy_wieloosobowa_f : boolean = false  );
var
  zt_gl_dummy_cube : TGLDummyCube;
begin

  //
  // Funkcja dodaje efekt lotu amunicji.
  //
  // Parametry:
  //   czy_torpeda_efekt_na_wodzie_f
  //     false - dodaje efekt œladu za amunicj¹.
  //     true - dodaje efekt œladu amunicji na wodzie.
  //   czy_wieloosobowa_f:
  //     false - amunicja przeliczana w grze pojedynczej lub na serwerze.
  //     true - amunicja tylko wyœwietlana u klientów wieloosobowych.
  //


  if   ( amunicja_f = nil )
    or (  not Assigned( amunicja_f )  ) then
    Exit;


  if czy_torpeda_efekt_na_wodzie_f then
    zt_gl_dummy_cube := amunicja_f.torpeda_efekt_na_wodzie
  else//if czy_torpeda_efekt_na_wodzie_f then
    zt_gl_dummy_cube := amunicja_f.korpus_ustawienie_pocz¹tkowe_dummy;


  //???
  // Dodaje efekt smugi za pociskiem.
  with GetOrCreateSourcePFX( zt_gl_dummy_cube ) do // uses GLParticleFX.
    begin

      Manager := Efekt__Smuga_GLPerlinPFXManager;
      //TGLPerlinPFXManager(Manager).Acceleration.AsVector := VectorNegate( zt_amunicja.korpus_opadanie_obrót_dummy.AbsoluteDirection );

      VelocityMode := GLParticleFX.svmAbsolute;

      if not czy_torpeda_efekt_na_wodzie_f then // Efekt na wodzie jest w poziomie.
        if not czy_wieloosobowa_f then
          InitialVelocity.AsVector := VectorNegate( amunicja_f.AbsoluteDirection )
        else//if not czy_wieloosobowa_f then
          InitialVelocity.AsVector := amunicja_f.AbsoluteDirection; // Nie wiem dlaczego amunicja wieloosobowa ma odwrócony kierunek bezwzglêdny.

      //InitialVelocity.AsVector := amunicja_f.AbsoluteDirection;
      //VelocityDispersion := 0.0001;
      //DispersionMode := GLParticleFX.sdmIsotropic;

    end;
  //---//with GetOrCreateSourcePFX( zt_gl_dummy_cube ) do

end;//---//Funkcja Amunicja_Wystrzelona_Efekt_Utwórz().

//Funkcja Odczytaj_Liczbê_Z_Napisu().
function TStatki_Form.Odczytaj_Liczbê_Z_Napisu( napis_f : string; const wartoœæ_minimalna_f : variant; const prze³¹cz_zak³adkê_f : boolean = true ) : real;
begin

  //
  // Funkcja odczytuje liczbê z napisu.
  //
  // Zwraca odczytan¹ liczbê.
  //
  // Parametry:
  //   napis_f
  //   wartoœæ_minimalna_f - je¿eli jest ró¿na od null i wynik jest mniejszy od niej to zwraca t¹ wartoœæ.
  //   prze³¹cz_zak³adkê_f:
  //     false - nie prze³¹cza zak³adki.
  //     true - prze³¹cza zak³adkê.
  //

  napis_f := StringReplace( napis_f, '.', ',', [ rfReplaceAll ] );
  napis_f := Trim(  StringReplace( napis_f, ' ', '', [ rfReplaceAll ] )  );

  try
    Result := StrToFloat( napis_f );
  except
    on E : Exception do
      begin

        Result := 1;
        Log_Wypisz( 'B³¹d odczytania liczby z napisu: ' + napis_f + ' ' + E.Message + ' ' + IntToStr( E.HelpContext ) + '.', prze³¹cz_zak³adkê_f );

      end;
    //---//on E : Exception do
  end;
  //---//try

  if    ( wartoœæ_minimalna_f <> null )
    and ( Result < wartoœæ_minimalna_f ) then
    Result := wartoœæ_minimalna_f;

end;//---//Funkcja Odczytaj_Liczbê_Z_Napisu().

//Funkcja Wygl¹d_Elementy__Utwórz_Element().
function TStatki_Form.Wygl¹d_Elementy__Utwórz_Element( const statek_f : TStatek; const l¹d_prymityw_f : string; const w³aœciciel_gl_base_scene_object_f : TGLBaseSceneObject; const rodzic_gl_dummy_cube_f : TGLDummyCube = nil ) : TGLCustomSceneObject;
begin

  //
  // Funkcja tworzy elementy wygl¹du.
  //
  // Zwraca utworzony element wygl¹du.
  //
  // Parametry:
  //   statek_f
  //     = nil - tworzy elementów wygl¹du l¹du.
  //     <> nil - tworzy elementów wygl¹du statku.
  //   l¹d_prymityw_f -symbol typu elementu wygl¹du (kula, prostopad³oœcian itp.)
  //   w³aœciciel_gl_base_scene_object_f - w³aœciciel tworzonego elementu wygl¹du
  //   rodzic_gl_dummy_cube_f - rodzic tworzonego elementu wygl¹du:
  //     = nil - rodzicem jest w³aœciciel.
  //     <> nil - rodzicem jest kontener na prymitywy.
  //


  Result := nil;


  if l¹d_prymityw_f = wygl¹d_prymityw__kula_c then
    Result := TGLSphere.Create( w³aœciciel_gl_base_scene_object_f )
  else
  if l¹d_prymityw_f = wygl¹d_prymityw__ostros³up_c then
    begin

      Result := TGLFrustrum.Create( w³aœciciel_gl_base_scene_object_f );
      TGLFrustrum(Result).Height := 1;
      TGLFrustrum(Result).ApexHeight := 1;

    end
  else//if l¹d_prymityw_f = wygl¹d_prymityw__ostros³up_c then
  if l¹d_prymityw_f = wygl¹d_prymityw__prostopad³oœcian_c then
    Result := TGLCube.Create( w³aœciciel_gl_base_scene_object_f )
  else
  if l¹d_prymityw_f = wygl¹d_prymityw__sto¿ek_c then
    Result := TGLCone.Create( w³aœciciel_gl_base_scene_object_f )
  else
  if l¹d_prymityw_f = wygl¹d_prymityw__walec_c then
    Result := TGLCylinder.Create( w³aœciciel_gl_base_scene_object_f )
  else
  if l¹d_prymityw_f = wygl¹d_prymityw_c then
    Result := TGLDummyCube.Create( w³aœciciel_gl_base_scene_object_f )
  else
    //Result := TGLSphere.Create( w³aœciciel_gl_base_scene_object_f );
    if statek_f = nil then
      Log_Wypisz( 'Tworzenie l¹du - nieznany typ prymitywu: ' + l¹d_prymityw_f + '.', not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
    else//if statek_f = nil then
      Log_Wypisz( 'Tworzenie elementów statku - nieznany typ prymitywu: ' + l¹d_prymityw_f + '.', not Statki_Form.Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );


  if Result <> nil then
    begin

      if rodzic_gl_dummy_cube_f = nil then
        Result.Parent := w³aœciciel_gl_base_scene_object_f
      else//if rodzic_gl_dummy_cube_f = nil then
        Result.Parent := rodzic_gl_dummy_cube_f;


      if l¹d_prymityw_f <> wygl¹d_prymityw_c then
        begin

          // Do kontenera prymitywów nie dodaje detekcji kolizji.

          if statek_f = nil then
            begin

              Result.Name := 'L¹d__' + Trim(  FormatFloat( '000000000', l¹d_list.Count + 1 )  );
              Result.TagFloat := 1; // Si³a wp³ywu kolizji.

            end
          else//if statek_f = nil then
            Result.Name := 'Statek_Wygl¹d_Elementy__' + Trim(  FormatFloat( '0000', statek_f.id_statek )  ) + '__' + Trim(  FormatFloat( '000000000', statek_f.wygl¹d_elementy_list.Count + 1 )  );

          //Result.MoveUp(); // Aby nie zas³ania³o Informacje_G³ówne_GLHUDText. //???



          // Dynamiczne dodanie zdarzenia kolizji.
          with TGLBCollision.Create( Result.Behaviours ) do
            begin

              GroupIndex := 0;
              Manager := Gra_GLCollisionManager;

              if l¹d_prymityw_f = wygl¹d_prymityw__kula_c then
                BoundingMode := cbmSphere
              else//if l¹d_prymityw_f = wygl¹d_prymityw__kula_c then
                BoundingMode := cbmCube;

            end;
          //---//with TGLBCollision.Create( Result.Behaviours ) do

        end;
      //---//if l¹d_prymityw_f <> wygl¹d_prymityw_c then

    end;
  //---//if Result <> nil then

end;//---//Funkcja Wygl¹d_Elementy__Utwórz_Element().

//Funkcja Wygl¹d_Elementy__Tekstura_Wczytaj().
function TStatki_Form.Wygl¹d_Elementy__Tekstura_Wczytaj( gl_custom_scene_object_f : TGLCustomSceneObject; tekstura_œcie¿ka_f : string ) : boolean;
var
  bit_map : TBitmap;
  obrazek_png : TPngImage; //Potrzebuje w uses pngimage.
begin

  Result := false;

  if Trim( tekstura_œcie¿ka_f ) = '' then
    Exit;

  if not FileExists( tekstura_œcie¿ka_f ) then // Application potrzebuje w uses Forms.
    tekstura_œcie¿ka_f := ExtractFilePath( Application.ExeName ) + 'Tekstury\' + tekstura_œcie¿ka_f;

  if not FileExists( tekstura_œcie¿ka_f ) then // Application potrzebuje w uses Forms.
    Exit;

  if AnsiLowerCase(  ExtractFileExt( tekstura_œcie¿ka_f )  ) <> '.png' then
    Exit;


  bit_map := TBitmap.Create();

  obrazek_png := TPngImage.Create();
  obrazek_png.LoadFromFile( tekstura_œcie¿ka_f );
  bit_map.Assign( obrazek_png );
  obrazek_png.Free();

  if not bit_map.Empty then
    begin

      gl_custom_scene_object_f.Material.Texture.Image.Assign( bit_map );
      gl_custom_scene_object_f.Material.Texture.Enabled := true;

    end;
  //---//if not bit_map.Empty then

  bit_map.Free();

  Result := true;

end;//---//Funkcja Wygl¹d_Elementy__Tekstura_Wczytaj().

//Funkcja L¹d_Utwórz().
procedure TStatki_Form.L¹d_Utwórz( const lista_indeks_f : integer; const prymityw_indeks_f : integer = -99; const prymityw_rodzic_gl_dummy_cube_f : TGLDummyCube = nil );
var
  i,
  j,
  jj
    : integer;
  ztr_1,
  ztr_2,
  ztr_3,
  ztr_4
    : real;
  definicja_treœæ : string;
  zt_xml_document : TXMLDocument; //uses XMLDoc
  zt_gl_custom_scene_object : TGLCustomSceneObject;
  wygl¹d_kolor_definicja : TWygl¹d_Kolor_Definicja;
begin

  //
  // Funkcja tworzy l¹d (mapê gry).
  //
  // Parametry:
  //   lista_indeks_f:
  //     = -99 - l¹d tworzony na podstawie danych otrzymanych z serwera.
  //     <> -99 - l¹d tworzony na podstawie danych z pola wyboru l¹du.
  //   prymityw_indeks_f:
  //     = -99 - tworzy l¹d.
  //     <> -99 - tworzy prymityw.
  //   prymityw_rodzic_gl_dummy_cube_f
  //     = nil - tworzy l¹d.
  //     <> nil - tworzy prymityw (rodzicem tworzonych obiektów jest utworzony wczeœniej kontener TGLDummyCube).
  //

  if prymityw_indeks_f = -99 then
    begin

      // Tworzy l¹d.

      l¹d_pozycja_pocz¹tkowa_parametry_t[ 1 ].korekta_obrót := 0;
      l¹d_pozycja_pocz¹tkowa_parametry_t[ 1 ].korekta_x := 0;
      l¹d_pozycja_pocz¹tkowa_parametry_t[ 1 ].korekta_z := 0;
      l¹d_pozycja_pocz¹tkowa_parametry_t[ 1 ].odstêp_x := 7;
      l¹d_pozycja_pocz¹tkowa_parametry_t[ 1 ].z := 10;
      l¹d_pozycja_pocz¹tkowa_parametry_t[ 2 ].korekta_obrót := 180;
      l¹d_pozycja_pocz¹tkowa_parametry_t[ 2 ].korekta_x := 0;
      l¹d_pozycja_pocz¹tkowa_parametry_t[ 2 ].korekta_z := 0;
      l¹d_pozycja_pocz¹tkowa_parametry_t[ 2 ].odstêp_x := 7;
      l¹d_pozycja_pocz¹tkowa_parametry_t[ 2 ].z := -10;

    end;
  //---//if prymityw_indeks_f = -99 then


  if   ( l¹d_list = nil )
    or (  not Assigned( l¹d_list )  ) then
    Exit;


  if prymityw_indeks_f = -99 then
    begin

      // Tworzy l¹d.

      if lista_indeks_f <> -99 then
        begin

          if   ( lista_indeks_f < 0 )
            or (  lista_indeks_f > Length( l¹dy_lista_t ) - 1  ) then
            begin

              Application.MessageBox( 'Brak definicji l¹du.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
              Exit;

            end;
          //---//if   ( lista_indeks_f < 0 ) (...)

          l¹d_definicja_g := l¹dy_lista_t[ lista_indeks_f ].treœæ;
          definicja_treœæ := l¹d_definicja_g;

        end
      else//if lista_indeks_f <> -99 then
        definicja_treœæ := l¹d_definicja_g; // Dla klientów.

    end
  else//if prymityw_indeks_f = -99 then
    begin

      // Tworzy prymityw.

      if   ( l¹d_list = nil )
        or (  not Assigned( l¹d_list )  ) then
        Exit;


      if prymityw_indeks_f <> -99 then
        begin

          if   ( prymityw_indeks_f < 0 )
            or (  prymityw_indeks_f > Length( prymitywy_lista_t ) - 1  ) then
            begin

              Application.MessageBox( 'Brak definicji prymitywu.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
              Exit;

            end;
          //---//if   ( prymityw_indeks_f < 0 ) (...)

          definicja_treœæ := prymitywy_lista_t[ prymityw_indeks_f ].treœæ;

        end;
      //---//if prymityw_indeks_f <> -99 then

    end;
  //---//if prymityw_indeks_f = -99 then


  zt_xml_document := TXMLDocument.Create( Application );

  zt_xml_document.Options := zt_xml_document.Options + [ doNodeAutoIndent ]; // Domyœlnie ma: doNodeAutoCreate, doAttrNull, doAutoPrefix, doNamespaceDecl.

  try
    // Serwer zg³asza b³¹d podczas odczytu danych o l¹dzie od klienta
    //   MSXML is not installed
    //   Assertion failure GLContext.pas
    // W L¹d_Zwolnij() chyba te¿ takie coœ siê dzieje (inne b³êdy) ale z podobnego powodu.
    //
    // Uda³o siê unikn¹æ b³êdów tak:
    //   w zdarzeniu odczytania danych o l¹dzie tylko w³¹czyæ Timer;
    //   w Timer.OnTimet wy³¹czyæ Timer i wywo³aæ zwalnianie i wczytywanie l¹du.
    //
    zt_xml_document.LoadFromXML( definicja_treœæ );
  except
    on E : Exception do
      if prymityw_indeks_f = -99 then
        //Application.MessageBox(  PChar('Nieprawid³owa definicja l¹du.' + #13 + E.Message + ' ' + IntToStr( E.HelpContext )), 'B³¹d', MB_OK + MB_ICONEXCLAMATION  );
        Log_Wypisz(  'Nieprawid³owa definicja l¹du.' + #13 + #10 + E.Message + ' ' + IntToStr( E.HelpContext ), not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked  )
      else//if prymityw_indeks_f = -99 then
        Log_Wypisz(  'Nieprawid³owa definicja prymitywu.' + #13 + #10 + E.Message + ' ' + IntToStr( E.HelpContext ), not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked  );
  end;
  //---//try

  {$region 'Odczyt danych xml.'}
  if zt_xml_document.Active then
    begin

      wygl¹d_kolor_definicja := TWygl¹d_Kolor_Definicja.Create();


      for i := 0 to zt_xml_document.DocumentElement.ChildNodes.Count - 1 do
        begin

          if    ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'kolor_definicja' )
            and (   Trim(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'nazwa' ] )  ) <> ''   )
            and (   not wygl¹d_kolor_definicja.Definicja_Istnieje(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'nazwa' ] )  )   ) then
            begin

              for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do
                begin

                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].LocalName = 'r' then
                    ztr_1 := Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].Text, 0, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                  else
                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].LocalName = 'g' then
                    ztr_2 := Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].Text, 0, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                  else
                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].LocalName = 'b' then
                    ztr_3 := Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].Text, 0, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                  else
                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].LocalName = 'a' then
                    ztr_4 := Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ jj ].Text, 0, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                end;
              //---//for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do


              wygl¹d_kolor_definicja.Dodaj_Definicjê(  ztr_1, ztr_2, ztr_3, ztr_4, VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'nazwa' ] )  );

            end
          else//if    ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'kolor_definicja' ) (...)
          if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' )
            or ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = wygl¹d_prymityw_c ) then
            begin

              if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' then
                zt_gl_custom_scene_object := Wygl¹d_Elementy__Utwórz_Element(  nil, VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'typ' ] ), Gra_Obiekty_GLDummyCube, prymityw_rodzic_gl_dummy_cube_f  )
              else//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' then
              if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = wygl¹d_prymityw_c then
                zt_gl_custom_scene_object := Wygl¹d_Elementy__Utwórz_Element( nil, wygl¹d_prymityw_c, Gra_Obiekty_GLDummyCube );


              if zt_gl_custom_scene_object <> nil then
                begin

                  l¹d_list.Add( zt_gl_custom_scene_object );


                  if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = wygl¹d_prymityw_c then
                    for j := 0 to Length( prymitywy_lista_t ) - 1 do
                      if prymitywy_lista_t[ j ].plik_nazwa = VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'nazwa' ] ) then
                        begin

                          L¹d_Utwórz( lista_indeks_f, j, TGLDummyCube(zt_gl_custom_scene_object) ); // lista_indeks_f nie ma tutaj znaczenia.
                          Break;

                        end;
                      //---//if prymitywy_lista_t[ j ].plik_nazwa = VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].Attributes[ 'nazwa' ] ) then



                  for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do
                    begin

                      if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'kolor' then
                        begin

                          if    (   Trim(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Attributes[ 'nazwa' ] )  ) <> ''   )
                            and (   wygl¹d_kolor_definicja.Definicja_Istnieje(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Attributes[ 'nazwa' ] )  )   ) then
                            begin

                              zt_gl_custom_scene_object.Material.FrontProperties.Emission.Color := wygl¹d_kolor_definicja.Odczytaj_Definicjê(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Attributes[ 'nazwa' ] )  );

                            end
                          else//if    (   Trim(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Attributes[ 'nazwa' ] )  ) <> ''   ) (...)
                            begin

                              for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do
                                begin

                                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'r' then
                                    ztr_1 := Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                                  else
                                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'g' then
                                    ztr_2 := Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                                  else
                                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'b' then
                                    ztr_3 := Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                                  else
                                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'a' then
                                    ztr_4 := Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                                end;
                              //---//for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do


                              zt_gl_custom_scene_object.Material.FrontProperties.Emission.SetColor( ztr_1, ztr_2, ztr_3, ztr_4 );

                            end;
                          //---//if    (   Trim(  VarToStr( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Attributes[ 'nazwa' ] )  ) <> ''   ) (...)

                        end
                      else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'kolor' then
                      if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'kolor_nazwa' then
                        begin

                          zt_gl_custom_scene_object.Material.FrontProperties.Emission.Color := GLColor.ColorManager.GetColor( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text ); // Robi wyciek pamiêci. // clrGreen clrYellowGreen clrBronze2 clrGray40

                        end
                      else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'kolor_nazwa' then
                      if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'obrót__lewo_prawo' then
                        begin

                          zt_gl_custom_scene_object.TurnAngle := Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                        end
                      else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'obrót__lewo_prawo' then
                      if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'si³a_wp³ywu_kolizji' then
                        begin

                          zt_gl_custom_scene_object.TagFloat := Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0.0001, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                        end
                      else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'si³a_wp³ywu_kolizji' then
                      if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'skala' then
                        begin

                          for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do
                            begin

                              if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'x' then
                                zt_gl_custom_scene_object.Scale.X := Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0.0001, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                              else
                              if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'y' then
                                zt_gl_custom_scene_object.Scale.Y := Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0.0001, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                              else
                              if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'z' then
                                zt_gl_custom_scene_object.Scale.Z := Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, 0.0001, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                            end;
                          //---//for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do

                        end
                      else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'skala' then
                      if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'skala_proporcjonalna' then
                        begin

                          zt_gl_custom_scene_object.Scale.Scale(  Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, 0.0001, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )  );

                        end
                      else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'skala_proporcjonalna' then
                      if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'tekstura' then
                        begin

                          if not Wygl¹d_Elementy__Tekstura_Wczytaj( zt_gl_custom_scene_object, zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text )  then
                            Log_Wypisz( 'Tworzenie l¹du - b³¹d wczytania tekstury: ' + zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text + '.', not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                        end
                      else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'tekstura' then
                      if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wartoœæ_dodatkowa_01' then
                        begin

                          if zt_gl_custom_scene_object is TGLFrustrum then
                            TGLFrustrum(zt_gl_custom_scene_object).Height := Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                        end
                      else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wartoœæ_dodatkowa_01' then
                      if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wspó³rzêdne' then
                        begin

                          for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do
                            begin

                              if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'x' then
                                zt_gl_custom_scene_object.Position.X := Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                              else
                              if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'y' then
                                zt_gl_custom_scene_object.Position.Y := Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )
                              else
                              if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'z' then
                                zt_gl_custom_scene_object.Position.Z := Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                            end;
                          //---//for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do

                        end
                      else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wspó³rzêdne' then
                      if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wychylenie__lewo_prawo' then
                        begin

                          zt_gl_custom_scene_object.RollAngle := Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                        end
                      else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wychylenie__lewo_prawo' then
                      if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wychylenie__przód_ty³' then
                        begin

                          zt_gl_custom_scene_object.PitchAngle := -Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked );

                        end;
                      //---//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'wychylenie__przód_ty³' then

                    end;
                  //---//for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do

                end;
              //---//if zt_gl_custom_scene_object <> nil then

            end
          else//if   ( zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'obiekt' ) (...)
          if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'statki_pozycja_pocz¹tkowa' then
            begin

              for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do
                begin

                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'grupa_1' then
                    begin

                      for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do
                        begin

                          if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'korekta_obrót' then
                            l¹d_pozycja_pocz¹tkowa_parametry_t[ 1 ].korekta_obrót := Round(  Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )  )
                          else
                          if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'korekta_x' then
                            l¹d_pozycja_pocz¹tkowa_parametry_t[ 1 ].korekta_x := Round(  Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )  )
                          else
                          if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'korekta_z' then
                            l¹d_pozycja_pocz¹tkowa_parametry_t[ 1 ].korekta_z := Round(  Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )  )
                          else
                          if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'odstêp_x' then
                            l¹d_pozycja_pocz¹tkowa_parametry_t[ 1 ].odstêp_x := Round(  Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )  )
                          else
                          if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'z' then
                            l¹d_pozycja_pocz¹tkowa_parametry_t[ 1 ].z := Round(  Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )  );

                        end;
                      //---//for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do

                    end
                  else//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'grupa_1' then
                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'grupa_2' then
                    begin

                      for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do
                        begin

                          if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'korekta_obrót' then
                            l¹d_pozycja_pocz¹tkowa_parametry_t[ 2 ].korekta_obrót := Round(  Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )  )
                          else
                          if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'korekta_x' then
                            l¹d_pozycja_pocz¹tkowa_parametry_t[ 2 ].korekta_x := Round(  Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )  )
                          else
                          if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'korekta_z' then
                            l¹d_pozycja_pocz¹tkowa_parametry_t[ 2 ].korekta_z := Round(  Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )  )
                          else
                          if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'odstêp_x' then
                            l¹d_pozycja_pocz¹tkowa_parametry_t[ 2 ].odstêp_x := Round(  Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )  )
                          else
                          if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].LocalName = 'z' then
                            l¹d_pozycja_pocz¹tkowa_parametry_t[ 2 ].z := Round(  Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes[ jj ].Text, null, not L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked )  );

                        end;
                      //---//for jj := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].ChildNodes.Count - 1 do

                    end;
                  //---//if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'grupa_2' then

                end;
              //---//for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do

            end;
          //---//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'statki_pozycja_pocz¹tkowa' then

        end;
      //---//for i := 0 to zt_xml_document.DocumentElement.ChildNodes.Count - 1 do


      FreeAndNil( wygl¹d_kolor_definicja );

    end;
  //---//if zt_xml_document.Active then
  {$endregion 'Odczyt danych xml.'}


  zt_xml_document.Free();


  Radar_L¹d_Rysuj();


  {$region 'Przyk³ad xml.'}
{
<l¹d>
  <nazwa>L¹d 1</nazwa>
  <opis><![CDATA[Opis l¹d 1.#13#10Nowa linia.]]></opis>


  <statki_pozycja_pocz¹tkowa> <!-- Rozmieszczenie statków mo¿e byæ zdefiniowane w definicji l¹du. -->
    <grupa_1>
      <korekta_obrót>123</korekta_obrót> <!-- Pocz¹tkowy obrót statku (+) lewo (-) prawo. -->
      <korekta_x>123</korekta_x> <!-- Przesuniêcie pozycji wszystkich statków w grupie (-) lewo (+) prawo. -->
      <korekta_z>123</korekta_z> <!-- Przesuniêcie pozycji ka¿dego statku w grupie osobno o wielokrotnoœæ wartoœci (-) przód (+) ty³. -->
      <odstêp_x>123</odstêp_x> <!-- Odstêp miêdzy statkami po bokach. -->
      <z>123</z> <!-- Odstêp od œrodka planszy (-) przód (+) ty³. -->
    </grupa_1>

    <grupa_2>
      <korekta_obrót>123</korekta_obrót>
      <korekta_x>123</korekta_x>
      <korekta_z>-123</korekta_z>
      <odstêp_x>123</odstêp_x>
      <z>-123</z>
    </grupa_2>
  </statki_pozycja_pocz¹tkowa>


  <kolor_definicja nazwa="kolor nazwa abc">
    <r>0,0</r>
    <g>0,5</g>
    <b>0,0</b>
    <a>0</a>
  </kolor_definicja>


  <obiekt typ="kula">
    <!-- Wymiar wynosi 1 we wszystkich g³ównych kierunkach. -->

    <kolor>
      <r>0</r>
      <g>1</g>
      <b>0,5</b>
      <a>0</a>
    </kolor>
      <!-- Od 0 (czarny) do 1 (bia³y), ujemne dzia³aj¹ jakoœ odwrotnie, a - nie wiem. -->
    <kolor nazwa="kolor nazwa abc"/>
    <kolor_nazwa>clrGreen</kolor_nazwa> <!-- Robi wyciek pamiêci. -->

    <skala>
      <x>1</x>
      <y>123,456</y>
      <z>123,456</z>
    </skala>
      <!-- 0 - w danym wymiarze jest jak p³aszczyzna, ujemne dzia³aj¹ jak dodatnie. -->

    <skala_proporcjonalna>2</skala_proporcjonalna>
      <!-- 0, ujemne dzia³aj¹ jak dodatnie. -->

    <si³a_wp³ywu_kolizji>1</si³a_wp³ywu_kolizji>
      <!-- 1 - domyœlna wartoœæ, 0 - 1 spowalnia 1 - 3 odbija (im wiêksza wartoœæ tym mocniej odbija). -->

    <wspó³rzêdne>
      <x>123,456</x>
      <y>123,456</y>
      <z>123,456</z>
    </wspó³rzêdne>

    <wychylenie__lewo_prawo>123,456</wychylenie__lewo_prawo>
    <obrót__lewo_prawo>123,456</obrót__lewo_prawo>
    <wychylenie__przód_ty³>123,456</wychylenie__przód_ty³>
      <!-- -(minus) w dó³, +(plus) w górê. -->
      <!-- 0, ujemne dzia³aj¹, wiêksze wartoœci obni¿ane s¹ poprzez wielokrotnoœæ 180. -->

    <tekstura>K1\P_1.png</tekstura>
      <!-- Pliki 'png'. Domyœlnie œcie¿ka w katalogu 'Tekstury' w folderze z gr¹. -->

    <wartoœæ_dodatkowa_01>123,456 abc</wartoœæ_dodatkowa_01>
      <!-- Dla wybranych prymitywów (bry³) dodatkowe parametry, których wartoœæ i typ wartoœci zale¿y od danego prymitywu. -->
        <!-- Dla prymitywu: ostros³up - Height - 123,456 - w zakresie od 0 do 1 - ( 0, 1 >. -->
  </obiekt>
</l¹d>
}
  {$endregion 'Przyk³ad xml.'}

end;//---//Funkcja L¹d_Utwórz().

//Funkcja L¹d_Zwolnij().
procedure TStatki_Form.L¹d_Zwolnij();
var
  i : integer;
begin

  if   ( l¹d_list = nil )
    or (  not Assigned( l¹d_list )  ) then
    Exit;


  for i := l¹d_list.Count - 1 downto 0 do
    begin
        
      TGLCustomSceneObject(l¹d_list[ i ]).Free();
      l¹d_list.Delete( i );

    end;
  //---//for i := l¹d_list.Count - 1 downto 0 do

end;//---//Funkcja L¹d_Zwolnij().

//Funkcja Statki_Zwolnij().
procedure TStatki_Form.Statki_Zwolnij( const zwolnij_pierwszy_statek_f : boolean = true; zwolnij_statki_za_pierwszym_f : boolean = true );

  //Funkcja Statek_Zwolnij() w Statki_Zwolnij().
  procedure Statek_Zwolnij( const indeks_statku_f : integer );
    var
      i_l : integer;
  begin

    if   ( indeks_statku_f < 0 )
      or (  indeks_statku_f > Length( statki_t ) - 1 ) then
      Exit;


    // Aby nie zwolni³o kamery wraz ze statkiem.
    while Gra_GLCamera.Parent = statki_t[ indeks_statku_f ] do
      Kamera_Prze³¹cz( kt_Swobodna );


    for i_l := trafienia_efekt_list.Count - 1 downto 0 do
      begin

        // Zwalnia efekty umieszczone na statku.
        // Je¿eli efekty umieszczone na statku nadal s¹ na scenie pojawiaj¹ siê b³êdy dostêpu.

        if   ( TTrafienia_Efekt(trafienia_efekt_list[ i_l ]).Owner = statki_t[ indeks_statku_f ] )
          or ( TTrafienia_Efekt(trafienia_efekt_list[ i_l ]).Parent = statki_t[ indeks_statku_f ] ) then
          Trafienia_Efekt_Zwolnij_Jeden( TTrafienia_Efekt(trafienia_efekt_list[ i_l ]) );

      end;
    //---//for i_l := trafienia_efekt_list.Count - 1 downto 0 do


    if statek_gracza = statki_t[ indeks_statku_f ] then
      statek_gracza := nil; // Nie zmienia statki_t[ 0 ].

    if projektowy_tryb__statek = statki_t[ indeks_statku_f ] then
      projektowy_tryb__statek := nil;


    FreeAndNil( statki_t[ indeks_statku_f ] );

  end;//---//Funkcja Statek_Zwolnij() w Statki_Zwolnij().

var
  i : integer;
begin//Funkcja Statki_Zwolnij().

  //
  // Funkcja zwalnia utworzone statki i czyœci listê statków.
  //
  // Parametry:
  //   zwolnij_pierwszy_statek_f:
  //     false - nie zwalnia pierwszego statku.
  //     true - zwalnia tylko pierwszy statek.
  //   zwolnij_statki_za_pierwszym_f:
  //     false - nie zwalnia statków po pierwszym statku.
  //     true - nie zwalnia pierwszego statku (gdy prezentuje wszystkie statki zwolni tylko statki prezentowane).
  //
  //     kolejnoœæ statków wed³ug indeksów w tabeli;
  //     statek pierwszy (indeks 0) jest tym wybranym w menu przez gracza;
  //     gry zwolnij_pierwszy_statek_f i zwolnij_statki_za_pierwszym_f = true zwolni wszystkie statki.
  //

  if    ( zwolnij_pierwszy_statek_f )
    and ( zwolnij_statki_za_pierwszym_f ) then
    begin

      // Aby nie zwolni³o kamery wraz ze statkiem.
      while Gra_GLCamera.Parent <> Gra_GLScene.Objects do
        Kamera_Prze³¹cz( kt_Swobodna );

      Trafienia_Efekt_Zwolnij_Wszystkie();

      statek_gracza := nil; // Nie zmienia statki_t[ 0 ].
      projektowy_tryb__statek := nil;

      for i := 0 to Length( statki_t ) - 1 do
        FreeAndNil( statki_t[ i ] );

      SetLength( statki_t, 0 );

    end
  else//if    ( zwolnij_pierwszy_statek_f ) (...)
    begin

      if zwolnij_statki_za_pierwszym_f then
        begin

          for i := 1 to Length( statki_t ) - 1 do
            Statek_Zwolnij( i );

          SetLength( statki_t, 1 );

        end
      else//if zwolnij_statki_za_pierwszym_f then
        if zwolnij_pierwszy_statek_f then
          Statek_Zwolnij( 0 );

    end;
  //---//if    ( zwolnij_pierwszy_statek_f ) (...)

end;//---//Funkcja Statki_Zwolnij().

//Funkcja Statek_Odczytaj_Schemat().
function TStatki_Form.Statek_Odczytaj_Schemat( const lista_indeks_f : integer ) : string;
begin

  if   ( lista_indeks_f < 0 )
    or (  lista_indeks_f > Length( statki_lista_t ) - 1  ) then
    begin

      Result := '';

      Log_Wypisz( 'Brak definicji statku.' );
      Exit;

    end;
  //---//if   ( Statek_ComboBox.Items.Count < 0 ) (...)
  
  Result := statki_lista_t[ lista_indeks_f ].treœæ;

end;//---//Funkcja Statek_Odczytaj_Schemat().

//Funkcja Trafienia_Efekt_Utwórz_Jeden().
procedure TStatki_Form.Trafienia_Efekt_Utwórz_Jeden( AOwner : TGLBaseSceneObject; efekt_rodzaj_f : TEfekt_Rodzaj; x_f, y_f, z_f : real; amunicja_f : TAmunicja; czas_trwania_f, czas_trwania_efekt_dodatkowy_f : Int64 );
var
  czas_trwania_l, // Dla elementów wieloosobowych.
  czas_trwania_efekt_dodatkowy_l // Dla elementów wieloosobowych.
    : Int64;
  zt_trafienia_efekt : TTrafienia_Efekt;
begin

  if   ( trafienia_efekt_list = nil )
    or (  not Assigned( trafienia_efekt_list )  ) then
    Exit;


  //if efekt_rodzaj_f = er_Trafienie_Statek then
  //  zt_trafienia_efekt := TTrafienia_Efekt.Create( AOwner, Efekt__Wpadniêcie_Do_Wody_GLFireFXManager, x_f, y_f, z_f, 0, amunicja_f )
  //else
  //if efekt_rodzaj_f = er_Trafienie_Woda then
  //  zt_trafienia_efekt := TTrafienia_Efekt.Create( AOwner, Efekt__Wpadniêcie_Do_Wody_GLPolygonPFXManager, x_f, y_f + 1, z_f, Gra_GLCadencer.CurrentTime, amunicja_f )
  //else
  //  zt_trafienia_efekt := nil;
  //if gl_cadence_able_component_f is TGLFireFXManager then
  //if gl_cadence_able_component_f is TGLPolygonPFXManager then


  {$region 'Podstawowe efekty.'}
  zt_trafienia_efekt := TTrafienia_Efekt.Create( AOwner, x_f, y_f, z_f );

  // Dynamiczne dodanie efektu.
  //if efekt_rodzaj_f = er_Trafienie_L¹d then
  //  begin
  //
  //    //TGLBFireFX(zt_trafienia_efekt.AddNewEffect(TGLBFireFX)).Manager := Efekt__Wpadniêcie_Do_Wody_0_GLFireFXManager;
  //
  //  end
  //else//if efekt_rodzaj_f = er_Trafienie_L¹d then
  if   ( efekt_rodzaj_f = er_Trafienie_Statek )
    or ( efekt_rodzaj_f = er_Trafienie_L¹d ) then
    begin

      zt_trafienia_efekt.czas_trwania := Random( 1000 );

      // Zmienia rozmiar efektu.
      if amunicja_f <> nil then
        begin

          case amunicja_f.amunicja_rodzaj of
              ar_Artyleria :
                begin

                  zt_trafienia_efekt.Scale.Scale( 5 );

                end;
              //---//ar_Artyleria :

              ar_Pocisk :
                begin

                  //zt_trafienia_efekt.Scale.Scale( 1 );

                end;
              //---//ar_Pocisk :

              ar_Torpeda :
                begin

                  zt_trafienia_efekt.Scale.Scale( 2 );

                end;
              //---//ar_Torpeda :
            end;
          //---//case amunicja_f.amunicja_rodzaj of

        end;
      //---//if amunicja_f <> nil then


      TGLBFireFX(zt_trafienia_efekt.AddNewEffect(TGLBFireFX)).Manager := Efekt__Ogieñ_GLFireFXManager;

    end
  else//if   ( efekt_rodzaj_f = er_Trafienie_Statek ) (...)
  if efekt_rodzaj_f = er_Trafienie_Woda then
    begin

      zt_trafienia_efekt.czas_trwania := 1500;

      // Gdy kamera jest wewn¹trz efektu bardzo zwalnia.

      TGLSourcePFXEffect(zt_trafienia_efekt.AddNewEffect(TGLSourcePFXEffect)).Manager := Efekt__Wpadniêcie_Do_Wody_GLPolygonPFXManager;

      with GetOrCreateSourcePFX( zt_trafienia_efekt ) do // uses GLParticleFX.
        begin

          // Jedno œwiate³ko na œrodku jest zawsze.

          VelocityDispersion := 0.75; // Prêdkoœæ rozpadania siê i wznoszenia.
          Burst( Gra_GLCadencer.CurrentTime, 100 ); // Iloœæ wylatuj¹cych œwiate³ek.

          VelocityDispersion := 0.05; // Prêdkoœæ rozpadania siê i wznoszenia.
          Burst( Gra_GLCadencer.CurrentTime, 1 ); // Iloœæ wylatuj¹cych œwiate³ek.

          VelocityDispersion := 0; // Prêdkoœæ rozpadania siê i wznoszenia.
          RingExplosion( Gra_GLCadencer.CurrentTime, 1, 1.2, 75 ); // uses GLParticleFX.
          //EffectScale := 0.0001; //??? nie dzia³a dobrze

        end;
      //---//with GetOrCreateSourcePFX( zt_trafienia_efekt ) do

      //TGLBFireFX(zt_trafienia_efekt.AddNewEffect(TGLBFireFX)).Manager := Efekt__Wpadniêcie_Do_Wody_0_GLFireFXManager;

    end;
  //---//if efekt_rodzaj_f = er_Trafienie_Woda then


  if zt_trafienia_efekt <> nil then
    begin

      czas_trwania_l := zt_trafienia_efekt.czas_trwania;

      if czas_trwania_f > 0 then // Dla elementów wieloosobowych.
        zt_trafienia_efekt.czas_trwania := czas_trwania_f;

      trafienia_efekt_list.Add( zt_trafienia_efekt );

    end
  else//if zt_trafienia_efekt <> nil then
    czas_trwania_l := -1;
  {$endregion 'Podstawowe efekty.'}


  {$region 'Dodatkowe efekty.'}
  zt_trafienia_efekt := nil;

  if efekt_rodzaj_f = er_Trafienie_L¹d then
    begin

      zt_trafienia_efekt := TTrafienia_Efekt.Create( AOwner, x_f, y_f, z_f );

      with GetOrCreateSourcePFX( zt_trafienia_efekt ) do // uses GLParticleFX.
        begin

          Manager := Efekt__Mg³a_GLPerlinPFXManager;
          // Gdy kamera jest wewn¹trz efektu bardzo zwalnia.

          // Zmienia rozmiar efektu.
          if amunicja_f <> nil then
            begin

              case amunicja_f.amunicja_rodzaj of
                  ar_Artyleria :
                    begin

                      //EffectScale := 1;

                    end;
                  //---//ar_Artyleria :

                  ar_Pocisk :
                    begin

                      EffectScale := 0.05;

                    end;
                  //---//ar_Pocisk :

                  ar_Torpeda :
                    begin

                      EffectScale := 0.1;

                    end;
                  //---//ar_Torpeda :
                end;
              //---//case amunicja_f.amunicja_rodzaj of

            end
          else//if amunicja_f <> nil then
            EffectScale := 0.2; // Kolizja statku ze statkiem.

        end;
      //---//with GetOrCreateSourcePFX( zt_trafienia_efekt ) do

    end
  else//if efekt_rodzaj_f = er_Trafienie_L¹d then
  if efekt_rodzaj_f = er_Trafienie_Statek then
    begin

      zt_trafienia_efekt := TTrafienia_Efekt.Create( AOwner, x_f, y_f, z_f );

      zt_trafienia_efekt.czas_trwania := Random( 10000 );

      with GetOrCreateSourcePFX( zt_trafienia_efekt ) do // uses GLParticleFX.
        begin

          Manager := Efekt__Dym_GLPerlinPFXManager;

          // Zmienia rozmiar efektu.
          if amunicja_f <> nil then
            begin

              case amunicja_f.amunicja_rodzaj of
                  ar_Artyleria :
                    begin

                      EffectScale := 5;

                    end;
                  //---//ar_Artyleria :

                  ar_Pocisk :
                    begin

                      //EffectScale := 1;

                    end;
                  //---//ar_Pocisk :

                  ar_Torpeda :
                    begin

                      EffectScale := 3;

                    end;
                  //---//ar_Torpeda :
                end;
              //---//case amunicja_f.amunicja_rodzaj of

            end;
          //---//if amunicja_f <> nil then

        end;
      //---//with GetOrCreateSourcePFX( zt_trafienia_efekt ) do

    end
  else//if efekt_rodzaj_f = er_Trafienie_Statek then
  if efekt_rodzaj_f = er_Trafienie_Woda then
    begin

      // Ustawia ten efekt, gdy¿ podstawowego nie widaæ wyraŸnie.

      //zt_trafienia_efekt := TTrafienia_Efekt.Create( AOwner, x_f, y_f, z_f );
      //
      //zt_trafienia_efekt.czas_trwania := 1500;
      //
      //// Zmienia rozmiar rozprysku wody.
      //if amunicja_f <> nil then
      //  begin
      //
      //    case amunicja_f.amunicja_rodzaj of
      //        ar_Artyleria :
      //          begin
      //
      //            zt_trafienia_efekt.Scale.Scale( 5 );
      //
      //          end;
      //        //---//ar_Artyleria :
      //
      //        ar_Pocisk :
      //          begin
      //
      //            //zt_trafienia_efekt.Scale.Scale( 1 );
      //
      //          end;
      //        //---//ar_Pocisk :
      //
      //        ar_Torpeda :
      //          begin
      //
      //            zt_trafienia_efekt.Scale.Scale( 2 );
      //
      //          end;
      //        //---//ar_Torpeda :
      //      end;
      //    //---//case amunicja_f.amunicja_rodzaj of
      //
      //  end;
      ////---//if amunicja_f <> nil then
      //
      //
      //TGLBFireFX(zt_trafienia_efekt.AddNewEffect(TGLBFireFX)).Manager := Efekt__Wpadniêcie_Do_Wody_0_GLFireFXManager;

    end;
  //---//if efekt_rodzaj_f = er_Trafienie_Woda then


  if zt_trafienia_efekt <> nil then
    begin

      czas_trwania_efekt_dodatkowy_l := zt_trafienia_efekt.czas_trwania;

      if czas_trwania_efekt_dodatkowy_f > 0 then // Dla elementów wieloosobowych.
        zt_trafienia_efekt.czas_trwania := czas_trwania_efekt_dodatkowy_f;

      trafienia_efekt_list.Add( zt_trafienia_efekt );

    end
  else//if zt_trafienia_efekt <> nil then
    czas_trwania_efekt_dodatkowy_l := -1;
  {$endregion 'Dodatkowe efekty.'}


  Wieloosobowe__Efekt_Odczytaj_Jeden( AOwner, efekt_rodzaj_f, x_f, y_f, z_f, amunicja_f, czas_trwania_l, czas_trwania_efekt_dodatkowy_l );

end;//---//Funkcja Trafienia_Efekt_Utwórz_Jeden().

//Funkcja Trafienia_Efekt_Zwolnij_Jeden().
procedure TStatki_Form.Trafienia_Efekt_Zwolnij_Jeden( trafienia_efekt_f : TTrafienia_Efekt );
begin

  // Usuwaæ tylko w jednym miejscu. !!!
  // Wywo³anie tej funkcji w kliku miejscach mo¿e coœ zepsuæ.

  if   ( trafienia_efekt_list = nil )
    or (  not Assigned( trafienia_efekt_list )  )
    or ( trafienia_efekt_f = nil ) then
    Exit;

  //pociski_magiczne_blokada := true;

  trafienia_efekt_list.Remove( trafienia_efekt_f );
  FreeAndNil( trafienia_efekt_f );

end;//---//Funkcja Trafienia_Efekt_Zwolnij_Jeden()

//Funkcja Trafienia_Efekt_Zwolnij_Wszystkie().
procedure TStatki_Form.Trafienia_Efekt_Zwolnij_Wszystkie();
var
  i : integer;
begin

  if   ( trafienia_efekt_list = nil )
    or (  not Assigned( trafienia_efekt_list )  ) then
    Exit;


  for i := trafienia_efekt_list.Count - 1 downto 0 do
    begin

      TTrafienia_Efekt(trafienia_efekt_list[ i ]).Free();
      trafienia_efekt_list.Delete( i );

    end;
  //---//for i := trafienia_efekt_list.Count - 1 downto 0 do

end;//---//Funkcja Trafienia_Efekt_Zwolnij_Wszystkie().

//Funkcja Amunicja_Rodzaj_Zbiór_Zwróæ().
function TStatki_Form.Amunicja_Rodzaj_Zbiór_Zwróæ() : TAmunicja_Rodzaj_Zbiór;
begin

  // To samo TAmunicja_Rodzaj, Amunicja_Rodzaj_Zbiór_Zwróæ().

  //
  // Funkcja zbiór rodzajów amunicji.
  //
  // Zwraca zbiór rodzajów amunicji.
  //

  Result := Amunicja_Rodzaj_Zbiór_Zwróæ( false, ar_Artyleria_CheckBox.Checked, ar_Pocisk_CheckBox.Checked, ar_Torpeda_CheckBox.Checked, ar_Wszystkie_CheckBox.Checked );

end;//---//Funkcja Amunicja_Rodzaj_Zbiór_Zwróæ().

//Funkcja Amunicja_Rodzaj_Zbiór_Zwróæ().
function TStatki_Form.Amunicja_Rodzaj_Zbiór_Zwróæ( const ar_brak_f, ar_artyleria_f, ar_pocisk_f, ar_torpeda_f, ar_wszystkie_f : boolean ) : TAmunicja_Rodzaj_Zbiór;
begin

  // To samo TAmunicja_Rodzaj, Amunicja_Rodzaj_Zbiór_Zwróæ().

  //
  // Funkcja na podstawie wybranych rodzajów amunicji tworzy zbiór rodzajów amunicji.
  //
  // Zwraca zbiór rodzajów amunicji.
  //
  // Parametry:
  //   ar_brak
  //   ar_artyleria
  //   ar_pocisk
  //   ar_torpeda
  //   ar_wszystkie
  //

  if ar_wszystkie_f then
    Result := [ ar_Wszystkie ]
  else//if ar_wszystkie_f then
    begin

      Result := [];

      if ar_artyleria_f then
        Result := Result + [ ar_Artyleria ];

      if ar_pocisk_f then
        Result := Result + [ ar_Pocisk ];

      if ar_torpeda_f then
        Result := Result + [ ar_Torpeda ];

    end;
  //---//if ar_wszystkie_f then

end;//---//Funkcja Amunicja_Rodzaj_Zbiór_Zwróæ().

//Funkcja Klawisz_Wciœniêto_SprawdŸ().
function TStatki_Form.Klawisz_Wciœniêto_SprawdŸ( const klawiatura_konfiguracja_r_f : TKlawiatura_Konfiguracja_r; const klawisz_f : Word; const mysz_przycisk_f : SmallInt; const shift_f : TShiftState; const czy_z_wieloosobowe__odczytaj_f : boolean = false ) : boolean;

  //Funkcja Klawisz_Plus__Alt_Ctrl_Shift() w Klawisz_Wciœniêto_SprawdŸ().
  function Klawisz_Plus__Alt_Ctrl_Shift( const klawiatura_konfiguracja_r_f : TKlawiatura_Konfiguracja_r ) : boolean; overload;
  begin

    //
    // Funkcja sprawdza czy wciœniêto klawisz z odpowiedni¹ konfiguracj¹ klawiszy Alt, Ctrl, Shift.
    //
    // Zwraca prawdê gdy wciœniêto klawisz z odpowiedni¹ konfiguracj¹ klawiszy Alt, Ctrl, Shift.
    //
    // Parametry:
    //   klawiatura_konfiguracja_r_f
    //

    if    (
               (
                     ( klawiatura_konfiguracja_r_f.plus_alt )
                 and (  IsKeyDown( VK_MENU )  )
               )
            or (
                     ( not klawiatura_konfiguracja_r_f.plus_alt )
                 and (  not IsKeyDown( VK_MENU )  )
               )
          )
      and (
               (
                     ( klawiatura_konfiguracja_r_f.plus_ctrl )
                 and ( IsKeyDown( VK_CONTROL ) )
               )
            or (
                     ( not klawiatura_konfiguracja_r_f.plus_ctrl )
                 and (  not IsKeyDown( VK_CONTROL )  )
               )
          )
      and (
               (
                     ( klawiatura_konfiguracja_r_f.plus_shift )
                 and ( IsKeyDown( VK_SHIFT ) )
               )
            or (
                     ( not klawiatura_konfiguracja_r_f.plus_shift )
                 and (  not IsKeyDown( VK_SHIFT )  )
               )
          )
      then
      Result := true
    else//if    ( (...)
      Result := false;

  end;//---//Funkcja Klawisz_Plus__Alt_Ctrl_Shift() w Klawisz_Wciœniêto_SprawdŸ().

  //Funkcja Klawisz_Plus__Alt_Ctrl_Shift() w Klawisz_Wciœniêto_SprawdŸ().
  function Klawisz_Plus__Alt_Ctrl_Shift( const klawiatura_konfiguracja_r_f : TKlawiatura_Konfiguracja_r; const shift_f : TShiftState ) : boolean; overload;
  begin

    //
    // Funkcja sprawdza czy wciœniêto klawisz z odpowiedni¹ konfiguracj¹ klawiszy Alt, Ctrl, Shift.
    //
    // Zwraca prawdê gdy wciœniêto klawisz z odpowiedni¹ konfiguracj¹ klawiszy Alt, Ctrl, Shift.
    //
    // Parametry:
    //   klawiatura_konfiguracja_r_f
    //   shift_f:
    //

    if    (
               (
                     ( klawiatura_konfiguracja_r_f.plus_alt )
                 and ( ssAlt in shift_f )
               )
            or (
                     ( not klawiatura_konfiguracja_r_f.plus_alt )
                 and (  not ( ssAlt in shift_f )  )
               )
          )
      and (
               (
                     ( klawiatura_konfiguracja_r_f.plus_ctrl )
                 and ( ssCtrl in shift_f )
               )
            or (
                     ( not klawiatura_konfiguracja_r_f.plus_ctrl )
                 and (  not ( ssCtrl in shift_f )  )
               )
          )
      and (
               (
                     ( klawiatura_konfiguracja_r_f.plus_shift )
                 and ( ssShift in shift_f )
               )
            or (
                     ( not klawiatura_konfiguracja_r_f.plus_shift )
                 and (  not ( ssShift in shift_f )  )
               )
          )
      then
      Result := true
    else//if    ( (...)
      Result := false;

  end;//---//Funkcja Klawisz_Plus__Alt_Ctrl_Shift() w Klawisz_Wciœniêto_SprawdŸ().

begin//Funkcja Klawisz_Wciœniêto_SprawdŸ().

  //
  // Funkcja sprawdza czy zosta³a wciœniêta zadana kombinacja klawiszy.
  //
  // Zwraca prawdê gdy zosta³a wciœniêta zadana kombinacja klawiszy.
  //
  // Parametry:
  //   klawiatura_konfiguracja_r_f
  //   klawisz_f - wciœniêty klawisz (0 = brak) (ma znaczenie przy obs³udze klientów wieloosobowych).
  //   mysz_przycisk_f - wciœniêty przycisk myszy (-1 = brak).
  //   shift_f - wciœniêty klawisz funkcyjny (ma znaczenie przy obs³udze przycisków myszy i klientów wieloosobowych).
  //   czy_z_wieloosobowe__odczytaj_f
  //     false - informacja analizowana wewnêtrznie w ramach programu.
  //     true - informacjê przes³a³ klient do serwera.
  //

  if   (
             ( not klawiatura_konfiguracja_r_f.czy_mysz )
         and (
                  (
                        ( not czy_z_wieloosobowe__odczytaj_f )
                    and (  IsKeyDown( klawiatura_konfiguracja_r_f.klawisz )  )
                    and (  Klawisz_Plus__Alt_Ctrl_Shift( klawiatura_konfiguracja_r_f )  )
                  )
               or (
                        ( czy_z_wieloosobowe__odczytaj_f )
                    and ( klawisz_f <> 0 )
                    and ( klawiatura_konfiguracja_r_f.klawisz = klawisz_f )
                    and (  Klawisz_Plus__Alt_Ctrl_Shift( klawiatura_konfiguracja_r_f, shift_f )  )
                  )
             )
       )
    or (
             ( klawiatura_konfiguracja_r_f.czy_mysz )
         and ( not klawiatura_konfiguracja_r_f.mysz_niezdefiniowana )
         and ( klawiatura_konfiguracja_r_f.klawisz = mysz_przycisk_f )
         and (  Klawisz_Plus__Alt_Ctrl_Shift( klawiatura_konfiguracja_r_f, shift_f )  )
       ) then
    Result := true
  else//if   ( (...)
    Result := false;

end;//---//Funkcja Klawisz_Wciœniêto_SprawdŸ().

//Funkcja Statek_Klawisze_Obs³uga().
procedure TStatki_Form.Statek_Klawisze_Obs³uga( const id_statek_f : integer; const klawisz_f : Word; const mysz_przycisk_f : SmallInt; const shift_f : TShiftState; const amunicja_rodzaj_zbiór_f : TAmunicja_Rodzaj_Zbiór; const czy_z_wieloosobowe__odczytaj_f : boolean = false );

  //Funkcja Klawisz_Wciœniêto_SprawdŸ_l() w Statek_Klawisze_Obs³uga().
  function Klawisz_Wciœniêto_SprawdŸ_l( const klawiatura_konfiguracja_r_f : TKlawiatura_Konfiguracja_r ) : boolean;
  begin

    Result := Klawisz_Wciœniêto_SprawdŸ( klawiatura_konfiguracja_r_f, klawisz_f, mysz_przycisk_f, shift_f, czy_z_wieloosobowe__odczytaj_f );

    if    ( czy_klient_g )
      and ( Result )
      and ( statek_gracza <> nil ) then
      begin

        Result := false;

        wieloosobowe__statek_klawisze_obs³uga_r.id_statek := statek_gracza.id_statek; //??? na pocz¹tku gry
        wieloosobowe__statek_klawisze_obs³uga_r.klawisz := klawisz_f;
        wieloosobowe__statek_klawisze_obs³uga_r.shift := shift_f;
        wieloosobowe__statek_klawisze_obs³uga_r.mysz_przycisk := mysz_przycisk_f;
        wieloosobowe__statek_klawisze_obs³uga_r.cel_wspó³rzêdne := statek_gracza.celownicza_linia.Nodes[ 1 ].AsVector;
        wieloosobowe__statek_klawisze_obs³uga_r.ar_artyleria := ar_Artyleria_CheckBox.Checked;
        wieloosobowe__statek_klawisze_obs³uga_r.ar_pocisk := ar_Pocisk_CheckBox.Checked;
        wieloosobowe__statek_klawisze_obs³uga_r.ar_torpeda := ar_Torpeda_CheckBox.Checked;
        wieloosobowe__statek_klawisze_obs³uga_r.ar_wszystkie := ar_Wszystkie_CheckBox.Checked;
        wieloosobowe__statek_klawisze_obs³uga_r.polecenie_nazwa := klawiatura_konfiguracja_r_f.polecenie_nazwa;

        Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__statek__klawisze_obs³uga_c, -99, '' );

      end;
    //---//if    ( czy_klient_g ) (...)

  end;//---//Funkcja Klawisz_Wciœniêto_SprawdŸ_l() w Statek_Klawisze_Obs³uga().

var
  i : integer;
  zt_statek : TStatek;
begin//Funkcja Statek_Klawisze_Obs³uga().

  //
  // Funkcja ustawia parametry zachowania statku zgodnie z poleceniami gracza.
  //
  // Parametry:
  //   id_statek_f - identyfikator statku, którego dotycz¹ wytyczne.
  //   klawisz_f - wciœniêty klawisz (0 = brak).
  //   mysz_przycisk_f - wciœniêty przycisk myszy (-1 = brak).
  //   shift_f - wciœniêty klawisz funkcyjny.
  //   amunicja_rodzaj_zbiór_f
  //   czy_z_wieloosobowe__odczytaj_f
  //     false - informacja analizowana wewnêtrznie w ramach programu.
  //     true - informacjê przes³a³ klient do serwera.
  //

  if    ( klawisz_f = 0 )
    and ( mysz_przycisk_f = -1 ) then
    Exit;


  zt_statek := nil;


  for i := 0 to Length( statki_t ) - 1 do
    if    ( statki_t[ i ] <> nil )
      and ( statki_t[ i ].id_statek = id_statek_f ) then
      begin

        zt_statek := statki_t[ i ];
        Break;

      end;
    //---//if    ( statki_t[ i ] <> nil ) (...)


  if   ( zt_statek = nil )
    or (  not Assigned( zt_statek )  ) then
    Exit;



  //if klawisz_f = Ord( 'L' ) then
  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__podnoœ_lufy ) then
    zt_statek.podnoœ_lufy := not zt_statek.podnoœ_lufy;

  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__obracaj_dzia³a ) then
    zt_statek.obracaj_dzia³a := not zt_statek.obracaj_dzia³a;


  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__prêdkoœæ_zadana_procent_zmieñ__100_plus ) then
    zt_statek.Prêdkoœæ_Zadana_Procent_Zmieñ( 100 );

  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__prêdkoœæ_zadana_procent_zmieñ__25_plus ) then
    zt_statek.Prêdkoœæ_Zadana_Procent_Zmieñ( 25 );

  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__prêdkoœæ_zadana_procent_zmieñ__1_plus ) then
    zt_statek.Prêdkoœæ_Zadana_Procent_Zmieñ( 1 );

  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__prêdkoœæ_zadana_procent_zmieñ__zero ) then
    zt_statek.Prêdkoœæ_Zadana_Procent_Zmieñ( 0 );

  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__prêdkoœæ_zadana_procent_zmieñ__1_minus ) then
    zt_statek.Prêdkoœæ_Zadana_Procent_Zmieñ( -1 );

  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__prêdkoœæ_zadana_procent_zmieñ__25_minus ) then
    zt_statek.Prêdkoœæ_Zadana_Procent_Zmieñ( -25 );

  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__prêdkoœæ_zadana_procent_zmieñ__100_minus ) then
    zt_statek.Prêdkoœæ_Zadana_Procent_Zmieñ( -100 );


  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__radar_widocznoœæ ) then
    Radar_Widocznoœæ_CheckBox.Checked := not Radar_Widocznoœæ_CheckBox.Checked;


  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__skrêt_zadany_procent_zmieñ__100_lewo ) then
    zt_statek.Skrêt_Zadany_Procent_Zmieñ( -100 );

  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__skrêt_zadany_procent_zmieñ__25_lewo ) then
    zt_statek.Skrêt_Zadany_Procent_Zmieñ( -25 );

  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__skrêt_zadany_procent_zmieñ__1_lewo ) then
    zt_statek.Skrêt_Zadany_Procent_Zmieñ( -1 );

  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__skrêt_zadany_procent_zmieñ__zero ) then
    zt_statek.Skrêt_Zadany_Procent_Zmieñ( 0 );

  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__skrêt_zadany_procent_zmieñ__1_prawo ) then
    zt_statek.Skrêt_Zadany_Procent_Zmieñ( 1 );

  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__skrêt_zadany_procent_zmieñ__25_prawo ) then
    zt_statek.Skrêt_Zadany_Procent_Zmieñ( 25 );

  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__skrêt_zadany_procent_zmieñ__100_prawo ) then
    zt_statek.Skrêt_Zadany_Procent_Zmieñ( 100 );


  if   (  Klawisz_Wciœniêto_SprawdŸ_l( klawisz__strza³_1 )  )
    or (  Klawisz_Wciœniêto_SprawdŸ_l( klawisz__strza³_2 )  ) then
    zt_statek.Strza³( amunicja_rodzaj_zbiór_f, false, false, zt_statek.obracaj_dzia³a, zt_statek.podnoœ_lufy, Celowniczy_GLDummyCube.Position.AsAffineVector );

  if   (  Klawisz_Wciœniêto_SprawdŸ_l( klawisz__strza³__wszystkie_lufy_1 )  )
    or (  Klawisz_Wciœniêto_SprawdŸ_l( klawisz__strza³__wszystkie_lufy_2 )  ) then
    zt_statek.Strza³( amunicja_rodzaj_zbiór_f, false, true, zt_statek.obracaj_dzia³a, zt_statek.podnoœ_lufy, Celowniczy_GLDummyCube.Position.AsAffineVector );

  if   (  Klawisz_Wciœniêto_SprawdŸ_l( klawisz__strza³__wszystkie_wybrane_1 )  )
    or (  Klawisz_Wciœniêto_SprawdŸ_l( klawisz__strza³__wszystkie_wybrane_2 )  ) then
    zt_statek.Strza³( amunicja_rodzaj_zbiór_f, true, true, zt_statek.obracaj_dzia³a, zt_statek.podnoœ_lufy, Celowniczy_GLDummyCube.Position.AsAffineVector );


  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__strza³__broñ_indeks_zmieniaj ) then
    zt_statek.Broñ_Indeks_Zmieniaj_Ustaw( amunicja_rodzaj_zbiór_f );

  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__strza³__broñ_indeks_poprzedni ) then
    zt_statek.Broñ_Indeks_Zmieniaj_Ustaw( true, amunicja_rodzaj_zbiór_f );

  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__strza³__broñ_indeks_nastêpny ) then
    zt_statek.Broñ_Indeks_Zmieniaj_Ustaw( false, amunicja_rodzaj_zbiór_f );

end;//---//Funkcja Statek_Klawisze_Obs³uga().

//Funkcja Klawisze_Obs³uga_Zachowanie_Ci¹g³e().
procedure TStatki_Form.Klawisze_Obs³uga_Zachowanie_Ci¹g³e( delta_czasu_f : double; const shift_f : TShiftState = []; const mysz_przycisk_f : SmallInt = -1 );

  //Funkcja Klawisz_Wciœniêto_SprawdŸ_l() w Klawisze_Obs³uga_Zachowanie_Ci¹g³e().
  function Klawisz_Wciœniêto_SprawdŸ_l( const klawiatura_konfiguracja_r_f : TKlawiatura_Konfiguracja_r ) : boolean;
  begin

    Result := Klawisz_Wciœniêto_SprawdŸ( klawiatura_konfiguracja_r_f, 0, mysz_przycisk_f, shift_f );

  end;//---//Funkcja Klawisz_Wciœniêto_SprawdŸ_l() w Klawisze_Obs³uga_Zachowanie_Ci¹g³e().

begin//Funkcja Klawisze_Obs³uga_Zachowanie_Ci¹g³e().

  //
  // Funkcja przetwarza obs³ugê klawiszy, które nale¿y obs³ugiwaæ ca³y czas gdy s¹ wciœniête (np. ruch kamery).
  //
  // Parametry:
  //   delta_czasu_f
  //   shift_f
  //   mysz_przycisk_f
  //

  if not Gra_GLSceneViewer.Focused then
    Exit;


  // Ruch kamery.
  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__kamera__do_przodu ) then
    Gra_GLCamera.Move( delta_czasu_f * kamera_szybkoœæ_ruchu_g );

  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__kamera__do_ty³u ) then
    Gra_GLCamera.Move( -delta_czasu_f * kamera_szybkoœæ_ruchu_g );

  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__kamera__w_lewo ) then
    Gra_GLCamera.Slide( -delta_czasu_f * kamera_szybkoœæ_ruchu_g );

  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__kamera__w_przawo ) then
    Gra_GLCamera.Slide( delta_czasu_f * kamera_szybkoœæ_ruchu_g );


  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__kamera__w_górê ) then // Góra.
    Gra_GLCamera.Lift( delta_czasu_f * kamera_szybkoœæ_ruchu_g );

  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__kamera__w_dó³ ) then // Dó³.
    Gra_GLCamera.Lift( -delta_czasu_f * kamera_szybkoœæ_ruchu_g );


  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__kamera__w_lewo_obrót ) then // Obrót  w lewo.
    Gra_GLCamera.Turn( -delta_czasu_f * kamera_szybkoœæ_ruchu_g * 10 );

  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__kamera__w_przawo_obrót ) then // Obrót  w prawo.
    Gra_GLCamera.Turn( delta_czasu_f * kamera_szybkoœæ_ruchu_g * 10 );

  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__kamera__w_górê_obrót ) then // Obrót  w górê.
    Gra_GLCamera.Pitch( delta_czasu_f * kamera_szybkoœæ_ruchu_g * 10 );

  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__kamera__w_dó³_obrót ) then // Obrót  w dó³.
    Gra_GLCamera.Pitch( -delta_czasu_f * kamera_szybkoœæ_ruchu_g * 10 );

  //if IsKeyDown( 'Q' ) then // Beczka w lewo.
  //  Gra_GLCamera.Roll( delta_czasu_f * 10 );
  //
  //if IsKeyDown( 'E' ) then // Beczka w prawo.
  //  Gra_GLCamera.Roll( -delta_czasu_f * 10 );
  //---// Ruch kamery.


  if czy_pauza_g then
    Kamera_Odleg³oœæ_Kontroluj_Ustaw( delta_czasu_f );


  {$region 'Przesuwanie statków (w trybie projektowym).'}
  if Projektowy_Tryb_CheckBox.Checked then
    begin

      if projektowy_tryb__statek <> nil then
        begin

          if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__projektowy_tryb__statek__przesuniêcie_w_lewo ) then // Przesuniêcie w lewo.
            begin

              projektowy_tryb__statek.Slide( -gra_wspó³czynnik_prêdkoœci_g );

            end;
          //---//if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__projektowy_tryb__statek__przesuniêcie_w_lewo ) then

          if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__projektowy_tryb__statek__przesuniêcie_w_prawo ) then // Przesuniêcie w prawo.
            begin

              projektowy_tryb__statek.Slide( gra_wspó³czynnik_prêdkoœci_g );

            end;
          //---//if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__projektowy_tryb__statek__przesuniêcie_w_prawo ) then


          if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__projektowy_tryb__statek__przesuniêcie_w_przód ) then // Przesuniêcie w przód.
            begin

              projektowy_tryb__statek.Move( gra_wspó³czynnik_prêdkoœci_g );

            end;
          //---//if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__projektowy_tryb__statek__przesuniêcie_w_przód ) then

          if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__projektowy_tryb__statek__przesuniêcie_w_ty³ ) then // Przesuniêcie w ty³.
            begin

              projektowy_tryb__statek.Move( -gra_wspó³czynnik_prêdkoœci_g );

            end;
          //---//if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__projektowy_tryb__statek__przesuniêcie_w_ty³ ) then


          if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__projektowy_tryb__statek__obrót_lewo ) then // Obrót lewo.
            begin

              projektowy_tryb__statek.TurnAngle := projektowy_tryb__statek.TurnAngle + 1;

            end;
          //---//if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__projektowy_tryb__statek__obrót_lewo ) then

          if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__projektowy_tryb__statek__obrót_prawo ) then // Obrót prawo.
            begin

              projektowy_tryb__statek.TurnAngle := projektowy_tryb__statek.TurnAngle - 1;

            end;
          //---//if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__projektowy_tryb__statek__obrót_prawo ) then


          if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__projektowy_tryb__statek__przechylenie_w_lewo ) then // Przechylenie w lewo.
            begin

              projektowy_tryb__statek.RollAngle := projektowy_tryb__statek.RollAngle - 1;

            end;
          //---//if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__projektowy_tryb__statek__przechylenie_w_lewo ) then

          if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__projektowy_tryb__statek__przechylenie_w_prawo ) then // Przechylenie w prawo.
            begin

              projektowy_tryb__statek.RollAngle := projektowy_tryb__statek.RollAngle + 1;

            end;
          //---//if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__projektowy_tryb__statek__przechylenie_w_prawo ) then


          if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__projektowy_tryb__statek__uniesienie_przodu ) then // Uniesienie przodu.
            begin

              projektowy_tryb__statek.PitchAngle := projektowy_tryb__statek.PitchAngle - 1;

            end;
          //---//if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__projektowy_tryb__statek__uniesienie_przodu ) then

          if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__projektowy_tryb__statek__uniesienie_ty³u ) then // Uniesienie ty³u.
            begin

              projektowy_tryb__statek.PitchAngle := projektowy_tryb__statek.PitchAngle + 1;

            end;
          //---//if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__projektowy_tryb__statek__uniesienie_ty³u ) then

        end;
      //---//if projektowy_tryb__statek <> nil then

    end;
  //---//if Projektowy_Tryb_CheckBox.Checked then
  {$endregion 'Przesuwanie statków (w trybie projektowym).'}



  Exit; // Test. //???
  //if MilliSecondsBetween( Now(), moment_wciœniêcia_klawisza ) >= 100 then
    begin

      // Lepiej dzia³a Gra_GLSceneViewerKeyDown, nie ³apie tak szybko ponownego wciœniêcia klawisza.

      //moment_wciœniêcia_klawisza := Now();


      //???
      if IsKeyDown( ';' ) then
        begin

          //Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_L¹d, 0, 10, 0, nil, -1, -1 );
          //Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_Statek, 0, 5, 0, nil, -1, -1 );
          //Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_Woda, 0, 2, 0, nil, -1, -1 );
          //Amunicja_Wystrzelona_Zwolnij_Wszystkie();

        end;
      //---//if IsKeyDown( ';' ) then

    end;
  //---//if MilliSecondsBetween( Now(), moment_wciœniêcia_klawisza ) >= 100 then


  //???
  if IsKeyDown( 'Y' ) then
    begin

      //statek_gracza.falowanie_dummy.ResetRotations();
      //statek_gracza.falowanie_dummy.PitchAngle := 0;
      //Statki_Form.Caption := FloatToStr( statek_gracza.falowanie_dummy.PitchAngle );

      //Statki_Form.Caption := FloatToStr( Czas_Miêdzy_W_Sekundach( 0 ) ) + ' ' + FloatToStr( Czas_Miêdzy_W_Milisekundach( 0 ) );
      //statek_gracza.torpedy_wyrzutnie_t[ 0 ].Obrót_Kierunek_Zmieñ( Celowanie_Precyzja_Obrót_SpinEdit.Value, true );
      //Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__odbierz__rekord_statki_c, -99, '' );
      //Wieloosobowe_Statki_Parametry_Ustaw();

      //statek_gracza.artyleria_t[ 0 ].lufy_t[ 0 ].prze³adowanie_wskaŸnik.Position.Z := statek_gracza.artyleria_t[ 0 ].lufy_t[ 0 ].prze³adowanie_wskaŸnik.Position.Z + 0.001;


      //Elementy_Gry_Zwolnij();
      //Elementy_Gry_Przygotuj();
      //L¹d_Utwórz( L¹d_ComboBox.ItemIndex );

      //Statek__Odœwie¿_Wskazany_BitBtnClick( nil );
      //Statek__Utwórz_BitBtnClick( nil );

    end;
  //---//if IsKeyDown( 'Y' ) then


  if IsKeyDown( 'V' ) then
    begin

      //Projektowy_Tryb_CheckBox.Checked := not Projektowy_Tryb_CheckBox.Checked;
      //Amunicja_Wystrzelona_Zwolnij_Wszystkie();

    end;
  //---//if IsKeyDown( 'J' ) then



  if IsKeyDown( 'N' ) then
    begin

      //statek_gracza.artyleria_t[ 0 ].lufy_t[ 0 ].Position.Z := statek_gracza.artyleria_t[ 0 ].lufy_t[ 0 ].Position.Z - 0.01;
      //statek_gracza.dzia³a_t[ 0 ].lufy_t[ 0 ].PitchAngle := statek_gracza.dzia³a_t[ 0 ].lufy_t[ 0 ].PitchAngle + gra_wspó³czynnik_prêdkoœci_g;
      //Statki_Form.Caption := FloatToStr( statek_gracza.dzia³a_t[ 0 ].lufy_t[ 0 ].PitchAngle );

      //statek_gracza.falowanie_dummy.Roll( gra_wspó³czynnik_prêdkoœci_g );
      //statek_gracza.falowanie_dummy.PitchAngle := statek_gracza.falowanie_dummy.PitchAngle - gra_wspó³czynnik_prêdkoœci_g;
      //Statki_Form.Caption := FloatToStr( statek_gracza.falowanie_dummy.PitchAngle );

      //statek_gracza.TurnAngle := statek_gracza.TurnAngle + 0.01; // Plus - lewo.
      //Amunicja_Ruch( gra_wspó³czynnik_prêdkoœci_g );

      //Celowniczy_GLDummyCube.Slide( 0.01 ); //???
      //statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector := Celowniczy_GLDummyCube.Position.AsAffineVector; //???

    end;
  //---//if IsKeyDown( 'N' ) then


  if IsKeyDown( 'M' ) then
    begin

      //statek_gracza.artyleria_t[ 0 ].lufy_t[ 0 ].Position.Z := statek_gracza.artyleria_t[ 0 ].lufy_t[ 0 ].Position.Z + 0.01;
      //statek_gracza.dzia³a_t[ 0 ].lufy_t[ 0 ].PitchAngle := statek_gracza.dzia³a_t[ 0 ].lufy_t[ 0 ].PitchAngle - gra_wspó³czynnik_prêdkoœci_g;
      //Statki_Form.Caption := FloatToStr( statek_gracza.dzia³a_t[ 0 ].lufy_t[ 0 ].PitchAngle );

      //statek_gracza.falowanie_dummy.Roll( -gra_wspó³czynnik_prêdkoœci_g );
      //statek_gracza.falowanie_dummy.PitchAngle := statek_gracza.falowanie_dummy.PitchAngle + gra_wspó³czynnik_prêdkoœci_g;
      //Statki_Form.Caption := FloatToStr( statek_gracza.falowanie_dummy.PitchAngle );

      //Celowniczy_GLDummyCube.Slide( -0.01 ); //???
      //statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector := Celowniczy_GLDummyCube.Position.AsAffineVector; //???

    end;
  //---//if IsKeyDown( 'M' ) then

end;//---//Funkcja Klawisze_Obs³uga_Zachowanie_Ci¹g³e().

//Funkcja Statek_Klient_Cel_Ustaw().
procedure TStatki_Form.Statek_Klient_Cel_Ustaw( const id_statek_f : integer; const cel_wspó³rzêdne_f : GLVectorGeometry.TVector );
var
  i : integer;
  zt_statek : TStatek;
begin

  //
  // Funkcja ustawia parametry zachowania statku zgodnie z poleceniami gracza.
  //
  // Parametry:
  //   id_statek_f - identyfikator statku, którego dotycz¹ wytyczne.
  //   cel_wspó³rzêdne_f - bezwzglêdne wspó³rzêdne celu.
  //


  zt_statek := nil;


  for i := 0 to Length( statki_t ) - 1 do
    if    ( statki_t[ i ] <> nil )
      and ( statki_t[ i ].id_statek = id_statek_f ) then
      begin

        zt_statek := statki_t[ i ];
        Break;

      end;
    //---//if    ( statki_t[ i ] <> nil ) (...)


  if   ( zt_statek = nil )
    or (  not Assigned( zt_statek )  ) then
    Exit;


  zt_statek.celownicza_linia.Nodes[ 1 ].AsVector := cel_wspó³rzêdne_f;

end;//---//Funkcja Statek_Klient_Cel_Ustaw().

//Funkcja Statki_Ruch().
procedure TStatki_Form.Statki_Ruch( delta_czasu_f : double );
var
  i,
  i_s
    : integer;
  ztr : real;
  zt_statek : TStatek;
begin//Funkcja Statki_Ruch().

  for i_s := 0 to Length( statki_t ) - 1 do
    begin

      zt_statek := statki_t[ i_s ];

      if zt_statek <> nil then
        begin

          if not zt_statek.czy_usun¹æ_statek then
            begin

              // czy_usun¹æ_statek - nie.


              //if zt_statek = statek_gracza then
              if not czy_klient_g then //???
                begin


                  {$region 'Ruch statku.'}
                  zt_statek.Skrêt_Procent_Zmieñ();
                  zt_statek.Prêdkoœæ_Procent_Zmieñ();


                  zt_statek.prêdkoœæ_aktualna := zt_statek.prêdkoœæ_maksymalna * zt_statek.prêdkoœæ_procent * 0.01;
                  zt_statek.Move( zt_statek.prêdkoœæ_aktualna * gra_wspó³czynnik_prêdkoœci_g * delta_czasu_f );
                  //Gra_GLCamera.Move( statek_prêdkoœæ_l );

                  if zt_statek.prêdkoœæ_procent <> 0 then
                    begin

                      //statek_obrót_l := zt_statek.skrêt_prêdkoœæ * zt_statek.skrêt_procent * ( zt_statek.prêdkoœæ_procent / 100 ) * delta_czasu_f;
                      zt_statek.prêdkoœæ_obrotu_aktualna := zt_statek.skrêt_prêdkoœæ * zt_statek.skrêt_procent * 0.01;

                      if    ( zt_statek.skrêt_wspó³czynnik_do_prêdkoœci <> 0 )
                        and (  Abs( zt_statek.prêdkoœæ_procent ) < zt_statek.skrêt_wspó³czynnik_do_prêdkoœci  ) then
                        //statek_obrót_l := statek_obrót_l * ( 100 * Abs( zt_statek.prêdkoœæ_procent ) / zt_statek.skrêt_wspó³czynnik_do_prêdkoœci ) / 100;
                        zt_statek.prêdkoœæ_obrotu_aktualna := zt_statek.prêdkoœæ_obrotu_aktualna * Abs( zt_statek.prêdkoœæ_procent ) / zt_statek.skrêt_wspó³czynnik_do_prêdkoœci;


                      if zt_statek.prêdkoœæ_procent < 0 then
                        zt_statek.prêdkoœæ_obrotu_aktualna := -zt_statek.prêdkoœæ_obrotu_aktualna;

                      //zt_statek.Turn( zt_statek.prêdkoœæ_obrotu_aktualna );
                      zt_statek.TurnAngle := zt_statek.TurnAngle - zt_statek.prêdkoœæ_obrotu_aktualna * gra_wspó³czynnik_prêdkoœci_g * delta_czasu_f;


                      zt_statek.falowanie_bok_skrêt := -zt_statek.falowanie_bok_skrêt_zakres * (  zt_statek.skrêt_procent * Abs( zt_statek.prêdkoœæ_procent ) * 0.01  ) * 0.01;
                      zt_statek.falowanie_przód_ruch := 1 * zt_statek.prêdkoœæ_procent * 0.01;

                    end
                  else//if zt_statek.prêdkoœæ_procent <> 0 then
                    begin

                      zt_statek.falowanie_bok_skrêt := 0;
                      zt_statek.falowanie_przód_ruch := 0;

                    end;
                  //---//if zt_statek.prêdkoœæ_procent <> 0 then



                  //Statki_Form.Caption := FloatToStr( zt_statek.falowanie_bok_skrêt ) + ' ' + FloatToStr( zt_statek.skrêt_procent ) + ' ' + FloatToStr( zt_statek.prêdkoœæ_procent );
                  {$endregion 'Ruch statku.'}


                  {$region '//Ruch dzia³.'}
                  //if zt_statek.obracaj_dzia³a then
                  //  begin
                  //
                  //    for i := 0 to Length( zt_statek.artyleria_t ) - 1 do
                  //      begin
                  //
                  //        zt_statek.artyleria_t[ i ].Obrót_Zadany_Zmieñ();
                  //        zt_statek.artyleria_t[ i ].Obrót_Kierunek_Zmieñ( Celowanie_Precyzja_Obrót_SpinEdit.Value );
                  //
                  //        zt_statek.artyleria_t[ i ].Podniesienie_Zadane_Zmieñ();
                  //        zt_statek.artyleria_t[ i ].Podniesienie_Kierunek_Zmieñ( Celowanie_Precyzja_Podniesienie_SpinEdit.Value );
                  //
                  //      end;
                  //    //---//for i := 0 to Length( zt_statek.artyleria_t ) - 1 do
                  //
                  //    for i := 0 to Length( zt_statek.dzia³a_t ) - 1 do
                  //      begin
                  //
                  //        zt_statek.dzia³a_t[ i ].Obrót_Zadany_Zmieñ();
                  //        zt_statek.dzia³a_t[ i ].Obrót_Kierunek_Zmieñ( Celowanie_Precyzja_Obrót_SpinEdit.Value );
                  //
                  //        zt_statek.dzia³a_t[ i ].Podniesienie_Zadane_Zmieñ();
                  //        zt_statek.dzia³a_t[ i ].Podniesienie_Kierunek_Zmieñ( Celowanie_Precyzja_Podniesienie_SpinEdit.Value );
                  //
                  //      end;
                  //    //---//for i := 0 to Length( zt_statek.dzia³a_t ) - 1 do
                  //
                  //
                  //    for i := 0 to Length( zt_statek.torpedy_wyrzutnie_t ) - 1 do
                  //      begin
                  //
                  //        zt_statek.torpedy_wyrzutnie_t[ i ].Obrót_Zadany_Zmieñ();
                  //        zt_statek.torpedy_wyrzutnie_t[ i ].Obrót_Kierunek_Zmieñ( Celowanie_Precyzja_Obrót_SpinEdit.Value, true );
                  //
                  //      end;
                  //    //---//for i := 0 to Length( zt_statek.torpedy_wyrzutnie_t ) - 1 do
                  //
                  //  end
                  //else//if zt_statek.obracaj_dzia³a then
                  //  begin
                  //
                  //    for i := 0 to Length( zt_statek.artyleria_t ) - 1 do
                  //      zt_statek.artyleria_t[ i ].celownik_linia.LineColor.Color := GLColor.clrYellow;
                  //
                  //
                  //    for i := 0 to Length( zt_statek.dzia³a_t ) - 1 do
                  //      zt_statek.dzia³a_t[ i ].celownik_linia.LineColor.Color := GLColor.clrYellow;
                  //
                  //
                  //    for i := 0 to Length( zt_statek.torpedy_wyrzutnie_t ) - 1 do
                  //      zt_statek.torpedy_wyrzutnie_t[ i ].celownik_linia.LineColor.Color := GLColor.clrYellow;
                  //
                  //  end;
                  ////---//if zt_statek.obracaj_dzia³a the
                  {$endregion '//Ruch dzia³.'}


                  {$region 'Obrót dzia³.'}
                  if zt_statek.obracaj_dzia³a then
                    begin

                      for i := 0 to Length( zt_statek.artyleria_t ) - 1 do
                        begin

                          zt_statek.artyleria_t[ i ].Obrót_Zadany_Zmieñ( ar_Artyleria_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );
                          zt_statek.artyleria_t[ i ].Obrót_Kierunek_Zmieñ( Celowanie_Precyzja_Obrót_SpinEdit.Value );

                        end;
                      //---//for i := 0 to Length( zt_statek.artyleria_t ) - 1 do

                      for i := 0 to Length( zt_statek.dzia³a_t ) - 1 do
                        begin

                          zt_statek.dzia³a_t[ i ].Obrót_Zadany_Zmieñ( ar_Pocisk_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );
                          zt_statek.dzia³a_t[ i ].Obrót_Kierunek_Zmieñ( Celowanie_Precyzja_Obrót_SpinEdit.Value );

                        end;
                      //---//for i := 0 to Length( zt_statek.dzia³a_t ) - 1 do


                      for i := 0 to Length( zt_statek.torpedy_wyrzutnie_t ) - 1 do
                        begin

                          zt_statek.torpedy_wyrzutnie_t[ i ].Obrót_Zadany_Zmieñ( ar_Torpeda_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );
                          zt_statek.torpedy_wyrzutnie_t[ i ].Obrót_Kierunek_Zmieñ( Celowanie_Precyzja_Obrót_SpinEdit.Value, true );

                        end;
                      //---//for i := 0 to Length( zt_statek.torpedy_wyrzutnie_t ) - 1 do

                    end
                  else//if zt_statek.obracaj_dzia³a then
                    begin

                      for i := 0 to Length( zt_statek.artyleria_t ) - 1 do
                        begin

                          if zt_statek.artyleria_t[ i ].czy_indeks_do_strza³u then
                            zt_statek.artyleria_t[ i ].celownik_linia.LineColor.Color := GLColor.clrOrange
                          else//if zt_statek.artyleria_t[ i ].czy_indeks_do_strza³u then
                            zt_statek.artyleria_t[ i ].celownik_linia.LineColor.Color := GLColor.clrYellow;

                          zt_statek.artyleria_t[ i ].celownik_linia_szerokoœæ_obrót := 0;
                          zt_statek.artyleria_t[ i ].celownik_linia.LineWidth := zt_statek.artyleria_t[ i ].celownik_linia_szerokoœæ_obrót;

                          zt_statek.artyleria_t[ i ].celownik_linia_bez_falowania.LineColor.Color := zt_statek.artyleria_t[ i ].celownik_linia.LineColor.Color;
                          zt_statek.artyleria_t[ i ].celownik_linia_bez_falowania.LineWidth := zt_statek.artyleria_t[ i ].celownik_linia.LineWidth;
                          zt_statek.artyleria_t[ i ].Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( ar_Artyleria_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );

                        end;
                      //---//for i := 0 to Length( zt_statek.artyleria_t ) - 1 do


                      for i := 0 to Length( zt_statek.dzia³a_t ) - 1 do
                        begin

                          if zt_statek.dzia³a_t[ i ].czy_indeks_do_strza³u then
                            zt_statek.dzia³a_t[ i ].celownik_linia.LineColor.Color := GLColor.clrOrange
                          else//if zt_statek.dzia³a_t[ i ].czy_indeks_do_strza³u then
                            zt_statek.dzia³a_t[ i ].celownik_linia.LineColor.Color := GLColor.clrYellow;

                          zt_statek.dzia³a_t[ i ].celownik_linia_szerokoœæ_obrót := 0;
                          zt_statek.dzia³a_t[ i ].celownik_linia.LineWidth := zt_statek.dzia³a_t[ i ].celownik_linia_szerokoœæ_obrót;

                          zt_statek.dzia³a_t[ i ].celownik_linia_bez_falowania.LineColor.Color := zt_statek.dzia³a_t[ i ].celownik_linia.LineColor.Color;
                          zt_statek.dzia³a_t[ i ].celownik_linia_bez_falowania.LineWidth := zt_statek.dzia³a_t[ i ].celownik_linia.LineWidth;
                          zt_statek.dzia³a_t[ i ].Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( ar_Pocisk_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );

                        end;
                      //---//for i := 0 to Length( zt_statek.dzia³a_t ) - 1 do

                      for i := 0 to Length( zt_statek.torpedy_wyrzutnie_t ) - 1 do
                        begin

                          if zt_statek.torpedy_wyrzutnie_t[ i ].czy_indeks_do_strza³u then
                            zt_statek.torpedy_wyrzutnie_t[ i ].celownik_linia.LineColor.Color := GLColor.clrOrange
                          else//if zt_statek.torpedy_wyrzutnie_t[ i ].czy_indeks_do_strza³u then
                            zt_statek.torpedy_wyrzutnie_t[ i ].celownik_linia.LineColor.Color := GLColor.clrYellow;

                          zt_statek.torpedy_wyrzutnie_t[ i ].celownik_linia_szerokoœæ_obrót := 0;
                          zt_statek.torpedy_wyrzutnie_t[ i ].celownik_linia.LineWidth := zt_statek.torpedy_wyrzutnie_t[ i ].celownik_linia_szerokoœæ_obrót;

                          zt_statek.torpedy_wyrzutnie_t[ i ].celownik_linia_bez_falowania.LineColor.Color := zt_statek.torpedy_wyrzutnie_t[ i ].celownik_linia.LineColor.Color;
                          zt_statek.torpedy_wyrzutnie_t[ i ].celownik_linia_bez_falowania.LineWidth := zt_statek.torpedy_wyrzutnie_t[ i ].celownik_linia.LineWidth;
                          zt_statek.torpedy_wyrzutnie_t[ i ].Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( ar_Torpeda_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );

                        end;
                      //---//for i := 0 to Length( zt_statek.torpedy_wyrzutnie_t ) - 1 do

                    end;
                  //---//if zt_statek.obracaj_dzia³a the
                  {$endregion 'Obrót dzia³.'}


                  {$region 'Podniesienie dzia³.'}
                  if zt_statek.podnoœ_lufy then
                    begin

                      for i := 0 to Length( zt_statek.artyleria_t ) - 1 do
                        begin

                          zt_statek.artyleria_t[ i ].Podniesienie_Zadane_Zmieñ( ar_Artyleria_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );
                          zt_statek.artyleria_t[ i ].Podniesienie_Kierunek_Zmieñ( Celowanie_Precyzja_Podniesienie_SpinEdit.Value );

                        end;
                      //---//for i := 0 to Length( zt_statek.artyleria_t ) - 1 do

                      for i := 0 to Length( zt_statek.dzia³a_t ) - 1 do
                        begin

                          zt_statek.dzia³a_t[ i ].Podniesienie_Zadane_Zmieñ( ar_Pocisk_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );
                          zt_statek.dzia³a_t[ i ].Podniesienie_Kierunek_Zmieñ( Celowanie_Precyzja_Podniesienie_SpinEdit.Value );

                        end;
                      //---//for i := 0 to Length( zt_statek.dzia³a_t ) - 1 do

                    end
                  else//if zt_statek.podnoœ_lufy then
                    begin

                      for i := 0 to Length( zt_statek.artyleria_t ) - 1 do
                        begin

                          //zt_statek.artyleria_t[ i ].celownik_linia.LineColor.Color := GLColor.clrYellow;
                          zt_statek.artyleria_t[ i ].celownik_linia.LineWidth := zt_statek.artyleria_t[ i ].celownik_linia_szerokoœæ_obrót;
                          zt_statek.artyleria_t[ i ].celownik_linia_bez_falowania.LineWidth := zt_statek.artyleria_t[ i ].celownik_linia.LineWidth;
                          zt_statek.artyleria_t[ i ].Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( ar_Artyleria_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );

                        end;
                      //---//for i := 0 to Length( zt_statek.artyleria_t ) - 1 do

                      for i := 0 to Length( zt_statek.dzia³a_t ) - 1 do
                        begin

                          //zt_statek.dzia³a_t[ i ].celownik_linia.LineColor.Color := GLColor.clrYellow;
                          zt_statek.dzia³a_t[ i ].celownik_linia.LineWidth := zt_statek.dzia³a_t[ i ].celownik_linia_szerokoœæ_obrót;
                          zt_statek.dzia³a_t[ i ].celownik_linia_bez_falowania.LineWidth := zt_statek.dzia³a_t[ i ].celownik_linia.LineWidth;
                          zt_statek.dzia³a_t[ i ].Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( ar_Pocisk_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );

                        end;
                      //---//for i := 0 to Length( zt_statek.dzia³a_t ) - 1 do

                      //???
                      //for i := 0 to Length( zt_statek.torpedy_wyrzutnie_t ) - 1 do
                      //  begin
                      //
                      //    zt_statek.torpedy_wyrzutnie_t[ i ].celownik_linia.LineColor.Color := GLColor.clrYellow;
                      //
                      //  end;
                      ////---//for i := 0 to Length( zt_statek.torpedy_wyrzutnie_t ) - 1 do

                    end;
                  //---//if zt_statek.podnoœ_lufy the
                  {$endregion 'Podniesienie dzia³.'}


                  for i := 0 to Length( zt_statek.artyleria_wygl¹d_t ) - 1 do
                    zt_statek.artyleria_wygl¹d_t[ i ].Parametry_Aktualizuj_Dla_Wygl¹du();

                  for i := 0 to Length( zt_statek.dzia³a_wygl¹d_t ) - 1 do
                    zt_statek.dzia³a_wygl¹d_t[ i ].Parametry_Aktualizuj_Dla_Wygl¹du();

                  for i := 0 to Length( zt_statek.torpedy_wyrzutnie_wygl¹d_t ) - 1 do
                    zt_statek.torpedy_wyrzutnie_wygl¹d_t[ i ].Parametry_Aktualizuj_Dla_Wygl¹du();


                  for i := 0 to Length( zt_statek.œruby_t ) - 1 do
                    zt_statek.œruby_t[ i ].Œruba_Obracaj();


                  {$region 'Animacja toniêcia statku.'}
                  if zt_statek.punkty_¿ycia <= 0 then
                    begin

                      if zt_statek.toniêcie__prêdkoœæ_w_dó³ = 0 then
                        begin

                          // Ustalenie wspó³czynników toniêcia (jeden raz).

                          zt_statek.toniêcie__obrót__lewo_prawo := (  Random( 20 ) + 1  ) * 0.01; // Od 0.01 do 0.2.
                          zt_statek.toniêcie__obrót__przód_ty³ := (  Random( 10 ) + 1  ) * 0.01; // Od 0.001 do 0.01.
                          zt_statek.toniêcie__prêdkoœæ_w_dó³ := (  Random( 10 ) + 1  ) * 0.001; // Od 0.01 do 0.1.


                          if Random( 2 ) = 0 then
                            zt_statek.toniêcie__obrót__lewo_prawo := -zt_statek.toniêcie__obrót__lewo_prawo;

                          if Random( 2 ) = 0 then
                            zt_statek.toniêcie__obrót__przód_ty³ := -zt_statek.toniêcie__obrót__przód_ty³;


                          zt_statek.toniêcie__czas_i := Czas_Teraz();

                        end;
                      //---//if zt_statek.toniêcie__prêdkoœæ_w_dó³ = 0 then


                      //zt_statek.PitchAngle := zt_statek.PitchAngle + 0.2; // Góra (+).
                      //zt_statek.RollAngle := zt_statek.RollAngle + 0.01; // Prawo (+).
                      //zt_statek.Lift( -0.005 ); // Dó³ (-). // Po obrocie przesuwa prostopadle do dna statku a nie w dó³ sceny.
                      //zt_statek.Position.Y := zt_statek.Position.Y - 0.01;

                      if zt_statek.Position.Y > Dno_Kolizje_GLCube.Position.Y then // Aby siê nie krêci³ na dnie.
                        begin

                          zt_statek.PitchAngle := zt_statek.PitchAngle + zt_statek.toniêcie__obrót__przód_ty³ * gra_wspó³czynnik_prêdkoœci_g; // Góra (+).
                          zt_statek.RollAngle := zt_statek.RollAngle + zt_statek.toniêcie__obrót__lewo_prawo * gra_wspó³czynnik_prêdkoœci_g; // Prawo (+).
                          zt_statek.Position.Y := zt_statek.Position.Y - zt_statek.toniêcie__prêdkoœæ_w_dó³ * gra_wspó³czynnik_prêdkoœci_g;

                          if zt_statek.Position.Y > 0 then // Zanim wytraci prêdkoœæ, przy pewnym obrocie, mo¿e wzlecieæ ponad wodê.
                            zt_statek.Position.Y := 0;

                        end;
                      //---//if zt_statek.Position.Y > Dno_Kolizje_GLCube.Position.Y then

                      //zt_statek.Lift( -0.005 ); // Dó³ (-). // Po obrocie przesuwa prostopadle do dna statku a nie w dó³ sceny.


                      if Czas_Miêdzy_W_Sekundach( zt_statek.toniêcie__czas_i ) * gra_wspó³czynnik_prêdkoœci_g > oczekiwanie_na_odnowienie_statku_czas_c then //  oczekiwanie_na_odnowienie_statku_czas_c / gra_wspó³czynnik_prêdkoœci_g //???
                        begin

                          i := Gra_Statystyki_R_Identyfikator_ZnajdŸ( zt_statek.id_statek );

                          if i >= 0 then
                            begin

                              gra_statystyki_r_t[ i ].zatoniêcia := gra_statystyki_r_t[ i ].zatoniêcia + 1;

                            end;
                          //---//if zti >= 0 then


                          zt_statek.czy_usun¹æ_statek := true;

                        end;
                      //---//if Czas_Miêdzy_W_Sekundach( zt_statek.toniêcie__czas_i ) * gra_wspó³czynnik_prêdkoœci_g > oczekiwanie_na_odnowienie_statku_czas_c then

                    end;
                  //---//if zt_statek.punkty_¿ycia <= 0 then
                  {$endregion 'Animacja toniêcia statku.'}

                end;
              //---//if not czy_klient_g then


              zt_statek.Punkty_¯ycia_WskaŸnik_Rysuj( Gra_GLCamera, 3 );


              {$region 'Falowanie statku.'}
              if zt_statek.falowanie_opóŸnienie <= 0 then
                begin

                  //zt_statek.falowanie_bok_wychylenie_aktualne := zt_statek.falowanie_bok_wychylenie_aktualne + 50 * gra_wspó³czynnik_prêdkoœci_g * delta_czasu_f;
                  zt_statek.falowanie_bok_wychylenie_aktualne := zt_statek.falowanie_bok_wychylenie_aktualne + (  25 + Random( 26 )  ) * gra_wspó³czynnik_prêdkoœci_g * delta_czasu_f; // Aby falowanie by³o bardziej zmienne.

                  if zt_statek.falowanie_bok_wychylenie_aktualne >= 360 then
                    begin

                      //zt_statek.falowanie_bok_wychylenie_aktualne := 0;
                      zt_statek.falowanie_bok_wychylenie_aktualne := zt_statek.falowanie_bok_wychylenie_aktualne - 360;
                      //zt_statek.falowanie_bok_zakres := Random( 10 );

                    end;
                  //---//if zt_statek.falowanie_bok_wychylenie_aktualne >= 360 then


                  ztr := zt_statek.falowanie_bok_zakres * Morze_Wzburzenie_SpinEdit.Value * 0.01;

                  if ztr > 60 then
                    ztr := 60;

                  zt_statek.falowanie_dummy.RollAngle := Sin(  DegToRad( zt_statek.falowanie_bok_wychylenie_aktualne ) ) * ztr + zt_statek.falowanie_bok_skrêt;


                  //zt_statek.falowanie_przód_wychylenie_aktualne := zt_statek.falowanie_przód_wychylenie_aktualne + 50 * gra_wspó³czynnik_prêdkoœci_g * delta_czasu_f;
                  zt_statek.falowanie_przód_wychylenie_aktualne := zt_statek.falowanie_przód_wychylenie_aktualne + (  25 + Random( 26 )  ) * gra_wspó³czynnik_prêdkoœci_g * delta_czasu_f; // Aby falowanie by³o bardziej zmienne.

                  if zt_statek.falowanie_przód_wychylenie_aktualne >= 360 then
                    begin

                      //zt_statek.falowanie_przód_wychylenie_aktualne := 0;
                      zt_statek.falowanie_przód_wychylenie_aktualne := zt_statek.falowanie_przód_wychylenie_aktualne - 360;
                      //zt_statek.falowanie_przód_zakres := Random( 10 );

                    end;
                  //---//if zt_statek.falowanie_przód_wychylenie_aktualne >= 360 then


                  ztr := zt_statek.falowanie_przód_zakres * Morze_Wzburzenie_SpinEdit.Value * 0.01;

                  if ztr > 45 then
                    ztr := 45;

                  zt_statek.falowanie_dummy.PitchAngle := Sin(  DegToRad( zt_statek.falowanie_przód_wychylenie_aktualne ) ) * ztr + zt_statek.falowanie_przód_ruch; // Gdy w przód to unosi przód i odwrotnie dla ty³u (aby oba koñce tak samo unosi³o nale¿y zapisaæ w nawiasie ( zt_statek.falowanie_przód_zakres + zt_statek.falowanie_przód_ruch ) ).


                  //zt_statek.falowanie_góra_dó³_wysokoœæ_aktualna := zt_statek.falowanie_góra_dó³_wysokoœæ_aktualna + 50 * gra_wspó³czynnik_prêdkoœci_g * delta_czasu_f;
                  zt_statek.falowanie_góra_dó³_wysokoœæ_aktualna := zt_statek.falowanie_góra_dó³_wysokoœæ_aktualna + (  25 + Random( 26 )  ) * gra_wspó³czynnik_prêdkoœci_g * delta_czasu_f;

                  if zt_statek.falowanie_góra_dó³_wysokoœæ_aktualna >= 360 then
                    zt_statek.falowanie_góra_dó³_wysokoœæ_aktualna := zt_statek.falowanie_góra_dó³_wysokoœæ_aktualna - 360;

                  ztr := zt_statek.falowanie_góra_dó³_zakres * Morze_Wzburzenie_SpinEdit.Value * 0.01;
                  zt_statek.falowanie_dummy.Position.Y := Sin(  DegToRad( zt_statek.falowanie_góra_dó³_wysokoœæ_aktualna ) ) * ztr;

                end
              else//if zt_statek.falowanie_opóŸnienie <= 0 then
                begin

                  if Czas_Teraz_W_Milisekundach() >= zt_statek.falowanie_opóŸnienie then
                    begin

                      zt_statek.falowanie_bok_wychylenie_aktualne := Random( 26 ); // Aby falowanie by³o bardziej zmienne.
                      zt_statek.falowanie_góra_dó³_wysokoœæ_aktualna := Random( 26 ); // Aby falowanie by³o bardziej zmienne.
                      zt_statek.falowanie_przód_wychylenie_aktualne := Random( 26 ); // Aby falowanie by³o bardziej zmienne.

                      zt_statek.falowanie_opóŸnienie := 0;

                    end;
                  //---//if Czas_Teraz_W_Milisekundach() >= zt_statek.falowanie_opóŸnienie then

                end;
              //---//if zt_statek.falowanie_opóŸnienie <= 0 then
              {$endregion 'Falowanie statku.'}

            end
          else//if not zt_statek.czy_usun¹æ_statek then
            begin

              // czy_usun¹æ_statek - tak.


              {$region 'Animacja toniêcia statku.'}
              // To jest raczej nie potrzebne. //???
              //if zt_statek.Position.Y > dno_poziom_c then
              //  zt_statek.Position.Y := zt_statek.Position.Y - zt_statek.toniêcie__prêdkoœæ_w_dó³;

              if zt_statek.Position.Y > 0 then // Zanim wytraci prêdkoœæ, przy pewnym obrocie, mo¿e wzlecieæ ponad wodê.
                zt_statek.Position.Y := 0;
              {$endregion 'Animacja toniêcia statku.'}


              Statek_Przywróæ_Do_Gry( zt_statek );

            end;
          //---//if not zt_statek.czy_usun¹æ_statek then

        end;
      //---//if zt_statek <> nil then

    end;
  //---//for i_s := 0 to Length( statki_t ) - 1 do

  Amunicja_Ruch( delta_czasu_f );

end;//---//Funkcja Statki_Ruch().

//Funkcja Amunicja_Ruch().
procedure TStatki_Form.Amunicja_Ruch( delta_czasu_f : double );
var
  i,
  zti
    : integer;
  ztr,
  lot_parabol¹__k¹ta_opadania__przed_namierzaniem_modyfikator_l // Zale¿nie od ustawionego procentu zasiêgu celu artylerii modyfikuje k¹t do jakiego pochylaæ amunicjê przed rozpoczêciem nakierowywania na cel.
    : real;
  zts : string;
  zt_vector : GLVectorGeometry.TVector;
  zt_amunicja : TAmunicja;
begin

  if   ( amunicja_wystrzelona_list = nil )
    or (  not Assigned( amunicja_wystrzelona_list )  ) then
    Exit;


  if czy_klient_g then
    Exit;


  for i := amunicja_wystrzelona_list.Count - 1 downto 0 do
    begin

      zt_amunicja := TAmunicja(amunicja_wystrzelona_list[ i ]);

      if zt_amunicja <> nil then
        begin

          // Gdy osi¹gnie odpowiedni¹ g³êbokoœæ jest usuwany (na wypadek gdyby nie dotknê³a dna).
          //if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y <= Dno_GLPlane.AbsolutePosition.Y - 1 then
          if zt_amunicja.AbsolutePosition.Y <= Dno_GLPlane.AbsolutePosition.Y - 1 then
            zt_amunicja.czy_usun¹æ_amunicja := true;


          if zt_amunicja.czy_usun¹æ_amunicja then
            Amunicja_Wystrzelona_Zwolnij_Jeden( zt_amunicja )
          else//if zt_amunicja.czy_usun¹æ_amunicja then
            begin

              {$region 'Ruch do przodu.'}
              if not zt_amunicja.czy_poza_luf¹ then
                ztr := zt_amunicja.prêdkoœæ // Amunicjê jest w lufie.
              else//if not zt_amunicja.czy_poza_luf¹ then
                ztr := zt_amunicja.prêdkoœæ * zt_amunicja.skala; // Amunicja jest poza luf¹. // Dzia³o mo¿e byæ skalowane. Koryguje wartoœæ o skalê dzia³a, wp³ywa na szybkoœæ ruchu amunicji.

              ztr := ztr * delta_czasu_f * gra_wspó³czynnik_prêdkoœci_g;
              
              if    (  not ( zt_amunicja.amunicja_rodzaj in [ ar_Torpeda ] )  )
                and ( not zt_amunicja.czy_lot_parabol¹ ) then
                begin

                  // Nie torpeda, nie parabola.

                  zt_amunicja.Move( ztr );

                end
              else//if not ( zt_amunicja.amunicja_rodzaj in [ ar_Torpeda ] ) then
                begin

                  // Torpeda, parabola.

                  if zt_amunicja.Parent <> Gra_Obiekty_GLDummyCube then
                    zt_amunicja.Move( ztr ) // Amunicja w lufie.
                  else//if zt_amunicja.Parent <> Gra_Obiekty_GLDummyCube then
                    begin

                      // Amunicja poza luf¹.

                      zt_amunicja.Position.AddScaledVector( ztr, zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.AbsoluteDirection );
                      zt_amunicja.TransformationChanged();

                    end;
                  //---//if zt_amunicja.Parent <> Gra_Obiekty_GLDummyCube then

                end;
              //---//if not ( zt_amunicja.amunicja_rodzaj in [ ar_Torpeda ] ) then
              {$endregion 'Ruch do przodu.'}


              if zt_amunicja.torpeda_efekt_na_wodzie <> nil then
                zt_amunicja.torpeda_efekt_na_wodzie.Position.AsVector := VectorMake(  zt_amunicja.korpus.AbsolutePosition.X, 0 + ( Random() - 0.5 ) * 0.25, zt_amunicja.korpus.AbsolutePosition.Z  );


              if not zt_amunicja.czy_poza_zasiêgiem then
                begin

                  // W skutecznym zasiêgu.

                  {$region 'Czy poza zasiêgiem.'}
                  //if zt_amunicja.DistanceTo( zt_amunicja.pozycja_startowa ) > zt_amunicja.zasiêg then
                  if   (     // Dla lotu liniowego poza zasiêgiem jest gdy wyleci poza swój zasiêg.
                             (
                                  (
                                        ( zt_amunicja.amunicja_rodzaj in [ ar_Artyleria, ar_Pocisk ] )
                                    and ( not zt_amunicja.czy_lot_parabol¹ )
                                  )
                               or (  not ( zt_amunicja.amunicja_rodzaj in [ ar_Artyleria, ar_Pocisk ] )  )
                             )
                         and ( zt_amunicja.DistanceTo( zt_amunicja.pozycja_startowa ) > zt_amunicja.zasiêg )
                       )
//                    or (     // Dla lotu parabolicznego poza zasiêgiem jest gdy znajdzie siê pod pod³o¿em. // A Je¿eli leci (pionowo) w górê to nie znajdzie siê pod pod³o¿em.
//                             ( zt_amunicja.amunicja_rodzaj in [ ar_Artyleria, ar_Pocisk ] )
//                         and ( zt_amunicja.czy_lot_parabol¹ )
//                         and ( zt_amunicja.AbsolutePosition.Y <= Dno_GLPlane.AbsolutePosition.Y )
//                       )
//                    or (     // Dla lotu parabolicznego poza zasiêgiem jest gdy wyleci poza swój zasiêg (liczony w poziomie). // A Je¿eli leci (pionowo) w górê to odleg³oœæ w poziomie mo¿e siê prawie nie zmieniaæ.
//                             ( zt_amunicja.amunicja_rodzaj in [ ar_Artyleria, ar_Pocisk ] )
//                         and ( zt_amunicja.czy_lot_parabol¹ )
//                         and (   zt_amunicja.pozycja_startowa.DistanceTo(  GLVectorGeometry.VectorMake( zt_amunicja.AbsolutePosition.X, zt_amunicja.pozycja_startowa.AbsolutePosition.Y, zt_amunicja.AbsolutePosition.Z )  ) > zt_amunicja.zasiêg   )
//                       )
                    or (
                             ( zt_amunicja.amunicja_rodzaj in [ ar_Artyleria, ar_Pocisk ] )
                         and ( zt_amunicja.czy_lot_parabol¹ )
                         //and ( zt_amunicja.DistanceTo( zt_amunicja.pozycja_startowa ) > zt_amunicja.zasiêg )
                         and (
                                  ( zt_amunicja.pozycja_woda.DistanceTo( zt_amunicja.pozycja_startowa ) > zt_amunicja.zasiêg )
                               or ( zt_amunicja.DistanceTo( zt_amunicja.pozycja_startowa ) > zt_amunicja.zasiêg * 1.5 ) // Je¿eli leci pionowo w górê.
                             )
                       )
                    then
                    begin

                      zt_amunicja.czy_poza_zasiêgiem := true;

                      zt_amunicja.opadanie_obrót_korekta_o_k¹t_na_granicy_zasiêgu := zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle;

                      zt_amunicja.korpus.Material.FrontProperties.Ambient.Color := clrBlack; //???

                    end;
                  //---//if   ( (...)
                  {$endregion 'Czy poza zasiêgiem.'}


                  {$region 'Przesuwa i obraca amunicjê razem ze statkiem - wersja 1.'}
                  //if zt_amunicja.statek <> nil then
                  //  begin
                  //
                  //    //zt_amunicja.statek_obrót := statek_obrót_f;
                  //    //zt_amunicja.czy_statek_dane := true;
                  //
                  //
                  //    if zt_amunicja.korpus.DistanceTo( zt_amunicja.pozycja_startowa.AbsolutePosition ) <= zt_amunicja.strza³_od_blokada_dystans then
                  //      begin
                  //
                  //        // Amunicjê jest w lufie.
                  //
                  //        zt_amunicja.statek_prêdkoœæ := zt_amunicja.statek.prêdkoœæ_aktualna;
                  //
                  //
                  //        // Obraca amunicjê gdy amunicja jest w lufie.
                  //
                  //        //zt_amunicja.Turn( zt_amunicja.statek.prêdkoœæ_obrotu_aktualna );
                  //        zt_amunicja.TurnAngle := zt_amunicja.TurnAngle - zt_amunicja.statek.prêdkoœæ_obrotu_aktualna;
                  //        zt_amunicja.korpus.Material.FrontProperties.Ambient.Color := clrGreen; //???
                  //
                  //      end
                  //    else//if zt_amunicja.korpus.DistanceTo( zt_amunicja.pozycja_startowa.AbsolutePosition ) <= zt_amunicja.strza³_od_blokada_dystans then
                  //      begin
                  //
                  //        // Amunicjê jest poza luf¹.
                  //
                  //        if not zt_amunicja.czy_poza_luf¹ then
                  //          zt_amunicja.czy_poza_luf¹ := true;
                  //
                  //
                  //        zt_amunicja.korpus.Material.FrontProperties.Ambient.Color := clrRed; //???
                  //
                  //        //if zt_amunicja.pozycja_startowa.AbsolutePosition.Y <> 0 then
                  //          //???zt_amunicja.pozycja_startowa.Position.Y := zt_amunicja.pozycja_startowa.AbsoluteToLocal( GLVectorGeometry.TVector(0, 0, 0) ).Y; // Zawsze poziom wody.
                  //        //  zt_amunicja.pozycja_startowa.Position.Y := 0;
                  //
                  //
                  //        if Abs( zt_amunicja.statek_prêdkoœæ ) > 0 then
                  //          begin
                  //
                  //            // Zmniejsza wspó³czynnik prêdkoœci statku gdy amunicja poza luf¹.
                  //
                  //            ztr := Abs( zt_amunicja.statek_prêdkoœæ ) * gra_wspó³czynnik_prêdkoœci_g;
                  //
                  //            if zt_amunicja.statek_prêdkoœæ < 0 then
                  //              ztr := -ztr;
                  //
                  //            zt_amunicja.statek_prêdkoœæ := zt_amunicja.statek_prêdkoœæ - ztr;
                  //
                  //
                  //            if Abs( zt_amunicja.statek_prêdkoœæ ) < 0.001 then
                  //              zt_amunicja.statek_prêdkoœæ := 0;
                  //
                  //          end;
                  //        //---//if Abs( zt_amunicja.statek_prêdkoœæ ) > 0 then
                  //
                  //      end;
                  //    //---//if zt_amunicja.korpus.DistanceTo( zt_amunicja.pozycja_startowa.AbsolutePosition ) <= zt_amunicja.strza³_od_blokada_dystans then
                  //
                  //
                  //    if Abs( zt_amunicja.statek_prêdkoœæ ) > 0 then
                  //      begin
                  //
                  //        // Przesuwa amunicjê o prêdkoœæ ruchu statku.
                  //
                  //        //zt_amunicja.Position.AddScaledVector( zt_amunicja.statek_prêdkoœæ, zt_amunicja.statek_kierunek );
                  //        //zt_amunicja.Position.AddScaledVector( zt_amunicja.statek_prêdkoœæ, statek_gracza.AbsoluteDirection );
                  //        zt_amunicja.Position.AddScaledVector( zt_amunicja.statek_prêdkoœæ, zt_amunicja.statek.AbsoluteDirection );
                  //        zt_amunicja.TransformationChanged();
                  //
                  //      end;
                  //    //---//if Abs( zt_amunicja.statek_prêdkoœæ ) > 0 then
                  //
                  //  end;
                  ////---//if zt_amunicja.statek <> nil then
                  {$endregion 'Przesuwa i obraca amunicjê razem ze statkiem - wersja 1.'}


                  if    ( not zt_amunicja.czy_poza_luf¹ )
                    and (  zt_amunicja.korpus.DistanceTo( zt_amunicja.pozycja_startowa.AbsolutePosition ) > zt_amunicja.strza³_od_blokada_dystans  ) then
                    begin

                      // Amunicja opuszcza lufê.

                      zt_amunicja.czy_poza_luf¹ := true;

                      zt_amunicja.korpus.Material.FrontProperties.Ambient.Color := clrYellow; //???


                      {$region 'Po opuszczeniu lufy amunicja zmienia rodzica.'}
                      // Istotna jest wartoœæ nie w momencie strza³u tylko w momencie opuszczenia lufy (ze wzglêdu na falowanie statku).
                      zt_amunicja.opadanie_obrót_korekta_o_ustawienie_pocz¹tkowe :=
                        RadToDeg( // uses Math.
                            AngleBetweenVectors( // uses GLVectorGeometry.
                               GLVectorGeometry.VectorMake(  zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.AbsoluteDirection.X, Abs( zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.AbsoluteDirection.Y ), zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.AbsoluteDirection.Z  ),
                               GLVectorGeometry.VectorMake( zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.AbsoluteDirection.X, 0, zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.AbsoluteDirection.Z ),
                               GLVectorGeometry.VectorMake( 0, 0, 0 )
                             )
                          );

                      if zt_amunicja.AbsoluteDirection.Y < 0 then
                        zt_amunicja.opadanie_obrót_korekta_o_ustawienie_pocz¹tkowe := -zt_amunicja.opadanie_obrót_korekta_o_ustawienie_pocz¹tkowe;


                      zt_amunicja.pozycja_startowa.Parent := Gra_Obiekty_GLDummyCube;
                      zt_amunicja.pozycja_startowa.AbsolutePosition := zt_amunicja.AbsolutePosition; // Tutaj tymczasowo zapamiêtuje aktualny kierunek amunicji.
                      zt_amunicja.pozycja_startowa.AbsoluteDirection := zt_amunicja.AbsoluteDirection; // Tutaj tymczasowo zapamiêtuje bezwzglêdn¹ górê amunicji.
                      zt_amunicja.pozycja_startowa.AbsoluteUp := zt_amunicja.AbsoluteUp;

                      zt_vector := zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.AbsoluteUp;


                      zt_amunicja.Parent := Gra_Obiekty_GLDummyCube; // Po zmianie rodzica amunicja:
                      zt_amunicja.AbsolutePosition := zt_amunicja.pozycja_startowa.AbsolutePosition; // jest w tej samej bezwzglêdnej pozycji;
                      zt_amunicja.AbsoluteDirection := zt_amunicja.pozycja_startowa.AbsoluteDirection; // zachowuje ten sam bezwzglêdny kierunek;
                      zt_amunicja.AbsoluteUp := zt_amunicja.pozycja_startowa.AbsoluteUp; // bezwzglêdna góra znajduje siê w tym samym miejscu (kierunku).

                      if zt_amunicja.czy_lot_parabol¹ then
                        zt_amunicja.pozycja_startowa.AbsolutePosition := zt_amunicja.dzia³o_pozycja_absolutna_vector;

                      zt_amunicja.korpus_opadanie_obrót_dummy.AbsoluteDirection := zt_amunicja.AbsoluteDirection;
                      zt_amunicja.korpus_opadanie_obrót_dummy.AbsoluteUp := GLVectorGeometry.VectorMake( 0, 1, 0 );

                      zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.AbsoluteDirection := zt_amunicja.AbsoluteDirection;
                      zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.AbsoluteUp := zt_vector;


                      // Wylicza pozycjê wskaŸnika celu.
                      zt_amunicja.pozycja_celu.AbsoluteDirection := zt_amunicja.AbsoluteDirection;
                      zt_amunicja.pozycja_celu.Direction.Y := 0;
                      zt_amunicja.pozycja_celu.Move( zt_amunicja.cel_odleg³oœæ );
                      //---// Wylicza pozycjê wskaŸnika celu.


                      zti := Gra_Statystyki_R_Identyfikator_ZnajdŸ( zt_amunicja.id_statek );

                      if zti >= 0 then
                        begin

                          gra_statystyki_r_t[ zti ].amunicja_wystrzelona_iloœæ := gra_statystyki_r_t[ zti ].amunicja_wystrzelona_iloœæ + 1;
                          gra_statystyki_r_t[ zti ].amunicja_wystrzelona_obra¿enia_zadawane := gra_statystyki_r_t[ zti ].amunicja_wystrzelona_obra¿enia_zadawane + zt_amunicja.obra¿enia_zadawane;

                        end;
                      //---//if zti >= 0 then
                      {$endregion 'Po opuszczeniu lufy amunicja zmienia rodzica.'}


                      zt_amunicja.Scale.Scale( zt_amunicja.skala );


                      zt_amunicja.czy_pod_wod¹ := zt_amunicja.AbsolutePosition.Y < 0;
                      zt_amunicja.czy_wynurzanie := zt_amunicja.czy_pod_wod¹;


                      if zt_amunicja.statek <> nil then
                        begin

                          zt_amunicja.statek_prêdkoœæ := zt_amunicja.statek.prêdkoœæ_aktualna;
                          zt_amunicja.pozycja_startowa.AbsoluteDirection := zt_amunicja.statek.AbsoluteDirection; // Tutaj zapamiêtuje aktualny kierunek statku.

                        end;
                      //---//if zt_amunicja.statek <> nil then


                      zts := Amunicja__Zanurzenie_G³êbokoœæ_Zadana_Edit.Text;
                      zts := StringReplace( zts, ' ', '', [ rfReplaceAll ] );
                      zts := StringReplace( zts, '.', ',', [ rfReplaceAll ] );

                      try
                        zt_amunicja.zanurzenie_g³êbokoœæ_zadana := StrToFloat( zts );
                      except
                      end;
                      //---//try


                      if    ( zt_amunicja.czy_lot_parabol¹ ) // Taki sam warunek pozycja_celu_Visible.
                        and ( Amunicja__Cel_Pozycja_Dla_Lotu_Parabol¹_Wyœwietl_CheckBox.Checked )
                        and ( not zt_amunicja.pozycja_celu.Visible )
                        and (
                                 ( zt_amunicja.id_statek = Gracz_Identyfikator() )
                              or ( // Gdy gra nie jest rozpoczêta.
                                       ( Wieloosobowe_Identyfikator_Edit.Text = '' )
                                   and ( zt_amunicja.id_statek = 0 )
                                 )
                            ) then
                        zt_amunicja.pozycja_celu.Visible := true;

                    end;
                  //---//if    ( not zt_amunicja.czy_poza_luf¹ ) (...)


                  if zt_amunicja.czy_poza_luf¹ then
                    begin

                      // Amunicja jest poza luf¹.

                      {$region 'Przesuwa i obraca amunicjê razem ze statkiem.'}
                      //??? po opuszczeniu lufy gdy statek p³ynie amunicja wyprzedza statek (1 skok)
                      if Abs( zt_amunicja.statek_prêdkoœæ ) > 0 then
                        begin

                          // Zmniejsza wspó³czynnik prêdkoœci statku gdy amunicja jest poza luf¹.

                          ztr := Abs( zt_amunicja.statek_prêdkoœæ ) * 0.01 * gra_wspó³czynnik_prêdkoœci_g;

                          if zt_amunicja.statek_prêdkoœæ > 0 then
                            zt_amunicja.statek_prêdkoœæ := zt_amunicja.statek_prêdkoœæ - ztr
                          else//if zt_amunicja.statek_prêdkoœæ > 0 then
                            zt_amunicja.statek_prêdkoœæ := zt_amunicja.statek_prêdkoœæ + ztr;


                          if Abs( zt_amunicja.statek_prêdkoœæ ) < 0.001 then
                            zt_amunicja.statek_prêdkoœæ := 0;

                        end;
                      //---//if Abs( zt_amunicja.statek_prêdkoœæ ) > 0 then


                      if Abs( zt_amunicja.statek_prêdkoœæ ) > 0 then
                        begin

                          // Przesuwa amunicjê o prêdkoœæ ruchu statku.

                          //zt_amunicja.Position.AddScaledVector( zt_amunicja.statek_prêdkoœæ, zt_amunicja.statek_kierunek );
                          //zt_amunicja.Position.AddScaledVector( zt_amunicja.statek_prêdkoœæ, statek_gracza.AbsoluteDirection );
                          zt_amunicja.Position.AddScaledVector( zt_amunicja.statek_prêdkoœæ * delta_czasu_f * gra_wspó³czynnik_prêdkoœci_g, zt_amunicja.pozycja_startowa.AbsoluteDirection );
                          zt_amunicja.TransformationChanged();

                        end;
                      //---//if Abs( zt_amunicja.statek_prêdkoœæ ) > 0 then
                      {$endregion 'Przesuwa i obraca amunicjê razem ze statkiem.'}


                      if zt_amunicja.amunicja_rodzaj in [ ar_Artyleria, ar_Pocisk ] then
                        begin

                          // Artyleria, pocisk.

                          {$region 'Wysokoœæ i obrót dla ruchu parabol¹.'}
                          if zt_amunicja.amunicja_rodzaj = ar_Artyleria then
                            begin

                              // Artyleria.

                              if zt_amunicja.czy_lot_parabol¹ then
                                begin

                                  if zt_amunicja.Tag = 0 then
                                    begin

                                      ztr := zt_amunicja.pozycja_startowa.DistanceTo( zt_amunicja.pozycja_woda ); // Odleg³oœæ od pozycji startowej w poziomie.

                                      if ztr >= zt_amunicja.cel_odleg³oœæ * lot_parabol¹__k¹ta_opadania__odleg³oœæ_od_procent_c then
                                        begin

                                          zt_amunicja.Tag := 1;

                                          // K¹t pod jakim amunicja leci wzglêdem wody w momencie kiedy amunicja zaczyna opadaæ w locie parabol¹.
                                          zt_amunicja.korpus_opadanie_obrót_dummy.TagFloat := RadToDeg(  AngleBetweenVectors( zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.AbsoluteDirection, GLVectorGeometry.VectorMake( zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.AbsoluteDirection.X, 0, zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.AbsoluteDirection.Z ), GLVectorGeometry.VectorMake( 0, 0, 0 ) )  );

                                        end;
                                      //---//if ztr >= zt_amunicja.cel_odleg³oœæ * lot_parabol¹__k¹ta_opadania__odleg³oœæ_od_procent_c then

                                    end;
                                  //---//if zt_amunicja.Tag = 0 then


                                  if zt_amunicja.Tag = 1 then
                                    begin

                                      ztr := zt_amunicja.pozycja_startowa.DistanceTo( zt_amunicja.pozycja_woda ); // Odleg³oœæ od pozycji startowej w poziomie.

                                      if ztr >= zt_amunicja.cel_odleg³oœæ * 0.9 then
                                        if zt_amunicja.dzia³o_podniesienie_procent_k¹ta_maksymalnego >= 70 then
                                          zt_amunicja.Tag := 2
                                        else//if zt_amunicja.dzia³o_podniesienie_procent_k¹ta_maksymalnego >= 48 then
                                          zt_amunicja.Tag := 2; // Dla bliskiego dystansu nie naprowadza amunicji na cel.


                                      if zt_amunicja.dzia³o_podniesienie_procent_k¹ta_maksymalnego <= 33 then
                                        lot_parabol¹__k¹ta_opadania__przed_namierzaniem_modyfikator_l := ( 2 * zt_amunicja.dzia³o_podniesienie_procent_k¹ta_maksymalnego / 100 )
                                      else//if zt_amunicja.dzia³o_podniesienie_procent_k¹ta_maksymalnego <= 38 then
                                      if zt_amunicja.dzia³o_podniesienie_procent_k¹ta_maksymalnego <= 66 then
                                        lot_parabol¹__k¹ta_opadania__przed_namierzaniem_modyfikator_l := ( 1.5 * zt_amunicja.dzia³o_podniesienie_procent_k¹ta_maksymalnego / 100 )
                                      else//if zt_amunicja.dzia³o_podniesienie_procent_k¹ta_maksymalnego <= 58 then
                                        lot_parabol¹__k¹ta_opadania__przed_namierzaniem_modyfikator_l := 1;


                                      // Podczas przelatywania zadanego odcinka obni¿a k¹t lotu z pozycji pocz¹tkowej (po wystrzeleniu) do koñcowej (opadania).
                                      zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle :=
                                          ( -lot_parabol¹__k¹ta_opadania__przed_namierzaniem_c - zt_amunicja.korpus_opadanie_obrót_dummy.TagFloat ) // K¹t o jaki nale¿y zmieniæ pochylenie.
                                        * lot_parabol¹__k¹ta_opadania__przed_namierzaniem_modyfikator_l
                                        * (   ( ztr - zt_amunicja.cel_odleg³oœæ * lot_parabol¹__k¹ta_opadania__odleg³oœæ_od_procent_c ) // Pocz¹tek odcinka, na którym nale¿y zmieniæ k¹t (aktualna odleg³oœæ minus odleg³oœæ pocz¹tku odcinka zmiany k¹ta).
                                        * 100
                                        / ( zt_amunicja.cel_odleg³oœæ * lot_parabol¹__k¹ta_opadania__odleg³oœæ_od_odcinek_zmiany_k¹ta_procent_c )  ) // Odcinek, na którym nale¿y zmieniæ k¹t.
                                        * 0.01;


                                      //// K¹t na cel z aktualnego po³o¿enia amunicji.
                                      //GLVectorGeometry.SetVector
                                      //  (
                                      //      zt_vector
                                      //      // Cel                 Obiekt celuj¹cy
                                      //    , zt_amunicja.pozycja_celu.AbsolutePosition.X - zt_amunicja.AbsolutePosition.X
                                      //    , zt_amunicja.pozycja_celu.AbsolutePosition.Y - zt_amunicja.AbsolutePosition.Y
                                      //    , zt_amunicja.pozycja_celu.AbsolutePosition.Z - zt_amunicja.AbsolutePosition.Z
                                      //  );
                                      //
                                      //// K¹t miêdzy kierunkiem lotu amunicji a kierunkiem na cel z aktualnego po³o¿enia amunicji.
                                      //ztr := RadToDeg(  AngleBetweenVectors( zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.AbsoluteDirection, zt_vector, GLVectorGeometry.VectorMake( 0, 0, 0 ) )  );

                                    end
                                  else//if zt_amunicja.Tag = 1 then
                                  if zt_amunicja.Tag in [ 2, 3 ] then
                                    begin

                                      if zt_amunicja.korpus.AbsolutePosition.Y <= zt_amunicja.pozycja_celu.AbsolutePosition.Y then
                                        zt_amunicja.Tag := 4;

                                      if zt_amunicja.Tag <> 4 then
                                        begin

                                          if zt_amunicja.Tag <> 3 then
                                            ztr := zt_amunicja.pozycja_startowa.DistanceTo( zt_amunicja.pozycja_woda ); // Odleg³oœæ od pozycji startowej w poziomie.

                                          if   ( zt_amunicja.Tag = 3 )
                                            or (  ztr > zt_amunicja.cel_odleg³oœæ * ( lot_parabol¹__k¹ta_opadania__odleg³oœæ_od_procent_c + lot_parabol¹__k¹ta_opadania__odleg³oœæ_od_odcinek_zmiany_k¹ta_procent_c )  ) then
                                            begin

                                              zt_amunicja.Tag := 3; // Ogranicza iloœæ obliczeñ.

                                              // Nakierowuje amunicjê na cel (jak rakietê).
                                              zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.AbsoluteDirection := GLVectorGeometry.VectorMake
                                                (
                                                    // Cel                 Obiekt celuj¹cy
                                                    zt_amunicja.pozycja_celu.AbsolutePosition.X - zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.AbsolutePosition.X
                                                  , zt_amunicja.pozycja_celu.AbsolutePosition.Y - zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.AbsolutePosition.Y
                                                  , zt_amunicja.pozycja_celu.AbsolutePosition.Z - zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.AbsolutePosition.Z
                                                );

                                              //zt_amunicja.korpus.Material.FrontProperties.Ambient.SetColor( 10, 0, 0 ); // Test.

                                            end;
                                          //---//if   ( zt_amunicja.Tag = 3 ) (...)


                                          ztr := zt_amunicja.DistanceTo( zt_amunicja.pozycja_celu ); // Odleg³oœæ amunicji do celu.

                                          if   ( ztr <= 1 )
                                            or ( ztr <= zt_amunicja.korpus.Height * 2 ) then
                                            zt_amunicja.Tag := 4;


                                          if zt_amunicja.Tag = 4  then
                                            begin

                                              zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.AbsoluteDirection := GLVectorGeometry.VectorMake( 0, -1, 0 ); // Zabezpieczenie aby poza kontrola naprowadzania amunicja lecia³a tylko w dó³.
                                              //zt_amunicja.korpus.Material.FrontProperties.Ambient.SetColor( 10, 10, 10 ); // Test.

                                            end;
                                          //---//if zt_amunicja.Tag = 4  then

                                        end;
                                      //---//if zt_amunicja.Tag <> 4 then

                                    end;
                                  //---//if zt_amunicja.Tag in [ 2, 3 ] then

                                end;
                              //---//if zt_amunicja.czy_opadanie_parabola then

                            end;
                          //---//if zt_amunicja.amunicja_rodzaj = ar_Artyleria then
                          {$endregion 'Wysokoœæ i obrót dla ruchu parabol¹.'}


                          {$region 'Wysokoœæ i obrót dla ruchu parabol¹ - wersja 1.'}
                          // Na podstawie punktów i równania paraboli.
                          //
                          //if zt_amunicja.amunicja_rodzaj = ar_Artyleria then
                          //  begin
                          //
                          //    // Artyleria.
                          //
                          //    if zt_amunicja.czy_lot_parabol¹ then
                          //      begin
                          //
                          //        //ztr := zt_amunicja.korpus.DistanceTo( zt_amunicja.pozycja_startowa.AbsolutePosition );
                          //
                          //        // Jest utworzony jako bezpoœredni potomek sceny.
                          //        zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.Position.X := zt_amunicja.AbsolutePosition.X;
                          //        zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.Position.Z := zt_amunicja.AbsolutePosition.Z;
                          //
                          //        // Dla paraboli wa¿na jest odleg³oœæ w linii prostej jako x dla równania na y ni¿ odleg³oœæ rzeczywista pocisku od lufy.
                          //        ztr := zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.DistanceTo( zt_amunicja.pozycja_startowa.AbsolutePosition );
                          //
                          //        //Statki_Form.Caption := FloatToStr( ztr );
                          //
                          //        zt_amunicja.Position.Y := zt_amunicja.parabola_równanie__a * Sqr( ztr ) + zt_amunicja.parabola_równanie__b * ztr + zt_amunicja.parabola_równanie__c;
                          //
                          //        //if zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle > -80 then
                          //          zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle := -zt_amunicja.parabola_k¹t_lotu_pocz¹tkowy - ztr * zt_amunicja.parabola_k¹t_lotu_wspó³czynnik; //???
                          //
                          //      end;
                          //    //---//if zt_amunicja.czy_opadanie_parabola then
                          //
                          //  end;
                          ////---//if zt_amunicja.amunicja_rodzaj = ar_Artyleria then
                          {$endregion 'Wysokoœæ i obrót dla ruchu parabol¹ - wersja 1.'}

                          {$region 'Wysokoœæ i obrót dla ruchu parabol¹ - wersja 2.'}
                          // Na podstawie d¹¿enia do zadanego k¹ta procentowo wzglêdem przebytej drogi z zadanej odleg³oœci (z uwzglêdnieniem zasiêgu dzia³a).
                          //
                          //if zt_amunicja.amunicja_rodzaj = ar_Artyleria then
                          //  begin
                          //
                          //    // Artyleria.
                          //
                          //    if zt_amunicja.czy_lot_parabol¹ then
                          //      begin
                          //
                          //        ztr := zt_amunicja.pozycja_startowa.DistanceTo(  GLVectorGeometry.VectorMake( zt_amunicja.AbsolutePosition.X, zt_amunicja.pozycja_startowa.AbsolutePosition.Y, zt_amunicja.AbsolutePosition.Z )  ); // Odleg³oœæ od pozycji startowej w poziomie.
                          //
                          //        // Obraca czubkiem w dó³ (im mniejszy dystans do celu tym k¹t jest bli¿szy 80).
                          //        //   Samo wykrywa, w któr¹ stronê obracaæ aby obraca³o siê czubkiem do do³u (najkrótsz¹ drog¹).
                          //        if    ( ztr <= zt_amunicja.cel_odleg³oœæ )
                          //          and ( zt_amunicja.cel_odleg³oœæ <> 0 )
                          //          and ( zt_amunicja.Tag = 0 ) then
                          //          zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle :=
                          //            // -( 80 + zt_amunicja.opadanie_obrót_korekta_o_ustawienie_pocz¹tkowe ) // K¹t docelowy 80 skorygowany o k¹t pocz¹tkowy.
                          //            // -( 60? + zt_amunicja.opadanie_obrót_korekta_o_ustawienie_pocz¹tkowe ) // K¹t docelowy 80 skorygowany o k¹t pocz¹tkowy. //??? daæ k¹t maksymalny podniesienia lufy + 10
                          //             -(  ( zt_amunicja.dzia³o_podniesienie_k¹t_maksymalny + zt_amunicja.dzia³o_podniesienie_k¹t_maksymalny * 0.3 ) + zt_amunicja.opadanie_obrót_korekta_o_ustawienie_pocz¹tkowe  )
                          //            * ( 100 * ztr / zt_amunicja.cel_odleg³oœæ ) // Procentowa modyfikacja wzglêdem odleg³oœci (odleg³oœæ od pozycji pocz¹tkowej jest bli¿sza odleg³oœci do celu si³a modyfikacji wzrasta do 100%).
                          //            * 0.01;
                          //
                          //      end;
                          //    //---//if zt_amunicja.czy_opadanie_parabola then
                          //
                          //  end;
                          ////---//if zt_amunicja.amunicja_rodzaj = ar_Artyleria then
                          {$endregion 'Wysokoœæ i obrót dla ruchu parabol¹ - wersja 2.'}

                        end
                      else//if zt_amunicja.amunicja_rodzaj in [ ar_Artyleria, ar_Pocisk ] then
                      if zt_amunicja.amunicja_rodzaj = ar_Torpeda then
                        begin

                          // Torpeda.

                          {$region 'Torpeda - zanurzanie i wynurzanie.'}
                          if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y > 0 then
                            begin

                              // Amunicja ponad wod¹.

                              if zt_amunicja.czy_wynurzanie then
                                zt_amunicja.czy_wynurzanie := false;

                              if zt_amunicja.czy_pod_wod¹ then
                                zt_amunicja.czy_pod_wod¹ := false;


                              // Obraca czubkiem w dó³.
                              //   Samo wykrywa, w któr¹ stronê obracaæ aby obraca³o siê czubkiem do do³u (najkrótsz¹ drog¹).
                              if zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle + zt_amunicja.opadanie_obrót_korekta_o_ustawienie_pocz¹tkowe > -45 then
                                zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle := zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle - gra_wspó³czynnik_prêdkoœci_g - delta_czasu_f
                              else//if zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle > -45 then
                                zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle := zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle + gra_wspó³czynnik_prêdkoœci_g + delta_czasu_f;


                              {$region 'Modyfikuje prêdkoœci lotu - w powietrzu amunicja zwalnia.'}
                              if zt_amunicja.prêdkoœæ > zt_amunicja.prêdkoœæ_wytracanie_wspó³czynnik then
                                zt_amunicja.prêdkoœæ := zt_amunicja.prêdkoœæ - zt_amunicja.prêdkoœæ_wytracanie_wspó³czynnik * gra_wspó³czynnik_prêdkoœci_g;

                              if zt_amunicja.prêdkoœæ < 0 then
                                zt_amunicja.prêdkoœæ := 0;
                              {$endregion 'Modyfikuje prêdkoœci lotu - w powietrzu amunicja zwalnia.'}


                              // Opada po wystrzeleniu.
                              zt_amunicja.prêdkoœæ_opadania := zt_amunicja.prêdkoœæ_opadania + zt_amunicja.prêdkoœæ_opadania_wspó³czynnik;

                              zt_amunicja.Position.AddScaledVector(  zt_amunicja.prêdkoœæ_opadania * gra_wspó³czynnik_prêdkoœci_g, GLVectorGeometry.VectorMake( 0, -1, 0 )  );
                              zt_amunicja.TransformationChanged();

                            end
                          else//if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y > 0 then
                            begin

                              // Amunicja w wodzie.

                              // Poziomuje w kierunku ruchu.
                              //   Samo wykrywa, w któr¹ stronê obracaæ aby obraca³o siê czubkiem do do³u (najkrótsz¹ drog¹).
                              if Abs( zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle + zt_amunicja.opadanie_obrót_korekta_o_ustawienie_pocz¹tkowe ) - gra_wspó³czynnik_prêdkoœci_g * 2 - delta_czasu_f > 0 then // Zabezpiecza aby nie drga³o.
                                begin

                                  if zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle + zt_amunicja.opadanie_obrót_korekta_o_ustawienie_pocz¹tkowe + delta_czasu_f > 0 then
                                    zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle := zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle - gra_wspó³czynnik_prêdkoœci_g - delta_czasu_f
                                  else//if zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle > -45 then
                                    zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle := zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle + gra_wspó³czynnik_prêdkoœci_g + delta_czasu_f;

                                end
                              else//if Abs( zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle + zt_amunicja.opadanie_obrót_korekta_o_ustawienie_pocz¹tkowe ) - gra_wspó³czynnik_prêdkoœci_g * 2 - delta_czasu_f > 0 then
                                begin

                                  zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle := -zt_amunicja.opadanie_obrót_korekta_o_ustawienie_pocz¹tkowe;

                                end;
                              //---//if Abs( zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle + zt_amunicja.opadanie_obrót_korekta_o_ustawienie_pocz¹tkowe ) - gra_wspó³czynnik_prêdkoœci_g * 2 - delta_czasu_f > 0 then


                              {$region 'Modyfikuje prêdkoœci lotu - w wodzie amunicja przyspiesza.'}
                              if zt_amunicja.prêdkoœæ < zt_amunicja.prêdkoœæ_pocz¹tkowa - zt_amunicja.prêdkoœæ_wytracanie_wspó³czynnik * gra_wspó³czynnik_prêdkoœci_g then
                                zt_amunicja.prêdkoœæ := zt_amunicja.prêdkoœæ + zt_amunicja.prêdkoœæ_wytracanie_wspó³czynnik * gra_wspó³czynnik_prêdkoœci_g;

                              if zt_amunicja.prêdkoœæ > zt_amunicja.prêdkoœæ_pocz¹tkowa then
                                zt_amunicja.prêdkoœæ := zt_amunicja.prêdkoœæ_pocz¹tkowa;
                              {$endregion 'Modyfikuje prêdkoœci lotu - w wodzie amunicja przyspiesza.'}


                              if not zt_amunicja.czy_pod_wod¹ then
                                begin

                                  // Pierwsze wpadniêcie do wody (po wpadniêciu do wody prêdkoœæ opadania maleje).

                                  zt_amunicja.czy_pod_wod¹ := true;
                                  zt_amunicja.zanurzenie_g³êbokoœæ_po_wpadniêciu_do_wody := zt_amunicja.zanurzenie_g³êbokoœæ_po_wpadniêciu_do_wody + zt_amunicja.prêdkoœæ_opadania * 10 * gra_wspó³czynnik_prêdkoœci_g; // Modyfikuje g³êbokoœæ zanurzenia o prêdkoœæ opadania. 10
                                  zt_amunicja.prêdkoœæ_opadania := zt_amunicja.prêdkoœæ_opadania * woda_wspó³czynnik_t³umienia_c;


                                  if    ( zt_amunicja.torpeda_efekt_na_wodzie <> nil )
                                    and ( zt_amunicja.torpeda_efekt_na_wodzie.Parent = nil ) then
                                    begin

                                      Amunicja_Wystrzelona_Efekt_Utwórz( zt_amunicja, true );
                                      zt_amunicja.torpeda_efekt_na_wodzie.Parent := Gra_Obiekty_GLDummyCube;

                                    end;
                                  //---//if    ( zt_amunicja.torpeda_efekt_na_wodzie <> nil ) (...)

                                end;
                              //---//if not zt_amunicja.czy_pod_wod¹ then


                              if not zt_amunicja.czy_wynurzanie then
                                begin

                                  // Zwiêksza g³êbokoœæ zanurzenia.

                                  zt_amunicja.prêdkoœæ_opadania := zt_amunicja.prêdkoœæ_opadania + zt_amunicja.prêdkoœæ_opadania_wspó³czynnik * woda_wspó³czynnik_t³umienia_c;

                                  zt_amunicja.Position.AddScaledVector(  zt_amunicja.prêdkoœæ_opadania * gra_wspó³czynnik_prêdkoœci_g, GLVectorGeometry.VectorMake( 0, -1, 0 )  );
                                  zt_amunicja.TransformationChanged();

                                  if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y <= -zt_amunicja.zanurzenie_g³êbokoœæ_po_wpadniêciu_do_wody then
                                    begin

                                      zt_amunicja.czy_wynurzanie := true;
                                      zt_amunicja.zanurzenie_g³êbokoœæ_po_wpadniêciu_do_wody := 0; // Zeruje wartoœæ na wypadek je¿eli znów amunicja wyskoczy³aby z wody.

                                    end;
                                  //---//if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y <= -zt_amunicja.zanurzenie_g³êbokoœæ_po_wpadniêciu_do_wody then

                                end
                              else//if not zt_amunicja.czy_wynurzanie then
                                begin

                                  // D¹¿y do zadanej g³êbokoœci.

                                  if    ( zt_amunicja.torpeda_efekt_na_wodzie <> nil )
                                    and ( zt_amunicja.torpeda_efekt_na_wodzie.Parent = nil ) then
                                    begin

                                      Amunicja_Wystrzelona_Efekt_Utwórz( zt_amunicja, true );
                                      zt_amunicja.torpeda_efekt_na_wodzie.Parent := Gra_Obiekty_GLDummyCube;

                                    end;
                                  //---//if    ( zt_amunicja.torpeda_efekt_na_wodzie <> nil ) (...)


                                  if Abs( zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y - zt_amunicja.zanurzenie_g³êbokoœæ_zadana ) > Abs( 0.01 ) then // Zabezpiecza aby nie drga³o.
                                    begin

                                      if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y < zt_amunicja.zanurzenie_g³êbokoœæ_zadana then
                                        zt_amunicja.prêdkoœæ_opadania := zt_amunicja.prêdkoœæ_opadania - zt_amunicja.prêdkoœæ_opadania_wspó³czynnik * woda_wspó³czynnik_t³umienia_c
                                      else//if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y < zt_amunicja.zanurzenie_g³êbokoœæ_zadana then
                                        zt_amunicja.prêdkoœæ_opadania := zt_amunicja.prêdkoœæ_opadania + zt_amunicja.prêdkoœæ_opadania_wspó³czynnik * woda_wspó³czynnik_t³umienia_c;


                                      if zt_amunicja.zanurzenie_g³êbokoœæ_zadana = 0 then
                                        ztr := 0.25
                                      else//if zt_amunicja.zanurzenie_g³êbokoœæ_zadana = 0 then
                                        begin

                                          // Im mniejszy dystans do zadanej g³êbokoœci tym prêdkoœæ opadania jest procentowo obni¿ana do 0 (im dalej tym jej skutecznoœæ osi¹ga 100%).
                                          //??? wielkoœæ wskaznika os³abiæ os³abiani gdy daleko
                                          ztr := Abs( 100 - Abs( zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y * 100 / zt_amunicja.zanurzenie_g³êbokoœæ_zadana )  ) * 0.01;

                                          if ztr > 1 then
                                            ztr := 1; // Nie wiêcej ni¿ 100%.

                                        end;
                                      //---//if zt_amunicja.zanurzenie_g³êbokoœæ_zadana = 0 then


                                      zt_amunicja.Position.AddScaledVector(  zt_amunicja.prêdkoœæ_opadania * torpeda_d¹¿enie_do_zadanej_g³êbokoœci_szybkoœæ_c * ztr * gra_wspó³czynnik_prêdkoœci_g, GLVectorGeometry.VectorMake( 0, -1, 0 )  );
                                      zt_amunicja.TransformationChanged();

                                    end
                                  else//if Abs( zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y - zt_amunicja.zanurzenie_g³êbokoœæ_zadana ) > Abs( 0.01 ) then
                                    begin

                                      if zt_amunicja.prêdkoœæ_opadania <> 0 then
                                        zt_amunicja.prêdkoœæ_opadania := 0;

                                    end;
                                  //---//if Abs( zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y - zt_amunicja.zanurzenie_g³êbokoœæ_zadana ) > Abs( 0.01 ) then

                                end;
                              //---//if not zt_amunicja.czy_wynurzanie then

                            end;
                          //---//if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y > 0 then
                          {$endregion 'Torpeda - zanurzanie i wynurzanie.'}


                          {$region 'Torpeda - zanurzanie i wynurzanie - wersja 1.'}
                          //if not zt_amunicja.czy_wynurzanie then
                          //  begin
                          //
                          //    // Opada i zanurza siê po wystrzeleniu.
                          //
                          //    if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y > -zt_amunicja.zanurzenie_g³êbokoœæ_po_wpadniêciu_do_wody then
                          //      begin
                          //
                          //        if not zt_amunicja.czy_pod_wod¹ then
                          //          zt_amunicja.prêdkoœæ_opadania := zt_amunicja.prêdkoœæ_opadania + zt_amunicja.prêdkoœæ_opadania_wspó³czynnik
                          //        else//if not zt_amunicja.czy_pod_wod¹ then
                          //          zt_amunicja.prêdkoœæ_opadania := zt_amunicja.prêdkoœæ_opadania + zt_amunicja.prêdkoœæ_opadania_wspó³czynnik * woda_wspó³czynnik_t³umienia_c;
                          //
                          //
                          //        if    ( not zt_amunicja.czy_pod_wod¹ )
                          //          and ( zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y <= 0 ) then
                          //          begin
                          //
                          //            // Po wpadniêciu do wody prêdkoœæ opadania maleje.
                          //
                          //            zt_amunicja.czy_pod_wod¹ := true;
                          //            zt_amunicja.zanurzenie_g³êbokoœæ_po_wpadniêciu_do_wody := zt_amunicja.zanurzenie_g³êbokoœæ_po_wpadniêciu_do_wody + zt_amunicja.prêdkoœæ_opadania * 10; // Modyfikuje g³êbokoœæ zanurzenia o prêdkoœæ opadania.
                          //            zt_amunicja.prêdkoœæ_opadania := zt_amunicja.prêdkoœæ_opadania * woda_wspó³czynnik_t³umienia_c;
                          //
                          //          end;
                          //        //---//if    ( not zt_amunicja.czy_pod_wod¹ ) (...)
                          //
                          //
                          //        zt_amunicja.korpus_opadanie_obrót_dummy.Lift( -zt_amunicja.prêdkoœæ_opadania );
                          //
                          //      end
                          //    else//if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y > -zt_amunicja.zanurzenie_g³êbokoœæ_po_wpadniêciu_do_wody then
                          //      begin
                          //
                          //        if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y <= -zt_amunicja.zanurzenie_g³êbokoœæ_po_wpadniêciu_do_wody then
                          //          zt_amunicja.czy_wynurzanie := true;
                          //
                          //      end;
                          //    //---//if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y > -zt_amunicja.zanurzenie_g³êbokoœæ_po_wpadniêciu_do_wody then
                          //
                          //
                          //
                          //    // Przechyla siê przodem w dó³ po wystrzeleniu.
                          //    // Je¿eli przechyli siê za mocno to zmieni¹ siê wspó³rzêdne i nie wykryje warunku do wynurzania.
                          //    //if    ( zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle < 89 )
                          //    //  and ( zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y > 0 ) then
                          //    //  zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.PitchAngle := zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.PitchAngle - gra_wspó³czynnik_prêdkoœci_g;
                          //
                          //    if    ( zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.PitchAngle > -89 )
                          //      and ( zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.AbsolutePosition.Y > 0 ) then
                          //      zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.PitchAngle := zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.PitchAngle - gra_wspó³czynnik_prêdkoœci_g;
                          //
                          //  end
                          //else//if not zt_amunicja.czy_wynurzanie then
                          //  begin
                          //
                          //    // Wynurza siê do poziomu standardowego p³yniêcia.
                          //
                          //    if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y < 0 then
                          //      zt_amunicja.korpus_opadanie_obrót_dummy.Lift( zt_amunicja.prêdkoœæ_opadania * 0.25 )
                          //    else//if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y < 0 then
                          //      if zt_amunicja.prêdkoœæ_opadania <> 0 then
                          //        zt_amunicja.prêdkoœæ_opadania := 0;
                          //
                          //  end;
                          ////---//if not zt_amunicja.czy_wynurzanie then
                          //
                          //
                          //if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y <= 0 then
                          //  begin
                          //
                          //    // Gdy jest ju¿ w wodzie.
                          //
                          //    // Wyrównuje przechylenie do poziomu.
                          //    //if zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle > 0 then
                          //    //  zt_amunicja.korpus_opadanie_obrót_dummy.Pitch( gra_wspó³czynnik_prêdkoœci_g );
                          //    if zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.PitchAngle < 0 then
                          //      zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.PitchAngle := zt_amunicja.korpus_ustawienie_pocz¹tkowe_dummy.PitchAngle + gra_wspó³czynnik_prêdkoœci_g;
                          //
                          //  end;
                          ////---//if zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y > 0 then
                          {$endregion 'Torpeda - zanurzanie i wynurzanie - wersja 1.'}

                        end;
                      //---//if zt_amunicja.amunicja_rodzaj = ar_Torpeda then

                    end;
                  //---//if zt_amunicja.czy_poza_luf¹ then

                end
              else//if not zt_amunicja.czy_poza_zasiêgiem then
                begin

                  // Poza skutecznym zasiêgiem.

                  {$region 'Modyfikuje prêdkoœci lotu.'}
                  if zt_amunicja.prêdkoœæ > zt_amunicja.prêdkoœæ_wytracanie_wspó³czynnik then
                    zt_amunicja.prêdkoœæ := zt_amunicja.prêdkoœæ - zt_amunicja.prêdkoœæ_wytracanie_wspó³czynnik * gra_wspó³czynnik_prêdkoœci_g;

                  if zt_amunicja.prêdkoœæ < 0 then
                    zt_amunicja.prêdkoœæ := 0;


                  if not zt_amunicja.czy_pod_wod¹ then
                    zt_amunicja.prêdkoœæ_opadania := zt_amunicja.prêdkoœæ_opadania + zt_amunicja.prêdkoœæ_opadania_wspó³czynnik * gra_wspó³czynnik_prêdkoœci_g
                  else//if not zt_amunicja.czy_pod_wod¹ then
                    zt_amunicja.prêdkoœæ_opadania := zt_amunicja.prêdkoœæ_opadania + zt_amunicja.prêdkoœæ_opadania_wspó³czynnik * woda_wspó³czynnik_t³umienia_c * gra_wspó³czynnik_prêdkoœci_g;


                  if    ( not zt_amunicja.czy_pod_wod¹ )
                    and ( zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y <= 0 ) then
                    begin

                      // Po wpadniêciu do wody prêdkoœæ opadania maleje.

                      zt_amunicja.czy_pod_wod¹ := true;
                      zt_amunicja.prêdkoœæ_opadania := zt_amunicja.prêdkoœæ_opadania * woda_wspó³czynnik_t³umienia_c;

                    end;
                  //---//if    ( not zt_amunicja.czy_pod_wod¹ ) (...)
                  {$endregion 'Modyfikuje prêdkoœci lotu.'}


                  {$region 'Poza skutecznym zasiêgiem amunicja opada.'}
                  zt_amunicja.Position.AddScaledVector(  -Abs(zt_amunicja.prêdkoœæ_opadania) * gra_wspó³czynnik_prêdkoœci_g, GLVectorGeometry.VectorMake( 0, 1, 0 )  );
                  zt_amunicja.TransformationChanged();
                  {$endregion 'Poza skutecznym zasiêgiem amunicja opada.'}


                  // Obraca czubkiem w dó³ (im mniejsza prêdkoœæ tym k¹t jest bli¿szy 90).
                  //   Samo wykrywa, w któr¹ stronê obracaæ aby obraca³o siê czubkiem do do³u (najkrótsz¹ drog¹).
                  if zt_amunicja.prêdkoœæ_pocz¹tkowa <> 0 then
                    //zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle := -( 90 + zt_amunicja.opadanie_obrót_korekta_o_ustawienie_pocz¹tkowe ) * ( 100 - 100 * zt_amunicja.prêdkoœæ / zt_amunicja.prêdkoœæ_pocz¹tkowa ) * 0.01;
                    zt_amunicja.korpus_opadanie_obrót_dummy.PitchAngle :=
                          zt_amunicja.opadanie_obrót_korekta_o_k¹t_na_granicy_zasiêgu
                      - ( 90 + zt_amunicja.opadanie_obrót_korekta_o_ustawienie_pocz¹tkowe + zt_amunicja.opadanie_obrót_korekta_o_k¹t_na_granicy_zasiêgu ) // K¹t docelowy 90 skorygowany o k¹t pocz¹tkowy i k¹t na granicy zasiêgu.
                      * ( 100 - 100 * zt_amunicja.prêdkoœæ / zt_amunicja.prêdkoœæ_pocz¹tkowa ) // Procentowa modyfikacja wzglêdem prêdkoœci (prêdkoœæ d¹¿y do 0 si³a modyfikacji wzrasta do 100%).
                      * 0.01;


                  {$region 'Modyfikacja wspó³czynnika zadawanych obra¿eñ.'}
                  if zt_amunicja.obra¿enia_zadawane_wspó³czynnik_zmodyfikowany > 0 then
                    begin

                      // zt_amunicja.zasiêg + zt_amunicja.zasiêg * 0.1{10%} // Koñcowy zakres zadawania obra¿eñ - 0.1 = 10%.
                      //
                      // ( zt_amunicja.zasiêg + zt_amunicja.zasiêg * 0.1 ) - zt_amunicja.DistanceTo( zt_amunicja.pozycja_startowa ) // Procent wartoœci obra¿eñ - obni¿enie.
                      //
                      // 100 * (  zt_amunicja.DistanceTo( zt_amunicja.pozycja_startowa ) - ( zt_amunicja.zasiêg + zt_amunicja.zasiêg * 0.1 )  ) / ( zt_amunicja.zasiêg * 0.1 )


                      ztr := zt_amunicja.zasiêg * 0.5; // Koñcowy zakres zadawania obra¿eñ 50%.

                      if ztr <> 0 then
                        begin

                          ztr := 100 * (  ( zt_amunicja.zasiêg + ztr ) - zt_amunicja.DistanceTo( zt_amunicja.pozycja_startowa )  ) / ztr;

                          zt_amunicja.obra¿enia_zadawane_wspó³czynnik_zmodyfikowany := ( zt_amunicja.obra¿enia_zadawane_wspó³czynnik * ztr / 100 );

                          if zt_amunicja.obra¿enia_zadawane_wspó³czynnik_zmodyfikowany > 1 then
                            zt_amunicja.obra¿enia_zadawane_wspó³czynnik_zmodyfikowany := 1
                          else//if zt_amunicja.obra¿enia_zadawane_wspó³czynnik_zmodyfikowany > 1 then
                            if zt_amunicja.obra¿enia_zadawane_wspó³czynnik_zmodyfikowany < 0.001 then
                              zt_amunicja.obra¿enia_zadawane_wspó³czynnik_zmodyfikowany := 0;


                          //zt_amunicja.Move( zt_amunicja.prêdkoœæ * zt_amunicja.obra¿enia_zadawane_wspó³czynnik_zmodyfikowany );

                        end;
                      //---//if ztr <> 0 then

                    end;
                  //---//if zt_amunicja.obra¿enia_zadawane_wspó³czynnik_zmodyfikowany > 0 then
                  {$endregion 'Modyfikacja wspó³czynnika zadawanych obra¿eñ.'}



                  if    ( zt_amunicja.torpeda_efekt_na_wodzie <> nil )
                    and ( zt_amunicja.torpeda_efekt_na_wodzie.Parent <> nil )
                    and ( zt_amunicja.korpus_opadanie_obrót_dummy.AbsolutePosition.Y < zt_amunicja.zanurzenie_g³êbokoœæ_zadana -1 ) then
                    begin

                      FreeAndNil( zt_amunicja.torpeda_efekt_na_wodzie );

                    end;
                  //---//if    ( zt_amunicja.torpeda_efekt_na_wodzie <> nil ) (...)

                end;
              //---//if not zt_amunicja.czy_poza_zasiêgiem then


              zt_amunicja.pozycja_woda.Position.X := zt_amunicja.AbsolutePosition.X;
              zt_amunicja.pozycja_woda.Position.Z := zt_amunicja.AbsolutePosition.Z;


              // Czy uzbrojona.
              if    ( zt_amunicja.czy_poza_luf¹ )
                and ( not zt_amunicja.czy_uzbrojona )
                and (  zt_amunicja.korpus.DistanceTo( zt_amunicja.pozycja_startowa.AbsolutePosition ) > zt_amunicja.strza³_od_blokada_dystans * 2  ) then //???
                begin

                  zt_amunicja.czy_uzbrojona := true;
                  zt_amunicja.korpus.Material.FrontProperties.Ambient.Color := clrRed; //???

                end;
              //---//if    ( zt_amunicja.czy_poza_luf¹ ) (...)

            end;
          //---//if zt_amunicja.czy_usun¹æ_amunicja then

        end;
      //---//if zt_amunicja <> nil then

    end;
  //---//for i := amunicja_wystrzelona_list.Count - 1 downto 0 do

end;//---//Funkcja Amunicja_Ruch().

//Funkcja Lufy_Prze³adowanie().
procedure TStatki_Form.Lufy_Prze³adowanie( delta_czasu_f : double );
var
  i,
  j,
  i_s
    : integer;
  zt_statek : TStatek;
begin

  if czy_klient_g then
    Exit;


  for i_s := 0 to Length( statki_t ) - 1 do
    begin

      zt_statek := statki_t[ i_s ];

      if zt_statek <> nil then
        begin

          for i := 0 to Length( zt_statek.artyleria_t ) - 1 do
            for j := 0 to Length( zt_statek.artyleria_t[ i ].lufy_t ) - 1 do
              if zt_statek.artyleria_t[ i ].lufy_t[ j ] <> nil then
                zt_statek.artyleria_t[ i ].lufy_t[ j ].Prze³adowanie( delta_czasu_f );


          for i := 0 to Length( zt_statek.dzia³a_t ) - 1 do
            for j := 0 to Length( zt_statek.dzia³a_t[ i ].lufy_t ) - 1 do
              if zt_statek.dzia³a_t[ i ].lufy_t[ j ] <> nil then
                zt_statek.dzia³a_t[ i ].lufy_t[ j ].Prze³adowanie( delta_czasu_f );


          for i := 0 to Length( zt_statek.torpedy_wyrzutnie_t ) - 1 do
            for j := 0 to Length( zt_statek.torpedy_wyrzutnie_t[ i ].lufy_t ) - 1 do
              if zt_statek.torpedy_wyrzutnie_t[ i ].lufy_t[ j ] <> nil then
                zt_statek.torpedy_wyrzutnie_t[ i ].lufy_t[ j ].Prze³adowanie( delta_czasu_f );

        end;
      //---//if zt_statek <> nil then

    end;
  //---//for i_s := 0 to Length( statki_t ) - 1 do

end;//---//Funkcja Lufy_Prze³adowanie().

//Funkcja Statki_Kolizja_Oznaczenie_SprawdŸ().
function TStatki_Form.Statki_Kolizja_Oznaczenie_SprawdŸ( string_list_f : TStringList; obiekt_nazwa_f : string ) : boolean;
var
  i : integer;
  zti64 : int64;
  zts : string;
begin

  //
  // Funkcja sprawdza czy jest oznaczona nieprzeterminowana kolizja z podanym obiektem.
  //
  // Zwraca prawdê gdy jest oznaczona nieprzeterminowana kolizja z podanym obiektem.
  //
  // Parametry:
  //   string_list_f - lista kolizji;
  //   obiekt_nazwa_f.
  //

  Result := false;


  if   ( string_list_f = nil )
    or (  not Assigned( string_list_f )  ) then
    Exit;


  for i := string_list_f.Count - 1 downto 0 do
    begin

      zts := Copy(  string_list_f[ i ], Pos( '|', string_list_f[ i ] ) + 1, Length( string_list_f[ i ] )  );

      try
        zti64 := StrToInt64( zts );
      except
        zti64 := statek_kolizja_oznaczenie_ponowne_czas_c;
      end;
      //---//try

      if Czas_Miêdzy_W_Sekundach( zti64 ) >= statek_kolizja_oznaczenie_ponowne_czas_c then
        begin

          string_list_f.Delete( i ); // Czyœci przeterminowane oznaczenia kolizji.

        end
      else//if Czas_Miêdzy_W_Sekundach( zti64 ) >= statek_kolizja_oznaczenie_ponowne_czas_c then
        if Pos( obiekt_nazwa_f, string_list_f[ i ] ) = 1 then
          begin

            // Kolizja z podanym obiektem jest ju¿ oznaczona i jest nieprzeterminowana.

            Result := true;
            Exit;

          end;
        //---//if Pos( obiekt_nazwa_f, string_list_f[ i ] ) = 1 then

    end;
  //---//for i := string_list_f.Count - 1 downto 0 do

end;//---//Funkcja Statki_Kolizja_Oznaczenie_SprawdŸ().

//Funkcja Trafienia_Efekt_Czas_Trwania_SprawdŸ().
procedure TStatki_Form.Trafienia_Efekt_Czas_Trwania_SprawdŸ();
var
  i : integer;
begin

  if   ( trafienia_efekt_list = nil )
    or (  not Assigned( trafienia_efekt_list )  ) then
    Exit;


  for i := trafienia_efekt_list.Count - 1 downto 0 do
    begin

      if Czas_Miêdzy_W_Milisekundach( TTrafienia_Efekt(trafienia_efekt_list[ i ]).czas_utworzenia ) >= TTrafienia_Efekt(trafienia_efekt_list[ i ]).czas_trwania then
        Trafienia_Efekt_Zwolnij_Jeden( TTrafienia_Efekt(trafienia_efekt_list[ i ]) );

    end;
  //---//for i := trafienia_efekt_list.Count - 1 downto 0 do

end;//---//Funkcja Trafienia_Efekt_Czas_Trwania_SprawdŸ().

//Funkcja Kamera_Odleg³oœæ_Kontroluj_Ustaw().
procedure TStatki_Form.Kamera_Odleg³oœæ_Kontroluj_Ustaw( delta_czasu_f : double );
var
  zt_vector : GLVectorGeometry.TVector;
begin

  //
  // Funkcja nie pozwala na odsuniêcie kamery zbyt daleko od statku, amunicji.
  //
  // Parametry:
  //   delta_czasu_f.
  //


  // Komponent dok³adnie nie pilnuje zakresów.
  if Kamera_Odleg³oœæ_Maksymalna_SpinEdit.Value > Kamera_Odleg³oœæ_Maksymalna_SpinEdit.MaxValue then
    Kamera_Odleg³oœæ_Maksymalna_SpinEdit.Value := Kamera_Odleg³oœæ_Maksymalna_SpinEdit.MaxValue;


  if    ( Kamera_Odleg³oœæ_Maksymalna_SpinEdit.Value > 0 )
    and ( Gra_GLCamera.Parent <> nil )
    and (
             ( Gra_GLCamera.Parent is TStatek )
          or ( Gra_GLCamera.Parent is TAmunicja )
        )
    and (  Gra_GLCamera.DistanceTo( Gra_GLCamera.Parent ) > Kamera_Odleg³oœæ_Maksymalna_SpinEdit.Value  ) then
    begin

      //Gra_GLCamera.Position.AddScaledVector
      //  (
      //      //-0.1
      //      -1 * delta_czasu_f
      //    , //NormalizeVector
      //      (
      //        GLVectorGeometry.VectorMake
      //          (
      //              Gra_GLCamera.Position.X
      //            , Gra_GLCamera.Position.Y
      //            , Gra_GLCamera.Position.Z
      //          )
      //      )
      //  );


      zt_vector := GLVectorGeometry.VectorMake
        (
            Gra_GLCamera.Position.X
          , Gra_GLCamera.Position.Y
          , Gra_GLCamera.Position.Z
        );


      NormalizeVector( zt_vector );


      Gra_GLCamera.Position.AddScaledVector
        (
            //-0.1
            -5 * delta_czasu_f
          , zt_vector
        );

    end;
  //---//if    ( Kamera_Odleg³oœæ_Maksymalna_SpinEdit.Value >= 0 ) (...)

end;//---//Funkcja Kamera_Odleg³oœæ_Kontroluj_Ustaw().

//Funkcja Kamera_Prze³¹cz().
procedure TStatki_Form.Kamera_Prze³¹cz( const kamera_tryb_f : TKamera_Tryb );
var
  i : integer;
  zt_vector_1,
  zt_vector_2
    : GLVectorGeometry.TVector;
begin

  //
  // Funkcja zmienia punkt zaczepienia kamery.
  //
  // Parametry:
  //   kamera_tryb_f:
  //     true - ustawi kamerê na wystrzelonej amunicji.
  //     false - ustawi kamerê na statku lub swobodn¹.
  //


  //Gra_GLCamera.ResetRotations(); // Je¿eli ¿aden warunek nie zostanie spe³niony to niepotrzebnie resetuje ustawienie kamery.


  if    ( kamera_tryb_f = kt_Amunicja )
    and ( statek_gracza <> nil )
    and ( amunicja_wystrzelona_list <> nil )
    and ( amunicja_wystrzelona_list.Count > 0 ) then
    begin

      // Ustawia kamerê na amunicji.

      if Gra_GLCamera.Tag <> integer(kt_Amunicja) then
        Gra_GLCamera.ResetRotations();

      {$region 'kt_Amunicja.'}
      i := kamera_indeks_amunicji;

      if not czy_kamera_od_najnowszego_pocisku then
        begin

          // Od najstarszego.

          if i = amunicja_wystrzelona_list.Count - 1 then
            i := 0
          else//if i = amunicja_wystrzelona_list.Count - 1 then
            if i > amunicja_wystrzelona_list.Count - 1 then
              i := amunicja_wystrzelona_list.Count - 1;

        end
      else//if not czy_kamera_od_najnowszego_pocisku then
        begin

          // Od najnowszego.

          if i = 0 then
            i := amunicja_wystrzelona_list.Count - 1
          else//if i = amunicja_wystrzelona_list.Count - 1 then
            if i > amunicja_wystrzelona_list.Count - 1 then
              i := amunicja_wystrzelona_list.Count - 1;

        end;
      //---//if not czy_kamera_od_najnowszego_pocisku then

      //i := 0;


      if not ( Gra_GLCamera.Parent is TAmunicja ) then
        begin

          Gra_GLCamera.Position.SetPoint( 0, 1, 0 );
          Gra_GLCamera.AbsoluteDirection := TAmunicja(Gra_GLCamera.Parent).AbsoluteDirection;
          Gra_GLCamera.ResetRotations();

        end;
      //---//if not ( Gra_GLCamera.Parent is TAmunicja ) then


      // Prze³¹cza na kolejn¹ wystrzelon¹ amunicjê.
      if not czy_kamera_od_najnowszego_pocisku then
        begin

          // Od najstarszego.

          while ( amunicja_wystrzelona_list.Count > i )
            and ( Gra_GLCamera.Parent = amunicja_wystrzelona_list[ i ] )
            and ( statek_gracza.id_statek = TAmunicja(amunicja_wystrzelona_list[ i ]).id_statek ) do // Prze³¹cza tylko na w³asnej amunicji gracza. //???
            inc( i );

        end
      else//if not czy_kamera_od_najnowszego_pocisku then
        begin

          // Od najnowszego.

          while ( amunicja_wystrzelona_list.Count > i )
            and ( i > 0 )
            and ( Gra_GLCamera.Parent = amunicja_wystrzelona_list[ i ] )
            and ( statek_gracza.id_statek = TAmunicja(amunicja_wystrzelona_list[ i ]).id_statek ) do // Prze³¹cza tylko na w³asnej amunicji gracza. //???
            dec( i );

        end;
      //---//if not czy_kamera_od_najnowszego_pocisku then


      // Ustawia kamerê na amunicji.
      if    ( amunicja_wystrzelona_list.Count > 0 )
        and ( i < amunicja_wystrzelona_list.Count )
        and ( i >= 0 )
        and ( statek_gracza.id_statek = TAmunicja(amunicja_wystrzelona_list[ i ]).id_statek ) then // Prze³¹cza tylko na w³asnej amunicji gracza. //???
          begin

            Gra_GLCamera.Parent := amunicja_wystrzelona_list[ i ];
            kamera_indeks_amunicji := i;

          end;
        //---//if    ( amunicja_wystrzelona_list.Count > 0 ) (...)
      {$endregion 'kt_Amunicja.'}


      if Gra_GLCamera.Tag <> integer(kt_Amunicja) then
        Gra_GLCamera.Tag := integer(kt_Amunicja);

    end
  else//if czy_na_pocisk then
  if    ( kamera_tryb_f = kt_Artyleria )
    and ( statek_gracza <> nil )
    and (  Length( statek_gracza.artyleria_t ) > 0  ) then
    begin

      // Ustawia kamerê do celowania artyleri¹ (z góry).

      //zt_vector_1 := Gra_GLCamera.AbsoluteDirection;
      zt_vector_1.Y := Gra_GLCamera.Position.Y;

      if Gra_GLCamera.Tag <> integer(kt_Artyleria) then
        begin

          Gra_GLCamera.ResetRotations();

          //if Gra_GLUserInterface.MouseLookActive then
          //  Gra_GLUserInterface.MouseLookActive := false;

          Gra_GLCamera.Parent := Gra_GLScene.Objects;

          // Ustawia kamerê w kierunku od statku do celu.
          Gra_GLCamera.Direction.SetVector
            (   // Cel                 Obiekt celuj¹cy
                statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector ).X - statek_gracza.AbsolutePosition.X
              , 0
              , statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Z - statek_gracza.AbsolutePosition.Z
            );

        end;
      //---//if Gra_GLCamera.Tag <> integer(kt_Artyleria) then


      // Ustawia kamerê nad celem.
      if statek_gracza.DistanceTo(  statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector )  ) <= statek_gracza.artyleria_t[ 0 ].zasiêg then
        Gra_GLCamera.Position.AsAffineVector := statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector )
      else//if statek_gracza.DistanceTo(  statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector )  ) <= statek_gracza.artyleria_t[ 0 ].zasiêg then
        begin

          // Je¿eli cel jest poza zasiêgiem artylerii ustawi kamerê na granicy zasiêgu w kierunku celu.

          Gra_GLCamera.Position.AsVector := statek_gracza.AbsolutePosition;
          //Gra_GLCamera.Position.AddScaledVector( statek_gracza.artyleria_t[ 0 ].zasiêg, Gra_GLCamera.AbsoluteDirection );

          Gra_GLCamera.Position.AddScaledVector
            (
              statek_gracza.artyleria_t[ 0 ].zasiêg,
              GLVectorGeometry.VectorNormalize
                (
                  // Ustawia kamerê w kierunku od statku do celu.
                  GLVectorGeometry.VectorMake
                    (   // Cel                 Obiekt celuj¹cy
                        statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector ).X - statek_gracza.AbsolutePosition.X
                      , 0
                      , statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Z - statek_gracza.AbsolutePosition.Z
                    )
                )
            );

        end;
      //---//if statek_gracza.DistanceTo(  statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector )  ) <= statek_gracza.artyleria_t[ 0 ].zasiêg then


      if Gra_GLCamera.Tag <> integer(kt_Artyleria) then
        begin

          // Ustawia wysokoœæ kamery i obraca w dó³.
          Gra_GLCamera.Position.Y := 10;
          Gra_GLCamera.PitchAngle := -90;

          Gra_GLCamera.Tag := integer(kt_Artyleria);

        end
      else//if Gra_GLCamera.Tag <> integer(kt_Artyleria) then
        Gra_GLCamera.Position.Y := zt_vector_1.Y;

    end
  else//if    ( kamera_tryb_f = kt_Artyleria ) (...)
  if    (
             ( kamera_tryb_f = kt_Statek )
          or ( kamera_tryb_f = kt_Statek_Swobodna )
        )
    and ( statek_gracza <> nil ) then
    begin

      // Ustawia kamerê na statku.

      if Gra_GLCamera.Tag <> integer(kt_Statek) then
        begin

          zt_vector_1 := Gra_GLCamera.AbsoluteDirection;
          Gra_GLCamera.ResetRotations();

        end;
      //---//if Gra_GLCamera.Tag <> integer(kt_Statek) then


      Gra_GLCamera.Parent := statek_gracza;

      //Gra_GLCamera.Position.SetPoint( 0, 1, 0 );
      Gra_GLCamera.Position.AsVector := Wieloosobowe__Wektor_4__Do__Vector( statek_gracza.kamera_na_statek_pozycja );


      if Gra_GLCamera.Tag <> integer(kt_Statek) then
        begin

          ////Gra_GLCamera.Up := statek_gracza.Up;
          //Gra_GLCamera.Up.SetVector( 0, 1, 0 );
          //Gra_GLCamera.AbsoluteDirection := statek_gracza.AbsoluteDirection;
          Gra_GLCamera.AbsoluteDirection := zt_vector_1;

          Gra_GLCamera.Tag := integer(kt_Statek);

        end;
      //---//if Gra_GLCamera.Tag <> integer(kt_Statek) then

    end
  else//if     ( (...)
  if   ( kamera_tryb_f = kt_Swobodna )
    or (
             ( kamera_tryb_f = kt_Statek_Swobodna )
         and ( statek_gracza = nil )
       ) then
    begin

      // Ustawia kamerê swobodn¹.

      if Gra_GLCamera.Tag <> integer(kt_Swobodna) then
        begin

          zt_vector_1 := Gra_GLCamera.AbsoluteDirection;
          zt_vector_2 := Gra_GLCamera.AbsolutePosition;
          //Gra_GLCamera.ResetRotations();

        end;
      //---//if Gra_GLCamera.Tag <> integer(kt_Swobodna) then


      Gra_GLCamera.Parent := Gra_GLScene.Objects;


      if Gra_GLCamera.Tag <> integer(kt_Swobodna) then
        begin

          Gra_GLCamera.AbsoluteDirection := zt_vector_1;
          Gra_GLCamera.AbsolutePosition := zt_vector_2;
          Gra_GLCamera.Tag := integer(kt_Swobodna);

        end;
      //---//if Gra_GLCamera.Tag <> integer(kt_Swobodna) then

    end;
  //---//if   ( kamera_tryb_f = kt_Swobodna ) (...)
  if    ( kamera_tryb_f = kt_Za_Statkiem )
    and ( statek_gracza <> nil ) then
    begin

      // Ustawia kamerê za statkiem.

      Gra_GLCamera.ResetRotations();

      //Gra_GLCamera.Parent := Gra_GLScene.Objects;
      Gra_GLCamera.Parent := statek_gracza;

      Gra_GLCamera.Position := statek_gracza.Position;
      //Gra_GLCamera.Position.Y := 5;
      Gra_GLCamera.Position.X := Gra_GLCamera.Position.X + statek_gracza.kamera_za_statkiem_pozycja.X;
      Gra_GLCamera.Position.Y := Gra_GLCamera.Position.Y + statek_gracza.kamera_za_statkiem_pozycja.Y;
      Gra_GLCamera.Position.Z := Gra_GLCamera.Position.Z + statek_gracza.kamera_za_statkiem_pozycja.Z;

      Gra_GLCamera.Up.SetVector( 0, 1, 0);
      //Gra_GLCamera.Direction.SetVector( 0, 0, -1 );
      Gra_GLCamera.AbsoluteDirection := statek_gracza.AbsoluteDirection;

      Gra_GLCamera.Move( -5 );

      Gra_GLCamera.Direction.SetVector
        (
            statek_gracza.Position.X - Gra_GLCamera.Position.X
          , statek_gracza.Position.Y - Gra_GLCamera.Position.Y
          , statek_gracza.Position.Z - Gra_GLCamera.Position.Z
        );


      if Gra_GLCamera.Tag <> integer(kt_Za_Statkiem) then
        Gra_GLCamera.Tag := integer(kt_Za_Statkiem);

    end;
  //---//if    ( kamera_tryb_f = kt_Za_Statkiem ) (...)

end;//---//Funkcja Kamera_Prze³¹cz().

//Funkcja Napis_Odœwie¿().
procedure TStatki_Form.Napis_Odœwie¿();
var
  i,
  j
    : integer;
  ztr : real;
  ró¿a_wiatrów,
  uzbrojenie,
  skrêt_kierunek,
  skrêt_kierunek_zadany
    : string;
  zt_statek : TStatek;
begin

  zt_statek := statek_gracza;

  if czy_pauza_g then
    Informacje_G³ówne_GLHUDText.Text := '          PAUZA' + #13#10 + #13#10
  else//if czy_pauza_g then
    Informacje_G³ówne_GLHUDText.Text := '';


  if zt_statek <> nil then
    begin

      {$region 'Opis skrêtu.'}
      if zt_statek.skrêt_procent < 0 then
        skrêt_kierunek := '<'//'lewo'
      else
      if zt_statek.skrêt_procent = 0 then
        skrêt_kierunek := '|'//''
      else
      if zt_statek.skrêt_procent > 0 then
        skrêt_kierunek := '>';//'prawo'

      if zt_statek.skrêt_zadany_procent < 0 then
        skrêt_kierunek_zadany := '<'//'lewo'
      else
      if zt_statek.skrêt_zadany_procent = 0 then
        skrêt_kierunek_zadany := '|'//''
      else
      if zt_statek.skrêt_zadany_procent > 0 then
        skrêt_kierunek_zadany := '>';//'prawo'

      if Abs( zt_statek.skrêt_zadany_procent ) > 50 then
        skrêt_kierunek_zadany := skrêt_kierunek_zadany + skrêt_kierunek_zadany;
      {$endregion 'Opis skrêtu.'}

      {$region 'Opis uzbrojenia.'}
      uzbrojenie := '';

      if Length( zt_statek.artyleria_t ) > 0 then
        begin

          if uzbrojenie <> '' then
            uzbrojenie := uzbrojenie + #13#10;

          if    ( not ar_Artyleria_CheckBox.Checked )
            and ( not ar_Wszystkie_CheckBox.Checked )then
            uzbrojenie := uzbrojenie + '---';

          uzbrojenie := uzbrojenie +
            ' artyleria:';

          for i := 0 to Length( zt_statek.artyleria_t ) - 1 do
            begin

              if i > 0 then
                uzbrojenie := uzbrojenie + ', ';

              for j := 0 to Length( zt_statek.artyleria_t[ i ].lufy_t ) - 1 do
                if zt_statek.artyleria_t[ i ].lufy_t[ j ].strza³_gotowoœæ then
                  uzbrojenie := uzbrojenie + ' *'
                else//if zt_statek.artyleria_t[ i ].lufy_t[ j ].strza³_gotowoœæ then
                  uzbrojenie := uzbrojenie + ' x';

              uzbrojenie := uzbrojenie +
                ' ' + Trim(  FormatFloat( '### ### ##0', i + 1 )  ) + ' - ' + Trim(  FormatFloat( '### ### ##0', zt_statek.artyleria_t[ i ].amunicja_iloœæ )  );

            end;
          //---//for i := 0 to Length( Self.artyleria_t ) - 1 do


        end;
      //---//if Length( zt_statek.artyleria_t ) > 0 then

      if Length( zt_statek.dzia³a_t ) > 0 then
        begin

          if uzbrojenie <> '' then
            uzbrojenie := uzbrojenie + #13#10;

          if    ( not ar_Pocisk_CheckBox.Checked )
            and ( not ar_Wszystkie_CheckBox.Checked )then
            uzbrojenie := uzbrojenie + '---';

          uzbrojenie := uzbrojenie +
            ' dzia³a:';

          for i := 0 to Length( zt_statek.dzia³a_t ) - 1 do
            begin

              if i > 0 then
                uzbrojenie := uzbrojenie + ', ';

              for j := 0 to Length( zt_statek.dzia³a_t[ i ].lufy_t ) - 1 do
                if zt_statek.dzia³a_t[ i ].lufy_t[ j ].strza³_gotowoœæ then
                  uzbrojenie := uzbrojenie + ' *'
                else//if zt_statek.dzia³a_t[ i ].lufy_t[ j ].strza³_gotowoœæ then
                  uzbrojenie := uzbrojenie + ' x';

              uzbrojenie := uzbrojenie +
                ' ' + Trim(  FormatFloat( '### ### ##0', i + 1 )  ) + ' - ' + Trim(  FormatFloat( '### ### ##0', zt_statek.dzia³a_t[ i ].amunicja_iloœæ )  );

            end;
          //---//for i := 0 to Length( Self.dzia³a_t ) - 1 do


        end;
      //---//if Length( zt_statek.dzia³a_t ) > 0 then

      if Length( zt_statek.torpedy_wyrzutnie_t ) > 0 then
        begin

          if uzbrojenie <> '' then
            uzbrojenie := uzbrojenie + #13#10;

          if    ( not ar_Torpeda_CheckBox.Checked )
            and ( not ar_Wszystkie_CheckBox.Checked )then
            uzbrojenie := uzbrojenie + '---';

          uzbrojenie := uzbrojenie +
            ' torpedy:';

          for i := 0 to Length( zt_statek.torpedy_wyrzutnie_t ) - 1 do
            begin

              if i > 0 then
                uzbrojenie := uzbrojenie + ', ';

              for j := 0 to Length( zt_statek.torpedy_wyrzutnie_t[ i ].lufy_t ) - 1 do
                if zt_statek.torpedy_wyrzutnie_t[ i ].lufy_t[ j ].strza³_gotowoœæ then
                  uzbrojenie := uzbrojenie + ' *'
                else//if zt_statek.torpedy_wyrzutnie_t[ i ].lufy_t[ j ].strza³_gotowoœæ then
                  uzbrojenie := uzbrojenie + ' x';

              uzbrojenie := uzbrojenie +
                ' ' + Trim(  FormatFloat( '### ### ##0', i + 1 )  ) + ' - ' + Trim(  FormatFloat( '### ### ##0', zt_statek.torpedy_wyrzutnie_t[ i ].amunicja_iloœæ )  );


            end;
          //---//for i := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do


        end;
      //---//if Length( zt_statek.torpedy_wyrzutnie_t ) > 0 then
      {$endregion 'Opis uzbrojenia.'}



      {$region 'Ró¿a wiatrów.'}
      ztr := RadToDeg( // uses Math.
                 AngleBetweenVectors( // uses GLVectorGeometry.
                    GLVectorGeometry.VectorMake(  statek_gracza.AbsoluteDirection.X, 0, statek_gracza.AbsoluteDirection.Z  ),
                    GLVectorGeometry.VectorMake( 0, 0, -1 ),
                    GLVectorGeometry.VectorMake( 0, 0, 0 )
                  )
               );

      if statek_gracza.AbsoluteDirection.X < 0 then
        ztr := 360 - ztr;

      ró¿a_wiatrów := Trim(  FormatFloat( '### ### ##0.00', ztr )  );

      if ró¿a_wiatrów = '360,00' then
        ró¿a_wiatrów := '0,00';

      ró¿a_wiatrów := ró¿a_wiatrów + '* ';

      // PN W PD Z PNW PDW PDZ PZ

      if    ( ztr >= 0 )
        and ( ztr < 22.5) then
        ró¿a_wiatrów := ró¿a_wiatrów + 'PN'
      else
      if    ( ztr >= 22.5 )
        and ( ztr < 67.5) then
        ró¿a_wiatrów := ró¿a_wiatrów + 'PNW'
      else
      if    ( ztr >= 67.5 )
        and ( ztr < 112.5) then
        ró¿a_wiatrów := ró¿a_wiatrów + 'W'
      else
      if    ( ztr >= 112.5 )
        and ( ztr < 157.5) then
        ró¿a_wiatrów := ró¿a_wiatrów + 'PDW'
      else
      if    ( ztr >= 157.5 )
        and ( ztr < 202.5) then
        ró¿a_wiatrów := ró¿a_wiatrów + 'PD'
      else
      if    ( ztr >= 202.5 )
        and ( ztr < 247.5) then
        ró¿a_wiatrów := ró¿a_wiatrów + 'PDZ'
      else
      if    ( ztr >= 247.5 )
        and ( ztr < 292.5) then
        ró¿a_wiatrów := ró¿a_wiatrów + 'Z'
      else
      if    ( ztr >= 292.5 )
        and ( ztr < 337.5) then
        ró¿a_wiatrów := ró¿a_wiatrów + 'PNZ'
      else
      if ztr >= 337.5 then
        ró¿a_wiatrów := ró¿a_wiatrów + 'PN';
      {$endregion 'Ró¿a wiatrów.'}


      Informacje_G³ówne_GLHUDText.Text := Informacje_G³ówne_GLHUDText.Text +
        ' ¿ycie: ' + Trim(  FormatFloat( '### ### ##0', zt_statek.punkty_¿ycia )  ) + ' (' + Trim(  FormatFloat( '### ### ##0', zt_statek.punkty_¿ycia_procent_zosta³o )  ) + '%)' + #13#10 +
        ' prêdkoœæ %: ' + Trim(  FormatFloat( '### ### ##0', zt_statek.prêdkoœæ_zadana_procent )  ) + ' (' + Trim(  FormatFloat( '### ### ##0', zt_statek.prêdkoœæ_procent )  ) + ')' +
        ', busola: ' + ró¿a_wiatrów + #13#10 +
        ' ster %: ' + skrêt_kierunek_zadany + ' ' + Trim(   FormatFloat(  '### ### ##0', Abs( zt_statek.skrêt_zadany_procent )  )   ) + ' (' +  skrêt_kierunek + ' ' + Trim(   FormatFloat(  '### ### ##0', Abs( zt_statek.skrêt_procent )  )   ) + ')' + #13#10 +
        ' lf ';


      if zt_statek.podnoœ_lufy then
        Informacje_G³ówne_GLHUDText.Text := Informacje_G³ówne_GLHUDText.Text +
          'v'
      else//if zt_statek.podnoœ_lufy then
        Informacje_G³ówne_GLHUDText.Text := Informacje_G³ówne_GLHUDText.Text +
          'x';


      Informacje_G³ówne_GLHUDText.Text := Informacje_G³ówne_GLHUDText.Text +
        ' obr ' ;

      if zt_statek.obracaj_dzia³a then
        Informacje_G³ówne_GLHUDText.Text := Informacje_G³ówne_GLHUDText.Text +
          'v'
      else//if zt_statek.obracaj_dzia³a then
        Informacje_G³ówne_GLHUDText.Text := Informacje_G³ówne_GLHUDText.Text +
          'x';


      Informacje_G³ówne_GLHUDText.Text := Informacje_G³ówne_GLHUDText.Text +
        ' ind ' ;

      if zt_statek.broñ_indeks_zmieniaj then
        Informacje_G³ówne_GLHUDText.Text := Informacje_G³ówne_GLHUDText.Text +
          'v'
      else//if zt_statek.broñ_indeks_zmieniaj then
        Informacje_G³ówne_GLHUDText.Text := Informacje_G³ówne_GLHUDText.Text +
          'x';


      Informacje_G³ówne_GLHUDText.Text := Informacje_G³ówne_GLHUDText.Text +
        #13#10 +
        uzbrojenie;

      if Dalmierz_CheckBox.Checked then
        Informacje_G³ówne_GLHUDText.Text := Informacje_G³ówne_GLHUDText.Text +
          #13#10 + 'dalmierz: ' + Trim(   FormatFloat(  '### ### ##0.000', Gra_GLCamera.DistanceTo( Celowniczy_GLDummyCube.AbsolutePosition )  )   ) + '.';



      Radar_GLHUDText.Text :=
        'S x: ' + Trim(  FormatFloat( '### ### ##0', zt_statek.AbsolutePosition.X )  ) +
        ', z: ' + Trim(  FormatFloat( '### ### ##0', zt_statek.AbsolutePosition.Z )  );

      if Radar_Wspó³rzêdna_Y_CheckBox.Checked then
        Radar_GLHUDText.Text := Radar_GLHUDText.Text +
          ', y: ' + Trim(  FormatFloat( '### ### ##0', zt_statek.AbsolutePosition.Y )  );

      Radar_GLHUDText.Text := Radar_GLHUDText.Text +
        ', b: ' + ró¿a_wiatrów;

      if Radar_Wspó³rzêdne_Kursora_CheckBox.Checked then
        begin

          Radar_GLHUDText.Text := Radar_GLHUDText.Text + #13#10 +
            'C x: ' + Trim(  FormatFloat( '### ### ##0', wspó³rzêdne_œwiata_z_radaru_affine_vector_g.X )  ) +
            ', z: ' + Trim(  FormatFloat( '### ### ##0', wspó³rzêdne_œwiata_z_radaru_affine_vector_g.Z )  );

          if Radar_Wspó³rzêdna_Y_CheckBox.Checked then
            Radar_GLHUDText.Text := Radar_GLHUDText.Text +
              ', y: ' + Trim(  FormatFloat( '### ### ##0', wspó³rzêdne_œwiata_z_radaru_affine_vector_g.Y )  );

        end;
      //---//if Radar_Wspó³rzêdne_Kursora_CheckBox.Checked then


      if Dalmierz_CheckBox.Checked then
        Radar_GLHUDText.Text := Radar_GLHUDText.Text + #13#10 +
          'd: ' + Trim(   FormatFloat(  '### ### ##0.000', zt_statek.DistanceTo( wspó³rzêdne_œwiata_z_radaru_affine_vector_g )  )   );



      Informacje_G³ówne_GLHUDText.Text := Informacje_G³ówne_GLHUDText.Text +
           #13#10 +
//        'zt_statek.AbsoluteDirection.X ' + Trim(  FormatFloat( '### ### ##0.00', zt_statek.AbsoluteDirection.X )  ) + #13#10 +
//        'zt_statek.AbsoluteDirection.Y ' + Trim(  FormatFloat( '### ### ##0.00', zt_statek.AbsoluteDirection.Y )  ) + #13#10 +
//        'zt_statek.AbsoluteDirection.Z ' + Trim(  FormatFloat( '### ### ##0.00', zt_statek.AbsoluteDirection.Z )  ) + #13#10 +
//        'punkty ¿ycia ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.punkty_¿ycia )  ) + #13#10 +
//        'punkty ¿ycia 1 ' + Trim(  FormatFloat( '### ### ##0.000000', statki_t[ 1 ].punkty_¿ycia )  ) + #13#10 +
//        'prêdkoœæ procent ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.prêdkoœæ_procent )  ) + #13#10 +
//        'prêdkoœæ aktualna ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.prêdkoœæ_aktualna )  ) + ' z ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.prêdkoœæ_maksymalna )  ) + #13#10 +
//        'prêdkoœæ aktualna % ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.prêdkoœæ_aktualna * 100 / zt_statek.prêdkoœæ_maksymalna )  ) + #13#10 +
//        '  przyspieszanie ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.prêdkoœæ_przyspieszanie )  ) + #13#10 +
//        '  zadany procent ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.prêdkoœæ_zadana_procent )  ) + #13#10 +
//        '  zwalnianie ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.prêdkoœæ_zwalnianie )  ) + #13#10 +
//        '  zwalnianie kolizja ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.prêdkoœæ__kolizja_zwalnianie )  ) + #13#10 +
//        #13#10 +
//        'k¹t skrêtu aktualny ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.TurnAngle )  ) + #13#10 +
//        'k¹t skrêtu aktualny 1 ' + Trim(  FormatFloat( '### ### ##0.000000', statki_t[ 1 ].TurnAngle )  ) + #13#10 +
//        'skrêt procent ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.skrêt_procent )  ) + ' ' + skrêt_kierunek + #13#10 +
//        '  szybkoœæ wychylania steru ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.skrêt_szybkoœæ_wychylania_steru )  ) + #13#10 +
//        '  œruba 0 prêdkoœæ obrotowa aktualna procent ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.œruby_t[ 0 ].prêdkoœæ_obrotowa_aktualna_procent )  ) + #13#10 +
//        '  zadany ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.skrêt_zadany_procent )  ) + #13#10;

//        'prze³adowanie_wskaŸnik__pozycja_roz³adowany.Z ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.dzia³a_t[ 0 ].lufy_t[ 0 ].prze³adowanie_wskaŸnik__pozycja_roz³adowany.Z )  ) + #13#10 +
//        'prze³adowanie_wskaŸnik__pozycja_za³adowany.Z ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.dzia³a_t[ 0 ].lufy_t[ 0 ].prze³adowanie_wskaŸnik__pozycja_za³adowany.Z )  ) + #13#10 +
//        'prze³adowanie_wskaŸnik.Position.Z ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.dzia³a_t[ 0 ].lufy_t[ 0 ].prze³adowanie_wskaŸnik.Position.Z )  ) + #13#10 +        
//        'prze³adowanie_wskaŸnik__dystans_do_przesuniêcia ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.dzia³a_t[ 0 ].lufy_t[ 0 ].prze³adowanie_wskaŸnik__dystans_do_przesuniêcia )  ) + #13#10 +        
                
//        #13#10 +
//        'obrót ' + #13#10 +
//        '  obrót_k¹t_zadany ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.torpedy_wyrzutnie_t[ 0 ].obrót_k¹t_zadany )  ) + #13#10 +
//        '  obrót_k¹t_zadany bezwzglêdny ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.torpedy_wyrzutnie_t[ 0 ].obrót_k¹t_zadany_bezwzglêdny )  ) + #13#10 +
//        '  TurnAngle ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.torpedy_wyrzutnie_t[ 0 ].TurnAngle )  ) + #13#10 +
//        '  spr ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.torpedy_wyrzutnie_t[ 0 ].TurnAngle - zt_statek.torpedy_wyrzutnie_t[ 0 ].obrót_k¹t_zadany )  ) + #13#10 +
//        '  X ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.torpedy_wyrzutnie_t[ 0 ].obrót_kierunek_zadany.X )  ) + #13#10 +
//        '  Z ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.torpedy_wyrzutnie_t[ 0 ].obrót_kierunek_zadany.Z )  ) + #13#10 +
//        '  podniesienie_k¹t_zadany ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.dzia³a_t[ 0 ].podniesienie_k¹t_zadany )  ) + #13#10 +
//        '  PitchAngle ' + Trim(  FormatFloat( '### ### ##0.000000', zt_statek.dzia³a_t[ 0 ].lufy_t[ 0 ].PitchAngle )  ) + #13#10 +


//        'kamera kierunek ' + #13#10 +
//        '  x ' + Trim(  FormatFloat( '### ### ##0.000000', Gra_GLCamera.Direction.X )  ) + #13#10 +
//        '  y ' + Trim(  FormatFloat( '### ### ##0.000000', Gra_GLCamera.Direction.Y )  ) + #13#10 +
//        '  z ' + Trim(  FormatFloat( '### ### ##0.000000', Gra_GLCamera.Direction.Z )  ) + #13#10 +
//        'kamera kierunek absolutny' + #13#10 +
//        '  x ' + Trim(  FormatFloat( '### ### ##0.000000', Gra_GLCamera.AbsoluteDirection.X )  ) + #13#10 +
//        '  y ' + Trim(  FormatFloat( '### ### ##0.000000', Gra_GLCamera.AbsoluteDirection.Y )  ) + #13#10 +
//        '  z ' + Trim(  FormatFloat( '### ### ##0.000000', Gra_GLCamera.AbsoluteDirection.Z )  ) + #13#10 +
//        '  u ' + Trim(  FormatFloat( '### ### ##0.000000', Gra_GLCamera.Up.Y )  ) + #13#10 +
//        'kamera pozycja ' + #13#10 +
//        '  x ' + Trim(  FormatFloat( '### ### ##0.000000', Gra_GLCamera.Position.X )  ) + #13#10 +
//        '  y ' + Trim(  FormatFloat( '### ### ##0.000000', Gra_GLCamera.Position.Y )  ) + #13#10 +
//        '  z ' + Trim(  FormatFloat( '### ### ##0.000000', Gra_GLCamera.Position.Z )  ) + #13#10 +
//        'kamera rodzic pozycja' + #13#10 +
//        '  x ' + Trim(  FormatFloat( '### ### ##0.000000', Gra_GLCamera.Parent.Position.X )  ) + #13#10 +
//        '  y ' + Trim(  FormatFloat( '### ### ##0.000000', Gra_GLCamera.Parent.Position.Y )  ) + #13#10 +
//        '  z ' + Trim(  FormatFloat( '### ### ##0.000000', Gra_GLCamera.Parent.Position.Z )  ) + #13#10 +

//        'statek kierunek ' + #13#10 +
//        '  x ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.Direction.X )  ) + #13#10 +
//        '  y ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.Direction.Y )  ) + #13#10 +
//        '  z ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.Direction.Z )  ) + #13#10 +
//        'statek kierunek absolutny' + #13#10 +
//        '  x ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.AbsoluteDirection.X )  ) + #13#10 +
//        '  y ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.AbsoluteDirection.Y )  ) + #13#10 +
//        '  z ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.AbsoluteDirection.Z )  ) + #13#10 +

//        'mysz' + #13#10 +
//        '  mx ' + Trim(  FormatFloat( '### ### ##0.000000', Mouse.CursorPos.X )  ) + #13#10 +
//        '  my ' + Trim(  FormatFloat( '### ### ##0.000000', Mouse.CursorPos.Y )  ) + #13#10 +
//        '  x ' + Trim(  FormatFloat( '### ### ##0.000000', Gra_GLSceneViewer.Buffer.PixelRayToWorld( Mouse.CursorPos.X, Mouse.CursorPos.Y ).X )  ) + #13#10 +
//        '  y ' + Trim(  FormatFloat( '### ### ##0.000000', Gra_GLSceneViewer.Buffer.PixelRayToWorld( Mouse.CursorPos.X, Mouse.CursorPos.Y ).Y )  ) + #13#10 +
//        '  z ' + Trim(  FormatFloat( '### ### ##0.000000', Gra_GLSceneViewer.Buffer.PixelRayToWorld( Mouse.CursorPos.X, Mouse.CursorPos.Y ).Z )  ) + #13#10;
//        '  x ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.celownicza_linia.Nodes[ 1 ].X )  ) + #13#10 +
//        '  y ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.celownicza_linia.Nodes[ 1 ].Y )  ) + #13#10 +
//        '  z ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.celownicza_linia.Nodes[ 1 ].Z )  ) + #13#10 +

//        '  1 ' + BoolToStr( statek_gracza.torpedy_wyrzutnie_t[ 0 ].lufy_t[ 0 ].czy_indeks_do_strza³u_lufa ) + #13#10 +
//        '  2 ' + BoolToStr( statek_gracza.torpedy_wyrzutnie_t[ 0 ].lufy_t[ 1 ].czy_indeks_do_strza³u_lufa ) + #13#10 +
//        '  3 ' + BoolToStr( statek_gracza.torpedy_wyrzutnie_t[ 0 ].lufy_t[ 2 ].czy_indeks_do_strza³u_lufa ) + #13#10 +

//        '  lufy_t[ 0 ].Position.Z ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.artyleria_t[ 0 ].lufy_t[ 0 ].Position.Z )  ) + #13#10 +
//        '  PitchAngle ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.dzia³a_t[ 0 ].lufy_t[ 0 ].PitchAngle )  ) + #13#10 +
//        '  x ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.dzia³a_wygl¹d_t[ 0 ].AbsoluteDirection.X )  ) + #13#10 +
//        '  y ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.dzia³a_t[ 0 ].AbsoluteDirection.Y )  ) + #13#10 +
//        '  y ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.dzia³a_wygl¹d_t[ 0 ].AbsoluteDirection.Y )  ) + #13#10 +
//        '  z ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.dzia³a_t[ 0 ].AbsoluteDirection.Z )  ) + #13#10 +
//        '  z ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.dzia³a_wygl¹d_t[ 0 ].AbsoluteDirection.Z )  ) + #13#10 +

//        '  statek_gracza.radar_id_statki_w_zasiêgu ' + statek_gracza.radar_id_statki_w_zasiêgu + #13#10 +
//        '  statek_gracza.radio_id_statki_w_zasiêgu ' + statek_gracza.radio_id_statki_w_zasiêgu + #13#10 +
//        '  Gra_GLCamera.FocalLength ' + Trim(  FormatFloat( '### ### ##0', Gra_GLCamera.FocalLength ) ) + #13#10 +
//        '  Gra_GLUserInterface.MouseSpeed ' + Trim(  FormatFloat( '### ### ##0.000000', Gra_GLUserInterface.MouseSpeed ) ) + #13#10 +

//        '  statek_gracza.celownicza_linia.Nodes[ 1 ].X ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.celownicza_linia.Nodes[ 1 ].X ) ) + #13#10 +
//        '  statek_gracza.celownicza_linia.Nodes[ 1 ].Y ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.celownicza_linia.Nodes[ 1 ].Y ) ) + #13#10 +
//        '  statek_gracza.celownicza_linia.Nodes[ 1 ].Z ' + Trim(  FormatFloat( '### ### ##0.000000', statek_gracza.celownicza_linia.Nodes[ 1 ].Z ) ) + #13#10 +
//
//        '  statek_gracza.celownicza_linia.Nodes[ 1 ].X loc to abs ' + Trim(   FormatFloat(  '### ### ##0.000000', statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector ).X  )  ) + #13#10 +
//        '  statek_gracza.celownicza_linia.Nodes[ 1 ].Y loc to abs ' + Trim(   FormatFloat(  '### ### ##0.000000', statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Y  )  ) + #13#10 +
//        '  statek_gracza.celownicza_linia.Nodes[ 1 ].Z loc to abs ' + Trim(   FormatFloat(  '### ### ##0.000000', statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Z  )  ) + #13#10 +

//          '  amunicja_wystrzelona_list d³ugoœæ ' + Trim(  FormatFloat( '### ### ##0', amunicja_wystrzelona_list.Count ) ) + #13#10 +
//          '  wieloosobowe__amunicja_t d³ugoœæ ' + Trim(   FormatFloat(  '### ### ##0', Length( wieloosobowe__amunicja_t )  )  ) + #13#10 +
//          '  statki_t ' + Trim(   FormatFloat(  '### ### ##0', Length( statki_t )  )  ) + #13#10 +

//          '  Radar_Panel.Left ' + Trim(  FormatFloat( '### ### ##0', Radar_Panel.Left ) ) + #13#10 +
//          '  Radar_Panel.Top ' + Trim(  FormatFloat( '### ### ##0', Radar_Panel.Top ) ) + #13#10 +
//          '  Radar_Panel.Height ' + Trim(  FormatFloat( '### ### ##0', Radar_Panel.Height ) ) + #13#10 +
//          '  Radar_Panel.Width ' + Trim(  FormatFloat( '### ### ##0', Radar_Panel.Width ) ) + #13#10 +
//          '  Radar_Panel.Visible ' + Trim(  FormatFloat( '### ### ##0', integer(Radar_Panel.Visible) ) ) + #13#10 +

          '';

//      if Gra_GLCamera.Parent <> nil then
//        Informacje_G³ówne_GLHUDText.Text := Informacje_G³ówne_GLHUDText.Text +
//          '  kamera ' + Trim(   FormatFloat(  '### ### ##0.000000', Gra_GLCamera.DistanceTo( Gra_GLCamera.Parent )  )   );

      if Length( statki_t ) > 1 then
        begin

//          Informacje_G³ówne_GLHUDText.Text := Informacje_G³ówne_GLHUDText.Text +
//            'st' + #13#10 +
//            '  x ' + Trim(  FormatFloat( '### ### ##0.000000', statki_t[ 1 ].dzia³a_t[ 0 ].obrót_k¹t_zadany )  ) + #13#10 +
//            '  x ' + Trim(  FormatFloat( '### ### ##0.000000', statki_t[ 1 ].dzia³a_t[ 0 ].podniesienie_k¹t_zadany )  ) + #13#10 +
//            '  x ' + Trim(  FormatFloat( '### ### ##0.000000', statki_t[ 1 ].celownicza_linia.Nodes[ 1 ].X )  ) + #13#10 +
//            '  y ' + Trim(  FormatFloat( '### ### ##0.000000', statki_t[ 1 ].celownicza_linia.Nodes[ 1 ].Y )  ) + #13#10 +
//            '  z ' + Trim(  FormatFloat( '### ### ##0.000000', statki_t[ 1 ].celownicza_linia.Nodes[ 1 ].Z )  ) + #13#10 +
//            '';

        end;
      //--//

      if amunicja_wystrzelona_list.Count > 0 then
        begin

          Informacje_G³ówne_GLHUDText.Text := Informacje_G³ówne_GLHUDText.Text +
//            'a0' + #13#10 +
//            '  prêdkoœæ ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).prêdkoœæ )  ) + #13#10 +
//            '  prêdkoœæ_pocz¹tkowa ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).prêdkoœæ_pocz¹tkowa )  ) + #13#10 +
//            '  statek prêdkoœæ ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).statek_prêdkoœæ )  ) + #13#10 +
//            '  odleg³oœæ pozycja startowa ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).DistanceTo( TAmunicja(amunicja_wystrzelona_list[ 0 ]).pozycja_startowa ) )  ) + #13#10 +
//            '  p a ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.PitchAngle )  ) + #13#10 +
//            '  t a ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.TurnAngle )  ) + #13#10 +
//            '  r a ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.RollAngle )  ) + #13#10 +
//            '  opad korekta k¹t ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).opadanie_obrót_korekta_o_ustawienie_pocz¹tkowe )  ) + #13#10 +
//            '  opad korekta k¹t z ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).opadanie_obrót_korekta_o_k¹t_na_granicy_zasiêgu )  ) + #13#10 +
//            '  aDx ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).AbsoluteDirection.X )  ) + #13#10 +
//            '  aDy ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).AbsoluteDirection.Y )  ) + #13#10 +
//            '  aDz ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).AbsoluteDirection.Z )  ) + #13#10 +
//            '  aRx ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.Up.DirectX )  ) + #13#10 +
//            '  aRy ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.Up.DirectY )  ) + #13#10 +
//            '  aRz ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.Up.DirectZ )  ) + #13#10 +
//            '  aUx ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_ustawienie_pocz¹tkowe_dummy.AbsoluteUp.X )  ) + #13#10 +
//            '  aUy ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_ustawienie_pocz¹tkowe_dummy.AbsoluteUp.Y )  ) + #13#10 +
//            '  aUz ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_ustawienie_pocz¹tkowe_dummy.AbsoluteUp.Z )  ) + #13#10 +
//            '  aPx ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).AbsolutePosition.X )  ) + #13#10 +
//            '  aPy ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).AbsolutePosition.Y )  ) + #13#10 +
//            '  aPz ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).AbsolutePosition.Z )  ) + #13#10 +
//            '  korpus_opadanie_obrót_dummy aPy ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.AbsolutePosition.Y )  ) + #13#10 +
            //'  g ' + Trim(  FormatFloat( '### ### ##0.000000', -TAmunicja(amunicja_wystrzelona_list[ 0 ]).zanurzenie_g³êbokoœæ_po_wpadniêciu_do_wody )  ) + #13#10 +
//            '  prêdkoœæ_opadania ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).prêdkoœæ_opadania )  ) + #13#10 +
//            '  prêdkoœæ_opadania_wspó³czynnik ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).prêdkoœæ_opadania_wspó³czynnik )  ) + #13#10 +
//            '  zasiêg ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).zasiêg )  ) + #13#10 +
//
//            '  aDx ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.AbsoluteDirection.X )  ) + #13#10 +
//            '  aDy ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.AbsoluteDirection.Y )  ) + #13#10 +
//            '  aDz ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.AbsoluteDirection.Z )  ) + #13#10 +
//            '  PitchAngle ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.PitchAngle )  ) + #13#10 +
//            '  Tag ' + Trim(  FormatFloat( '### ### ##0', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.Tag )  ) + #13#10 +
//            '  TagFloat ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_opadanie_obrót_dummy.TagFloat )  ) + #13#10 +

            '';

        end;
      //---//

//      if Length( wieloosobowe__amunicja_t ) > 0 then
//        begin
//
//          Informacje_G³ówne_GLHUDText.Text := Informacje_G³ówne_GLHUDText.Text +
//            'wieloosobowe__amunicja_t' + #13#10 +
////            '  czy_torpeda_efekt_na_wodzie ' + BoolToStr( wieloosobowe__amunicja_t[ 0 ].czy_torpeda_efekt_na_wodzie ) + #13#10 +
//            '';
//
//        end;
      //---//

//      if amunicja_wystrzelona_list.Count > 1 then
//        begin
//
//          Informacje_G³ówne_GLHUDText.Text := Informacje_G³ówne_GLHUDText.Text +
//            'a1' + #13#10 +
//            '  y ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 1 ]).korpus_opadanie_obrót_dummy.AbsolutePosition.Y )  ) + #13#10 +
//            '  g ' + Trim(  FormatFloat( '### ### ##0.000000', -TAmunicja(amunicja_wystrzelona_list[ 1 ]).zanurzenie_g³êbokoœæ_po_wpadniêciu_do_wody )  ) + #13#10;
//            '';
//
//        end;
//      //---//
//
//      if amunicja_wystrzelona_list.Count > 2 then
//        begin
//
//          Informacje_G³ówne_GLHUDText.Text := Informacje_G³ówne_GLHUDText.Text +
//            'a2' + #13#10 +
//            '  y ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 2 ]).korpus_opadanie_obrót_dummy.AbsolutePosition.Y )  ) + #13#10 +
//            '  g ' + Trim(  FormatFloat( '### ### ##0.000000', -TAmunicja(amunicja_wystrzelona_list[ 2 ]).zanurzenie_g³êbokoœæ_po_wpadniêciu_do_wody )  ) + #13#10;
//
//        end;
//      //---//
//
//      if amunicja_wystrzelona_list.Count > 3 then
//        begin
//
//          Informacje_G³ówne_GLHUDText.Text := Informacje_G³ówne_GLHUDText.Text +
//            'a3' + #13#10 +
//            '  y ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 3 ]).korpus_opadanie_obrót_dummy.AbsolutePosition.Y )  ) + #13#10 +
//            '  g ' + Trim(  FormatFloat( '### ### ##0.000000', -TAmunicja(amunicja_wystrzelona_list[ 3 ]).zanurzenie_g³êbokoœæ_po_wpadniêciu_do_wody )  ) + #13#10;
//
//        end;
//      //---//

//      if amunicja_wystrzelona_list.Count > 0 then
//        begin
//          Informacje_G³ówne_GLHUDText.Text := Informacje_G³ówne_GLHUDText.Text +
//            'a1' + #13#10 +
//            //'  pro ' + Trim(  FormatFloat( '### ### ##0.000000', -TAmunicja(amunicja_wystrzelona_list[ 0 ]).prêdkoœæ )  ) + #13#10 +
//            //'  Y ' + Trim(  FormatFloat( '### ### ##0.000000', -TAmunicja(amunicja_wystrzelona_list[ 0 ]).prêdkoœæ_opadania * 10 * ( 1 - TAmunicja(amunicja_wystrzelona_list[ 0 ]).obra¿enia_zadawane_wspó³czynnik_zmodyfikowany ) )  ) + #13#10 +
//            //'  1 - woz ' + Trim(  FormatFloat( '### ### ##0.000000', 1 - TAmunicja(amunicja_wystrzelona_list[ 0 ]).obra¿enia_zadawane_wspó³czynnik_zmodyfikowany )  ) + #13#10 +
//            '  obra¿enia_zadawane_wspó³czynnik ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).obra¿enia_zadawane_wspó³czynnik )  ) + #13#10 +
//            '  obra¿enia_zadawane_wspó³czynnik_zmodyfikowany ' + Trim(  FormatFloat( '### ### ##0.000000', TAmunicja(amunicja_wystrzelona_list[ 0 ]).obra¿enia_zadawane_wspó³czynnik_zmodyfikowany )  ) + #13#10;
//
//        end;
//      //---//

//      if Length( statek_gracza.torpedy_wyrzutnie_t ) > 1 then
//        begin
//          Informacje_G³ówne_GLHUDText.Text := Informacje_G³ówne_GLHUDText.Text +
//            'tw' + #13#10 +
////            '  torpedy_wyrzutnia_ostatni_strza³_indeks ' + Trim(  FormatFloat( '### ### ##0', statek_gracza.torpedy_wyrzutnia_ostatni_strza³_indeks )  ) + #13#10 +
////            '  statek_gracza.torpedy_wyrzutnie_t[ 0 ].czy_indeks_do_strza³u ' + BoolToStr( statek_gracza.torpedy_wyrzutnie_t[ 0 ].czy_indeks_do_strza³u ) + #13#10 +
////            '  statek_gracza.torpedy_wyrzutnie_t[ 1 ].czy_indeks_do_strza³u ' + BoolToStr( statek_gracza.torpedy_wyrzutnie_t[ 1 ].czy_indeks_do_strza³u ) + #13#10 +
////            '  statek_gracza.torpedy_wyrzutnie_t[ 2 ].czy_indeks_do_strza³u ' + BoolToStr( statek_gracza.torpedy_wyrzutnie_t[ 2 ].czy_indeks_do_strza³u ) + #13#10 +
////            '  statek_gracza.torpedy_wyrzutnie_t[ 0 ].celownik_linia.Visible ' + BoolToStr( statek_gracza.torpedy_wyrzutnie_t[ 0 ].celownik_linia.Visible ) + #13#10 +
////            '  statek_gracza.torpedy_wyrzutnie_t[ 0 ].celownik_linia_bez_falowania ' + BoolToStr( statek_gracza.torpedy_wyrzutnie_t[ 0 ].celownik_linia_bez_falowania.Visible ) + #13#10 +
//            '';
//
//        end;
//      //---//

//Gra_GLSceneViewer.Buffer.PixelRayToWorld( Mouse.CursorPos.X, Mouse.CursorPos.Y ).;



      //???
      //Statki_Form.Caption := FloatToStr( Gra_GLCamera.Direction.X ) + ' ' + FloatToStr( Gra_GLCamera.Direction.Y ) + ' ' + FloatToStr( Gra_GLCamera.Direction.Z );
      //Statki_Form.Caption := FloatToStr( Gra_GLCamera.TurnAngle ) + ' ' + FloatToStr( Gra_GLCamera.PitchAngle ) + ' ' + FloatToStr( Gra_GLCamera.RollAngle );

    end;
  //---//if zt_statek <> nil then


  // Oznacza kiedy nie ma skupienia na 'ekranie' gry.
  //if Gra_GLSceneViewer.Focused then
  if Gra_GLSceneViewer.Tag = 1 then
    Informacje_G³ówne_GLHUDText.ModulateColor.Color :=  clrWhite
  else//if Gra_GLSceneViewer.Tag <> 0 then
    Informacje_G³ówne_GLHUDText.ModulateColor.Color := clrGray85;


  Informacje_Dodatkowe_GLHUDText.Position.X := Gra_GLSceneViewer.Width; // Prawy dó³.
  Informacje_Dodatkowe_GLHUDText.Position.Y := Gra_GLSceneViewer.Height;


  Gra_GLWindowsBitmapFont.EnsureString( Informacje_G³ówne_GLHUDText.Text );
  Gra_GLWindowsBitmapFont.EnsureString( Informacje_Dodatkowe_GLHUDText.Text );

  Radar_GLWindowsBitmapFont.EnsureString( Radar_GLHUDText.Text );

end;//---//Funkcja Napis_Odœwie¿().

//Funkcja Celownicza_Kula_Zmieñ_Pozycjê().
procedure TStatki_Form.Celownicza_Kula_Zmieñ_Pozycjê();
var
  ztr,
  ztr1
    : real;
  mysz_pozycja : TPoint;
  zt_vektor : TAffineVector;
begin

  if statek_gracza = nil then
    Exit;


  mysz_pozycja := Mouse.CursorPos;
  mysz_pozycja := ScreenToClient( mysz_pozycja );
  //Statki_Form.Caption := FloatToStr( mysz_pozycja.X ) + ' ' + FloatToStr( mysz_pozycja.Y ) + ' ' + FloatToStr( 0 ) + ' ' + FloatToStr( 0 );


  zt_vektor := Gra_GLSceneViewer.Buffer.PixelRayToWorld( mysz_pozycja.X, mysz_pozycja.Y );
  //zt_vektor := Gra_GLSceneViewer.Buffer.ScreenToWorld( mysz_pozycja.X, mysz_pozycja.Y );
  //Statki_Form.Caption := FloatToStr( zt_vektor.X ) + ' ' + FloatToStr( zt_vektor.Y ) + ' ' + FloatToStr( zt_vektor.Z );


  //Celownicza_GLSphere.Position.AsAffineVector := zt_vektor;


  //GLLines3.Nodes[ 1 ].AsAffineVector := zt_vektor;//Celownicza_GLSphere.Position.AsAffineVector;

  //zt_vektor := Gra_GLScene.Objects.LocalToAbsolute( zt_vektor );

//  GLLines3.Nodes[ 1 ].X := -zt_vektor.X;
//  GLLines3.Nodes[ 1 ].Y := zt_vektor.Y;
//  GLLines3.Nodes[ 1 ].Z := -zt_vektor.Z;

  //statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector := zt_vektor;
  statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector := statek_gracza.celownicza_linia.AbsoluteToLocal( zt_vektor );

  //???
  //if statek_gracza.celownicza_linia.Nodes[ 1 ].Y < 0 then // Chyba nie jest bardzo wa¿ne, p³aszczyzna wydaje siê poprawnie wykrywana.
  //  statek_gracza.celownicza_linia.Nodes[ 1 ].Y := 0;


  Celowniczy_GLDummyCube.Position.AsAffineVector := zt_vektor;


//  Celowniczy_GLDummyCube.Position.SetPoint( -6.6, 0.25, 0 ); //???
//  statek_gracza.celownicza_linia.Nodes[ 1 ].X := Celowniczy_GLDummyCube.Position.X; //???
//  statek_gracza.celownicza_linia.Nodes[ 1 ].Y := Celowniczy_GLDummyCube.Position.Y; //???
//  statek_gracza.celownicza_linia.Nodes[ 1 ].Z := Celowniczy_GLDummyCube.Position.Z; //???

//  Celowniczy_GLDummyCube.Position.X := zt_vektor.X;
//  Celowniczy_GLDummyCube.Position.Y := zt_vektor.Y;
//  Celowniczy_GLDummyCube.Position.Z := zt_vektor.Z;


//  Celownicza_GLSphere.Position.X := zt_vektor.X;
//  Celownicza_GLSphere.Position.Y := zt_vektor.Y;
//  Celownicza_GLSphere.Position.Z := zt_vektor.Z;


  //Celownicza_GLSphere.Position.SetPoint(  statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector )  );
  //Celownicza_GLSphere.Position.SetPoint( Gra_GLScene.Objects.LocalToAbsolute(GLLines3.Nodes[ 1 ].AsAffineVector) );
  //Celownicza_GLSphere.Position.SetPoint(  Gra_GLSceneViewer.Buffer.ScreenToWorld( mysz_pozycja.X, mysz_pozycja.Y )  );
  //Celownicza_GLSphere.Position.SetPoint(  Gra_GLSceneViewer.Buffer.ScreenToVector( mysz_pozycja.X, mysz_pozycja.Y )  );
  //Statki_Form.mo
  ztr := Gra_GLSceneViewer.Buffer.GetPixelDepth( mysz_pozycja.X, mysz_pozycja.Y );
  ztr1 := Gra_GLSceneViewer.Buffer.PixelDepthToDistance( ztr ); // Odleg³oœæ od kamery do wskazanego (mysz¹) punktu.

  //ztr := statek_gracza.celownicza_linia.DistanceTo( statek_gracza.celownicza_linia.Nodes[ 1 ].AsVector );
  ztr := statek_gracza.DistanceTo( statek_gracza.celownicza_linia.Nodes[ 1 ].AsVector ); // Odleg³oœæ od statku do wskazanego (mysz¹) punktu.

  //ztr := TGLBaseSceneObject(statek_gracza.celownicza_linia.Nodes[ 0 ]).DistanceTo( statek_gracza.celownicza_linia.Nodes[ 1 ].AsVector );

  //Celownicza_GLSphere.Position.Z := -ztr1;

  //Statki_Form.Caption := FloatToStr( ztr ) + ' ' + FloatToStr( ztr1 ) + ' ' + FloatToStr( mysz_pozycja.X ) + ' ' + FloatToStr( mysz_pozycja.Y );
  //Statki_Form.Caption := FloatToStr( ztr );
  //Statki_Form.Caption := FloatToStr( ztr1 ) + ' ' + FloatToStr( ztr );

  //Celownicza_GLSphere.Position.SetPoint(  Gra_GLSceneViewer.Buffer.ScreenToVector( Mouse.CursorPos.X, Mouse.CursorPos.Y )  );
  //Celownicza_GLSphere.Position.SetPoint(  Gra_GLSceneViewer.Buffer.PixelRayToWorld( Mouse.CursorPos.X, Mouse.CursorPos.Y )  );

//          Gra_GLCamera.Direction.SetVector
//            (
//                zt_statek.Position.X - Gra_GLCamera.Position.X
//              , zt_statek.Position.Y - Gra_GLCamera.Position.Y
//              , zt_statek.Position.Z - Gra_GLCamera.Position.Z
//            );


  //statek_gracza.GLArrowLine1.Direction.SetVector(  NormalizeVector( statek_gracza.celownicza_linia.Nodes[ 1 ].AsVector )  );
  //statek_gracza.GLArrowLine1.Direction.SetVector( statek_gracza.celownicza_linia.Nodes[ 1 ].AsVector );
  //zt_vektor.Y := 0;
//  NormalizeVector( zt_vektor );
//  statek_gracza.GLArrowLine1.Direction.SetVector( zt_vektor );
//  statek_gracza.GLArrowLine1.Direction.AsVector := GLVectorGeometry.VectorNegate( statek_gracza.GLArrowLine1.Direction.AsVector );

//  statek_gracza.GLArrowLine1.Direction.SetVector
//    (   // Cel                 Obiekt celuj¹cy
//        -(statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector ).X - statek_gracza.GLArrowLine1.AbsolutePosition.X)
//      , statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Y - statek_gracza.GLArrowLine1.AbsolutePosition.Y
//      , -(statek_gracza.celownicza_linia.LocalToAbsolute( statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector ).Z - statek_gracza.GLArrowLine1.AbsolutePosition.Z)
//    );

//  statek_gracza.GLArrowLine1.Direction.SetVector
//    (   // Cel                 Obiekt celuj¹cy
//        -(statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector.X - statek_gracza.GLArrowLine1.Position.X)
//      , statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector.Y - statek_gracza.GLArrowLine1.Position.Y
//      , -(statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector.Z - statek_gracza.GLArrowLine1.Position.Z)
//    );

  //NegateVector( statek_gracza.GLArrowLine1.Direction.AsVector );

end;//---//Funkcja Celownicza_Kula_Zmieñ_Pozycjê().

//Funkcja Pauza().
procedure TStatki_Form.Pauza( const czy_pauza_f : boolean );
begin

  //
  // Funkcja ustawia pauzê.
  //
  // Parametry:
  //   czy_zwolniæ:
  //     true - w³¹cza pauzê.
  //     false - wy³¹cza pauzê.
  //

  czy_pauza_g := czy_pauza_f;


  Czas_Bezwzglêdny_Timer.Enabled := not czy_pauza_g;
  Gra_GLCadencer.Enabled := not czy_pauza_g;
  Radar_Timer.Enabled := not czy_pauza_g;

  if czy_pauza_g then
    begin

      //mouse_look_active_przed_pauz¹ := Gra_GLUserInterface.MouseLookActive;
      //Gra_GLUserInterface.MouseLookActive := false;
      Napis_Odœwie¿();

    end;
  //else//if czy_pauza_g then
    //Gra_GLUserInterface.MouseLookActive := mouse_look_active_przed_pauz¹;

end;//---//Funkcja Pauza().

//Funkcja Elementy_Gry_Przygotuj().
procedure TStatki_Form.Elementy_Gry_Przygotuj();
var
  i : integer;
begin

  //
  // Funkcja przygotowuje elementy potrzebne dla gry.
  //

  czas_bezwzglêdny_g := 0;
  id_amunicja_g := Low( cardinal );

  if not czy_klient_g then // Klient otrzyma wytyczne tworzenia statków osobno.
    begin

        for i := 0 to tcp_klienci_lista_g.klienci_lista_list.Count - 1 do
          begin

            SetLength( statki_t, i + 1 );
            statki_t[ i ] := TStatek.Create(  Gra_Obiekty_GLDummyCube, Statki_Form.Gra_GLCollisionManager, i, Statek_Odczytaj_Schemat( TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).id_statek_schemat ), prymitywy_lista_t  );
            statki_t[ i ].id_grupa := TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).id_grupa;
            statki_t[ i ].id_statek := TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator;
            statki_t[ i ].id_statek_schemat := TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).id_statek_schemat;
            statki_t[ i ].gracz__nazwa.Text := TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).nazwa;

            // Ustawi wspó³rzêdne celu poza statkiem.
            statki_t[ i ].celownicza_linia.Nodes[ 1 ].X := 0;
            statki_t[ i ].celownicza_linia.Nodes[ 1 ].Y := 5;
            statki_t[ i ].celownicza_linia.Nodes[ 1 ].Z := -15;


            // Gdy gracz nie jest gotowy to ma id_grupa = 0 i przy rozstawianiu statków indeks jest poza zakresem tabeli gra_pozycja_pocz¹tkowa_parametry_t.
            //if    ( statki_t[ i ].id_grupa <> 1 )
            //  and ( statki_t[ i ].id_grupa <> 2 ) then
            //   statki_t[ i ].id_grupa := 1;


            if TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator = Gracz_Identyfikator() then
              begin

                statek_gracza := statki_t[ i ];

                // Pozycja kamery na statek. //???

                statek_gracza.Elementy_Gracza_Dostosuj( -99, Punkty_¯ycia_WskaŸnik__Gracz_CheckBox.Checked, false, false, Obrót_K¹t_Zablokowany_WskaŸnik_CheckBox.Checked, Obrót_K¹t_Zablokowany_Strza³_WskaŸnik_CheckBox.Checked );

                Interfejs_Parametry_Wed³ug_Statku_Ustaw();

              end
            else//if TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator = Gracz_Identyfikator() then
              begin

                statki_t[ i ].Elementy_Gracza_Widocznoœæ( Gracz_Grupa_SpinEdit.Value, false );
                statki_t[ i ].Elementy_Gracza_Dostosuj( Gracz_Grupa_SpinEdit.Value, false, Punkty_¯ycia_WskaŸnik__Przeciwnik_CheckBox.Checked, Punkty_¯ycia_WskaŸnik__Sojusznik_CheckBox.Checked, false, false );

              end;
            //---//if TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator = Gracz_Identyfikator() then

          end;
        //---//for i := 0 to tcp_klienci_lista_g.klienci_lista_list.Count - 1 do


        L¹d_Utwórz( L¹d_ComboBox.ItemIndex ); // Wczytuje pozycje pocz¹tkowe statków.


        Statki_Rozstaw( nil );

    end;
  //---//if not czy_klient_g then


  Czas_Bezwzglêdny_Timer.Enabled := true;

  if    ( not czy_klient_g )
    and ( statek_gracza = nil ) then
    Application.MessageBox( 'Nie uda³o siê zlokalizowaæ statku gracza.', 'Informacja', MB_ICONEXCLAMATION );

end;//---//Funkcja Elementy_Gry_Przygotuj().

//Funkcja Elementy_Gry_Zwolnij().
procedure TStatki_Form.Elementy_Gry_Zwolnij();
var
  i : integer;
begin

  //
  // Funkcja zwalnia utworzone elementy gry.
  //

  Amunicja_Wystrzelona_Zwolnij_Wszystkie();


  for i := wieloosobowe_amunicja_wystrzelona_list.Count - 1 downto 0 do
    begin

      //TAmunicja(wieloosobowe_amunicja_wystrzelona_list[ i ]).Free(); //???
      TGLCylinder(wieloosobowe_amunicja_wystrzelona_list[ i ]).Free();
      wieloosobowe_amunicja_wystrzelona_list.Delete( i );

    end;
  //---//for i := wieloosobowe_amunicja_wystrzelona_list.Count - 1 downto 0 do


  L¹d_Zwolnij();

  Trafienia_Efekt_Zwolnij_Wszystkie();

  
  Statki_Zwolnij();

  
  Wieloosobowe_Statki_Rekord_Czyœæ();

  SetLength( wieloosobowe__amunicja_t, 0 );
  SetLength( wieloosobowe__efekt_t, 0 );

end;//---//Funkcja Elementy_Gry_Zwolnij().

//Funkcja Statek_Przywróæ_Do_Gry().
procedure TStatki_Form.Statek_Przywróæ_Do_Gry( const id_statek_f : integer );
var
  i : integer;
begin

  //
  // Funkcja wyszukuje po id statek, który nale¿y przywróciæ do gry i wywo³uje funkcje przywracania statku do gry.
  //

  for i := 0 to Length( statki_t ) - 1 do
    if statki_t[ i ].id_statek = id_statek_f then
      begin

        Statek_Przywróæ_Do_Gry( statki_t[ i ] );

        Break;

      end;
    //---//if statek_f = statki_t[ i ] then

end;//---//Funkcja Statek_Przywróæ_Do_Gry().

//Funkcja Statek_Przywróæ_Do_Gry().
procedure TStatki_Form.Statek_Przywróæ_Do_Gry( const statek_f : TStatek );
var
  i,
  j,
  id_grupa_l,
  id_statek_l,
  id_statek_schemat_l
    : integer;
  czy_statek_gracza_l : boolean;
  gracz__nazwa_l : string;
begin

  //
  // Funkcja zwalnia i tworzy na nowo statek.
  //


  // Pojawia siê b³¹d access violation nie wiadomo gdzie. //???

  id_statek_l := -99;


  for i := 0 to Length( statki_t ) - 1 do
    if statek_f = statki_t[ i ] then
      begin

        id_grupa_l := statki_t[ i ].id_grupa;
        id_statek_l := statki_t[ i ].id_statek;
        id_statek_schemat_l := statki_t[ i ].id_statek_schemat;
        gracz__nazwa_l := statki_t[ i ].gracz__nazwa.Text;

        if statek_gracza = statki_t[ i ] then
          begin

            czy_statek_gracza_l := true;
            statek_gracza := nil; // Nie zmienia statki_t[ 0 ].

          end
        else//if statek_gracza = statki_t[ i ] then
          czy_statek_gracza_l := false;


        for j := trafienia_efekt_list.Count - 1 downto 0 do
          begin

            // Zwalnia efekty umieszczone na statku.
            // Je¿eli efekty umieszczone na statku nadal s¹ na scenie pojawiaj¹ siê b³êdy dostêpu.

            if   ( TTrafienia_Efekt(trafienia_efekt_list[ j ]).Owner = statki_t[ i ] )
              or ( TTrafienia_Efekt(trafienia_efekt_list[ j ]).Parent = statki_t[ i ] ) then
              Trafienia_Efekt_Zwolnij_Jeden( TTrafienia_Efekt(trafienia_efekt_list[ j ]) );

          end;
        //---//for j := trafienia_efekt_list.Count - 1 downto 0 do


        if Gra_GLCamera.Parent = statki_t[ i ] then
          Kamera_Prze³¹cz( kt_Statek_Swobodna );


        FreeAndNil( statki_t[ i ] );


        statki_t[ i ] := TStatek.Create(  Gra_Obiekty_GLDummyCube, Statki_Form.Gra_GLCollisionManager, i, Statek_Odczytaj_Schemat( id_statek_schemat_l ), prymitywy_lista_t  );
        statki_t[ i ].id_grupa := id_grupa_l;
        statki_t[ i ].id_statek := id_statek_l;
        statki_t[ i ].id_statek_schemat := id_statek_schemat_l;
        statki_t[ i ].gracz__nazwa.Text := gracz__nazwa_l;


        if czy_statek_gracza_l then
          begin

            statek_gracza := statki_t[ i ];

            statek_gracza.Elementy_Gracza_Dostosuj( -99, Punkty_¯ycia_WskaŸnik__Gracz_CheckBox.Checked, false, false, Obrót_K¹t_Zablokowany_WskaŸnik_CheckBox.Checked, Obrót_K¹t_Zablokowany_Strza³_WskaŸnik_CheckBox.Checked );

            if not ( Gra_GLCamera.Parent is TStatek ) then
              Kamera_Prze³¹cz( kt_Statek ); // Ustawi kamerê na statku gracza.

          end
        else//if czy_statek_gracza_l then
          begin

            statki_t[ i ].Elementy_Gracza_Widocznoœæ( Gracz_Grupa_SpinEdit.Value, false );
            statki_t[ i ].Elementy_Gracza_Dostosuj( Gracz_Grupa_SpinEdit.Value, false, Punkty_¯ycia_WskaŸnik__Przeciwnik_CheckBox.Checked, Punkty_¯ycia_WskaŸnik__Sojusznik_CheckBox.Checked, false, false );

          end;
        //---//if czy_statek_gracza_l then


        if czy_klient_g then
          statki_t[ i ].Visible := false; // Po przywróceniu statku do gry klient umieszcza go na wyliczonej samodzielnie pozycji i dopiero po odebraniu danych o pozycji z serwera zaktualizuje pozycjê statku i ustawi na widoczny.


        Break;

      end;
    //---//if statek_f = statki_t[ i ] then


  if id_statek_l = -99 then
    begin

      Application.MessageBox( 'Nie uda³o siê zlokalizowaæ statku do przywrócenia.', 'Informacja', MB_ICONEXCLAMATION );
      Exit;

    end;
  //---//if id_statek_l = -99 then


  if    ( i >= 0 )
    and (  i <= Length( statki_t ) - 1  ) then
    Statki_Rozstaw( statki_t[ i ] );


  if czy_serwer_g then
    begin

      wieloosobowe__statek_przywróæ_do_gry__id_statek_g := id_statek_l;
      Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__statek__przywróæ_do_gry_c, -99, '' );

    end;
  //---//if czy_serwer_g then

end;//---//Funkcja Statek_Przywróæ_Do_Gry().

//Funkcja Statki_Rozstaw().
procedure TStatki_Form.Statki_Rozstaw( const statek_f : TStatek );
var
  i,
  j,
  id_grupa_l,
  pozycja_ustawienie_iloœæ_prób,
  statki_kolejnoœæ_w_grupie_l,
  statki_iloœæ_w_grupie_l
    : integer;
  ztr : single;
  koniec_grup_l : boolean;
begin

  //
  // Funkcja ustawia pocz¹tkow¹ pozycjê statków (tworzy formacjê).
  //
  // Parametry:
  //   statek_f:
  //     nil - rozstawia wszystkie statki.
  //     nie nil - rozstawia wskazany statek.
  //


  koniec_grup_l := false; // Aby uruchomiæ pierwszy przebieg pêtli.
  id_grupa_l := -1;


  if statek_f = nil then
    begin

      if Statki_Pozycje_Pocz¹tkowe_ComboBox.ItemIndex >= 0 then
        begin

          gra_pozycja_pocz¹tkowa_parametry_t[ 1 ] := statki_pozycja_pocz¹tkowa_parametry_t[ 1 ];
          gra_pozycja_pocz¹tkowa_parametry_t[ 2 ] := statki_pozycja_pocz¹tkowa_parametry_t[ 2 ];

        end
      else//if Statki_Pozycje_Pocz¹tkowe_ComboBox.ItemIndex >= 0 then
        begin

          gra_pozycja_pocz¹tkowa_parametry_t[ 1 ] := l¹d_pozycja_pocz¹tkowa_parametry_t[ 1 ];
          gra_pozycja_pocz¹tkowa_parametry_t[ 2 ] := l¹d_pozycja_pocz¹tkowa_parametry_t[ 2 ];

        end;
      //---//if Statki_Pozycje_Pocz¹tkowe_ComboBox.ItemIndex >= 0 then

    end;
  //---//if statek_f = nil then


  while not koniec_grup_l do
    begin

      // Pêtla dla wszystkich grup.


      koniec_grup_l := true;


      if statek_f = nil then
        begin

          if id_grupa_l <= -1 then
            begin

              // Wyszuka najmniejsze id_grupa.

              for i := 0 to Length( statki_t ) - 1 do
                if   ( id_grupa_l <= -1 )
                  or ( statki_t[ i ].id_grupa < id_grupa_l ) then
                  begin

                    id_grupa_l := statki_t[ i ].id_grupa;

                    if koniec_grup_l then
                      koniec_grup_l := false;

                  end;
                //---//if statki_t[ i ].id_grupa > id_grupa_l then

            end
          else//if id_grupa_l <= -1 then
            begin

              // Wyszuka kolejne id_grupa.

              for i := 0 to Length( statki_t ) - 1 do
                if statki_t[ i ].id_grupa > id_grupa_l then
                  begin

                    koniec_grup_l := false;
                    id_grupa_l := statki_t[ i ].id_grupa;
                    Break;

                  end;
                //---//if statki_t[ i ].id_grupa > id_grupa_l then

            end;
          //---//if id_grupa_l <= -1 then


          if   ( id_grupa_l <= -1 )
            or ( koniec_grup_l ) then
            Exit; // Nie ma wiêcej grup.

        end
      else//if statek_f = nil then
        begin

          id_grupa_l := statek_f.id_grupa;

        end;
      //---//if statek_f = nil then


      statki_iloœæ_w_grupie_l := 0;

      for i := 0 to Length( statki_t ) - 1 do
        if statki_t[ i ].id_grupa = id_grupa_l then
          inc( statki_iloœæ_w_grupie_l );


      // Gdy gracz nie jest gotowy to ma id_grupa = 0 i przy rozstawianiu statków indeks jest poza zakresem tabeli gra_pozycja_pocz¹tkowa_parametry_t.
      if    ( id_grupa_l <> 1 )
        and ( id_grupa_l <> 2 ) then
         id_grupa_l := 1;


      // Obs³uguje tylko 2 grupy.
      statki_kolejnoœæ_w_grupie_l := 0;

      for i := 0 to Length( statki_t ) - 1 do
        if    ( statki_t[ i ].id_grupa = id_grupa_l )
          and (
                   ( statek_f = nil )
                or (
                         ( statek_f <> nil )
                     and ( statki_t[ i ].id_statek = statek_f.id_statek )
                   )
              ) then
          begin

            if statek_f = nil then
              inc( statki_kolejnoœæ_w_grupie_l )
            else//if statek_f = nil then
              statki_kolejnoœæ_w_grupie_l := Random( statki_iloœæ_w_grupie_l ) + 1;


            //statki_t[ i ].Position.X := gra_pozycja_pocz¹tkowa_parametry_t[ id_grupa_l ].odstêp_x * ( statki_kolejnoœæ_w_grupie_l - 1 );
            statki_t[ i ].Position.X :=
                gra_pozycja_pocz¹tkowa_parametry_t[ id_grupa_l ].odstêp_x * ( statki_kolejnoœæ_w_grupie_l - 1 )
              - (  gra_pozycja_pocz¹tkowa_parametry_t[ id_grupa_l ].odstêp_x * ( statki_iloœæ_w_grupie_l - 1 ) * 0.5  )
              + gra_pozycja_pocz¹tkowa_parametry_t[ id_grupa_l ].korekta_x;

            if id_grupa_l = 1 then
              begin

                statki_t[ i ].Position.Z :=
                    gra_pozycja_pocz¹tkowa_parametry_t[ id_grupa_l ].z
                  + gra_pozycja_pocz¹tkowa_parametry_t[ id_grupa_l ].korekta_z * ( statki_kolejnoœæ_w_grupie_l - 1 );
                statki_t[ i ].TurnAngle := gra_pozycja_pocz¹tkowa_parametry_t[ id_grupa_l ].korekta_obrót;

              end
            else//if id_grupa_l = 1 then
              begin

                statki_t[ i ].Position.Z :=
                    gra_pozycja_pocz¹tkowa_parametry_t[ id_grupa_l ].z
                  + gra_pozycja_pocz¹tkowa_parametry_t[ id_grupa_l ].korekta_z * ( statki_kolejnoœæ_w_grupie_l - 1 );
                statki_t[ i ].TurnAngle := gra_pozycja_pocz¹tkowa_parametry_t[ id_grupa_l ].korekta_obrót;

              end;
            //---//if id_grupa_l = 1 then


            {$region 'Sprawdza odleg³oœæ do najbli¿szego statku i l¹du.'}
            ztr := 9999999;
            pozycja_ustawienie_iloœæ_prób := 0;

            while ( ztr = 9999999 )
              and ( pozycja_ustawienie_iloœæ_prób < 100 ) do
              begin

                inc( pozycja_ustawienie_iloœæ_prób );

                statki_t[ i ].statki_rozstawianie_status := srs_Rozstawianie_Kolizja_SprawdŸ;


                for j := 0 to Length( statki_t ) - 1 do
                  if statki_t[ j ].id_statek <> statki_t[ i ].id_statek then
                    if ztr > statki_t[ i ].DistanceTo( statki_t[ j ] ) then
                      ztr := statki_t[ i ].DistanceTo( statki_t[ j ] );


                if ztr >= gra_pozycja_pocz¹tkowa_parametry_t[ id_grupa_l ].odstêp_x then
                  if   ( l¹d_list <> nil )
                    and (  Assigned( l¹d_list )  ) then
                    for j := 0 to l¹d_list.Count - 1 do
                      if ztr > statki_t[ i ].DistanceTo( TGLCustomSceneObject(l¹d_list[ j ]) ) then
                        ztr := statki_t[ i ].DistanceTo( TGLCustomSceneObject(l¹d_list[ j ]) );


                if ztr >= gra_pozycja_pocz¹tkowa_parametry_t[ id_grupa_l ].odstêp_x then
                  Gra_GLCollisionManager.CheckCollisions(); // Uwzglêdnia wielkoœæ obiektów l¹du i statków.


                if   ( ztr < gra_pozycja_pocz¹tkowa_parametry_t[ id_grupa_l ].odstêp_x )
                  or ( statki_t[ i ].statki_rozstawianie_status = srs_Rozstawianie_Kolizja_Wykryta ) then
                  begin

                    ztr := 9999999;
                    statki_t[ i ].Position.X := statki_t[ i ].Position.X + 1;

                    if gra_pozycja_pocz¹tkowa_parametry_t[ id_grupa_l ].z >= 0 then
                      statki_t[ i ].Position.Z := statki_t[ i ].Position.Z + 1
                    else//if gra_pozycja_pocz¹tkowa_parametry_t[ id_grupa_l ].z >= 0 then
                      statki_t[ i ].Position.Z := statki_t[ i ].Position.Z - 1;

                  end;
                //---//if ztr < gra_pozycja_pocz¹tkowa_parametry_t[ id_grupa_l ].odstêp_x then

              end;
            //---//while ( ztr = 9999999 ) (...)


            if statki_t[ i ].statki_rozstawianie_status <> srs_Brak then
              statki_t[ i ].statki_rozstawianie_status := srs_Brak;
            {$endregion 'Sprawdza odleg³oœæ do najbli¿szego statku i l¹du.'}


            if statek_f <> nil then
              Break;

          end;
        //---//if    ( statki_t[ i ].id_grupa = id_grupa_l ) (...)


      if statek_f <> nil then
        Exit;

    end;
  //---//while not koniec_grup_l do

end;//---//Funkcja Statki_Rozstaw().

//Funkcja Ustawienia_Plik().
procedure TStatki_Form.Ustawienia_Plik( const zapisuj_ustawienia_f : boolean = false );
var
  plik_ini : TIniFile; // uses IniFiles.
  zti : integer;
  ztr : real;
  zts : string;
begin//Funkcja Ustawienia_Plik().
//??? sprawdzic wszystkie pozycje
  //
  // Funkcja wczytuje i zapisuje ustawienia.
  //
  // Parametry:
  //   zapisuj_ustawienia_f:
  //     false - tylko odczytuje ustawienia.
  //     true - zapisuje ustawienia.
  //

  zts := ExtractFilePath( Application.ExeName ) + 'Statki.ini';

  plik_ini := TIniFile.Create( zts );


  {$region 'KLAWIATURA_KONFIGURACJA.'}
  zti := Klawiatura_Konfiguracja__Konfiguracja_Numer_SpinEdit.Value;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'KLAWIATURA_KONFIGURACJA', 'klawiatura_konfiguracja__konfiguracja_numer' )  ) then
    plik_ini.WriteInteger( 'KLAWIATURA_KONFIGURACJA', 'klawiatura_konfiguracja__konfiguracja_numer', zti )
  else
    zti := plik_ini.ReadInteger( 'KLAWIATURA_KONFIGURACJA', 'klawiatura_konfiguracja__konfiguracja_numer', zti ); // Je¿eli nie znajdzie to podstawia wartoœæ zti.

  Klawiatura_Konfiguracja__Konfiguracja_Numer_SpinEdit.Value := zti;


  if Klawiatura_Konfiguracja__Rozmiar_Zak³adki_Poszerz_CheckBox.Checked then
    zts := 'tak'
  else//if Klawiatura_Konfiguracja__Rozmiar_Zak³adki_Poszerz_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'KLAWIATURA_KONFIGURACJA', 'klawiatura_konfiguracja__rozmiar_zak³adki_poszerz' )  ) then
    plik_ini.WriteString( 'KLAWIATURA_KONFIGURACJA', 'klawiatura_konfiguracja__rozmiar_zak³adki_poszerz', zts )
  else
    zts := plik_ini.ReadString( 'KLAWIATURA_KONFIGURACJA', 'klawiatura_konfiguracja__rozmiar_zak³adki_poszerz', zts ); // Je¿eli nie znajdzie to podstawia wartoœæ zts.

  Klawiatura_Konfiguracja__Rozmiar_Zak³adki_Poszerz_CheckBox.Checked := zts = 'tak';
  {$endregion 'KLAWIATURA_KONFIGURACJA.'}

  {$region 'POZOSTA£E.'}
  zti := Statki_Zaprezentuj__Pozycja_Pocz¹tkowa__X_SpinEdit.Value;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'POZOSTA£E', 'statki_zaprezentuj__pozycja_pocz¹tkowa__x' )  ) then
    plik_ini.WriteInteger( 'POZOSTA£E', 'statki_zaprezentuj__pozycja_pocz¹tkowa__x', zti )
  else
    zti := plik_ini.ReadInteger( 'POZOSTA£E', 'statki_zaprezentuj__pozycja_pocz¹tkowa__x', zti ); // Je¿eli nie znajdzie to podstawia wartoœæ zti.

  Statki_Zaprezentuj__Pozycja_Pocz¹tkowa__X_SpinEdit.Value := zti;


  zti := Statki_Zaprezentuj__Pozycja_Pocz¹tkowa__Y_SpinEdit.Value;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'POZOSTA£E', 'statki_zaprezentuj__pozycja_pocz¹tkowa__y' )  ) then
    plik_ini.WriteInteger( 'POZOSTA£E', 'statki_zaprezentuj__pozycja_pocz¹tkowa__y', zti )
  else
    zti := plik_ini.ReadInteger( 'POZOSTA£E', 'statki_zaprezentuj__pozycja_pocz¹tkowa__y', zti ); // Je¿eli nie znajdzie to podstawia wartoœæ zti.

  Statki_Zaprezentuj__Pozycja_Pocz¹tkowa__Y_SpinEdit.Value := zti;


  zti := Statki_Zaprezentuj__Pozycja_Pocz¹tkowa__Z_SpinEdit.Value;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'POZOSTA£E', 'statki_zaprezentuj__pozycja_pocz¹tkowa__z' )  ) then
    plik_ini.WriteInteger( 'POZOSTA£E', 'statki_zaprezentuj__pozycja_pocz¹tkowa__z', zti )
  else
    zti := plik_ini.ReadInteger( 'POZOSTA£E', 'statki_zaprezentuj__pozycja_pocz¹tkowa__z', zti ); // Je¿eli nie znajdzie to podstawia wartoœæ zti.

  Statki_Zaprezentuj__Pozycja_Pocz¹tkowa__Z_SpinEdit.Value := zti;


  zti := Statki_Zaprezentuj__Odstêpy_Miêdzy_Statkami_SpinEdit.Value;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'POZOSTA£E', 'statki_zaprezentuj__odstêpy_miêdzy_statkami' )  ) then
    plik_ini.WriteInteger( 'POZOSTA£E', 'statki_zaprezentuj__odstêpy_miêdzy_statkami', zti )
  else
    zti := plik_ini.ReadInteger( 'POZOSTA£E', 'statki_zaprezentuj__odstêpy_miêdzy_statkami', zti ); // Je¿eli nie znajdzie to podstawia wartoœæ zti.

  Statki_Zaprezentuj__Odstêpy_Miêdzy_Statkami_SpinEdit.Value := zti;


  if Statki_Zaprezentuj__Kolumna_CheckBox.Checked then
    zts := 'tak'
  else//if Statki_Zaprezentuj__Kolumna_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'POZOSTA£E', 'statki_zaprezentuj__kolumna' )  ) then
    plik_ini.WriteString( 'POZOSTA£E', 'statki_zaprezentuj__kolumna', zts )
  else
    zts := plik_ini.ReadString( 'POZOSTA£E', 'statki_zaprezentuj__kolumna', zts ); // Je¿eli nie znajdzie to podstawia wartoœæ zts.

  Statki_Zaprezentuj__Kolumna_CheckBox.Checked := zts = 'tak';
  {$endregion 'POZOSTA£E.'}

  {$region 'PREFERENCJE.'}
  zti := 1;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'PREFERENCJE', 'gracz_grupa' )  ) then
    plik_ini.WriteInteger( 'PREFERENCJE', 'gracz_grupa', zti )
  else
    zti := plik_ini.ReadInteger( 'PREFERENCJE', 'gracz_grupa', zti ); // Je¿eli nie znajdzie to podstawia wartoœæ zti.

  Gracz_Grupa_SpinEdit.Value := zti;


  zts := Gracz_Nazwa_Edit.Text;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'WIELOOSOBOWE', 'gracz_nazwa' )  ) then
    plik_ini.WriteString( 'WIELOOSOBOWE', 'gracz_nazwa', zts )
  else
    zts := plik_ini.ReadString( 'WIELOOSOBOWE', 'gracz_nazwa', zts ); // Je¿eli nie znajdzie to podstawia wartoœæ zts.

  Gracz_Nazwa_Edit.Text := zts;


  //if kamera_obrót_mysz¹_g then
  //  zts := 'tak'
  //else//if kamera_obrót_mysz¹_g then
  //  zts := 'nie';
  //
  //if   (  zapisuj_ustawienia_f )
  //  or (  not plik_ini.ValueExists( 'PREFERENCJE', 'kamera_obrót_mysz¹' )  ) then
  //  plik_ini.WriteString( 'PREFERENCJE', 'kamera_obrót_mysz¹', zts )
  //else
  //  zts := plik_ini.ReadString( 'PREFERENCJE', 'kamera_obrót_mysz¹', zts ); // Je¿eli nie znajdzie to podstawia wartoœæ zts.
  //
  //kamera_obrót_mysz¹_g := zts = 'tak';


  zti := L¹d_ComboBox.ItemIndex;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'PREFERENCJE', 'l¹d' )  ) then
    plik_ini.WriteInteger( 'PREFERENCJE', 'l¹d', zti )
  else
    zti := plik_ini.ReadInteger( 'PREFERENCJE', 'l¹d', zti ); // Je¿eli nie znajdzie to podstawia wartoœæ zti.

  L¹d_ComboBox.ItemIndex := zti; // Nie wywo³a L¹d_ComboBoxChange().


  if L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked then
    zts := 'tak'
  else//if L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'PREFERENCJE', 'l¹d__komunikat_b³êdu_pomiñ' )  ) then
    plik_ini.WriteString( 'PREFERENCJE', 'l¹d__komunikat_b³êdu_pomiñ', zts )
  else
    zts := plik_ini.ReadString( 'PREFERENCJE', 'l¹d__komunikat_b³êdu_pomiñ', zts ); // Je¿eli nie znajdzie to podstawia wartoœæ zts.

  L¹d__Komunikat_B³êdu_Pomiñ_CheckBox.Checked := zts = 'tak';


  if Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked then
    zts := 'tak'
  else//if Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'PREFERENCJE', 'statek__komunikat_b³êdu_pomiñ' )  ) then
    plik_ini.WriteString( 'PREFERENCJE', 'statek__komunikat_b³êdu_pomiñ', zts )
  else
    zts := plik_ini.ReadString( 'PREFERENCJE', 'statek__komunikat_b³êdu_pomiñ', zts ); // Je¿eli nie znajdzie to podstawia wartoœæ zts.

  Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked := zts = 'tak';


  zti := Statek_ComboBox.ItemIndex;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'PREFERENCJE', 'statek' )  ) then
    plik_ini.WriteInteger( 'PREFERENCJE', 'statek', zti )
  else
    zti := plik_ini.ReadInteger( 'PREFERENCJE', 'statek', zti ); // Je¿eli nie znajdzie to podstawia wartoœæ zti.

  Statek_ComboBox.ItemIndex := zti; // Nie wywo³a Statek_ComboBoxChange().


  zti := Statki_Pozycje_Pocz¹tkowe_ComboBox.ItemIndex;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'PREFERENCJE', 'statki_pozycje_pocz¹tkowe' )  ) then
    plik_ini.WriteInteger( 'PREFERENCJE', 'statki_pozycje_pocz¹tkowe', zti )
  else
    zti := plik_ini.ReadInteger( 'PREFERENCJE', 'statki_pozycje_pocz¹tkowe', zti ); // Je¿eli nie znajdzie to podstawia wartoœæ zti.

  Statki_Pozycje_Pocz¹tkowe_ComboBox.ItemIndex := zti; // Nie wywo³a Statki_Pozycje_Pocz¹tkowe_ComboBoxChange().
  {$endregion 'PREFERENCJE.'}

  {$region 'USTAWIENIA.'}
  if Amunicja__Cel_Pozycja_Dla_Lotu_Parabol¹_Wyœwietl_CheckBox.Checked then
    zts := 'tak'
  else//if Amunicja__Cel_Pozycja_Dla_Lotu_Parabol¹_Wyœwietl_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'amunicja__cel_pozycja_dla_lotu_parabol¹_wyœwietl' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'amunicja__cel_pozycja_dla_lotu_parabol¹_wyœwietl', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'amunicja__cel_pozycja_dla_lotu_parabol¹_wyœwietl', zts ); // Je¿eli nie znajdzie to podstawia wartoœæ zts.

  Amunicja__Cel_Pozycja_Dla_Lotu_Parabol¹_Wyœwietl_CheckBox.Checked := zts = 'tak';


  zti := Celowanie_Tryb_RadioGroup.ItemIndex;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'celowanie_tryb' )  ) then
    plik_ini.WriteInteger( 'USTAWIENIA', 'celowanie_tryb', zti )
  else
    zti := plik_ini.ReadInteger( 'USTAWIENIA', 'celowanie_tryb', zti ); // Je¿eli nie znajdzie to podstawia wartoœæ zti.

  Celowanie_Tryb_RadioGroup.ItemIndex := zti;


  zti := Celowanie_Precyzja_Obrót_SpinEdit.Value;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'celowanie_precyzja_obrót' )  ) then
    plik_ini.WriteInteger( 'USTAWIENIA', 'celowanie_precyzja_obrót', zti )
  else
    zti := plik_ini.ReadInteger( 'USTAWIENIA', 'celowanie_precyzja_obrót', zti ); // Je¿eli nie znajdzie to podstawia wartoœæ zti.

  Celowanie_Precyzja_Obrót_SpinEdit.Value := zti;


  zti := Celowanie_Precyzja_Podniesienie_SpinEdit.Value;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'celowanie_precyzja_podniesienie' )  ) then
    plik_ini.WriteInteger( 'USTAWIENIA', 'celowanie_precyzja_podniesienie', zti )
  else
    zti := plik_ini.ReadInteger( 'USTAWIENIA', 'celowanie_precyzja_podniesienie', zti ); // Je¿eli nie znajdzie to podstawia wartoœæ zti.

  Celowanie_Precyzja_Podniesienie_SpinEdit.Value := zti;


  if Celownik_Widocznoœæ_CheckBox.Checked then
    zts := 'tak'
  else//if Celownik_Widocznoœæ_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'celownik_widocznoœæ' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'celownik_widocznoœæ', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'celownik_widocznoœæ', zts ); // Je¿eli nie znajdzie to podstawia wartoœæ zts.

  Celownik_Widocznoœæ_CheckBox.Checked := zts = 'tak';


  if Celownik_Widocznoœæ_Mouse_Look_Active_CheckBox.Checked then
    zts := 'tak'
  else//if Celownik_Widocznoœæ_Mouse_Look_Active_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'celownik_widocznoœæ_mouse_look_active' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'celownik_widocznoœæ_mouse_look_active', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'celownik_widocznoœæ_mouse_look_active', zts ); // Je¿eli nie znajdzie to podstawia wartoœæ zts.

  Celownik_Widocznoœæ_Mouse_Look_Active_CheckBox.Checked := zts = 'tak';


  ztr := Odczytaj_Liczbê_Z_Napisu( Celownik_Wielkoœæ_Edit.Text, 0.01 );

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'celownik_wielkoœæ' )  ) then
    plik_ini.WriteFloat( 'USTAWIENIA', 'celownik_wielkoœæ', ztr )
  else
    ztr := plik_ini.ReadFloat( 'USTAWIENIA', 'celownik_wielkoœæ', ztr ); // Je¿eli nie znajdzie to podstawia wartoœæ zti.

  Celownik_Wielkoœæ_Edit.Text := FloatToStr( ztr );


  if Dalmierz_CheckBox.Checked then
    zts := 'tak'
  else//if Dalmierz_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'dalmierz' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'dalmierz', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'dalmierz', zts ); // Je¿eli nie znajdzie to podstawia wartoœæ zts.

  Dalmierz_CheckBox.Checked := zts = 'tak';


  zti := Gra_Wspó³czynnik_Prêdkoœci_SpinEdit.Value;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'gra_wspó³czynnik_prêdkoœci' )  ) then
    plik_ini.WriteInteger( 'USTAWIENIA', 'gra_wspó³czynnik_prêdkoœci', zti )
  else
    zti := plik_ini.ReadInteger( 'USTAWIENIA', 'gra_wspó³czynnik_prêdkoœci', zti ); // Je¿eli nie znajdzie to podstawia wartoœæ zti.

  if not czy_klient_g then
    Gra_Wspó³czynnik_Prêdkoœci_SpinEdit.Value := zti;


  zti := Kamera_Odleg³oœæ_Maksymalna_SpinEdit.Value;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'kamera_odleg³oœæ_maksymalna' )  ) then
    plik_ini.WriteInteger( 'USTAWIENIA', 'kamera_odleg³oœæ_maksymalna', zti )
  else
    zti := plik_ini.ReadInteger( 'USTAWIENIA', 'kamera_odleg³oœæ_maksymalna', zti ); // Je¿eli nie znajdzie to podstawia wartoœæ zti.

  Kamera_Odleg³oœæ_Maksymalna_SpinEdit.Value := zti;


  ztr := Odczytaj_Liczbê_Z_Napisu( Kamera_Szybkoœæ_Ruchu_Edit.Text, 1 );

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'kamera_szybkoœæ_ruchu' )  ) then
    plik_ini.WriteFloat( 'USTAWIENIA', 'kamera_szybkoœæ_ruchu', ztr )
  else
    ztr := plik_ini.ReadFloat( 'USTAWIENIA', 'kamera_szybkoœæ_ruchu', ztr ); // Je¿eli nie znajdzie to podstawia wartoœæ zti.

  Kamera_Szybkoœæ_Ruchu_Edit.Text := FloatToStr( ztr );


  zti := Morze_Wzburzenie_SpinEdit.Value;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'morze_wzburzenie' )  ) then
    plik_ini.WriteInteger( 'USTAWIENIA', 'morze_wzburzenie', zti )
  else
    zti := plik_ini.ReadInteger( 'USTAWIENIA', 'morze_wzburzenie', zti ); // Je¿eli nie znajdzie to podstawia wartoœæ zti.

  if not czy_klient_g then
    Morze_Wzburzenie_SpinEdit.Value := zti;


  ztr := Odczytaj_Liczbê_Z_Napisu( Mysz_Czu³oœæ_Edit.Text, 10 );

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'mysz_czu³oœæ' )  ) then
    plik_ini.WriteFloat( 'USTAWIENIA', 'mysz_czu³oœæ', ztr )
  else
    ztr := plik_ini.ReadFloat( 'USTAWIENIA', 'mysz_czu³oœæ', ztr ); // Je¿eli nie znajdzie to podstawia wartoœæ zti.

  Mysz_Czu³oœæ_Edit.Text := FloatToStr( ztr );


  ztr := Odczytaj_Liczbê_Z_Napisu( Mysz_Czu³oœæ_Luneta_Edit.Text, 0.1 );

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'mysz_czu³oœæ_luneta' )  ) then
    plik_ini.WriteFloat( 'USTAWIENIA', 'mysz_czu³oœæ_luneta', ztr )
  else
    ztr := plik_ini.ReadFloat( 'USTAWIENIA', 'mysz_czu³oœæ_luneta', ztr ); // Je¿eli nie znajdzie to podstawia wartoœæ zti.

  Mysz_Czu³oœæ_Luneta_Edit.Text := FloatToStr( ztr );


  if Obrót_K¹t_Zablokowany_WskaŸnik_CheckBox.Checked then
    zts := 'tak'
  else//if Obrót_K¹t_Zablokowany_WskaŸnik_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'obrót_k¹t_zablokowany_wskaŸnik' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'obrót_k¹t_zablokowany_wskaŸnik', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'obrót_k¹t_zablokowany_wskaŸnik', zts ); // Je¿eli nie znajdzie to podstawia wartoœæ zts.

  Obrót_K¹t_Zablokowany_WskaŸnik_CheckBox.Checked := zts = 'tak';


  if Obrót_K¹t_Zablokowany_Strza³_WskaŸnik_CheckBox.Checked then
    zts := 'tak'
  else//if Obrót_K¹t_Zablokowany_Strza³_WskaŸnik_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'obrót_k¹t_zablokowany_strza³_wskaŸnik' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'obrót_k¹t_zablokowany_strza³_wskaŸnik', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'obrót_k¹t_zablokowany_strza³_wskaŸnik', zts ); // Je¿eli nie znajdzie to podstawia wartoœæ zts.

  Obrót_K¹t_Zablokowany_Strza³_WskaŸnik_CheckBox.Checked := zts = 'tak';


  if Pe³ny_Ekran_CheckBox.Checked then
    zts := 'tak'
  else//if Pe³ny_Ekran_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'pe³ny_ekran' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'pe³ny_ekran', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'pe³ny_ekran', zts ); // Je¿eli nie znajdzie to podstawia wartoœæ zts.

  Pe³ny_Ekran_CheckBox.Checked := zts = 'tak';


  if Pokój_Rozmów__Informacja_Dodatkowa_CheckBox.Checked then
    zts := 'tak'
  else//if Pokój_Rozmów__Informacja_Dodatkowa_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'pokój_rozmów__informacja_dodatkowa' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'pokój_rozmów__informacja_dodatkowa', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'pokój_rozmów__informacja_dodatkowa', zts ); // Je¿eli nie znajdzie to podstawia wartoœæ zts.

  Pokój_Rozmów__Informacja_Dodatkowa_CheckBox.Checked := zts = 'tak';


  if Pokój_Rozmów__Na_Ekranie_CheckBox.Checked then
    zts := 'tak'
  else//if Pokój_Rozmów__Na_Ekranie_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'pokój_rozmów__na_ekranie' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'pokój_rozmów__na_ekranie', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'pokój_rozmów__na_ekranie', zts ); // Je¿eli nie znajdzie to podstawia wartoœæ zts.

  Pokój_Rozmów__Na_Ekranie_CheckBox.Checked := zts = 'tak';


  if Punkty_¯ycia_WskaŸnik__Gracz_CheckBox.Checked then
    zts := 'tak'
  else//if Punkty_¯ycia_WskaŸnik__Gracz_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'punkty_¿ycia_wskaŸnik__gracz' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'punkty_¿ycia_wskaŸnik__gracz', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'punkty_¿ycia_wskaŸnik__gracz', zts ); // Je¿eli nie znajdzie to podstawia wartoœæ zts.

  Punkty_¯ycia_WskaŸnik__Gracz_CheckBox.Checked := zts = 'tak';


  if Punkty_¯ycia_WskaŸnik__Przeciwnik_CheckBox.Checked then
    zts := 'tak'
  else//if Punkty_¯ycia_WskaŸnik__Przeciwnik_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'punkty_¿ycia_wskaŸnik__przeciwnik' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'punkty_¿ycia_wskaŸnik__przeciwnik', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'punkty_¿ycia_wskaŸnik__przeciwnik', zts ); // Je¿eli nie znajdzie to podstawia wartoœæ zts.

  Punkty_¯ycia_WskaŸnik__Przeciwnik_CheckBox.Checked := zts = 'tak';


  if Punkty_¯ycia_WskaŸnik__Sojusznik_CheckBox.Checked then
    zts := 'tak'
  else//if Punkty_¯ycia_WskaŸnik__Sojusznik_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'punkty_¿ycia_wskaŸnik__sojusznik' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'punkty_¿ycia_wskaŸnik__sojusznik', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'punkty_¿ycia_wskaŸnik__sojusznik', zts ); // Je¿eli nie znajdzie to podstawia wartoœæ zts.

  Punkty_¯ycia_WskaŸnik__Sojusznik_CheckBox.Checked := zts = 'tak';


  if Radar_Widocznoœæ_CheckBox.Checked then
    zts := 'tak'
  else//if Radar_Widocznoœæ_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'radar_widocznoœæ' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'radar_widocznoœæ', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'radar_widocznoœæ', zts ); // Je¿eli nie znajdzie to podstawia wartoœæ zts.

  Radar_Widocznoœæ_CheckBox.Checked := zts = 'tak';


  if Radar_Kamera_Kierunek_Wyœwietlaj_CheckBox.Checked then
    zts := 'tak'
  else//if Radar_Kamera_Kierunek_Wyœwietlaj_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'radar_kamera_kierunek_wyœwietlaj' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'radar_kamera_kierunek_wyœwietlaj', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'radar_kamera_kierunek_wyœwietlaj', zts ); // Je¿eli nie znajdzie to podstawia wartoœæ zts.

  Radar_Kamera_Kierunek_Wyœwietlaj_CheckBox.Checked := zts = 'tak';


  zti := Radar_Rysowanie_Œladów__Statków_Sekundy_SpinEdit.Value;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'radar_rysowanie_œladów__statków_sekundy' )  ) then
    plik_ini.WriteInteger( 'USTAWIENIA', 'radar_rysowanie_œladów__statków_sekundy', zti )
  else
    zti := plik_ini.ReadInteger( 'USTAWIENIA', 'radar_rysowanie_œladów__statków_sekundy', zti ); // Je¿eli nie znajdzie to podstawia wartoœæ zti.

  Radar_Rysowanie_Œladów__Statków_Sekundy_SpinEdit.Value := zti;


  zti := Radar_Rysowanie_Œladów__Amunicji_Sekundy_SpinEdit.Value;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'radar_rysowanie_œladów__amunicji_sekundy' )  ) then
    plik_ini.WriteInteger( 'USTAWIENIA', 'radar_rysowanie_œladów__amunicji_sekundy', zti )
  else
    zti := plik_ini.ReadInteger( 'USTAWIENIA', 'radar_rysowanie_œladów__amunicji_sekundy', zti ); // Je¿eli nie znajdzie to podstawia wartoœæ zti.

  Radar_Rysowanie_Œladów__Amunicji_Sekundy_SpinEdit.Value := zti;


  if Radar_Wspó³rzêdna_Y_CheckBox.Checked then
    zts := 'tak'
  else//if Radar_Wspó³rzêdna_Y_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'radar_wspó³rzêdna_y' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'radar_wspó³rzêdna_y', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'radar_wspó³rzêdna_y', zts ); // Je¿eli nie znajdzie to podstawia wartoœæ zts.

  Radar_Wspó³rzêdna_Y_CheckBox.Checked := zts = 'tak';


  if Radar_Wspó³rzêdne_Kursora_CheckBox.Checked then
    zts := 'tak'
  else//if Radar_Wspó³rzêdne_Kursora_CheckBox.Checked then
    zts := 'nie';

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'USTAWIENIA', 'radar_wspó³rzêdne_kursora' )  ) then
    plik_ini.WriteString( 'USTAWIENIA', 'radar_wspó³rzêdne_kursora', zts )
  else
    zts := plik_ini.ReadString( 'USTAWIENIA', 'radar_wspó³rzêdne_kursora', zts ); // Je¿eli nie znajdzie to podstawia wartoœæ zts.

  Radar_Wspó³rzêdne_Kursora_CheckBox.Checked := zts = 'tak';
  {$endregion 'USTAWIENIA.'}

  {$region 'POZOSTA£E.'}
  ztr := Odczytaj_Liczbê_Z_Napisu( Amunicja__Zanurzenie_G³êbokoœæ_Zadana_Edit.Text, -0.3 );

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'POZOSTA£E', 'amunicja__zanurzenie_g³êbokoœæ_zadana' )  ) then
    plik_ini.WriteFloat( 'POZOSTA£E', 'amunicja__zanurzenie_g³êbokoœæ_zadana', ztr )
  else
    ztr := plik_ini.ReadFloat( 'POZOSTA£E', 'amunicja__zanurzenie_g³êbokoœæ_zadana', ztr ); // Je¿eli nie znajdzie to podstawia wartoœæ zti.

  Amunicja__Zanurzenie_G³êbokoœæ_Zadana_Edit.Text := FloatToStr( ztr );


  ztr := Odczytaj_Liczbê_Z_Napisu( Amunicja__Zanurzenie_G³êbokoœæ_Zadana__Skok_O_Edit.Text, 0 );

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'POZOSTA£E', 'amunicja__zanurzenie_g³êbokoœæ_zadana_skok_o' )  ) then
    plik_ini.WriteFloat( 'POZOSTA£E', 'amunicja__zanurzenie_g³êbokoœæ_zadana_skok_o', ztr )
  else
    ztr := plik_ini.ReadFloat( 'POZOSTA£E', 'amunicja__zanurzenie_g³êbokoœæ_zadana_skok_o', ztr ); // Je¿eli nie znajdzie to podstawia wartoœæ zti.

  Amunicja__Zanurzenie_G³êbokoœæ_Zadana__Skok_O_Edit.Text := FloatToStr( ztr );
  {$endregion 'POZOSTA£E.'}

  {$region 'WIELOOSOBOWE.'}
  zts := Serwer_Adres_IP_Edit.Text;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'WIELOOSOBOWE', 'serwer_adres_ip' )  ) then
    plik_ini.WriteString( 'WIELOOSOBOWE', 'serwer_adres_ip', zts )
  else
    zts := plik_ini.ReadString( 'WIELOOSOBOWE', 'serwer_adres_ip', zts ); // Je¿eli nie znajdzie to podstawia wartoœæ zts.

  Serwer_Adres_IP_Edit.Text := zts;


  zti := Serwer_Port_SpinEdit.Value;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'WIELOOSOBOWE', 'serwer_port' )  ) then
    plik_ini.WriteInteger( 'WIELOOSOBOWE', 'serwer_port', zti )
  else
    zti := plik_ini.ReadInteger( 'WIELOOSOBOWE', 'serwer_port', zti ); // Je¿eli nie znajdzie to podstawia wartoœæ zti.

  Serwer_Port_SpinEdit.Value := zti;


  zts := Has³o_Edit.Text;

  if   (  zapisuj_ustawienia_f )
    or (  not plik_ini.ValueExists( 'WIELOOSOBOWE', 'has³o' )  ) then
    plik_ini.WriteString( 'WIELOOSOBOWE', 'has³o', zts )
  else
    zts := plik_ini.ReadString( 'WIELOOSOBOWE', 'has³o', zts ); // Je¿eli nie znajdzie to podstawia wartoœæ zts.

  Has³o_Edit.Text := zts;
  {$endregion 'WIELOOSOBOWE.'}


  plik_ini.Free();


  L¹d_ComboBoxChange( nil );
  Statek_ComboBoxChange( nil );
  Statki_Pozycje_Pocz¹tkowe_ComboBoxChange( nil );


  //???
  //Projektowy_Tryb_CheckBox.Enabled := false;

end;//---//Ustawienia_Plik().

//Funkcja Wczytaj_Schemat().
procedure TStatki_Form.Wczytaj_Schemat( const katalog_nazwa_f : string; const lista_indeks_f : integer; var schematy_lista_r_t_f : TSchematy_Lista_r_t );
var
  i,
  j
    : integer;
  zts : string;
  search_rec : TSearchRec;
  zt_string_list : TStringList;
  zt_xml_document : TXMLDocument; //uses XMLDoc

  zt_combo_box : TComboBox;
begin

  //
  // Funkcja wczytuje schematy z plików xml w zadanym katalogu i sprawdza poprawnoœæ sk³adni xml.
  //
  // Parametry:
  //   katalog_nazwa_f - katalog, w którym wyszukiwaæ pliki.
  //   lista_indeks_f:
  //     < 0 - czyœci tabelê schematów i wczyta wszystkie schematy z plików.
  //     >= 0 - odczyta ponowie schemat tylko dla podanego indeksu tabeli schematów.
  //   schematy_lista_r_t_f - tabela, do której wpisywaæ dane schematów.
  //

  if    ( lista_indeks_f >= 0 )
    and (
             (  Length( schematy_lista_r_t_f ) < 0  )
          or (  lista_indeks_f > Length( schematy_lista_r_t_f ) - 1  )
        ) then
    Exit;

    
  if katalog_nazwa_f = katalog_schematy_lista__l¹dy_c then
    begin

      zt_combo_box := L¹d_ComboBox;

    end
  else//if katalog_nazwa_f = katalog_schematy_lista__l¹dy_c then
  if katalog_nazwa_f = katalog_schematy_lista__statki_c then
    begin

      zt_combo_box := Statek_ComboBox;

    end
  else//if katalog_nazwa_f = katalog_schematy_lista__statki_c then
  if katalog_nazwa_f = katalog_schematy_lista__statki_pozycje_pocz¹tkowe_c then
    begin

      zt_combo_box := Statki_Pozycje_Pocz¹tkowe_ComboBox;

    end
  else//if katalog_nazwa_f = katalog_schematy_lista__statki_pozycje_pocz¹tkowe_c then
    zt_combo_box := nil;


  if lista_indeks_f < 0 then
    begin

      if zt_combo_box <> nil then
        zt_combo_box.Items.Clear();

      SetLength( schematy_lista_r_t_f, 0 );

    end;
  //---//if lista_indeks_f < 0 then   

  
  zt_string_list := TStringList.Create();
  zt_xml_document := TXMLDocument.Create( Application );
  zt_xml_document.Options := zt_xml_document.Options + [ doNodeAutoIndent ]; // Domyœlnie ma: doNodeAutoCreate, doAttrNull, doAutoPrefix, doNamespaceDecl.

  j := -99;

  zts := ExtractFilePath( Application.ExeName ) + katalog_nazwa_f + '\';

  // Je¿eli znajdzie plik zwraca 0, je¿eli nie znajdzie zwraca numer b³êdu. Na pocz¹tku znajduje '.' '..' potem listê plików.
  if FindFirst( zts + '*.xml', faAnyFile, search_rec ) = 0 then // Application potrzebuje w uses Forms.
    begin

      repeat //FindNext( search_rec ) <> 0;
        // Czasami bez begin i end nieprawid³owo rozpoznaje miejsca na umieszczenie breakpoint (linijkê za wysoko) w XE5.

        if    ( search_rec.Attr <> faDirectory )
          and ( search_rec.Name <> '.' )
          and ( search_rec.Name <> '..' )
          and (
                   ( lista_indeks_f < 0 )
                or ( schematy_lista_r_t_f[ lista_indeks_f ].plik_nazwa = search_rec.Name )
              ) then
          begin

            if zt_xml_document.Active then
              zt_xml_document.Active := false;
              
          
            zt_string_list.Clear();
            zt_string_list.LoadFromFile( zts + search_rec.Name );
  

            try
              zt_xml_document.LoadFromXML( zt_string_list.Text );
            except
              on E : Exception do
                //Application.MessageBox(  PChar('Nieprawid³owa definicja l¹du ' + search_rec.Name + '.' + #13 + E.Message + ' ' + IntToStr( E.HelpContext )), 'B³¹d', MB_OK + MB_ICONEXCLAMATION  );
                Log_Wypisz(  'Nieprawid³owa definicja l¹du ' + search_rec.Name + '.' + #13 + #10 + E.Message + ' ' + IntToStr( E.HelpContext )  );
            end;
            //---//try

            if zt_xml_document.Active then
              begin

                if lista_indeks_f < 0 then
                  begin

                    i := Length( schematy_lista_r_t_f );
                    SetLength( schematy_lista_r_t_f, i + 1 );

                  end
                else//if lista_indeks_f < 0 then                
                  i := lista_indeks_f;
                  

                schematy_lista_r_t_f[ i ].id := IntToStr( i + 1 );
                schematy_lista_r_t_f[ i ].plik_nazwa := search_rec.Name;
                schematy_lista_r_t_f[ i ].treœæ := zt_string_list.Text; // Jako 'abc'#$D#$A'def'#$D#$A gdy treœæ pliku abc + #13 + def.

                for j := 0 to zt_xml_document.DocumentElement.ChildNodes.Count - 1 do
                  begin

                    if zt_xml_document.DocumentElement.ChildNodes[ j ].LocalName = 'nazwa' then
                      schematy_lista_r_t_f[ i ].nazwa := zt_xml_document.DocumentElement.ChildNodes[ j ].Text
                    else  
                    if zt_xml_document.DocumentElement.ChildNodes[ j ].LocalName = 'opis' then
                      schematy_lista_r_t_f[ i ].opis := zt_xml_document.DocumentElement.ChildNodes[ j ].Text;

                  end;
                //---//for j := 0 to zt_xml_document.DocumentElement.ChildNodes.Count - 1 do
                  
              end;
            //---//if zt_xml_document.Active then


            j := -88;

          end;
        //---//if    ( search_rec.Attr <> faDirectory )
          

      until FindNext( search_rec ) <> 0; // Zwraca dane kolejnego pliku zgodnego z parametrami wczeœniej wywo³anej funkcji FindFirst. Je¿eli mo¿na przejœæ do nastêpnego znalezionego pliku zwraca 0.

    end;
  //---//if FindFirst( zts + '*.xml', faAnyFile, search_rec ) = 0 then

  FindClose( search_rec );
  
  zt_string_list.Free();
  zt_xml_document.Free();


  if j = -99 then
    if lista_indeks_f < 0 then
      Application.MessageBox( PChar('Nie odnaleziono plików (' + katalog_nazwa_f + ').'), 'B³¹d', MB_OK + MB_ICONEXCLAMATION )
    else//if lista_indeks_f < 0 then
      Application.MessageBox( PChar('Nie odnaleziono pliku (' + katalog_nazwa_f + ').'), 'B³¹d', MB_OK + MB_ICONEXCLAMATION );


  if zt_combo_box <> nil then
    begin

      if lista_indeks_f < 0 then
        for i := 0 to Length( schematy_lista_r_t_f ) - 1 do
          if Trim( schematy_lista_r_t_f[ i ].nazwa ) <> '' then
            zt_combo_box.Items.Add( schematy_lista_r_t_f[ i ].nazwa )
          else//if Trim( schematy_lista_r_t_f[ i ].nazwa ) <> '' then
            zt_combo_box.Items.Add( schematy_lista_r_t_f[ i ].plik_nazwa );



      if katalog_nazwa_f = katalog_schematy_lista__statki_c then
        begin

          // Dopisuje statki do listy wyboru dla SI.

          for i := 0 to zt_combo_box.Items.Count - 1 do
            SI__Statek_ComboBox.Items.Add( zt_combo_box.Items[ i ] );

          if SI__Statek_ComboBox.Items.Count > 0 then
            SI__Statek_ComboBox.ItemIndex := 0;

        end;
      //---//if katalog_nazwa_f = katalog_schematy_lista__statki_c then

    end;
  //---//if zt_combo_box <> nil then


  if katalog_nazwa_f = katalog_schematy_lista__l¹dy_c then
    Wczytaj_Schemat( katalog_schematy_lista__prymitywy_c, -1, prymitywy_lista_t );

end;//---//Funkcja Wczytaj_Schemat().

//Funkcja Wieloosobowe_Amunicja_Parametry_Odczytaj().
procedure TStatki_Form.Wieloosobowe_Amunicja_Parametry_Odczytaj();
var
  i : integer;
begin

  //
  // Funkcja odczytuje parametry amunicji.
  //

  if   ( amunicja_wystrzelona_list = nil )
    or (  not Assigned( amunicja_wystrzelona_list )  ) then
    Exit;


  SetLength( wieloosobowe__amunicja_t, 0 );
  SetLength( wieloosobowe__amunicja_t, amunicja_wystrzelona_list.Count );


  for i := amunicja_wystrzelona_list.Count - 1 downto 0 do
    begin

      wieloosobowe__amunicja_t[ i ].id_statek := TAmunicja(amunicja_wystrzelona_list[ i ]).id_statek;
      wieloosobowe__amunicja_t[ i ].id_wieloosobowe_amunicja := TAmunicja(amunicja_wystrzelona_list[ i ]).id_amunicja;
      wieloosobowe__amunicja_t[ i ].czy_lot_parabol¹ := TAmunicja(amunicja_wystrzelona_list[ i ]).czy_lot_parabol¹;
      wieloosobowe__amunicja_t[ i ].czy_poza_luf¹ := TAmunicja(amunicja_wystrzelona_list[ i ]).czy_poza_luf¹;
      wieloosobowe__amunicja_t[ i ].przeliczone := false;

      wieloosobowe__amunicja_t[ i ].kierunek := TAmunicja(amunicja_wystrzelona_list[ i ]).korpus_ustawienie_pocz¹tkowe_dummy.AbsoluteDirection;
      wieloosobowe__amunicja_t[ i ].pozycja := TAmunicja(amunicja_wystrzelona_list[ i ]).korpus_ustawienie_pocz¹tkowe_dummy.AbsolutePosition;
      wieloosobowe__amunicja_t[ i ].pozycja_celu := TAmunicja(amunicja_wystrzelona_list[ i ]).pozycja_celu.AbsolutePosition;

      wieloosobowe__amunicja_t[ i ].turn_angle := TAmunicja(amunicja_wystrzelona_list[ i ]).TurnAngle;
      wieloosobowe__amunicja_t[ i ].pitch_angle := TAmunicja(amunicja_wystrzelona_list[ i ]).PitchAngle;

      wieloosobowe__amunicja_t[ i ].korpus__Height := TAmunicja(amunicja_wystrzelona_list[ i ]).korpus.Height;
      wieloosobowe__amunicja_t[ i ].korpus__TopRadius := TAmunicja(amunicja_wystrzelona_list[ i ]).korpus.TopRadius;
      wieloosobowe__amunicja_t[ i ].korpus__BottomRadius := TAmunicja(amunicja_wystrzelona_list[ i ]).korpus.BottomRadius;

      wieloosobowe__amunicja_t[ i ].amunicja_rodzaj := TAmunicja(amunicja_wystrzelona_list[ i ]).amunicja_rodzaj;

      if TAmunicja(amunicja_wystrzelona_list[ i ]).torpeda_efekt_na_wodzie = nil then
        wieloosobowe__amunicja_t[ i ].torpeda_efekt_na_wodzie_stan := 2
      else//if TAmunicja(amunicja_wystrzelona_list[ i ]).torpeda_efekt_na_wodzie = nil then
      if TAmunicja(amunicja_wystrzelona_list[ i ]).torpeda_efekt_na_wodzie.Parent = nil then
        wieloosobowe__amunicja_t[ i ].torpeda_efekt_na_wodzie_stan := 0
      else//if TAmunicja(amunicja_wystrzelona_list[ i ]).torpeda_efekt_na_wodzie.Parent = nil then
        wieloosobowe__amunicja_t[ i ].torpeda_efekt_na_wodzie_stan := 1;

      //wieloosobowe__amunicja_t[ i ].ztr := TAmunicja(amunicja_wystrzelona_list[ i ]).korpus_opadanie_obrót_dummy.RollAngle;


      //???
      //wieloosobowe__amunicja_t[ i ].pozycja.X := wieloosobowe__amunicja_t[ i ].pozycja.X + 3;
      //wieloosobowe__amunicja_t[ i ].pozycja.Z := wieloosobowe__amunicja_t[ i ].pozycja.Z + 4;

    end;
  //---//for i := amunicja_wystrzelona_list.Count - 1 downto 0 do

end;//---//Funkcja Wieloosobowe_Amunicja_Parametry_Odczytaj().

//Funkcja Wieloosobowe_Amunicja_Parametry_Ustaw().
procedure TStatki_Form.Wieloosobowe_Amunicja_Parametry_Ustaw();

  //Funkcja Parametry_Ustaw() w Wieloosobowe_Amunicja_Parametry_Ustaw().
  procedure Parametry_Ustaw( amunicja_f : TAmunicja; var obiekty_wieloosobowe_amunicja_r_f : TObiekty_Wieloosobowe__Amunicja_r );
  begin

    if   ( amunicja_wystrzelona_list = nil )
      or (  not Assigned( amunicja_wystrzelona_list )  ) then
      Exit;

    amunicja_f.korpus_ustawienie_pocz¹tkowe_dummy.AbsolutePosition := obiekty_wieloosobowe_amunicja_r_f.pozycja;
    amunicja_f.korpus_ustawienie_pocz¹tkowe_dummy.AbsoluteDirection := obiekty_wieloosobowe_amunicja_r_f.kierunek;

    amunicja_f.TurnAngle := obiekty_wieloosobowe_amunicja_r_f.turn_angle;
    amunicja_f.PitchAngle := obiekty_wieloosobowe_amunicja_r_f.pitch_angle;

    if    ( Amunicja__Cel_Pozycja_Dla_Lotu_Parabol¹_Wyœwietl_CheckBox.Checked ) // Taki sam warunek pozycja_celu_Visible.
      and ( not amunicja_f.pozycja_celu.Visible )
      and ( obiekty_wieloosobowe_amunicja_r_f.czy_lot_parabol¹ )
      and ( obiekty_wieloosobowe_amunicja_r_f.czy_poza_luf¹ )
      and ( amunicja_f.id_statek = Gracz_Identyfikator() ) then
      begin

        amunicja_f.pozycja_celu.AbsolutePosition := obiekty_wieloosobowe_amunicja_r_f.pozycja_celu;
        amunicja_f.pozycja_celu.Visible := true;

      end;
    //---//if    ( Amunicja__Cel_Pozycja_Dla_Lotu_Parabol¹_Wyœwietl_CheckBox.Checked ) (...)


    obiekty_wieloosobowe_amunicja_r_f.przeliczone := true;


      if    ( obiekty_wieloosobowe_amunicja_r_f.torpeda_efekt_na_wodzie_stan = 1 )
        and ( amunicja_f.torpeda_efekt_na_wodzie <> nil ) then
        begin

          if amunicja_f.torpeda_efekt_na_wodzie.Parent = nil then
            begin

              Amunicja_Wystrzelona_Efekt_Utwórz( amunicja_f, true, true );
              amunicja_f.torpeda_efekt_na_wodzie.Parent := Gra_Obiekty_GLDummyCube;

            end
          else//if amunicja_f.torpeda_efekt_na_wodzie.Parent = nil then
            begin

              amunicja_f.torpeda_efekt_na_wodzie.Position.AsVector := VectorMake(  amunicja_f.korpus.AbsolutePosition.X, 0 + ( Random() - 0.5 ) * 0.25, amunicja_f.korpus.AbsolutePosition.Z  );

            end;
          //---//if amunicja_f.torpeda_efekt_na_wodzie.Parent <> nil then

        end
      else//if    ( obiekty_wieloosobowe_amunicja_r_f.torpeda_efekt_na_wodzie_stan = 1 ) (...)
      if    ( obiekty_wieloosobowe_amunicja_r_f.torpeda_efekt_na_wodzie_stan = 2 )
        and ( amunicja_f.torpeda_efekt_na_wodzie <> nil ) then
        FreeAndNil( amunicja_f.torpeda_efekt_na_wodzie );

  end;//---//Funkcja Parametry_Ustaw() w Wieloosobowe_Amunicja_Parametry_Ustaw().

var
  i,
  j
    : integer;
  zt_amunicja : TAmunicja;

  ztb : boolean;
begin//Funkcja Wieloosobowe_Amunicja_Parametry_Ustaw().

  //
  // Funkcja ustawia parametry amunicji wieloosobowej.
  //

  // Je¿eli wczeœniej utworzonej amunicji nie ma na otrzymanej liœcie amunicji usuwa wczeœniej utworzon¹ amunicjê.
  for i := wieloosobowe_amunicja_wystrzelona_list.Count - 1 downto 0 do
    begin

      ztb := false;

      for j := 0 to Length( wieloosobowe__amunicja_t ) - 1 do
        if wieloosobowe__amunicja_t[ j ].id_wieloosobowe_amunicja = TAmunicja(wieloosobowe_amunicja_wystrzelona_list[ i ]).id_amunicja then
          begin

            ztb := true;
            Parametry_Ustaw( TAmunicja(wieloosobowe_amunicja_wystrzelona_list[ i ]), wieloosobowe__amunicja_t[ j ] );
            //wieloosobowe__amunicja_t[ j ].przeliczone := true;
            Break;

          end;
        //---//if wieloosobowe__amunicja_t[ j ].id_wieloosobowe_amunicja = TAmunicja(wieloosobowe_amunicja_wystrzelona_list[ i ]).id_amunicja then


      if not ztb then
        begin

          //TAmunicja(wieloosobowe_amunicja_wystrzelona_list[ i ]).Free(); //???
          TGLCylinder(wieloosobowe_amunicja_wystrzelona_list[ i ]).Free();
          wieloosobowe_amunicja_wystrzelona_list.Delete( i );

        end;
      //---//if not ztb then

    end;
  //---//for i := wieloosobowe_amunicja_wystrzelona_list.Count - 1 downto 0 do
  //---// Je¿eli wczeœniej utworzonej amunicji nie ma na otrzymanej liœcie amunicji usuwa wczeœniej utworzon¹ amunicjê.


  for i := 0 to Length( wieloosobowe__amunicja_t ) - 1 do
    if not wieloosobowe__amunicja_t[ i ].przeliczone then
      begin

        ztb := false;

        for j := 0 to wieloosobowe_amunicja_wystrzelona_list.Count - 1 do
          if wieloosobowe__amunicja_t[ i ].id_wieloosobowe_amunicja = TAmunicja(wieloosobowe_amunicja_wystrzelona_list[ j ]).id_amunicja then
            begin

              // Je¿eli wczeœniej utworzona amunicja jest na otrzymanej liœcie amunicji ustawia jej aktualne parametry.

              ztb := true;
              Parametry_Ustaw( TAmunicja(wieloosobowe_amunicja_wystrzelona_list[ j ]), wieloosobowe__amunicja_t[ i ] );
              //wieloosobowe__amunicja_t[ i ].przeliczone := true;
              Break;

            end;
          //---//if wieloosobowe__amunicja_t[ i ].id_wieloosobowe_amunicja = TAmunicja(wieloosobowe_amunicja_wystrzelona_list[ j ]).id_amunicja then

        if not ztb then
          begin

            // Je¿eli na otrzymanej liœcie amunicji nie ma wczeœniej utworzonej amunicji dodaje brakuj¹c¹ amunicjê.

            zt_amunicja := TAmunicja.Create( wieloosobowe__amunicja_t[ i ], Gra_Obiekty_GLDummyCube );


            if wieloosobowe_amunicja_efekt_g = nil then
              begin

                wieloosobowe_amunicja_efekt_g := TAmunicja.Create( wieloosobowe__amunicja_t[ i ], Gra_Obiekty_GLDummyCube ); // Pierwsze utworzenie instancji.

                // Nie ma detekcji kolizji.
                wieloosobowe_amunicja_efekt_g.Position.Y := dno_poziom_c * 2;
                wieloosobowe_amunicja_efekt_g.ResetRotations();
                wieloosobowe_amunicja_efekt_g.Visible := false;

              end;
            //---//if wieloosobowe_amunicja_efekt_g = nil then


            Amunicja_Wystrzelona_Efekt_Utwórz( zt_amunicja, false, true );

            wieloosobowe_amunicja_wystrzelona_list.Add( zt_amunicja );

            Parametry_Ustaw( zt_amunicja, wieloosobowe__amunicja_t[ i ] );
            //wieloosobowe__amunicja_t[ i ].przeliczone := true;

          end;
        //---//if not ztb then

        // ???
//        TAmunicja(wieloosobowe_amunicja_wystrzelona_list[ i ]).Position.X := TAmunicja(wieloosobowe_amunicja_wystrzelona_list[ i ]).Position.X + 1;
//        TAmunicja(wieloosobowe_amunicja_wystrzelona_list[ i ]).Position.Z := TAmunicja(wieloosobowe_amunicja_wystrzelona_list[ i ]).Position.Z + 1;

      end;
    //---//if not wieloosobowe__amunicja_t[ i ].przeliczone then

end;//---//Funkcja Wieloosobowe_Amunicja_Parametry_Ustaw().

//Funkcja Wieloosobowe__Efekt_Odczytaj_Jeden().
procedure TStatki_Form.Wieloosobowe__Efekt_Odczytaj_Jeden( AOwner : TGLBaseSceneObject; efekt_rodzaj_f : TEfekt_Rodzaj; x_f, y_f, z_f : real; amunicja_f : TAmunicja; czas_trwania_f, czas_trwania_efekt_dodatkowy_f : Int64 );
var
  i : integer;
begin

  if not czy_serwer_g then
    Exit;


  if    ( AOwner <> nil )
    and ( AOwner is TStatek ) then
    wieloosobowe__efekt_r.id_statek := TStatek(AOwner).id_statek
  else//if    ( statki_t[ i ] <> nil ) (...)
    wieloosobowe__efekt_r.id_statek := -1; // Scena.


  wieloosobowe__efekt_r.czas_trwania := czas_trwania_f;
  wieloosobowe__efekt_r.czas_trwania_efekt_dodatkowy := czas_trwania_efekt_dodatkowy_f;

  wieloosobowe__efekt_r.efekt_rodzaj := efekt_rodzaj_f;

  wieloosobowe__efekt_r.pozycja.X := x_f;
  wieloosobowe__efekt_r.pozycja.Y := y_f;
  wieloosobowe__efekt_r.pozycja.Z := z_f;

  wieloosobowe__efekt_r.wys³ane := false;


  if amunicja_f <> nil then
    begin

      wieloosobowe__efekt_r.amunicja_rodzaj := amunicja_f.amunicja_rodzaj;

    end
  else//if amunicja_f <> nil then
    begin

      wieloosobowe__efekt_r.amunicja_rodzaj := ar_Brak;

    end;
  //---//if amunicja_f <> nil then

  Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__odbierz__rekord_efekt_c, -99, '', true );

  Exit;
  // Efekt wysy³any jako tabela.

  i := Length( wieloosobowe__efekt_t );
  SetLength( wieloosobowe__efekt_t, i + 1 );


  if    ( AOwner <> nil )
    and ( AOwner is TStatek ) then
    wieloosobowe__efekt_t[ i ].id_statek := TStatek(AOwner).id_statek
  else//if    ( statki_t[ i ] <> nil ) (...)
    wieloosobowe__efekt_t[ i ].id_statek := -1; // Scena.


  wieloosobowe__efekt_t[ i ].czas_trwania := czas_trwania_f;
  wieloosobowe__efekt_t[ i ].czas_trwania_efekt_dodatkowy := czas_trwania_efekt_dodatkowy_f;

  wieloosobowe__efekt_t[ i ].efekt_rodzaj := efekt_rodzaj_f;

  wieloosobowe__efekt_t[ i ].pozycja.X := x_f;
  wieloosobowe__efekt_t[ i ].pozycja.Y := y_f;
  wieloosobowe__efekt_t[ i ].pozycja.Z := z_f;

  wieloosobowe__efekt_t[ i ].wys³ane := false;


  if amunicja_f <> nil then
    begin

      wieloosobowe__efekt_t[ i ].amunicja_rodzaj := amunicja_f.amunicja_rodzaj;

    end
  else//if amunicja_f <> nil then
    begin

      wieloosobowe__efekt_t[ i ].amunicja_rodzaj := ar_Brak;

    end;
  //---//if amunicja_f <> nil then

end;//---//Funkcja Wieloosobowe__Efekt_Odczytaj_Jeden().

//Funkcja Wieloosobowe_Statki_Rekord_Czyœæ().
procedure TStatki_Form.Wieloosobowe_Statki_Rekord_Czyœæ();
var
  i,
  j,
  k
    : integer;
begin

  //
  // Funkcja czyœci dane parametrów statków wieloosobowych.
  //

  for i := 0 to Length( wieloosobowe__statki_t ) - 1 do
    begin

      wieloosobowe__statki_t[ i ].id_statek := -99;
      wieloosobowe__statki_t[ i ].id_statek_schemat := -1;
      wieloosobowe__statki_t[ i ].gracz__nazwa := '';

      SetLength( wieloosobowe__statki_t[ i ].œruba_obrót_k¹t, 0 );


      {$region 'Dzia³a strzelaj¹ce.'}
      for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t ) - 1 do
        SetLength( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t, 0 );

      SetLength( wieloosobowe__statki_t[ i ].artyleria_t, 0 );


      for j := 0 to Length( wieloosobowe__statki_t[ i ].dzia³a_t ) - 1 do
        SetLength( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t, 0 );

      SetLength( wieloosobowe__statki_t[ i ].dzia³a_t, 0 );


      for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do
        SetLength( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t, 0 );

      SetLength( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t, 0 );
      {$endregion 'Dzia³a strzelaj¹ce.'}

      {$region 'Dzia³a ³adnie wygl¹daj¹ce.'}
      for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t ) - 1 do
        SetLength( wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t, 0 );

      SetLength( wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t, 0 );


      for j := 0 to Length( wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t ) - 1 do
        SetLength( wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t, 0 );

      SetLength( wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t, 0 );


      for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t ) - 1 do
        SetLength( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t, 0 );

      SetLength( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t, 0 );
      {$endregion 'Dzia³a ³adnie wygl¹daj¹ce.'}

    end;
  //---//for i := 0 to Length( wieloosobowe__statki_t ) - 1 do


  SetLength( wieloosobowe__statki_t, 0 );

end;//---//Funkcja Wieloosobowe_Statki_Rekord_Czyœæ().

//Funkcja Wieloosobowe_Statki_Utwórz().
procedure TStatki_Form.Wieloosobowe_Statki_Utwórz();
var
  i : integer;
begin

  //
  // Funkcja tworzy statki dla klienta gry wieloosobowej.
  //

  // Aby nie zwolni³o kamery wraz ze statkiem.
  while Gra_GLCamera.Parent <> Gra_GLScene.Objects do
    Kamera_Prze³¹cz( kt_Statek );

  statek_gracza := nil; // Nie zmienia statki_t[ 0 ].

  for i := 0 to Length( statki_t ) - 1 do
    FreeAndNil( statki_t[ i ] );

  SetLength( statki_t, 0 );


  for i := 0 to Length( wieloosobowe__statki_t ) - 1 do
    begin

      SetLength( statki_t, i + 1 );
      statki_t[ i ] := TStatek.Create(  Gra_Obiekty_GLDummyCube, nil, i, Statek_Odczytaj_Schemat( wieloosobowe__statki_t[ i ].id_statek_schemat ), prymitywy_lista_t  );
      statki_t[ i ].id_grupa := wieloosobowe__statki_t[ i ].id_grupa;
      statki_t[ i ].id_statek := wieloosobowe__statki_t[ i ].id_statek;
      statki_t[ i ].id_statek_schemat := wieloosobowe__statki_t[ i ].id_statek_schemat;
      statki_t[ i ].gracz__nazwa.Text := wieloosobowe__statki_t[ i ].gracz__nazwa;

      if wieloosobowe__statki_t[ i ].id_statek = Gracz_Identyfikator() then
        begin

          statek_gracza := statki_t[ i ];

          // Pozycja kamery na statek. //???

          statek_gracza.Elementy_Gracza_Dostosuj( -99, Punkty_¯ycia_WskaŸnik__Gracz_CheckBox.Checked, false, false, Obrót_K¹t_Zablokowany_WskaŸnik_CheckBox.Checked, Obrót_K¹t_Zablokowany_Strza³_WskaŸnik_CheckBox.Checked );

          Interfejs_Parametry_Wed³ug_Statku_Ustaw();

        end
      else//if wieloosobowe__statki_t[ i ].id_statek = Gracz_Identyfikator() then
        begin

          statki_t[ i ].Elementy_Gracza_Widocznoœæ( Gracz_Grupa_SpinEdit.Value, false );
          statki_t[ i ].Elementy_Gracza_Dostosuj( Gracz_Grupa_SpinEdit.Value, false, Punkty_¯ycia_WskaŸnik__Przeciwnik_CheckBox.Checked, Punkty_¯ycia_WskaŸnik__Sojusznik_CheckBox.Checked, false, false );

        end;
      //---//if wieloosobowe__statki_t[ i ].id_statek = Gracz_Identyfikator() then

    end;
  //---//for i := 0 to Length( wieloosobowe__statki_t ) - 1 do


  if statek_gracza = nil then
    Application.MessageBox( 'Nie uda³o siê zlokalizowaæ statku gracza.', 'Informacja', MB_ICONEXCLAMATION );

end;//---//Funkcja Wieloosobowe_Statki_Utwórz().

//Funkcja Wieloosobowe_Statki_Parametry_Odczytaj().
procedure TStatki_Form.Wieloosobowe_Statki_Parametry_Odczytaj();
var
  i,
  j,
  k
    : integer;
begin

  //
  // Funkcja odczytuje parametry statków wieloosobowych.
  //

  if Length( wieloosobowe__statki_t ) <> Length( statki_t ) then
    begin


      Wieloosobowe_Statki_Rekord_Czyœæ();
      SetLength(  wieloosobowe__statki_t, Length( statki_t )  );

    end;
  //---//if Length( wieloosobowe__statki_t ) <> Length( statki_t ) then


  for i := 0 to Length( statki_t ) - 1 do
    begin

      wieloosobowe__statki_t[ i ].cel_wspó³rzêdne := Vector__Do__Wieloosobowe__Wektor_4( Celowniczy_GLDummyCube.AbsolutePosition ); //???

      wieloosobowe__statki_t[ i ].id_grupa := statki_t[ i ].id_grupa;
      wieloosobowe__statki_t[ i ].id_statek := statki_t[ i ].id_statek;
      wieloosobowe__statki_t[ i ].id_statek_schemat := statki_t[ i ].id_statek_schemat;
      wieloosobowe__statki_t[ i ].gracz__nazwa := statki_t[ i ].gracz__nazwa.Text;
      wieloosobowe__statki_t[ i ].przeliczone := false;

      wieloosobowe__statki_t[ i ].pozycja := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].AbsolutePosition );
      wieloosobowe__statki_t[ i ].kierunek := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].AbsoluteDirection );

      wieloosobowe__statki_t[ i ].falowanie_bok_skrêt := statki_t[ i ].falowanie_bok_skrêt;
      wieloosobowe__statki_t[ i ].toniêcie__przechylenie__lewo_prawo := statki_t[ i ].RollAngle;
      wieloosobowe__statki_t[ i ].toniêcie__przechylenie__przód_ty³ := statki_t[ i ].PitchAngle;
      wieloosobowe__statki_t[ i ].punkty_¿ycia := statki_t[ i ].punkty_¿ycia;
      wieloosobowe__statki_t[ i ].punkty_¿ycia_maksymalne := statki_t[ i ].punkty_¿ycia_maksymalne;
      wieloosobowe__statki_t[ i ].punkty_¿ycia_procent_zosta³o := statki_t[ i ].punkty_¿ycia_procent_zosta³o;

      if Length( statki_t[ i ].ster_t )> 0 then
        wieloosobowe__statki_t[ i ].ster_k¹t := statki_t[ i ].ster_t[ 0 ].TurnAngle
      else//if Length( statki_t[ i ].ster_t )> 0 then
        wieloosobowe__statki_t[ i ].ster_k¹t := 0;


      wieloosobowe__statki_t[ i ].radar_id_statki_w_zasiêgu := statki_t[ i ].radar_id_statki_w_zasiêgu;
      wieloosobowe__statki_t[ i ].radio_id_statki_w_zasiêgu := statki_t[ i ].radio_id_statki_w_zasiêgu;


      SetLength(  wieloosobowe__statki_t[ i ].œruba_obrót_k¹t, Length( statki_t[ i ].œruby_t )  ); // Ustawia d³ugoœæ tabel.
      wieloosobowe__statki_t[ i ].œruba_obrót_k¹t__d³ugoœæ := Length( wieloosobowe__statki_t[ i ].œruba_obrót_k¹t );


      {$region 'Dzia³a strzelaj¹ce - ustawia d³ugoœæ tabel.'}
      SetLength(  wieloosobowe__statki_t[ i ].artyleria_t, Length( statki_t[ i ].artyleria_t )  );
      wieloosobowe__statki_t[ i ].artyleria_t__d³ugoœæ_tabeli := Length( wieloosobowe__statki_t[ i ].artyleria_t );

      for j := 0 to Length( statki_t[ i ].artyleria_t ) - 1 do
        begin

          SetLength(  wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t, Length( statki_t[ i ].artyleria_t[ j ].lufy_t )  );
          wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t__d³ugoœæ_tabeli := Length( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t );

        end;
      //---//for j := 0 to Length( statki_t[ i ].artyleria_t ) - 1 do


      SetLength(  wieloosobowe__statki_t[ i ].dzia³a_t, Length( statki_t[ i ].dzia³a_t )  );
      wieloosobowe__statki_t[ i ].dzia³a_t__d³ugoœæ_tabeli := Length( wieloosobowe__statki_t[ i ].dzia³a_t );

      for j := 0 to Length( statki_t[ i ].dzia³a_t ) - 1 do
        begin

          SetLength(  wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t, Length( statki_t[ i ].dzia³a_t[ j ].lufy_t )  );
          wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t__d³ugoœæ_tabeli := Length( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t );

        end;
      //---//for j := 0 to Length( statki_t[ i ].dzia³a_t ) - 1 do


      SetLength(  wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t, Length( statki_t[ i ].torpedy_wyrzutnie_t )  );
      wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t__d³ugoœæ_tabeli := Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t );

      for j := 0 to Length( statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do
        begin

          SetLength(  wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t, Length( statki_t[ i ].torpedy_wyrzutnie_t[ j ].lufy_t )  );
          wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t__d³ugoœæ_tabeli := Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t );

        end;
      //---//for j := 0 to Length( statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do
      {$endregion 'Dzia³a strzelaj¹ce - ustawia d³ugoœæ tabel.'}

      {$region 'Dzia³a ³adnie wygl¹daj¹ce - ustawia d³ugoœæ tabel.'}
      SetLength(  wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t, Length( statki_t[ i ].artyleria_wygl¹d_t )  );
      wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t__d³ugoœæ_tabeli := Length( wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t );

      for j := 0 to Length( statki_t[ i ].artyleria_wygl¹d_t ) - 1 do
        begin

          SetLength(  wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t, Length( statki_t[ i ].artyleria_wygl¹d_t[ j ].lufy_t )  );
          wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t__d³ugoœæ_tabeli := Length( wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t );

        end;
      //---//for j := 0 to Length( statki_t[ i ].artyleria_wygl¹d_t ) - 1 do


      SetLength(  wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t, Length( statki_t[ i ].dzia³a_wygl¹d_t )  );
      wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t__d³ugoœæ_tabeli := Length( wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t );

      for j := 0 to Length( statki_t[ i ].dzia³a_wygl¹d_t ) - 1 do
        begin

          SetLength(  wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t, Length( statki_t[ i ].dzia³a_wygl¹d_t[ j ].lufy_t )  );
          wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t__d³ugoœæ_tabeli := Length( wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t );

        end;
      //---//for j := 0 to Length( statki_t[ i ].dzia³a_wygl¹d_t ) - 1 do


      SetLength(  wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t, Length( statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t )  );
      wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t__d³ugoœæ_tabeli := Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t );

      for j := 0 to Length( statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t ) - 1 do
        begin

          SetLength(  wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t, Length( statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ].lufy_t )  );
          wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t__d³ugoœæ_tabeli := Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t );

        end;
      //---//for j := 0 to Length( statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t ) - 1 do
      {$endregion 'Dzia³a ³adnie wygl¹daj¹ce - ustawia d³ugoœæ tabel.'}


      for j := 0 to Length( statki_t[ i ].œruby_t ) - 1 do
        wieloosobowe__statki_t[ i ].œruba_obrót_k¹t[ j ] := statki_t[ i ].œruby_t[ j ].obrót_dummy.RollAngle;


      {$region 'Dzia³a strzelaj¹ce.'}
      for j := 0 to Length( statki_t[ i ].artyleria_t ) - 1 do
        begin

          wieloosobowe__statki_t[ i ].artyleria_t[ j ].czy_lot_parabol¹ := statki_t[ i ].artyleria_t[ j ].czy_lot_parabol¹;
          wieloosobowe__statki_t[ i ].artyleria_t[ j ].obrót_k¹t := statki_t[ i ].artyleria_t[ j ].TurnAngle;
          wieloosobowe__statki_t[ i ].artyleria_t[ j ].celownik_linia__podniesienie_k¹t := statki_t[ i ].artyleria_t[ j ].celownik_linia.PitchAngle;
          wieloosobowe__statki_t[ i ].artyleria_t[ j ].celownik_linia__kolor := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].artyleria_t[ j ].celownik_linia.LineColor.Color );
          wieloosobowe__statki_t[ i ].artyleria_t[ j ].celownik_linia__szerokoœæ := statki_t[ i ].artyleria_t[ j ].celownik_linia.LineWidth;
          wieloosobowe__statki_t[ i ].artyleria_t[ j ].celownik_linia__wzór := statki_t[ i ].artyleria_t[ j ].celownik_linia.LinePattern;

          wieloosobowe__statki_t[ i ].artyleria_t[ j ].amunicja_iloœæ := statki_t[ i ].artyleria_t[ j ].amunicja_iloœæ; // Informacje do wyœwietlania dla gracza o jego statku.

          for k := 0 to Length( statki_t[ i ].artyleria_t[ j ].lufy_t ) - 1 do
            begin

              wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_k¹t := statki_t[ i ].artyleria_t[ j ].lufy_t[ k ].PitchAngle;
              wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z := statki_t[ i ].artyleria_t[ j ].lufy_t[ k ].korpus.Position.Z;
              wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__pozycja := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].artyleria_t[ j ].lufy_t[ k ].prze³adowanie_wskaŸnik.AbsolutePosition );
              wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__kolor := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].artyleria_t[ j ].lufy_t[ k ].prze³adowanie_wskaŸnik.Material.FrontProperties.Ambient.Color );

              wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].strza³_gotowoœæ := statki_t[ i ].artyleria_t[ j ].lufy_t[ k ].strza³_gotowoœæ; // Informacje do wyœwietlania dla gracza o jego statku.

            end;
          //---//for k := 0 to Length( statki_t[ i ].artyleria_t[ j ].lufy_t ) - 1 do

        end;
      //---//for j := 0 to Length( statki_t[ i ].artyleria_t ) - 1 do


      for j := 0 to Length( statki_t[ i ].dzia³a_t ) - 1 do
        begin

          wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obrót_k¹t := statki_t[ i ].dzia³a_t[ j ].TurnAngle;
          wieloosobowe__statki_t[ i ].dzia³a_t[ j ].celownik_linia__podniesienie_k¹t := statki_t[ i ].dzia³a_t[ j ].celownik_linia.PitchAngle;
          wieloosobowe__statki_t[ i ].dzia³a_t[ j ].celownik_linia__kolor := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].dzia³a_t[ j ].celownik_linia.LineColor.Color );
          wieloosobowe__statki_t[ i ].dzia³a_t[ j ].celownik_linia__szerokoœæ := statki_t[ i ].dzia³a_t[ j ].celownik_linia.LineWidth;
          wieloosobowe__statki_t[ i ].dzia³a_t[ j ].celownik_linia__wzór := statki_t[ i ].dzia³a_t[ j ].celownik_linia.LinePattern;

          wieloosobowe__statki_t[ i ].dzia³a_t[ j ].amunicja_iloœæ := statki_t[ i ].dzia³a_t[ j ].amunicja_iloœæ; // Informacje do wyœwietlania dla gracza o jego statku.

          for k := 0 to Length( statki_t[ i ].dzia³a_t[ j ].lufy_t ) - 1 do
            begin

              wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_k¹t := statki_t[ i ].dzia³a_t[ j ].lufy_t[ k ].PitchAngle;
              wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z := statki_t[ i ].dzia³a_t[ j ].lufy_t[ k ].korpus.Position.Z;
              wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__pozycja := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].dzia³a_t[ j ].lufy_t[ k ].prze³adowanie_wskaŸnik.AbsolutePosition );
              wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__kolor := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].dzia³a_t[ j ].lufy_t[ k ].prze³adowanie_wskaŸnik.Material.FrontProperties.Ambient.Color );

              wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].strza³_gotowoœæ := statki_t[ i ].dzia³a_t[ j ].lufy_t[ k ].strza³_gotowoœæ; // Informacje do wyœwietlania dla gracza o jego statku.

            end;
          //---//for k := 0 to Length( statki_t[ i ].dzia³a_t[ j ].lufy_t ) - 1 do

        end;
      //---//for j := 0 to Length( statki_t[ i ].dzia³a_t ) - 1 do


      for j := 0 to Length( statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do
        begin

          wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obrót_k¹t := statki_t[ i ].torpedy_wyrzutnie_t[ j ].TurnAngle;
          wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia__podniesienie_k¹t := statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia.PitchAngle;
          wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia__kolor := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia.LineColor.Color );
          wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia__szerokoœæ := statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia.LineWidth;
          wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia__wzór := statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia.LinePattern;

          wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].amunicja_iloœæ := statki_t[ i ].torpedy_wyrzutnie_t[ j ].amunicja_iloœæ; // Informacje do wyœwietlania dla gracza o jego statku.

          for k := 0 to Length( statki_t[ i ].torpedy_wyrzutnie_t[ j ].lufy_t ) - 1 do
            begin

              wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_k¹t := statki_t[ i ].torpedy_wyrzutnie_t[ j ].lufy_t[ k ].PitchAngle;
              wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z := statki_t[ i ].torpedy_wyrzutnie_t[ j ].lufy_t[ k ].korpus.Position.Z;
              wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__pozycja := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].torpedy_wyrzutnie_t[ j ].lufy_t[ k ].prze³adowanie_wskaŸnik.AbsolutePosition );
              wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__kolor := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].torpedy_wyrzutnie_t[ j ].lufy_t[ k ].prze³adowanie_wskaŸnik.Material.FrontProperties.Ambient.Color );

              wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].strza³_gotowoœæ := statki_t[ i ].torpedy_wyrzutnie_t[ j ].lufy_t[ k ].strza³_gotowoœæ; // Informacje do wyœwietlania dla gracza o jego statku.

            end;
          //---//for k := 0 to Length( statki_t[ i ].torpedy_wyrzutnie_t[ j ].lufy_t ) - 1 do

        end;
      //---//for j := 0 to Length( statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do
      {$endregion 'Dzia³a strzelaj¹ce.'}

      {$region 'Dzia³a ³adnie wygl¹daj¹ce.'}
      for j := 0 to Length( statki_t[ i ].artyleria_wygl¹d_t ) - 1 do
        begin

          wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t[ j ].obrót_k¹t := statki_t[ i ].artyleria_wygl¹d_t[ j ].TurnAngle;

          for k := 0 to Length( statki_t[ i ].artyleria_wygl¹d_t[ j ].lufy_t ) - 1 do
            begin

              wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_k¹t := statki_t[ i ].artyleria_wygl¹d_t[ j ].lufy_t[ k ].PitchAngle;
              wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z := statki_t[ i ].artyleria_wygl¹d_t[ j ].lufy_t[ k ].korpus.Position.Z;
              wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__pozycja := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].artyleria_wygl¹d_t[ j ].lufy_t[ k ].prze³adowanie_wskaŸnik.AbsolutePosition );
              wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__kolor := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].artyleria_wygl¹d_t[ j ].lufy_t[ k ].prze³adowanie_wskaŸnik.Material.FrontProperties.Ambient.Color );

            end;
          //---//for k := 0 to Length( statki_t[ i ].artyleria_wygl¹d_t[ j ].lufy_t ) - 1 do

        end;
      //---//for j := 0 to Length( statki_t[ i ].artyleria_wygl¹d_t ) - 1 do


      for j := 0 to Length( statki_t[ i ].dzia³a_wygl¹d_t ) - 1 do
        begin

          wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t[ j ].obrót_k¹t := statki_t[ i ].dzia³a_wygl¹d_t[ j ].TurnAngle;

          for k := 0 to Length( statki_t[ i ].dzia³a_wygl¹d_t[ j ].lufy_t ) - 1 do
            begin

              wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_k¹t := statki_t[ i ].dzia³a_wygl¹d_t[ j ].lufy_t[ k ].PitchAngle;
              wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z := statki_t[ i ].dzia³a_wygl¹d_t[ j ].lufy_t[ k ].korpus.Position.Z;
              wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__pozycja := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].dzia³a_wygl¹d_t[ j ].lufy_t[ k ].prze³adowanie_wskaŸnik.AbsolutePosition );
              wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__kolor := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].dzia³a_wygl¹d_t[ j ].lufy_t[ k ].prze³adowanie_wskaŸnik.Material.FrontProperties.Ambient.Color );

            end;
          //---//for k := 0 to Length( statki_t[ i ].dzia³a_wygl¹d_t[ j ].lufy_t ) - 1 do

        end;
      //---//for j := 0 to Length( statki_t[ i ].dzia³a_wygl¹d_t ) - 1 do


      for j := 0 to Length( statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t ) - 1 do
        begin

          wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ].obrót_k¹t := statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ].TurnAngle;

          for k := 0 to Length( statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ].lufy_t ) - 1 do
            begin

              wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_k¹t := statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ].lufy_t[ k ].PitchAngle;
              wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z := statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ].lufy_t[ k ].korpus.Position.Z;
              wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__pozycja := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ].lufy_t[ k ].prze³adowanie_wskaŸnik.AbsolutePosition );
              wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__kolor := Vector__Do__Wieloosobowe__Wektor_4( statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ].lufy_t[ k ].prze³adowanie_wskaŸnik.Material.FrontProperties.Ambient.Color );

            end;
          //---//for k := 0 to Length( statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ].lufy_t ) - 1 do

        end;
      //---//for j := 0 to Length( statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t ) - 1 do
      {$endregion 'Dzia³a ³adnie wygl¹daj¹ce.'}


      // Wysy³ane osobn¹ funkcj¹ do przesy³ania sterowania (nacisniêtych klawiszy). //???
      wieloosobowe__statki_t[ i ].czy_wszystkie_lufy := false; //???

      wieloosobowe__statki_t[ i ].obracaj_dzia³a := statki_t[ i ].obracaj_dzia³a;
      wieloosobowe__statki_t[ i ].podnoœ_lufy := statki_t[ i ].podnoœ_lufy;

      wieloosobowe__statki_t[ i ].amunicja_rodzaj := ar_Wszystkie; //???


      // Informacje do wyœwietlania dla gracza o jego statku.
      wieloosobowe__statki_t[ i ].obracaj_dzia³a := statki_t[ i ].obracaj_dzia³a;
      wieloosobowe__statki_t[ i ].podnoœ_lufy := statki_t[ i ].podnoœ_lufy;
      wieloosobowe__statki_t[ i ].prêdkoœæ_procent := statki_t[ i ].prêdkoœæ_procent;
      wieloosobowe__statki_t[ i ].prêdkoœæ_zadana_procent := statki_t[ i ].prêdkoœæ_zadana_procent;
      wieloosobowe__statki_t[ i ].skrêt_procent := statki_t[ i ].skrêt_procent;
      wieloosobowe__statki_t[ i ].skrêt_zadany_procent := statki_t[ i ].skrêt_zadany_procent;
      //---// Informacje do wyœwietlania dla gracza o jego statku.

      //wieloosobowe__statki_t[ i ].ztr := statki_t[ i ].œruby_t[ 0 ].obrót_dummy.RollAngle;


      //???
      //wieloosobowe__statki_t[ i ].pozycja.X := wieloosobowe__statki_t[ i ].pozycja.X + 3;
      //wieloosobowe__statki_t[ i ].pozycja.Z := wieloosobowe__statki_t[ i ].pozycja.Z + 4;

    end;
  //---//for i := 0 to Length( statki_t ) - 1 do

end;//---//Funkcja Wieloosobowe_Statki_Parametry_Odczytaj().

//Funkcja Wieloosobowe_Statki_Parametry_Ustaw().
procedure TStatki_Form.Wieloosobowe_Statki_Parametry_Ustaw();

  //Funkcja Parametry_Ustaw() w Wieloosobowe_Statki_Parametry_Ustaw().
  procedure Parametry_Ustaw( statek_f : TStatek; var obiekty_wieloosobowe_statek_r_f : TObiekty_Wieloosobowe__Statek_r );
  var
    // Nie ma i aby by³o tak samo jak w konstruktorze. //???
    j,
    k
      : integer;
  begin

    if   ( statek_f = nil )
      or (  not Assigned( statek_f )  ) then
      Exit;

    statek_f.AbsolutePosition := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.pozycja );
    statek_f.AbsoluteDirection := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.kierunek );

    statek_f.falowanie_bok_skrêt := obiekty_wieloosobowe_statek_r_f.falowanie_bok_skrêt;
    statek_f.RollAngle := obiekty_wieloosobowe_statek_r_f.toniêcie__przechylenie__lewo_prawo;
    statek_f.PitchAngle := obiekty_wieloosobowe_statek_r_f.toniêcie__przechylenie__przód_ty³;
    statek_f.punkty_¿ycia := obiekty_wieloosobowe_statek_r_f.punkty_¿ycia;
    statek_f.punkty_¿ycia_procent_zosta³o := obiekty_wieloosobowe_statek_r_f.punkty_¿ycia_procent_zosta³o;

    if statek_f.punkty_¿ycia_maksymalne <> obiekty_wieloosobowe_statek_r_f.punkty_¿ycia_maksymalne then
      statek_f.punkty_¿ycia_maksymalne := obiekty_wieloosobowe_statek_r_f.punkty_¿ycia_maksymalne;

    statek_f.radar_id_statki_w_zasiêgu := obiekty_wieloosobowe_statek_r_f.radar_id_statki_w_zasiêgu;
    statek_f.radio_id_statki_w_zasiêgu := obiekty_wieloosobowe_statek_r_f.radio_id_statki_w_zasiêgu;

    //statek_f.œruby_t[ 0 ].obrót_dummy.RollAngle := obiekty_wieloosobowe_statek_r_f.ztr;

    for j := 0 to Length( statek_f.œruby_t ) - 1 do
      statek_f.œruby_t[ j ].obrót_dummy.RollAngle := obiekty_wieloosobowe_statek_r_f.œruba_obrót_k¹t[ j ];

    for j := 0 to Length( statek_f.ster_t ) - 1 do
      statek_f.ster_t[ j ].TurnAngle := obiekty_wieloosobowe_statek_r_f.ster_k¹t;


    {$region 'Dzia³a strzelaj¹ce.'}
    for j := 0 to Length( statek_f.artyleria_t ) - 1 do
      begin

        statek_f.artyleria_t[ j ].czy_lot_parabol¹ := obiekty_wieloosobowe_statek_r_f.artyleria_t[ j ].czy_lot_parabol¹;
        statek_f.artyleria_t[ j ].TurnAngle := obiekty_wieloosobowe_statek_r_f.artyleria_t[ j ].obrót_k¹t;
        statek_f.artyleria_t[ j ].celownik_linia.PitchAngle := obiekty_wieloosobowe_statek_r_f.artyleria_t[ j ].celownik_linia__podniesienie_k¹t;
        statek_f.artyleria_t[ j ].celownik_linia.LineColor.Color := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.artyleria_t[ j ].celownik_linia__kolor );
        statek_f.artyleria_t[ j ].celownik_linia.LineWidth := obiekty_wieloosobowe_statek_r_f.artyleria_t[ j ].celownik_linia__szerokoœæ;
        statek_f.artyleria_t[ j ].celownik_linia.LinePattern := obiekty_wieloosobowe_statek_r_f.artyleria_t[ j ].celownik_linia__wzór;
        statek_f.artyleria_t[ j ].celownik_linia_bez_falowania.LineColor.Color := statek_f.artyleria_t[ j ].celownik_linia.LineColor.Color;
        statek_f.artyleria_t[ j ].celownik_linia_bez_falowania.LinePattern := statek_f.artyleria_t[ j ].celownik_linia.LinePattern;
        statek_f.artyleria_t[ j ].celownik_linia_bez_falowania.LineWidth := statek_f.artyleria_t[ j ].celownik_linia.LineWidth;
        TTorpedy_Wyrzutnia(statek_f.artyleria_t[ j ]).Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( false );
        statek_f.artyleria_t[ j ].Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( ar_Artyleria_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );

        for k := 0 to Length( statek_f.artyleria_t[ j ].lufy_t ) - 1 do
          begin

            statek_f.artyleria_t[ j ].lufy_t[ k ].PitchAngle := obiekty_wieloosobowe_statek_r_f.artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_k¹t;
            statek_f.artyleria_t[ j ].lufy_t[ k ].korpus.Position.Z := obiekty_wieloosobowe_statek_r_f.artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z;
            statek_f.artyleria_t[ j ].lufy_t[ k ].prze³adowanie_wskaŸnik.AbsolutePosition := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__pozycja );
            statek_f.artyleria_t[ j ].lufy_t[ k ].prze³adowanie_wskaŸnik.Material.FrontProperties.Ambient.Color := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__kolor );

          end;
        //---//for k := 0 to Length( statek_f.artyleria_t[ j ].lufy_t ) - 1 do

      end;
    //---//for j := 0 to Length( statek_f.artyleria_t ) - 1 do


    for j := 0 to Length( statek_f.dzia³a_t ) - 1 do
      begin

        statek_f.dzia³a_t[ j ].TurnAngle := obiekty_wieloosobowe_statek_r_f.dzia³a_t[ j ].obrót_k¹t;
        statek_f.dzia³a_t[ j ].celownik_linia.PitchAngle := obiekty_wieloosobowe_statek_r_f.dzia³a_t[ j ].celownik_linia__podniesienie_k¹t;
        statek_f.dzia³a_t[ j ].celownik_linia.LineColor.Color := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.dzia³a_t[ j ].celownik_linia__kolor );
        statek_f.dzia³a_t[ j ].celownik_linia.LineWidth := obiekty_wieloosobowe_statek_r_f.dzia³a_t[ j ].celownik_linia__szerokoœæ;
        statek_f.dzia³a_t[ j ].celownik_linia.LinePattern := obiekty_wieloosobowe_statek_r_f.dzia³a_t[ j ].celownik_linia__wzór;
        statek_f.dzia³a_t[ j ].celownik_linia_bez_falowania.LineColor.Color := statek_f.dzia³a_t[ j ].celownik_linia.LineColor.Color;
        statek_f.dzia³a_t[ j ].celownik_linia_bez_falowania.LinePattern := statek_f.dzia³a_t[ j ].celownik_linia.LinePattern;
        statek_f.dzia³a_t[ j ].celownik_linia_bez_falowania.LineWidth := statek_f.dzia³a_t[ j ].celownik_linia.LineWidth;
        TTorpedy_Wyrzutnia(statek_f.dzia³a_t[ j ]).Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( false );
        statek_f.dzia³a_t[ j ].Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( ar_Pocisk_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );

        for k := 0 to Length( statek_f.dzia³a_t[ j ].lufy_t ) - 1 do
          begin

            statek_f.dzia³a_t[ j ].lufy_t[ k ].PitchAngle := obiekty_wieloosobowe_statek_r_f.dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_k¹t;
            statek_f.dzia³a_t[ j ].lufy_t[ k ].korpus.Position.Z := obiekty_wieloosobowe_statek_r_f.dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z;
            statek_f.dzia³a_t[ j ].lufy_t[ k ].prze³adowanie_wskaŸnik.AbsolutePosition := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__pozycja );
            statek_f.dzia³a_t[ j ].lufy_t[ k ].prze³adowanie_wskaŸnik.Material.FrontProperties.Ambient.Color := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__kolor );

          end;
        //---//for k := 0 to Length( statek_f.dzia³a_t[ j ].lufy_t ) - 1 do

      end;
    //---//for j := 0 to Length( statek_f.dzia³a_t ) - 1 do


    for j := 0 to Length( statek_f.torpedy_wyrzutnie_t ) - 1 do
      begin

        statek_f.torpedy_wyrzutnie_t[ j ].TurnAngle := obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_t[ j ].obrót_k¹t;
        statek_f.torpedy_wyrzutnie_t[ j ].celownik_linia.PitchAngle := obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_t[ j ].celownik_linia__podniesienie_k¹t;
        statek_f.torpedy_wyrzutnie_t[ j ].celownik_linia.LineColor.Color := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_t[ j ].celownik_linia__kolor );
        statek_f.torpedy_wyrzutnie_t[ j ].celownik_linia.LineWidth := obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_t[ j ].celownik_linia__szerokoœæ;
        statek_f.torpedy_wyrzutnie_t[ j ].celownik_linia.LinePattern := obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_t[ j ].celownik_linia__wzór;
        statek_f.torpedy_wyrzutnie_t[ j ].celownik_linia_bez_falowania.LineColor.Color := statek_f.torpedy_wyrzutnie_t[ j ].celownik_linia.LineColor.Color;
        statek_f.torpedy_wyrzutnie_t[ j ].celownik_linia_bez_falowania.LinePattern := statek_f.torpedy_wyrzutnie_t[ j ].celownik_linia.LinePattern;
        statek_f.torpedy_wyrzutnie_t[ j ].celownik_linia_bez_falowania.LineWidth := statek_f.torpedy_wyrzutnie_t[ j ].celownik_linia.LineWidth;
        statek_f.torpedy_wyrzutnie_t[ j ].Celownik_Linia_Bez_Falowania_Kierunek_Aktualizuj( ar_Torpeda_CheckBox.Checked or ar_Wszystkie_CheckBox.Checked );

        for k := 0 to Length( statek_f.torpedy_wyrzutnie_t[ j ].lufy_t ) - 1 do
          begin

            statek_f.torpedy_wyrzutnie_t[ j ].lufy_t[ k ].PitchAngle := obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_k¹t;
            statek_f.torpedy_wyrzutnie_t[ j ].lufy_t[ k ].korpus.Position.Z := obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z;
            statek_f.torpedy_wyrzutnie_t[ j ].lufy_t[ k ].prze³adowanie_wskaŸnik.AbsolutePosition := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__pozycja );
            statek_f.torpedy_wyrzutnie_t[ j ].lufy_t[ k ].prze³adowanie_wskaŸnik.Material.FrontProperties.Ambient.Color := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__kolor );

          end;
        //---//for k := 0 to Length( statek_f.torpedy_wyrzutnie_t[ j ].lufy_t ) - 1 do

      end;
    //---//for j := 0 to Length( statek_f.torpedy_wyrzutnie_t ) - 1 do
    {$endregion 'Dzia³a strzelaj¹ce.'}

    {$region 'Dzia³a ³adnie wygl¹daj¹ce.'}
    for j := 0 to Length( statek_f.artyleria_wygl¹d_t ) - 1 do
      begin

        statek_f.artyleria_wygl¹d_t[ j ].TurnAngle := obiekty_wieloosobowe_statek_r_f.artyleria_wygl¹d_t[ j ].obrót_k¹t;

        for k := 0 to Length( statek_f.artyleria_wygl¹d_t[ j ].lufy_t ) - 1 do
          begin

            statek_f.artyleria_wygl¹d_t[ j ].lufy_t[ k ].PitchAngle := obiekty_wieloosobowe_statek_r_f.artyleria_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_k¹t;
            statek_f.artyleria_wygl¹d_t[ j ].lufy_t[ k ].korpus.Position.Z := obiekty_wieloosobowe_statek_r_f.artyleria_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z;
            statek_f.artyleria_wygl¹d_t[ j ].lufy_t[ k ].prze³adowanie_wskaŸnik.AbsolutePosition := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.artyleria_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__pozycja );
            statek_f.artyleria_wygl¹d_t[ j ].lufy_t[ k ].prze³adowanie_wskaŸnik.Material.FrontProperties.Ambient.Color := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.artyleria_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__kolor );

          end;
        //---//for k := 0 to Length( statek_f.artyleria_wygl¹d_t[ j ].lufy_t ) - 1 do

      end;
    //---//for j := 0 to Length( statek_f.artyleria_wygl¹d_t ) - 1 do


    for j := 0 to Length( statek_f.dzia³a_wygl¹d_t ) - 1 do
      begin

        statek_f.dzia³a_wygl¹d_t[ j ].TurnAngle := obiekty_wieloosobowe_statek_r_f.dzia³a_wygl¹d_t[ j ].obrót_k¹t;

        for k := 0 to Length( statek_f.dzia³a_wygl¹d_t[ j ].lufy_t ) - 1 do
          begin

            statek_f.dzia³a_wygl¹d_t[ j ].lufy_t[ k ].PitchAngle := obiekty_wieloosobowe_statek_r_f.dzia³a_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_k¹t;
            statek_f.dzia³a_wygl¹d_t[ j ].lufy_t[ k ].korpus.Position.Z := obiekty_wieloosobowe_statek_r_f.dzia³a_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z;
            statek_f.dzia³a_wygl¹d_t[ j ].lufy_t[ k ].prze³adowanie_wskaŸnik.AbsolutePosition := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.dzia³a_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__pozycja );
            statek_f.dzia³a_wygl¹d_t[ j ].lufy_t[ k ].prze³adowanie_wskaŸnik.Material.FrontProperties.Ambient.Color := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.dzia³a_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__kolor );

          end;
        //---//for k := 0 to Length( statek_f.dzia³a_wygl¹d_t[ j ].lufy_t ) - 1 do

      end;
    //---//for j := 0 to Length( statek_f.dzia³a_wygl¹d_t ) - 1 do


    for j := 0 to Length( statek_f.torpedy_wyrzutnie_wygl¹d_t ) - 1 do
      begin

        statek_f.torpedy_wyrzutnie_wygl¹d_t[ j ].TurnAngle := obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_wygl¹d_t[ j ].obrót_k¹t;

        for k := 0 to Length( statek_f.torpedy_wyrzutnie_wygl¹d_t[ j ].lufy_t ) - 1 do
          begin

            statek_f.torpedy_wyrzutnie_wygl¹d_t[ j ].lufy_t[ k ].PitchAngle := obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_k¹t;
            statek_f.torpedy_wyrzutnie_wygl¹d_t[ j ].lufy_t[ k ].korpus.Position.Z := obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z;
            statek_f.torpedy_wyrzutnie_wygl¹d_t[ j ].lufy_t[ k ].prze³adowanie_wskaŸnik.AbsolutePosition := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__pozycja );
            statek_f.torpedy_wyrzutnie_wygl¹d_t[ j ].lufy_t[ k ].prze³adowanie_wskaŸnik.Material.FrontProperties.Ambient.Color := Wieloosobowe__Wektor_4__Do__Vector( obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__kolor );

          end;
        //---//for k := 0 to Length( statek_f.torpedy_wyrzutnie_wygl¹d_t[ j ].lufy_t ) - 1 do

      end;
    //---//for j := 0 to Length( statek_f.torpedy_wyrzutnie_wygl¹d_t ) - 1 do
    {$endregion 'Dzia³a ³adnie wygl¹daj¹ce.'}


    obiekty_wieloosobowe_statek_r_f.przeliczone := true;

    // ???
    //statek_f.Position.X := statek_f.Position.X + 3;
    //statek_f.Position.Z := statek_f.Position.Z + 4;

    if not statek_f.Visible then
      statek_f.Visible := true; // Po przywróceniu statku do gry klient umieszcza go na wyliczonej samodzielnie pozycji i dopiero po odebraniu danych o pozycji z serwera zaktualizuje pozycjê statku i ustawi na widoczny.


    {$region 'Informacje do wyœwietlania dla gracza o jego statku.'}
    if    ( statek_gracza <> nil )
      and ( statek_f.id_statek = Gracz_Identyfikator() ) then //statek_gracza.id_statek
      begin

        // Potem mo¿na przesy³aæ po TCP tylko do danego gracza.

        statek_gracza.obracaj_dzia³a := obiekty_wieloosobowe_statek_r_f.obracaj_dzia³a;
        statek_gracza.podnoœ_lufy := obiekty_wieloosobowe_statek_r_f.podnoœ_lufy;
        statek_gracza.prêdkoœæ_procent := obiekty_wieloosobowe_statek_r_f.prêdkoœæ_procent;
        statek_gracza.prêdkoœæ_zadana_procent := obiekty_wieloosobowe_statek_r_f.prêdkoœæ_zadana_procent;
        statek_gracza.skrêt_procent := obiekty_wieloosobowe_statek_r_f.skrêt_procent;
        statek_gracza.skrêt_zadany_procent := obiekty_wieloosobowe_statek_r_f.skrêt_zadany_procent;

        for j := 0 to Length( statek_gracza.artyleria_t ) - 1 do
          begin

            statek_gracza.artyleria_t[ j ].amunicja_iloœæ := obiekty_wieloosobowe_statek_r_f.artyleria_t[ j ].amunicja_iloœæ;

            for k := 0 to Length( statek_gracza.artyleria_t[ j ].lufy_t ) - 1 do
              statek_gracza.artyleria_t[ j ].lufy_t[ k ].strza³_gotowoœæ := obiekty_wieloosobowe_statek_r_f.artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].strza³_gotowoœæ;

          end;
        //---//for j := 0 to Length( Self.artyleria_t ) - 1 do

        for j := 0 to Length( statek_gracza.dzia³a_t ) - 1 do
          begin

            statek_gracza.dzia³a_t[ j ].amunicja_iloœæ := obiekty_wieloosobowe_statek_r_f.dzia³a_t[ j ].amunicja_iloœæ;

            for k := 0 to Length( statek_gracza.dzia³a_t[ j ].lufy_t ) - 1 do
              statek_gracza.dzia³a_t[ j ].lufy_t[ k ].strza³_gotowoœæ := obiekty_wieloosobowe_statek_r_f.dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].strza³_gotowoœæ;

          end;
        //---//for j := 0 to Length( Self.dzia³a_t ) - 1 do

        for j := 0 to Length( statek_gracza.torpedy_wyrzutnie_t ) - 1 do
          begin

            statek_gracza.torpedy_wyrzutnie_t[ j ].amunicja_iloœæ := obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_t[ j ].amunicja_iloœæ;

            for k := 0 to Length( statek_gracza.torpedy_wyrzutnie_t[ j ].lufy_t ) - 1 do
              statek_gracza.torpedy_wyrzutnie_t[ j ].lufy_t[ k ].strza³_gotowoœæ := obiekty_wieloosobowe_statek_r_f.torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].strza³_gotowoœæ;

          end;
        //---//for j := 0 to Length( Self.torpedy_wyrzutnie_t ) - 1 do

      end;
    //---//if    ( statek_gracza <> nil ) (...)
    {$endregion 'Informacje do wyœwietlania dla gracza o jego statku.'}

  end;//---//Funkcja Parametry_Ustaw() w Wieloosobowe_Statki_Parametry_Ustaw().

var
  i,
  j
    : integer;
begin//Funkcja Wieloosobowe_Statki_Parametry_Ustaw().

  //
  // Funkcja ustawia parametry statków wieloosobowych.
  //

  if Length( statki_t ) <> Length( wieloosobowe__statki_t ) then
    begin

      Wieloosobowe_Statki_Utwórz();

    end;
  //---//if Length( statki_t ) <> Length( wieloosobowe__statki_t ) then



  for i := 0 to Length( wieloosobowe__statki_t ) - 1 do
    if not wieloosobowe__statki_t[ i ].przeliczone then
      begin

        for j := 0 to Length( statki_t ) - 1 do
          if wieloosobowe__statki_t[ i ].id_statek = statki_t[ j ].id_statek then
            begin

              // Je¿eli wczeœniej utworzony statek jest na otrzymanej liœcie statków ustawia jego aktualne parametry.

              Parametry_Ustaw( statki_t[ j ], wieloosobowe__statki_t[ i ] );
              Break;

            end;
          //---//if wieloosobowe__statki_t[ i ].id_statek = statki_t[ j ].id_statek then

      end;
    //---//if not wieloosobowe__statki_t[ i ].przeliczone then


  for i := 0 to Length( wieloosobowe__statki_t ) - 1 do
    if not wieloosobowe__statki_t[ i ].przeliczone then
      Wieloosobowe_Statki_Utwórz();


  if klient_pierwsze_ustawienie_kamery_g then
    begin

      klient_pierwsze_ustawienie_kamery_g := false;

      if not ( Gra_GLCamera.Parent is TStatek ) then
        Kamera_Prze³¹cz( kt_Statek ); // Ustawi kamerê na statku gracza.

    end;
  //---//if klient_pierwsze_ustawienie_kamery_g then

end;//---//Funkcja Wieloosobowe_Statki_Parametry_Ustaw().

//Funkcja Wieloosobowe__Tekst_Wyœlij().
procedure TStatki_Form.Wieloosobowe__Tekst_Wyœlij( const napis_f : string; const peer_port_f : integer = -99 );
var
  i : integer;
  lista : TList;
begin

  if not czy_serwer_g then
    begin

      // Klient.

      if IdTCPClient1.Connected then
        begin

          IdTCPClient1.IOHandler.WriteLn( napis_f, IdGlobal.IndyTextEncoding_UTF8 );

        end;
      //---//if IdTCPClient1.Connected then

    end
  else//if not czy_serwer_g then
    begin

      // Serwer.

      lista := IdTCPServer1.Contexts.LockList();

      try
        for i := 0 to lista.Count - 1 do
          if   ( peer_port_f = -99 )
            or ( TIdContext(lista[ i ]).Connection.Socket.Binding.PeerPort = peer_port_f ) then
            begin
              try
                TIdContext(lista[ i ]).Connection.IOHandler.WriteLn( napis_f, IdGlobal.IndyTextEncoding_UTF8 );
              except
                on E : Exception do
                  begin
                    Wieloosobowe__Log_Wypisz(
                        'Nie uda³o siê wys³aæ danych (t) do klienta: ' + IntToStr( TIdContext(lista[ i ]).Binding.PeerPort ) + #13 + #10 +
                        E.Message + ' ' + IntToStr( E.HelpContext ) + '.'
                      );
                    //Application.MessageBox(
                    //    PChar('Nie uda³o siê wys³aæ danych (t) do klienta: ' + IntToStr( TIdContext(lista[ i ]).Binding.PeerPort ) + #13 +
                    //    E.Message + ' ' + IntToStr( E.HelpContext ) + '.'), 'B³¹d',
                    //    MB_OK + MB_ICONEXCLAMATION
                    //  );
                  end;
              end;
            end;
          //---//if   ( peer_port_f = -99 ) (...)
      finally
        IdTCPServer1.Contexts.UnlockList();
      end;
      //---//try

    end;
  //---//if not czy_serwer_g then

end;//---//Funkcja Wieloosobowe__Tekst_Wyœlij().

//Funkcja Wieloosobowe__Tekst_Wyœlij_UDP().
procedure TStatki_Form.Wieloosobowe__Tekst_Wyœlij_UDP( const napis_f : string );
var
  i : integer;
  lista : TList;
begin

  if not czy_serwer_g then
    begin

      // Klient.

      if IdUDPClient1.Connected then // Tylko pod³¹cza klienta do portu (lokalnie). Je¿eli nie ma serwera i tak wyœwietla, ¿e siê po³¹czy³.
        begin

          IdUDPClient1.Send( napis_f, IdGlobal.IndyTextEncoding_UTF8 ); // W XE 3 IdGlobal.TIdTextEncoding.UTF8. // try nie obs³uguje b³êdu (np. gdy nie ma serwera).

        end;
      //---//if IdUDPClient1.Connected then

    end
  else//if not czy_serwer_g then
    begin

      // Serwer.

      for i := udp_klienci_lista_g.klienci_lista_list.Count - 1 downto 0 do
        begin

          IdUDPServer1.Send( TUDP_Klient_Dane(udp_klienci_lista_g.klienci_lista_list[ i ]).adres_ip, TUDP_Klient_Dane(udp_klienci_lista_g.klienci_lista_list[ i ]).peer_port, napis_f, IdGlobal.IndyTextEncoding_UTF8 );

        end;
      //---//for i := udp_klienci_lista_g.klienci_lista_list.Count - 1 downto 0 do

    end;
  //---//if not czy_serwer_g then

end;//---//Funkcja Wieloosobowe__Tekst_Wyœlij_UDP().

//Funkcja Wieloosobowe__Strumieñ_Wyœlij().
procedure TStatki_Form.Wieloosobowe__Strumieñ_Wyœlij( const komenda_f : string; const peer_port_f : integer; const wartoœæ_f : TWieloosobowe_String; const czy_udp_f : boolean = false );

  //Funkcja Strumieñ_Napis_Wpisz() w Wieloosobowe__Strumieñ_Wyœlij().
  procedure Strumieñ_Napis_Wpisz( napis_f : string; strumieñ_pamiêci_f : TMemoryStream );
  var
    i : integer;
    zt_wieloosobowe_string : TWieloosobowe_String;
  begin

    i := Ceil(  Length( napis_f ) / High( zt_wieloosobowe_string )  );

    strumieñ_pamiêci_f.Write(  i, SizeOf( i )  );


    while Length( napis_f ) > 0 do
      begin

        zt_wieloosobowe_string := Copy(  napis_f, 1, High( zt_wieloosobowe_string )  );
        Delete(  napis_f, 1, High( zt_wieloosobowe_string )  );

        strumieñ_pamiêci_f.Write( zt_wieloosobowe_string, wieloosobowe_string__rozmiar_c );

      end;
    //---//while Length( napis_f ) > 0 do

  end;//---//Funkcja Strumieñ_Napis_Wpisz() w Wieloosobowe__Strumieñ_Wyœlij().

var
  i,
  j,
  k
    : integer;
  zts : string;
  lista : TList;
  zt_tcp_klient_dane : TTCP_Klient_Dane;
  strumieñ_pamiêci_l : TMemoryStream;
  zt_id_bytes : TIdBytes;
begin//Funkcja Wieloosobowe__Strumieñ_Wyœlij().

  //
  // Funkcja wysy³a zadany rekord danych - komenda (komenda_f) jest wysy³ana zawsze.
  //
  // Parametry:
  //   komenda_f - rodzaj rekordu.
  //   peer_port_f
  //       (parametr nie ma znaczenia gdy wysy³a klient)
  //     -99 - serwer wysy³a do wszystkich klientów.
  //     <> -99 - serwer wysy³a do wskazanego klienta.
  //   wartoœæ_f - wartoœæ wysy³ana w poleceniu.
  //   czy_udp_f
  //     false - wysy³a poprzez TCP.
  //     true - wysy³a poprzez UDP.
  //


  if   (  Trim( komenda_f ) = ''  )
    or (
             ( komenda_f <> wieloosobowe__komenda__gra__rozpocznij_c )
         and ( komenda_f <> wieloosobowe__komenda__gra__zakoñcz_c )
         and ( komenda_f <> wieloosobowe__komenda__gra__morze_wzburzenie_c )
         and ( komenda_f <> wieloosobowe__komenda__gra__statystyki_wyœlij_c )
         and ( komenda_f <> wieloosobowe__komenda__gra__wspó³czynnik_prêdkoœci_c )
         and ( komenda_f <> wieloosobowe__komenda__gracz_gotowoœæ_c )
         and ( komenda_f <> wieloosobowe__komenda__gracz_lista_odœwie¿_c )
         and ( komenda_f <> wieloosobowe__komenda__has³o__sprawdŸ_c )
         and ( komenda_f <> wieloosobowe__komenda__identyfikator__nadaj_c )
         and ( komenda_f <> wieloosobowe__komenda__identyfikator__przypomnij_c )
         and ( komenda_f <> wieloosobowe__komenda__identyfikator__zapamiêtaj_c )
         and ( komenda_f <> wieloosobowe__komenda__odbierz__l¹d_definicja_c )
         and ( komenda_f <> wieloosobowe__komenda__odbierz__prymitywy_definicja_c )
         and ( komenda_f <> wieloosobowe__komenda__odbierz__rekord_amunicja_c )
         and ( komenda_f <> wieloosobowe__komenda__odbierz__rekord_efekt_c )
         and ( komenda_f <> wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c )
         and ( komenda_f <> wieloosobowe__komenda__odbierz__rekord_statki_c )
         and ( komenda_f <> wieloosobowe__komenda__odbierz__statki_definicje_c )
         and ( komenda_f <> wieloosobowe__komenda__pauza_c )
         //and ( komenda_f <> wieloosobowe__komenda__serwer_wy³¹cza_siê_c )
         and ( komenda_f <> wieloosobowe__komenda__statek__klawisze_obs³uga_c )
         and ( komenda_f <> wieloosobowe__komenda__statek__przywróæ_do_gry_c )
         and ( komenda_f <> wieloosobowe__komenda__udp__klient_po³¹czony_nadal_c )
         and ( komenda_f <> wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_r_c )
         and ( komenda_f <> wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_2_r_c )
       ) then
    Exit;


  strumieñ_pamiêci_l := TMemoryStream.Create();


  {$region 'Zapisuje rekord do strumienia.'}
  //if komenda_f = wieloosobowe__komenda__gra__rozpocznij_c then
  //  begin
  //  end
  //else//if komenda_f = wieloosobowe__komenda__gra__rozpocznij_c then
  //if komenda_f = wieloosobowe__komenda__gra__zakoñcz_c then
  //  begin
  //  end
  //else//if komenda_f = wieloosobowe__komenda__gra__zakoñcz_c then
  if   ( komenda_f = wieloosobowe__komenda__gra__morze_wzburzenie_c )
    or ( komenda_f = wieloosobowe__komenda__gra__wspó³czynnik_prêdkoœci_c ) then
    begin

      if czy_serwer_g then
        begin

          // Tylko serwer wysy³a informacjê o wspó³czynniku prêdkoœci gry, wzburzeniu morza.

          Strumieñ_Napis_Wpisz( wartoœæ_f, strumieñ_pamiêci_l );

        end;
      //---//if czy_serwer_g then

    end
  else//if   ( komenda_f = wieloosobowe__komenda__gra__morze_wzburzenie_c ) (...)
  if komenda_f = wieloosobowe__komenda__gra__statystyki_wyœlij_c then
    begin

      //if czy_klient_g then
      //  begin
      //
      //    // Tylko klient pyta o dane statystyk.
      //
      //  end
      //else//if czy_klient_g then
      if czy_serwer_g then
        begin

          // Tylko serwer wysy³a dane statystyk.

          for i := 0 to Length( gra_statystyki_r_t ) - 1 do
            begin

              strumieñ_pamiêci_l.Write( gra_statystyki_r_t[ i ], obiekty_wieloosobowe__gra_statystyki_r_rozmiar_c );

            end;
          //---//for i := 0 to Length( gra_statystyki_r_t ) - 1 do

        end;
      //---//if czy_serwer_g then

    end
  else//if komenda_f = wieloosobowe__komenda__gra__statystyki_wyœlij_c then
  if komenda_f = wieloosobowe__komenda__gracz_gotowoœæ_c then
    begin

      if czy_serwer_g then
        begin

          // Serwer potwierdza, ¿e gracz jest gotowy.

          if wartoœæ_f = 'Tak' then
            begin

              Strumieñ_Napis_Wpisz( wartoœæ_f, strumieñ_pamiêci_l );

            end;
          //---//if wartoœæ_f = 'Tak' then

        end
      else//if czy_serwer_g then
      if czy_klient_g then
        begin

          // Tylko klient zwraca siê o nadanie statusu gotowoœci.

          Strumieñ_Napis_Wpisz( wartoœæ_f, strumieñ_pamiêci_l );

          if wartoœæ_f = 'Tak' then
            begin

              i := Gracz_Grupa_SpinEdit.Value;
              strumieñ_pamiêci_l.Write(  i, SizeOf ( integer )  );

              i := Statek_ComboBox.ItemIndex;
              strumieñ_pamiêci_l.Write(  i, SizeOf ( integer )  );

              Strumieñ_Napis_Wpisz( Gracz_Nazwa_Edit.Text, strumieñ_pamiêci_l );

            end;
          //---//if wartoœæ_f = 'Tak' then

        end;
      //---//if czy_klient_g then

    end
  else//if komenda_f = wieloosobowe__komenda__gracz_gotowoœæ_c then
  if komenda_f = wieloosobowe__komenda__gracz_lista_odœwie¿_c then
    begin

      if czy_serwer_g then
        begin

          // Tylko serwer wysy³a listê graczy.

          Strumieñ_Napis_Wpisz( L¹d_ComboBox.Text, strumieñ_pamiêci_l );

          if Statki_Pozycje_Pocz¹tkowe_ComboBox.ItemIndex > 0 then
            Strumieñ_Napis_Wpisz( Statki_Pozycje_Pocz¹tkowe_ComboBox.Text, strumieñ_pamiêci_l )
          else//if Statki_Pozycje_Pocz¹tkowe_ComboBox.ItemIndex > 0 then
            Strumieñ_Napis_Wpisz( '<wed³ug mapy>', strumieñ_pamiêci_l );


          for i := 0 to tcp_klienci_lista_g.klienci_lista_list.Count - 1 do
            begin

              zt_tcp_klient_dane := TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]);


              strumieñ_pamiêci_l.Write(  zt_tcp_klient_dane.identyfikator, SizeOf( integer )  );
              strumieñ_pamiêci_l.Write(  zt_tcp_klient_dane.id_grupa, SizeOf( integer )  );
              strumieñ_pamiêci_l.Write(  zt_tcp_klient_dane.id_statek_schemat, SizeOf( integer )  );
              strumieñ_pamiêci_l.Write(  zt_tcp_klient_dane.peer_port_tcp, SizeOf( integer )  );
              strumieñ_pamiêci_l.Write(  zt_tcp_klient_dane.peer_port_udp, SizeOf( integer )  );

              strumieñ_pamiêci_l.Write(  zt_tcp_klient_dane.data_czas__d³¹czenia, SizeOf( TDateTime )  );
              strumieñ_pamiêci_l.Write(  zt_tcp_klient_dane.data_czas__pod³¹czenia, SizeOf( TDateTime )  );
              strumieñ_pamiêci_l.Write(  zt_tcp_klient_dane.data_czas__pod³¹czenia_ostatniego, SizeOf( TDateTime )  );
              strumieñ_pamiêci_l.Write(  zt_tcp_klient_dane.data_czas__udp_kontakt, SizeOf( TDateTime )  );

              strumieñ_pamiêci_l.Write(  zt_tcp_klient_dane.gotowy, SizeOf( boolean )  );
              strumieñ_pamiêci_l.Write(  zt_tcp_klient_dane.od³¹czony, SizeOf( boolean )  );

              strumieñ_pamiêci_l.Write( zt_tcp_klient_dane.nazwa, wieloosobowe_string__rozmiar_c );

            end;
          //---//klienci_lista_list

        end
      //---//if czy_serwer_g then

      // Klienta pyta serwer o aktualn¹ listê graczy.

    end
  else//if komenda_f = wieloosobowe__komenda__gracz_lista_odœwie¿_c then
  if komenda_f = wieloosobowe__komenda__has³o__sprawdŸ_c then
    begin

      if czy_serwer_g then
        begin

          // Serwer wysy³a odpowiedŸ czy has³o jest prawid³owe.

          Strumieñ_Napis_Wpisz( wartoœæ_f, strumieñ_pamiêci_l );

        end;
      //else//if czy_serwer_g then
      //if czy_klient_g then
      //  begin
      //
      //    // Tylko klient wysy³a has³o do sprawdzenia.
      //
      //    Strumieñ_Napis_Wpisz( Has³o_Edit.Text, strumieñ_pamiêci_l );
      //
      //  end;
      ////---//if czy_klient_g then

    end
  else//if komenda_f = wieloosobowe__komenda__has³o__sprawdŸ_c then
  if komenda_f = wieloosobowe__komenda__identyfikator__nadaj_c then
    begin

      if czy_klient_g then
        begin

          // Tylko klient zwraca siê o nadanie identyfikatora.

          Strumieñ_Napis_Wpisz( Has³o_Edit.Text, strumieñ_pamiêci_l ); // Tylko klient wysy³a has³o do sprawdzenia.

        end;
      //---//if czy_klient_g then

    end
  else//if komenda_f = wieloosobowe__komenda__identyfikator__nadaj_c then
  if komenda_f = wieloosobowe__komenda__identyfikator__przypomnij_c then
    begin

      if czy_klient_g then
        begin

          // Tylko klient przypomina swój identyfikator.

          Strumieñ_Napis_Wpisz( Has³o_Edit.Text, strumieñ_pamiêci_l ); // Tylko klient wysy³a has³o do sprawdzenia.
          Strumieñ_Napis_Wpisz( wartoœæ_f, strumieñ_pamiêci_l );

        end;
      //---//if czy_klient_g then

    end
  else//if komenda_f = wieloosobowe__komenda__identyfikator__przypomnij_c then
  if komenda_f = wieloosobowe__komenda__identyfikator__zapamiêtaj_c then
    begin

      if czy_serwer_g then
        begin

          // Tylko serwer nadaje identyfikator.

          Strumieñ_Napis_Wpisz( wartoœæ_f, strumieñ_pamiêci_l );

        end;
      //---//if czy_serwer_g then

    end
  else//if komenda_f = wieloosobowe__komenda__identyfikator__zapamiêtaj_c then
  if komenda_f = wieloosobowe__komenda__odbierz__l¹d_definicja_c then
    begin

      if not czy_klient_g then
        begin

          // Tylko serwer wysy³a dane o l¹dzie.

          Strumieñ_Napis_Wpisz( l¹d_definicja_g, strumieñ_pamiêci_l );

        end;
      //---//if not czy_klient_g then

    end
  else//if komenda_f = wieloosobowe__komenda__odbierz__l¹d_definicja_c then
  if komenda_f = wieloosobowe__komenda__odbierz__prymitywy_definicja_c then
    begin

      if not czy_klient_g then
        begin

          // Tylko serwer wysy³a dane o prymitywach.

          try
            i := StrToInt( wartoœæ_f );
          except
            i := -99;
          end;
          //---//try

          if    ( i >= 0 )
            and (  i <= Length( prymitywy_lista_t ) - 1  ) then
            begin

              Strumieñ_Napis_Wpisz( prymitywy_lista_t[ i ].plik_nazwa, strumieñ_pamiêci_l );
              Strumieñ_Napis_Wpisz( prymitywy_lista_t[ i ].treœæ, strumieñ_pamiêci_l );

            end;
          //---//if    ( i >= 0 ) (...)

        end;
      //---//if not czy_klient_g then

    end
  else//if komenda_f = wieloosobowe__komenda__odbierz__prymitywy_definicja_c then
  if komenda_f = wieloosobowe__komenda__odbierz__rekord_amunicja_c then
    begin

      Wieloosobowe_Amunicja_Parametry_Odczytaj();


      for i := 0 to Length( wieloosobowe__amunicja_t ) - 1 do
        begin

          strumieñ_pamiêci_l.Write( wieloosobowe__amunicja_t[ i ], obiekty_wieloosobowe__amunicja_r__rozmiar_c );

        end;
      //---//for i := 0 to Length( wieloosobowe__amunicja_t ) - 1 do

    end
  else//if komenda_f = wieloosobowe__komenda__odbierz__rekord_amunicja_c then
  if komenda_f = wieloosobowe__komenda__odbierz__rekord_efekt_c then
    begin

      strumieñ_pamiêci_l.Write( wieloosobowe__efekt_r, obiekty_wieloosobowe__efekt_r__rozmiar_c );

      // Efekt wysy³any jako tabela.
      //for i := 0 to Length( wieloosobowe__efekt_t ) - 1 do
      //  begin
      //
      //    if not wieloosobowe__efekt_t[ i ].wys³ane then
      //      begin
      //
      //        strumieñ_pamiêci_l.Write( wieloosobowe__efekt_t[ i ], obiekty_wieloosobowe__efekt_r__rozmiar_c );
      //        wieloosobowe__efekt_t[ i ].wys³ane := true;
      //
      //      end;
      //    //---//if not wieloosobowe__efekt_t[ i ].wys³ane then
      //
      //  end;
      ////---//for i := 0 to Length( wieloosobowe__efekt_t ) - 1 do

    end
  else//if komenda_f = wieloosobowe__komenda__odbierz__rekord_efekt_c then
  if komenda_f = wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c then
    begin

      //pokój_rozmów_r.wiadomoœæ__d³ugoœæ := Length( pokój_rozmów_r.wiadomoœæ );
      strumieñ_pamiêci_l.Write( pokój_rozmów_r, pokój_rozmów_r__rozmiar_c );

      // Gdy bêd¹ napisy z dowoln¹ d³ugoœci¹.
      //if pokój_rozmów_r.wiadomoœæ__d³ugoœæ > 0 then
      //  strumieñ_pamiêci_l.WriteBuffer(
      //      Pointer( pokój_rozmów_r.wiadomoœæ )^, // value of first name
      //      char_rozmiar_c * pokój_rozmów_r.wiadomoœæ__d³ugoœæ
      //    );

    end
  else//if komenda_f = wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c then
  if komenda_f = wieloosobowe__komenda__odbierz__rekord_statki_c then
    begin

      Wieloosobowe_Statki_Parametry_Odczytaj();

      {$region 'Zakomentowane - obs³ugiwane w taki sposób zg³asza b³êdy dostêpu - wieloosobowe__komenda__odbierz__rekord_statki_c.'}
      //for i := 0 to Length( wieloosobowe__statki_t ) - 1 do
      //  begin
      //
      //    strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ], obiekty_wieloosobowe__statki_r__rozmiar_c );
      //
      //
      //    for j := 0 to Length( wieloosobowe__statki_t[ i ].œruba_obrót_k¹t ) - 1 do
      //      strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].œruba_obrót_k¹t[ j ], SizeOf( real )  );
      //
      //
      //    for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t ) - 1 do
      //      begin
      //
      //        strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].artyleria_t[ j ], obiekty_wieloosobowe__dzia³o_r__rozmiar_c  );
      //
      //        for k := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
      //          strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );
      //
      //      end;
      //    //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t ) - 1 do
      //
      //    for j := 0 to Length( wieloosobowe__statki_t[ i ].dzia³a_t ) - 1 do
      //      begin
      //
      //        strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].dzia³a_t[ j ], obiekty_wieloosobowe__dzia³o_r__rozmiar_c  );
      //
      //        for k := 0 to Length( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
      //          strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );
      //
      //      end;
      //    //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].dzia³a_t ) - 1 do
      //
      //    for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do
      //      begin
      //
      //        strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ], obiekty_wieloosobowe__dzia³o_r__rozmiar_c  );
      //
      //        for k := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
      //          strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );
      //
      //      end;
      //    //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do
      //
      //
      //    for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t ) - 1 do
      //      begin
      //
      //        strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t[ j ], obiekty_wieloosobowe__dzia³o_r__rozmiar_c  );
      //
      //        for k := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
      //          strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );
      //
      //      end;
      //    //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t ) - 1 do
      //
      //    for j := 0 to Length( wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t ) - 1 do
      //      begin
      //
      //        strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t[ j ], obiekty_wieloosobowe__dzia³o_r__rozmiar_c  );
      //
      //        for k := 0 to Length( wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
      //          strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );
      //
      //      end;
      //    //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t ) - 1 do
      //
      //    for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t ) - 1 do
      //      begin
      //
      //        strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ], obiekty_wieloosobowe__dzia³o_r__rozmiar_c  );
      //
      //        for k := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
      //          strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );
      //
      //      end;
      //    //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t ) - 1 do
      //
      //  end;
      ////---//for i := 0 to Length( rekord_r_t ) - 1 do
      {$endregion 'Zakomentowane - obs³ugiwane w taki sposób zg³asza b³êdy dostêpu - wieloosobowe__komenda__odbierz__rekord_statki_c.'}


      {$region 'wieloosobowe__komenda__odbierz__rekord_statki_c.'}
      for i := 0 to Length( wieloosobowe__statki_t ) - 1 do
        begin

          //strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ], obiekty_wieloosobowe__statki_r__rozmiar_c );

          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].id_grupa, SizeOf( integer )  );
          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].id_statek, SizeOf( integer )  );
          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].id_statek_schemat, SizeOf( integer )  );
          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].artyleria_t__d³ugoœæ_tabeli, SizeOf( integer )  );
          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].dzia³a_t__d³ugoœæ_tabeli, SizeOf( integer )  );
          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t__d³ugoœæ_tabeli, SizeOf( integer )  );
          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t__d³ugoœæ_tabeli, SizeOf( integer )  );
          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t__d³ugoœæ_tabeli, SizeOf( integer )  );
          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t__d³ugoœæ_tabeli, SizeOf( integer )  );
          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].œruba_obrót_k¹t__d³ugoœæ, SizeOf( integer )  );

          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].falowanie_bok_skrêt, SizeOf( real )  );
          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].prêdkoœæ_procent, SizeOf( real )  );
          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].prêdkoœæ_zadana_procent, SizeOf( real )  );
          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].punkty_¿ycia, SizeOf( real )  );
          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].punkty_¿ycia_maksymalne, SizeOf( real )  );
          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].punkty_¿ycia_procent_zosta³o, SizeOf( real )  );
          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].skrêt_procent, SizeOf( real )  );
          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].skrêt_zadany_procent, SizeOf( real )  );
          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].ster_k¹t, SizeOf( real )  );
          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].toniêcie__przechylenie__lewo_prawo, SizeOf( real )  );
          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].toniêcie__przechylenie__przód_ty³, SizeOf( real )  );

          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].czy_wszystkie_lufy, SizeOf( boolean )  );
          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].obracaj_dzia³a, SizeOf( boolean )  );
          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].podnoœ_lufy, SizeOf( boolean )  );
          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].przeliczone, SizeOf( boolean )  );

          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].gracz__nazwa, SizeOf( TWieloosobowe_String )  );

          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].cel_wspó³rzêdne, SizeOf( TWieloosobowe__Wektor_4 )  );
          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].kierunek, SizeOf( TWieloosobowe__Wektor_4 )  );
          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].pozycja, SizeOf( TWieloosobowe__Wektor_4 )  );

          strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].amunicja_rodzaj, SizeOf( TAmunicja_Rodzaj )  );


          for j := 0 to Length( wieloosobowe__statki_t[ i ].œruba_obrót_k¹t ) - 1 do
            strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].œruba_obrót_k¹t[ j ], SizeOf( real )  );


          for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t ) - 1 do
            begin

              //strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].artyleria_t[ j ], obiekty_wieloosobowe__dzia³o_r__rozmiar_c  );

              strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].czy_lot_parabol¹, SizeOf( boolean )  );
              strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obrót_k¹t, SizeOf( real )  );
              strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].celownik_linia__podniesienie_k¹t, SizeOf( real )  );
              strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].celownik_linia__szerokoœæ, SizeOf( single )  );
              strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].celownik_linia__wzór, SizeOf( word )  );
              strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].amunicja_iloœæ, SizeOf( integer )  );
              strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t__d³ugoœæ_tabeli, SizeOf( integer )  );
              strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].celownik_linia__kolor, SizeOf( TWieloosobowe__Wektor_4 )  );

              for k := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
                begin

                  //strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );

                  strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_k¹t, SizeOf( real )  );
                  strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z, SizeOf( real )  );
                  strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].strza³_gotowoœæ, SizeOf( boolean )  );
                  strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__kolor, SizeOf( TWieloosobowe__Wektor_4 )  );
                  strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__pozycja, SizeOf( TWieloosobowe__Wektor_4 )  );

                end;
              //---//for k := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do

            end;
          //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t ) - 1 do

          for j := 0 to Length( wieloosobowe__statki_t[ i ].dzia³a_t ) - 1 do
            begin

              //strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].dzia³a_t[ j ], obiekty_wieloosobowe__dzia³o_r__rozmiar_c  );

              strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obrót_k¹t, SizeOf( real )  );
              strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].celownik_linia__podniesienie_k¹t, SizeOf( real )  );
              strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].celownik_linia__szerokoœæ, SizeOf( single )  );
              strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].celownik_linia__wzór, SizeOf( word )  );
              strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].amunicja_iloœæ, SizeOf( integer )  );
              strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t__d³ugoœæ_tabeli, SizeOf( integer )  );
              strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].celownik_linia__kolor, SizeOf( TWieloosobowe__Wektor_4 )  );

              for k := 0 to Length( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
                begin

                  //strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );

                  strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_k¹t, SizeOf( real )  );
                  strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z, SizeOf( real )  );
                  strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].strza³_gotowoœæ, SizeOf( boolean )  );
                  strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__kolor, SizeOf( TWieloosobowe__Wektor_4 )  );
                  strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__pozycja, SizeOf( TWieloosobowe__Wektor_4 )  );

                end;
              //---//for k := 0 to Length( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do

            end;
          //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].dzia³a_t ) - 1 do

          for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do
            begin

              //strumieñ_pamiêci_l.Write(  wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ], obiekty_wieloosobowe__dzia³o_r__rozmiar_c  );

              strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obrót_k¹t, SizeOf( real )  );
              strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia__podniesienie_k¹t, SizeOf( real )  );
              strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia__szerokoœæ, SizeOf( single )  );
              strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia__wzór, SizeOf( word )  );
              strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].amunicja_iloœæ, SizeOf( integer )  );
              strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t__d³ugoœæ_tabeli, SizeOf( integer )  );
              strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia__kolor, SizeOf( TWieloosobowe__Wektor_4 )  );

              for k := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
                begin

                  //strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );

                  strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_k¹t, SizeOf( real )  );
                  strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z, SizeOf( real )  );
                  strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].strza³_gotowoœæ, SizeOf( boolean )  );
                  strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__kolor, SizeOf( TWieloosobowe__Wektor_4 )  );
                  strumieñ_pamiêci_l.Write( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__pozycja, SizeOf( TWieloosobowe__Wektor_4 )  );

                end;
              //---//for k := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do

            end;
          //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do


          Strumieñ_Napis_Wpisz( wieloosobowe__statki_t[ i ].radar_id_statki_w_zasiêgu, strumieñ_pamiêci_l );
          Strumieñ_Napis_Wpisz( wieloosobowe__statki_t[ i ].radio_id_statki_w_zasiêgu, strumieñ_pamiêci_l );

        end;
      //---//for i := 0 to Length( rekord_r_t ) - 1 do
      {$endregion 'wieloosobowe__komenda__odbierz__rekord_statki_c.'}


      // Tutaj mo¿na przetestowaæ odczytanie strumienia. //???
      // Wieloosobowe_Statki_Rekord_Czyœæ();
      // strumieñ_pamiêci_l.Position := 0; // while strumieñ_pamiêci_l.Position < strumieñ_pamiêci_l.Size do (...)

    end
  else//if komenda_f = wieloosobowe__komenda__odbierz__rekord_statki_c then
  if komenda_f = wieloosobowe__komenda__odbierz__statki_definicje_c then
    begin

      if not czy_klient_g then
        begin

          // Tylko serwer wysy³a dane o statkach.

          for i := 0 to Length( statki_lista_t ) - 1 do
            begin

              Strumieñ_Napis_Wpisz( statki_lista_t[ i ].id, strumieñ_pamiêci_l );
              Strumieñ_Napis_Wpisz( statki_lista_t[ i ].nazwa, strumieñ_pamiêci_l );
              Strumieñ_Napis_Wpisz( statki_lista_t[ i ].opis, strumieñ_pamiêci_l );
              Strumieñ_Napis_Wpisz( statki_lista_t[ i ].plik_nazwa, strumieñ_pamiêci_l );
              Strumieñ_Napis_Wpisz( statki_lista_t[ i ].treœæ, strumieñ_pamiêci_l );

            end;
          //---//for i := 0 to Length( statki_lista_t ) - 1 do

        end;
      //---//if not czy_klient_g then

    end
  else//if komenda_f = wieloosobowe__komenda__odbierz__statki_definicje_c then
  if komenda_f = wieloosobowe__komenda__pauza_c then
    begin

      if czy_serwer_g then
        begin

          // Tylko serwer wysy³a informacjê o pauzie.

          Strumieñ_Napis_Wpisz( wartoœæ_f, strumieñ_pamiêci_l );

        end;
      //---//if czy_serwer_g then

    end
  else//if komenda_f = wieloosobowe__komenda__pauza_c then
  if komenda_f = wieloosobowe__komenda__serwer_wy³¹cza_siê_c then
    begin

      strumieñ_pamiêci_l.Write(  wieloosobowe__komenda__serwer_wy³¹cza_siê_c, SizeOf ( wieloosobowe__komenda__serwer_wy³¹cza_siê_c )  );

    end
  else//if komenda_f = wieloosobowe__komenda__serwer_wy³¹cza_siê_c then
  if komenda_f = wieloosobowe__komenda__statek__klawisze_obs³uga_c then
    begin

      if czy_klient_g then // Tylko klient wysy³a informacje o obs³udze klawiszy na serwer.
        strumieñ_pamiêci_l.Write( wieloosobowe__statek_klawisze_obs³uga_r, obiekty_wieloosobowe__statek_klawisze_obs³uga_r__rozmiar_c );

    end
  else//if komenda_f = wieloosobowe__komenda__statek__klawisze_obs³uga_c then
  if komenda_f = wieloosobowe__komenda__statek__przywróæ_do_gry_c then
    begin

      strumieñ_pamiêci_l.Write(  wieloosobowe__statek_przywróæ_do_gry__id_statek_g, SizeOf( wieloosobowe__statek_przywróæ_do_gry__id_statek_g )  );
      wieloosobowe__statek_przywróæ_do_gry__id_statek_g := -99;

    end
  else//if komenda_f = wieloosobowe__komenda__statek__przywróæ_do_gry_c then
  if komenda_f = wieloosobowe__komenda__udp__klient_po³¹czony_nadal_c then
    begin

      if czy_klient_g then
        begin

          // Tylko klient informuje o aktywnoœci swojego pod³¹czenia do serwera.

          if czy_udp_f then
            begin

              Strumieñ_Napis_Wpisz
                (
                  IntToStr( IdTCPClient1.Socket.Binding.Port ) + ';' +
                  Wieloosobowe_Identyfikator_Edit.Text + ';' +
                  FloatToStr( double(Now()) ) + ';',
                  strumieñ_pamiêci_l
                );

            end;
          //---//if czy_udp_f then

        end;
      //---//if czy_klient_g then

    end
  else//if komenda_f = wieloosobowe__komenda__udp__klient_po³¹czony_nadal_c then
  if komenda_f = wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_r_c then
    begin

      Komunikacja_Rekord_Testowy_Obs³uga( false );
      strumieñ_pamiêci_l.Write( komunikacja_rekord_testowy_r, komunikacja_rekord_testowy_r__rozmiar_c );

    end
  else//if komenda_f = wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_r_c then
  if komenda_f = wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_2_r_c then
    begin

      komunikacja_rekord_testowy_2_r.napis := '¹ê ŒÆ ³Ñ';
      komunikacja_rekord_testowy_2_r.liczba_ca³kowita := Length( komunikacja_rekord_testowy_2_r.napis );

      //strumieñ_pamiêci_l.Write( komunikacja_rekord_testowy_2_r, komunikacja_rekord_testowy_2_r__rozmiar_c ); // Tak nie dzia³a.

      strumieñ_pamiêci_l.Write(  komunikacja_rekord_testowy_2_r.liczba_ca³kowita, SizeOf( integer )  );
      strumieñ_pamiêci_l.Write(  komunikacja_rekord_testowy_2_r.liczba_rzeczywista, SizeOf( real )  );
      strumieñ_pamiêci_l.Write(  komunikacja_rekord_testowy_2_r.data_czas, SizeOf( TDateTime )  );

      if komunikacja_rekord_testowy_2_r.liczba_ca³kowita > 0 then
        strumieñ_pamiêci_l.WriteBuffer(
            Pointer( komunikacja_rekord_testowy_2_r.napis )^,
            char_rozmiar_c * komunikacja_rekord_testowy_2_r.liczba_ca³kowita
          );

    end;
  //else//if komenda_f = wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_2_r_c then
  //  ;
  {$endregion 'Zapisuje rekord do strumienia.'}


  strumieñ_pamiêci_l.Position := 0; // Chyba nie trzeba.
  //strumieñ_rozmiar := strumieñ_pamiêci_l.Size;


  {$region 'Wysy³a dane.'}
  if not czy_serwer_g then
    begin

      // Klient.

      if not czy_udp_f then
        begin

          // TCP.

          if IdTCPClient1.Connected then
            begin

              //IdTCPClient1.IOHandler.WriteBufferOpen(); //???
              IdTCPClient1.IOHandler.WriteLn( komenda_f, IdGlobal.IndyTextEncoding_UTF8 ); // W XE 3 IdGlobal.TIdTextEncoding.UTF8.
              IdTCPClient1.IOHandler.WriteLn(  IntToStr( strumieñ_pamiêci_l.Size ), IdGlobal.IndyTextEncoding_UTF8  );
              IdTCPClient1.IOHandler.Write( strumieñ_pamiêci_l, strumieñ_pamiêci_l.Size );
              //IdTCPClient1.IOHandler.WriteBufferFlush(); //???

            end;
          //---//if IdTCPClient1.Connected then

        end
      else//if not czy_udp_f then
        begin

          // UDP.

          if IdUDPClient1.Connected then // Tylko pod³¹cza klienta do portu (lokalnie). Je¿eli nie ma serwera i tak wyœwietla, ¿e siê po³¹czy³.
            begin

              IdGlobal.ReadTIdBytesFromStream( strumieñ_pamiêci_l, zt_id_bytes, strumieñ_pamiêci_l.Size );


              IdUDPClient1.Send( komenda_f, IdGlobal.IndyTextEncoding_UTF8 ); // W XE 3 IdGlobal.TIdTextEncoding.UTF8.
              IdUDPClient1.Send(  IntToStr( strumieñ_pamiêci_l.Size ), IdGlobal.IndyTextEncoding_UTF8  );
              IdUDPClient1.SendBuffer( IdUDPClient1.Host, IdUDPClient1.Port, zt_id_bytes );

            end;
          //---//if IdUDPClient1.Connected then

        end;
      //---//if not czy_udp_f then

    end
  else//if not czy_serwer_g then
    begin

      // Serwer.

      if not czy_udp_f then
        begin

          // TCP.

          lista := IdTCPServer1.Contexts.LockList();

          try
            for i := 0 to lista.Count - 1 do
              if   ( peer_port_f = -99 )
                or ( TIdContext(lista[ i ]).Connection.Socket.Binding.PeerPort = peer_port_f ) then
                begin
                  try
                    strumieñ_pamiêci_l.Position := 0; // Chyba nie trzeba.

                    //TIdContext(lista[ i ]).Connection.IOHandler.WriteBufferOpen(); //???
                    TIdContext(lista[ i ]).Connection.IOHandler.WriteLn( komenda_f, IdGlobal.IndyTextEncoding_UTF8 ); // W XE 3 IdGlobal.TIdTextEncoding.UTF8.
                    TIdContext(lista[ i ]).Connection.IOHandler.WriteLn(  IntToStr( strumieñ_pamiêci_l.Size ), IdGlobal.IndyTextEncoding_UTF8  );
                    TIdContext(lista[ i ]).Connection.IOHandler.Write( strumieñ_pamiêci_l, strumieñ_pamiêci_l.Size );
                    //TIdContext(lista[ i ]).Connection.IOHandler.WriteBufferFlush(); //???
                  except
                    on E : Exception do
                      begin
                        Wieloosobowe__Log_Wypisz(
                            'Nie uda³o siê wys³aæ danych (s) do klienta: ' + IntToStr( TIdContext(lista[ i ]).Binding.PeerPort ) + #13 + #10 +
                            E.Message + ' ' + IntToStr( E.HelpContext ) + '.'
                          );
                        //Application.MessageBox(
                        //    PChar('Nie uda³o siê wys³aæ danych (s) do klienta: ' + IntToStr( TIdContext(lista[ i ]).Binding.PeerPort ) + #13 +
                        //    E.Message + ' ' + IntToStr( E.HelpContext ) + '.'), 'B³¹d',
                        //    MB_OK + MB_ICONEXCLAMATION
                        //  );
                      end;
                  end;
                end;
              //---//if   ( peer_port_f = -99 ) (...)
          finally
            IdTCPServer1.Contexts.UnlockList();
          end;
          //---//try

        end
      else//if not czy_udp_f then
        begin

          // UDP.

          IdGlobal.ReadTIdBytesFromStream( strumieñ_pamiêci_l, zt_id_bytes, strumieñ_pamiêci_l.Size );


          for i := udp_klienci_lista_g.klienci_lista_list.Count - 1 downto 0 do
            if   ( peer_port_f = -99 )
              or ( TUDP_Klient_Dane(udp_klienci_lista_g.klienci_lista_list[ i ]).peer_port = peer_port_f ) then //???
              begin

                IdUDPServer1.Send( TUDP_Klient_Dane(udp_klienci_lista_g.klienci_lista_list[ i ]).adres_ip, TUDP_Klient_Dane(udp_klienci_lista_g.klienci_lista_list[ i ]).peer_port, komenda_f, IdGlobal.IndyTextEncoding_UTF8 );
                IdUDPServer1.Send(  TUDP_Klient_Dane(udp_klienci_lista_g.klienci_lista_list[ i ]).adres_ip, TUDP_Klient_Dane(udp_klienci_lista_g.klienci_lista_list[ i ]).peer_port, IntToStr( strumieñ_pamiêci_l.Size ), IdGlobal.IndyTextEncoding_UTF8  );
                IdUDPServer1.SendBuffer( TUDP_Klient_Dane(udp_klienci_lista_g.klienci_lista_list[ i ]).adres_ip, TUDP_Klient_Dane(udp_klienci_lista_g.klienci_lista_list[ i ]).peer_port, zt_id_bytes );

              end;
            //---//if   ( peer_port_f = -99 ) (...)

        end;
      //---//if not czy_udp_f then

    end;
  //---//if not czy_serwer_g then
  {$endregion 'Wysy³a dane.'}


  FreeAndNil( strumieñ_pamiêci_l );

end;//---//Funkcja Wieloosobowe__Strumieñ_Wyœlij().

//Funkcja Wieloosobowe__Odczytaj().
function TStatki_Form.Wieloosobowe__Odczytaj( const io_handler_f : TIdIOHandler; const komenda_udp_f : string; const id_context_f : TIdContext; const id_socket_handle_f : TIdSocketHandle ) : string; // uses IdIOHandler.

  //Funkcja Strumieñ_Napis_Odczytaj() w Wieloosobowe__Odczytaj().
  function Strumieñ_Napis_Odczytaj( strumieñ_pamiêci_f : TMemoryStream ) : string;
  var
    i,
    j
      : integer;
    zt_wieloosobowe_string : TWieloosobowe_String;
  begin

    strumieñ_pamiêci_f.Read(  i, SizeOf( i )  );

    Result := '';

    for j := 1 to i do
      begin

        zt_wieloosobowe_string := '';
        strumieñ_pamiêci_f.Read( zt_wieloosobowe_string, wieloosobowe_string__rozmiar_c );
        Result := Result + zt_wieloosobowe_string;

      end;
    //---//for j := 0 to i do

  end;//---//Funkcja Strumieñ_Napis_Odczytaj() w Wieloosobowe__Odczytaj().

var
  i,
  j,
  k,
  strumieñ_rozmiar
    : integer;
  ztdu : double;
  zts,
  komenda_l
    : string;
  czy_udp_l : boolean;
  pokój_rozmów_r_l : TPokój_Rozmów_r;
  zt_tcp_klient_dane : TTCP_Klient_Dane;
  komunikacja_rekord_testowy_2_r_l : TKomunikacja_Rekord_Testowy_2_r; // Ze zmienn¹ lokaln¹ lepiej dzia³a (?). //???
  wieloosobowe__statek_klawisze_obs³uga_r_l : TObiekty_Wieloosobowe__Statek_Klawisze_Obs³uga_r;
  strumieñ_pamiêci_l : TMemoryStream;
  zt_id_bytes : TIdBytes;
begin//Funkcja Wieloosobowe__Odczytaj().

  Result := '';


  if    (
             ( io_handler_f = nil )
          or (  not Assigned( io_handler_f )  )
        )
    and ( Trim( komenda_udp_f ) = ''  ) then
    Exit;


  if    ( io_handler_f <> nil )
    and (  Assigned( io_handler_f )  ) then
    czy_udp_l := false
  else//if    ( io_handler_f <> nil ) (...)
    czy_udp_l := true;


  if not czy_udp_l then
    komenda_l := io_handler_f.ReadLn( IdGlobal.IndyTextEncoding_UTF8 ) // W XE 3 IdGlobal.TIdTextEncoding.UTF8.
  else//if not czy_udp_l then
    komenda_l := komenda_udp_f;


  if id_context_f <> nil then
    begin

      zts := 'TCP ';
      zts := zts + id_context_f.Binding.PeerIP; // 127.0.0.1
      zts := zts + '; ' + IntToStr( id_context_f.Binding.PeerPort ); // 62951 - Niepowtarzalny dla klientów numer.
      zts := zts + '; ' + IntToStr( id_context_f.Binding.Port ); // 3500
      zts := zts + '; ' + komenda_l;

      //Wieloosobowe__Log_Wypisz( zts );

    end
  else//if id_context_f <> nil then
  if id_socket_handle_f <> nil then
    begin

      zts := 'UDP ';
      zts := zts + id_socket_handle_f.PeerIP; // 127.0.0.1
      zts := zts + '; ' + IntToStr( id_socket_handle_f.PeerPort ); // 62951 - Niepowtarzalny dla klientów numer.
      zts := zts + '; ' + IntToStr( id_socket_handle_f.Port ); // 3500
      zts := zts + '; ' + komenda_l;

      //Wieloosobowe__Log_Wypisz( zts );

    end;
  //---//if id_socket_handle_f <> nil then


  if   ( komenda_l = wieloosobowe__komenda__gra__rozpocznij_c )
    or ( komenda_l = wieloosobowe__komenda__gra__zakoñcz_c )
    or ( komenda_l = wieloosobowe__komenda__gra__morze_wzburzenie_c )
    or ( komenda_l = wieloosobowe__komenda__gra__statystyki_wyœlij_c )
    or ( komenda_l = wieloosobowe__komenda__gra__wspó³czynnik_prêdkoœci_c )
    or ( komenda_l = wieloosobowe__komenda__gracz_gotowoœæ_c )
    or ( komenda_l = wieloosobowe__komenda__gracz_lista_odœwie¿_c )
    or ( komenda_l = wieloosobowe__komenda__has³o__sprawdŸ_c )
    or ( komenda_l = wieloosobowe__komenda__identyfikator__nadaj_c )
    or ( komenda_l = wieloosobowe__komenda__identyfikator__przypomnij_c )
    or ( komenda_l = wieloosobowe__komenda__identyfikator__zapamiêtaj_c )
    or ( komenda_l = wieloosobowe__komenda__odbierz__l¹d_definicja_c )
    or ( komenda_l = wieloosobowe__komenda__odbierz__prymitywy_definicja_c )
    or ( komenda_l = wieloosobowe__komenda__odbierz__rekord_amunicja_c )
    or ( komenda_l = wieloosobowe__komenda__odbierz__rekord_efekt_c )
    or ( komenda_l = wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c )
    or ( komenda_l = wieloosobowe__komenda__odbierz__rekord_statki_c )
    or ( komenda_l = wieloosobowe__komenda__odbierz__statki_definicje_c )
    or ( komenda_l = wieloosobowe__komenda__pauza_c )
    //or ( komenda_l = wieloosobowe__komenda__serwer_wy³¹cza_siê_c )
    or ( komenda_l = wieloosobowe__komenda__statek__klawisze_obs³uga_c )
    or ( komenda_l = wieloosobowe__komenda__statek__przywróæ_do_gry_c )
    or ( komenda_l = wieloosobowe__komenda__udp__klient_po³¹czony_nadal_c )
    or ( komenda_l = wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_r_c )
    or ( komenda_l = wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_2_r_c ) then
    begin

      {$region 'Odczytuje dane.'}
      // Rozmiar strumienia.
      if not czy_udp_l then
        zts := io_handler_f.ReadLn( IdGlobal.IndyTextEncoding_UTF8 )
      else//if not czy_udp_l then
        begin

          i := 0;

          if czy_serwer_g then
            zts := IdUDPServer1.ReceiveString( -1, IdGlobal.IndyTextEncoding_UTF8 )
          else//if czy_serwer_g then
            zts := IdUDPClient1.ReceiveString( -1, IdGlobal.IndyTextEncoding_UTF8 );

        end;
      //---//if not czy_udp_l then


      try
        strumieñ_rozmiar := StrToInt( zts );
      except
        strumieñ_rozmiar := 0;

        zts := 'B³êdny rozmiar strumienia od ';

        if id_context_f <> nil then
          zts := zts + IntToStr( id_context_f.Binding.PeerPort )
        else//if id_context_f <> nil then
        if id_socket_handle_f <> nil then
          zts := zts + IntToStr( id_socket_handle_f.PeerPort );

        zts := zts + '.';

        Log_Memo.Lines.Add( zts );
      end;
      //---//try

      if    ( czy_udp_l )
        and ( strumieñ_rozmiar > 0 ) then
        begin

          SetLength( zt_id_bytes, strumieñ_rozmiar ); //???  IdUDPClient1.BufferSize // Najlepiej przesy³aæ informacjê wielkoœæ wysy³anego (do odebrania) strumienia.

          if czy_serwer_g then
            i := IdUDPServer1.ReceiveBuffer( zt_id_bytes ) // Nie oczekuje na dane (przechodzi dalej, nie zatrzymuje siê tutaj).
          else//if czy_serwer_g then
            i := IdUDPClient1.ReceiveBuffer( zt_id_bytes ); // Nie oczekuje na dane (przechodzi dalej, nie zatrzymuje siê tutaj).

        end;
      //---//if    ( czy_udp_l ) (...)


      //if    ( strumieñ_rozmiar > 0 )
      //  and (
      //           ( not czy_udp_l )
      //        or (
      //                 ( czy_udp_l )
      //             and ( i > 0 )
      //           )
      //      ) then
      if    (
                 ( not czy_udp_l )
              or (
                       ( czy_udp_l )
                   and ( i > 0 )
                 )
            ) then
        begin

          strumieñ_pamiêci_l := TMemoryStream.Create();


          if strumieñ_rozmiar > 0 then
            if not czy_udp_l then
              begin

                io_handler_f.ReadStream( strumieñ_pamiêci_l, strumieñ_rozmiar ); // Najlepiej przesy³aæ informacjê wielkoœæ wysy³anego (do odebrania) strumienia.

              end
            else//if not czy_udp_l then
              begin

                //SetLength( zt_id_bytes, strumieñ_rozmiar ); //???  IdUDPClient1.BufferSize // Najlepiej przesy³aæ informacjê wielkoœæ wysy³anego (do odebrania) strumienia.
                //
                //i := IdUDPClient1.ReceiveBuffer( zt_id_bytes ); // Nie oczekuje na dane (przechodzi dalej, nie zatrzymuje siê tutaj).

                if i > 0 then
                  IdGlobal.WriteTIdBytesToStream( strumieñ_pamiêci_l, zt_id_bytes );

              end;
            //---//if not czy_udp_l then


          strumieñ_pamiêci_l.Position := 0;

//          strumieñ_pamiêci_l.Read( rekord_r, strumieñ_rozmiar ); // Najlepiej przesy³aæ informacjê wielkoœæ wysy³anego (do odebrania) strumienia.
          //strumieñ_pamiêci_l.Read( rekord_r_t, strumieñ_rozmiar );
        {$endregion 'Odczytuje dane.'}

          {$region 'Przetwarza odczytane dane.'}
          if komenda_l = wieloosobowe__komenda__gra__rozpocznij_c then
            begin

              if czy_klient_g then
                begin

                  // Tylko klient odczytuje komunikat o rozpoczêciu gry.

                  czas_bezwzglêdny_g := 0;

                  if not IdUDPClient1.Connected then
                    begin

                      Gracz_Gotowoœæ_Tak_BitBtn.Enabled := false;
                      Gracz_Gotowoœæ_Nie_BitBtn.Enabled := false;

                      Statek_GroupBox.Enabled := false;

                      Statki_Zaprezentuj_Button.Enabled := false;
                      Statki_Zaprezentuj__Zwolnij_BitBtn.Enabled := false;


                      Elementy_Gry_Zwolnij();


                      IdUDPClient1.Host := Serwer_Adres_IP_Edit.Text;
                      IdUDPClient1.Port := Serwer_Port_SpinEdit.Value;
                      IdUDPClient1.ReceiveTimeout := 5; //???

                      IdUDPClient1.Connect();

                    end;
                  //---//if not IdUDPClient1.Connected then



                  udp_data_czas_sprawdzanie_po³¹czeñ_ostatnie_g := Now();
                  //udp_klienci_lista_g.Dodaj( '0', 0, Gracz_Identyfikator() ); // Przechowa dane o (próbie) swoim ostatnim kontakcie z serwerem.


                  Klient_IdUDP_Czyta_Timer.Enabled := true;
                  Klient_Wysy³a_Timer.Enabled := true;

                  klient_pierwsze_ustawienie_kamery_g := true;


                  SetLength( prymitywy_lista_t, 0 );


                  Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__udp__klient_po³¹czony_nadal_c, -99, '', true );


                  Radar_Wyczyœæ( true );

                end;
              //---//if czy_klient_g then

            end
          else//if komenda_l = wieloosobowe__komenda__gra__rozpocznij_c then
          if komenda_l = wieloosobowe__komenda__gra__zakoñcz_c then
            begin

              if czy_klient_g then
                begin

                  // Tylko klient odczytuje komunikat o zakoñczeniu gry.

                  Klient_IdUDP_Czyta_Timer.Enabled := false;
                  Klient_Wysy³a_Timer.Enabled := false;


                  if IdUDPClient1.Connected then
                    IdUDPClient1.Disconnect();


                  //udp_klienci_lista_g.Usuñ_Wszystkich();


                  Gracz_Gotowoœæ_BitBtnClick( Gracz_Gotowoœæ_Nie_BitBtn );

                  //Gracz_Gotowoœæ_Tak_BitBtn.Enabled := true;
                  //Gracz_Gotowoœæ_Nie_BitBtn.Enabled := true;

                  Statek_GroupBox.Enabled := true;

                  Statki_Zaprezentuj_Button.Enabled := true;
                  Statki_Zaprezentuj__Zwolnij_BitBtn.Enabled := true;


                  Elementy_Gry_Zwolnij();
                  Statek__Utwórz_BitBtnClick( nil );

                  if not ( Gra_GLCamera.Parent is TStatek ) then
                    Kamera_Prze³¹cz( kt_Statek ); // Ustawi kamerê na statku gracza.

                end;
              //---//if czy_klient_g then

            end
          else//if komenda_l = wieloosobowe__komenda__gra__zakoñcz_c then
          if komenda_l = wieloosobowe__komenda__gra__morze_wzburzenie_c then
            begin

              if czy_klient_g then
                begin

                  // Tylko klient odczytuje komunikat o wspó³czynniku prêdkoœci gry.

                  zts := Strumieñ_Napis_Odczytaj( strumieñ_pamiêci_l );

                  try
                    Morze_Wzburzenie_SpinEdit.Value := StrToInt( zts );
                  except
                    Log_Wypisz( 'Nieprawid³owa wartoœæ wspó³czynnika morze wzburzenie: ' + zts + '.', false );
                  end;
                  //---//try

                end;
              //---//if czy_klient_g then

            end
          else//if komenda_l = wieloosobowe__komenda__gra__morze_wzburzenie_c then
          if komenda_l = wieloosobowe__komenda__gra__statystyki_wyœlij_c then
            begin

              if czy_klient_g then
                begin

                  // Tylko klient odczytuje dane statystyk.

                  SetLength( gra_statystyki_r_t, 0 );

                  while strumieñ_pamiêci_l.Position < strumieñ_pamiêci_l.Size do
                    begin

                      i := Length( gra_statystyki_r_t );
                      SetLength( gra_statystyki_r_t, i + 1 );

                      strumieñ_pamiêci_l.Read( gra_statystyki_r_t[ i ], obiekty_wieloosobowe__gra_statystyki_r_rozmiar_c );

                    end;
                  //---//while strumieñ_pamiêci_l.Position < strumieñ_pamiêci_l.Size do


                  Gra_Statystyki_Wypisz();

                end
              else//if czy_klient_g then
              if czy_serwer_g then
                begin

                  // Tylko serwer wysy³a dane statystyk.

                  Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__gra__statystyki_wyœlij_c, -99, '' );

                end;
              //---//if czy_serwer_g then

            end
          else//if komenda_l = wieloosobowe__komenda__gra__statystyki_wyœlij_c then
          if komenda_l = wieloosobowe__komenda__gra__wspó³czynnik_prêdkoœci_c then
            begin

              if czy_klient_g then
                begin

                  // Tylko klient odczytuje komunikat o wspó³czynniku prêdkoœci gry, wzburzeniu morza.

                  zts := Strumieñ_Napis_Odczytaj( strumieñ_pamiêci_l );

                  try
                    Gra_Wspó³czynnik_Prêdkoœci_SpinEdit.Value := StrToInt( zts );
                  except
                    Log_Wypisz( 'Nieprawid³owa wartoœæ wspó³czynnika prêdkoœci gry: ' + zts + '.', false );
                  end;
                  //---//try

                end;
              //---//if czy_klient_g then

            end
          else//if komenda_l = wieloosobowe__komenda__gra__wspó³czynnik_prêdkoœci_c then
          if komenda_l = wieloosobowe__komenda__gracz_gotowoœæ_c then
            begin

              zts := Strumieñ_Napis_Odczytaj( strumieñ_pamiêci_l );

              if czy_serwer_g then
                begin

                  // Tylko serwer okreœla status gotowoœci.

                  i := -99;

                  if id_context_f <> nil then
                    i := id_context_f.Binding.PeerPort
                  else//if id_context_f <> nil then
                  if id_socket_handle_f <> nil then
                    i := id_socket_handle_f.PeerPort;

                  if i <> -99 then
                    begin

                      zt_tcp_klient_dane := tcp_klienci_lista_g.ZnajdŸ_Peer_Port( i );

                      if zt_tcp_klient_dane <> nil then
                        begin

                          if zts = 'Tak' then
                            begin

                              // Gracz zg³asza, ¿e jest gotowy.

                              strumieñ_pamiêci_l.Read(  j, SizeOf ( integer )  );
                              zt_tcp_klient_dane.id_grupa := j;

                              strumieñ_pamiêci_l.Read(  j, SizeOf ( integer )  );
                              zt_tcp_klient_dane.id_statek_schemat := j;

                              zts := Strumieñ_Napis_Odczytaj( strumieñ_pamiêci_l );


                              if tcp_klienci_lista_g.Nazwa_Niepowtarzalna( zt_tcp_klient_dane.peer_port_tcp, zts ) then
                                begin

                                  zt_tcp_klient_dane.nazwa := zts;
                                  zt_tcp_klient_dane.gotowy := true;

                                  Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__gracz_gotowoœæ_c, zt_tcp_klient_dane.peer_port_tcp, 'Tak' ); // Serwer potwierdza, ¿e gracz jest gotowy.

                                end
                              else//if tcp_klienci_lista_g.Nazwa_Niepowtarzalna( zt_tcp_klient_dane.peer_port_tcp, zts ) then
                                begin

                                  zt_tcp_klient_dane.gotowy := false;

                                  //Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__gracz_gotowoœæ_c, zt_tcp_klient_dane.peer_port_tcp, 'Nie' ); // Serwer wskazuje b³¹d gotowoœci gracza.
                                  Wieloosobowe__Tekst_Wyœlij( 'Nazwa gracza powinna byæ niepowtarzalna.', i );

                                end;
                              //---//if tcp_klienci_lista_g.Nazwa_Niepowtarzalna( zt_tcp_klient_dane.peer_port, zts ) then

                            end
                          else//if zts = 'Tak' then
                            begin

                              // Gracz zg³asza, ¿e nie jest gotowy.

                              zt_tcp_klient_dane.gotowy := false;

                            end;
                          //---//if zts = 'Tak' then

                          Gracze_Lista_Odœwie¿();

                          Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__gracz_lista_odœwie¿_c, -99, '' );

                        end;
                      //---//if zt_tcp_klient_dane <> nil then

                    end;
                  //---//if i <> -99 then

                end
              else//if czy_serwer_g then
              if czy_klient_g then
                begin

                  // Klient otrzymuje potwierdzenie statusu gotowoœci.

                  if zts = 'Tak' then
                    begin

                      // Status gotowoœci potwierdzony.

                      Gracz_Gotowoœæ_Nie_BitBtn.Enabled := true;
                      Gracz_Gotowoœæ_Tak_BitBtn.Enabled := false;

                      Gracz_Grupa_SpinEdit.Enabled := false;
                      Gracz_Nazwa_Edit.Enabled := false;
                      Statek_GroupBox.Enabled := false;

                    end;
                  //---//if zts = 'Tak' then

                end;
              //---//if czy_klient_g then

            end
          else//if komenda_l = wieloosobowe__komenda__gracz_gotowoœæ_c then
          if komenda_l = wieloosobowe__komenda__gracz_lista_odœwie¿_c then
            begin

              if czy_serwer_g then
                Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__gracz_lista_odœwie¿_c, -99, '' ) // Na zapytanie klienta serwer odsy³a aktualn¹ listê graczy.
              else//if czy_serwer_g then
              if czy_klient_g then
                begin

                  // Tylko klient odbiera listê graczy.

                  Mapa_Label.Caption := 'Mapa: ' + Strumieñ_Napis_Odczytaj( strumieñ_pamiêci_l ) + '.';
                  Statki_Pozycje_Pocz¹tkowe_Label.Caption := 'Pozycje pocz¹tkowe statków: ' + Strumieñ_Napis_Odczytaj( strumieñ_pamiêci_l ) + '.';


                  tcp_klienci_lista_g.Usuñ_Wszystkich();

                  while strumieñ_pamiêci_l.Position < strumieñ_pamiêci_l.Size do
                    begin

                      zt_tcp_klient_dane := TTCP_Klient_Dane.Create();


                      strumieñ_pamiêci_l.Read(  zt_tcp_klient_dane.identyfikator, SizeOf( integer )  );
                      strumieñ_pamiêci_l.Read(  zt_tcp_klient_dane.id_grupa, SizeOf( integer )  );
                      strumieñ_pamiêci_l.Read(  zt_tcp_klient_dane.id_statek_schemat, SizeOf( integer )  );
                      strumieñ_pamiêci_l.Read(  zt_tcp_klient_dane.peer_port_tcp, SizeOf( integer )  );
                      strumieñ_pamiêci_l.Read(  zt_tcp_klient_dane.peer_port_udp, SizeOf( integer )  );

                      strumieñ_pamiêci_l.Read(  zt_tcp_klient_dane.data_czas__d³¹czenia, SizeOf( TDateTime )  );
                      strumieñ_pamiêci_l.Read(  zt_tcp_klient_dane.data_czas__pod³¹czenia, SizeOf( TDateTime )  );
                      strumieñ_pamiêci_l.Read(  zt_tcp_klient_dane.data_czas__pod³¹czenia_ostatniego, SizeOf( TDateTime )  );
                      strumieñ_pamiêci_l.Read(  zt_tcp_klient_dane.data_czas__udp_kontakt, SizeOf( TDateTime )  );

                      strumieñ_pamiêci_l.Read(  zt_tcp_klient_dane.gotowy, SizeOf( boolean )  );
                      strumieñ_pamiêci_l.Read(  zt_tcp_klient_dane.od³¹czony, SizeOf( boolean )  );

                      strumieñ_pamiêci_l.Read( zt_tcp_klient_dane.nazwa, wieloosobowe_string__rozmiar_c );


                      tcp_klienci_lista_g.klienci_lista_list.Add( zt_tcp_klient_dane );

                    end;
                  //---//while strumieñ_pamiêci_l.Position < strumieñ_pamiêci_l.Size do


                  Gracze_Lista_Odœwie¿();

                end;
              //---//if czy_klient_g then

            end
          else//if komenda_l = wieloosobowe__komenda__gracz_lista_odœwie¿_c then
          if komenda_l = wieloosobowe__komenda__has³o__sprawdŸ_c then
            begin

              if czy_klient_g then
                begin

                  // Tylko klient czeka na potwierdzenie prawid³owoœci has³a.

                  zts := Strumieñ_Napis_Odczytaj( strumieñ_pamiêci_l );

                  if zts = 'Tak' then
                    begin

                      // Has³o prawid³owe.

                    end
                  else//if zts = 'Tak' then
                    Wieloosobowe__Od³¹cz_BitBtnClick( nil );

                end;
              //---//if czy_klient_g then

            end
          else//if komenda_l = wieloosobowe__komenda__has³o__sprawdŸ_c then
          if komenda_l = wieloosobowe__komenda__identyfikator__nadaj_c then
            begin

              if czy_serwer_g then
                begin

                  // Tylko serwer nadaje identyfikator.

                  i := -99;

                  if id_context_f <> nil then
                    i := id_context_f.Binding.PeerPort
                  else//if id_context_f <> nil then
                  if id_socket_handle_f <> nil then
                    i := id_socket_handle_f.PeerPort;

                  if i <> -99 then
                    begin

                      zts := Strumieñ_Napis_Odczytaj( strumieñ_pamiêci_l );

                      if zts = Has³o_Edit.Text then
                        begin

                          zt_tcp_klient_dane := tcp_klienci_lista_g.Dodaj_Aktualizuj( i, -99 );

                          if zt_tcp_klient_dane <> nil then
                            begin

                              j := zt_tcp_klient_dane.identyfikator;

                              Wieloosobowe__Strumieñ_Wyœlij(  wieloosobowe__komenda__identyfikator__zapamiêtaj_c, i, IntToStr( j )  );

                              Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__gracz_lista_odœwie¿_c, -99, '' );


                              Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__odbierz__statki_definicje_c, i, '' );

                            end
                          else//if zt_tcp_klient_dane <> nil then
                            Wieloosobowe__Tekst_Wyœlij( 'Nie uda³o siê nadaæ identyfikatora.', i );


                          Gracze_Lista_Odœwie¿();

                        end
                      else//if zts = Has³o_Edit.Text then
                        begin

                          Wieloosobowe__Tekst_Wyœlij( 'Nieprawid³owe has³o (n).', i ); // Je¿eli najpierw roz³¹czy to potem nie ma sensu wysy³aæ komunikatu.
                          Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__has³o__sprawdŸ_c, i, 'Nie' );

                        end;
                      //---//if zts = Has³o_Edit.Text then

                    end;
                  //---//if i <> -99 then

                end;
              //---//if czy_serwer_g then

            end
          else//if komenda_l = wieloosobowe__komenda__identyfikator__nadaj_c then
          if komenda_l = wieloosobowe__komenda__identyfikator__przypomnij_c then
            begin

              if czy_serwer_g then
                begin

                  // Tylko serwer obs³uguje wys³ane przypomnienia identyfikatorów.

                  i := -99;

                  if id_context_f <> nil then
                    i := id_context_f.Binding.PeerPort
                  else//if id_context_f <> nil then
                  if id_socket_handle_f <> nil then
                    i := id_socket_handle_f.PeerPort;

                  if i <> -99 then
                    begin

                      zts := Strumieñ_Napis_Odczytaj( strumieñ_pamiêci_l );

                      if zts = Has³o_Edit.Text then
                        begin

                          zts := Strumieñ_Napis_Odczytaj( strumieñ_pamiêci_l );

                          try
                            j := StrToInt( zts );

                            if tcp_klienci_lista_g.Dodaj_Aktualizuj( i, j ) = nil then
                              begin

                                Wieloosobowe__Tekst_Wyœlij( 'Wskazanego identyfikatora nie ma na liœcie ''' + zts + '''.', i );
                                Wieloosobowe__Tekst_Wyœlij( wieloosobowe__komenda__serwer_wy³¹cza_siê_c, i );

                              end;
                            //---//if tcp_klienci_lista_g.Dodaj_Aktualizuj( i, j ) = nil then

                          except
                            Wieloosobowe__Tekst_Wyœlij( 'Nie uda³o siê przypomnieæ identyfikatora.', i );
                            Wieloosobowe__Tekst_Wyœlij( 'Nieprawid³owe has³o (p1).', i ); // Je¿eli najpierw roz³¹czy to potem nie ma sensu wysy³aæ komunikatu.
                            Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__has³o__sprawdŸ_c, i, 'Nie' );
                          end;
                          //---//try

                          Gracze_Lista_Odœwie¿();

                          Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__gracz_lista_odœwie¿_c, -99, '' );

                        end
                      else//if zts = Has³o_Edit.Text then
                        begin

                          Wieloosobowe__Tekst_Wyœlij( 'Nieprawid³owe has³o (p2).', i ); // Je¿eli najpierw roz³¹czy to potem nie ma sensu wysy³aæ komunikatu.
                          Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__has³o__sprawdŸ_c, i, 'Nie' );

                        end;
                      //---//if zts = Has³o_Edit.Text then

                    end;
                  //---//if i <> -99 then

                end;
              //---//if czy_serwer_g then

            end
          else//if komenda_l = wieloosobowe__komenda__identyfikator__przypomnij_c then
          if komenda_l = wieloosobowe__komenda__identyfikator__zapamiêtaj_c then
            begin

              if czy_klient_g then
                begin

                  // Tylko serwer nadaje identyfikator.

                  Wieloosobowe_Identyfikator_Edit.Text := Strumieñ_Napis_Odczytaj( strumieñ_pamiêci_l );
                  Wieloosobowe_Identyfikator_Gra_Label.Caption := Wieloosobowe_Identyfikator_Edit.Text;

                end;
              //---//if czy_klient_g then

            end
          else//if komenda_l = wieloosobowe__komenda__identyfikator__zapamiêtaj_c then
          if komenda_l = wieloosobowe__komenda__odbierz__l¹d_definicja_c then
            begin

              if czy_klient_g then
                begin

                  // Tylko klient odczytuje dane o l¹dzie.

                  l¹d_definicja_g := Strumieñ_Napis_Odczytaj( strumieñ_pamiêci_l );

                  L¹d_Zwolnij();
                  L¹d_Utwórz( -99 );

                end;
              //---//if czy_klient_g then

            end
          else//if komenda_l = wieloosobowe__komenda__odbierz__l¹d_definicja_c then
          if komenda_l = wieloosobowe__komenda__odbierz__prymitywy_definicja_c then
            begin

              if czy_klient_g then
                begin

                  // Tylko klient odczytuje dane o prymitywach.

                  i := Length( prymitywy_lista_t );
                  SetLength( prymitywy_lista_t, i + 1 );

                  prymitywy_lista_t[ i ].plik_nazwa := Strumieñ_Napis_Odczytaj( strumieñ_pamiêci_l );
                  prymitywy_lista_t[ i ].treœæ := Strumieñ_Napis_Odczytaj( strumieñ_pamiêci_l );

                end;
              //---//if czy_klient_g then

            end
          else//if komenda_l = wieloosobowe__komenda__odbierz__prymitywy_definicja_c then
          if komenda_l = wieloosobowe__komenda__odbierz__rekord_amunicja_c then
            begin

              SetLength( wieloosobowe__amunicja_t, 0 );

              while strumieñ_pamiêci_l.Position < strumieñ_pamiêci_l.Size do
                begin

                  i := Length( wieloosobowe__amunicja_t );
                  SetLength( wieloosobowe__amunicja_t, i + 1 );

                  strumieñ_pamiêci_l.Read( wieloosobowe__amunicja_t[ i ], obiekty_wieloosobowe__amunicja_r__rozmiar_c );

                end;
              //---//while strumieñ_pamiêci_l.Position < strumieñ_pamiêci_l.Size do

            end
          else//if komenda_l = wieloosobowe__komenda__odbierz__rekord_amunicja_c then
          if komenda_l = wieloosobowe__komenda__odbierz__rekord_efekt_c then
            begin

              strumieñ_pamiêci_l.Read( wieloosobowe__efekt_r, obiekty_wieloosobowe__efekt_r__rozmiar_c );
              Wieloosobowe__Trafienia_Efekt_Utwórz( wieloosobowe__efekt_r );

              // Efekt wysy³any jako tabela.
              //SetLength( wieloosobowe__efekt_t, 0 );
              //
              //while strumieñ_pamiêci_l.Position < strumieñ_pamiêci_l.Size do
              //  begin
              //
              //    i := Length( wieloosobowe__efekt_t );
              //    SetLength( wieloosobowe__efekt_t, i + 1 );
              //
              //    strumieñ_pamiêci_l.Read( wieloosobowe__efekt_t[ i ], obiekty_wieloosobowe__efekt_r__rozmiar_c );
              //
              //  end;
              ////---//while strumieñ_pamiêci_l.Position < strumieñ_pamiêci_l.Size do
              //
              //Wieloosobowe__Trafienia_Efekt_Utwórz( wieloosobowe__efekt_t );
              //SetLength( wieloosobowe__efekt_t, 0 );

            end
          else//if komenda_l = wieloosobowe__komenda__odbierz__rekord_efekt_c then
          if komenda_l = wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c then
            begin

              strumieñ_pamiêci_l.Read( pokój_rozmów_r_l, pokój_rozmów_r__rozmiar_c );

              // Gdy bêd¹ napisy z dowoln¹ d³ugoœci¹.
              //SetLength( pokój_rozmów_r_l.wiadomoœæ, pokój_rozmów_r_l.wiadomoœæ__d³ugoœæ );
              //
              //if pokój_rozmów_r_l.wiadomoœæ__d³ugoœæ > 0 then
              //  strumieñ_pamiêci_l.ReadBuffer(
              //      Pointer( pokój_rozmów_r_l.wiadomoœæ )^, // value of first name
              //      char_rozmiar_c * pokój_rozmów_r_l.wiadomoœæ__d³ugoœæ
              //    );

              //Wieloosobowe__Log_Wypisz(   'P_R_o od: ' + IntToStr( pokój_rozmów_r_l.id_nadawca ) + ' do: ' + IntToStr( pokój_rozmów_r_l.id_odbiorca ) + ' opóŸnienie: ' + IntToStr(  SecondsBetween( Now(), pokój_rozmów_r_l.data_czas_wys³ania )  ) + ' wiadomoœæ : ' + pokój_rozmów_r_l.wiadomoœæ + '.'  ); //???

              if   ( czy_klient_g )
                or ( pokój_rozmów_r_l.odbiorca_rodzaj = pror_Wszyscy )
                or (
                         ( pokój_rozmów_r_l.odbiorca_rodzaj = pror_Grupa_Jedna )
                     and ( pokój_rozmów_r_l.id_odbiorca = Gracz_Grupa_SpinEdit.Value )
                   )
                or (
                         ( pokój_rozmów_r_l.odbiorca_rodzaj = pror_Gracz_Jeden )
                     and ( pokój_rozmów_r_l.id_odbiorca = Gracz_Identyfikator() )
                   ) then
                Pokój_Rozmów__Wyœwietl_Wiadomoœæ( pokój_rozmów_r_l );

              if czy_serwer_g then
                begin

                  // Przesy³a wiadomoœæ do klientów.

                  pokój_rozmów_r.id_nadawca := pokój_rozmów_r_l.id_nadawca;
                  pokój_rozmów_r.id_odbiorca := pokój_rozmów_r_l.id_odbiorca;
                  //pokój_rozmów_r.wiadomoœæ__d³ugoœæ := pokój_rozmów_r_l.wiadomoœæ__d³ugoœæ;
                  pokój_rozmów_r.odbiorca_rodzaj := pokój_rozmów_r_l.odbiorca_rodzaj;
                  pokój_rozmów_r.data_czas_wys³ania := pokój_rozmów_r_l.data_czas_wys³ania;
                  pokój_rozmów_r.wiadomoœæ := pokój_rozmów_r_l.wiadomoœæ;

                  if pokój_rozmów_r.odbiorca_rodzaj = pror_Wszyscy then
                    Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c, -99, '' )
                  else//if pokój_rozmów_r.odbiorca_rodzaj = pror_Wszyscy then
                    begin

                      for i := 0 to tcp_klienci_lista_g.klienci_lista_list.Count - 1 do
                        if   ( pokój_rozmów_r.id_nadawca = TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator ) // Odsy³a wiadomoœci do nadawcy.
                          or (
                                   ( pokój_rozmów_r.odbiorca_rodzaj = pror_Gracz_Jeden )
                               and ( pokój_rozmów_r.id_odbiorca = TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator )
                             )
                          or (
                                   ( pokój_rozmów_r.odbiorca_rodzaj = pror_Grupa_Jedna )
                               and ( pokój_rozmów_r.id_odbiorca = TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).id_grupa )
                             ) then
                          begin

                            Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c, TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).peer_port_tcp, '' );

                            if    ( pokój_rozmów_r.odbiorca_rodzaj = pror_Gracz_Jeden )
                              and ( pokój_rozmów_r.id_nadawca <> TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator ) then
                              Break;

                          end;
                        //---//if    ( pokój_rozmów_r.id_nadawca <> TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator ) (...)

                    end;
                  //---//if pokój_rozmów_r.odbiorca_rodzaj = pror_Wszyscy then

                end;
              //---//if czy_serwer_g then

            end
          else//if komenda_l = wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c then
          if komenda_l = wieloosobowe__komenda__odbierz__rekord_statki_c then
            begin

              {$region 'Zakomentowane - obs³ugiwane w taki sposób zg³asza b³êdy dostêpu - wieloosobowe__komenda__odbierz__rekord_statki_c.'}
              //Wieloosobowe_Statki_Rekord_Czyœæ();
              //
              //while strumieñ_pamiêci_l.Position < strumieñ_pamiêci_l.Size do
              //  begin
              //
              //    i := Length( wieloosobowe__statki_t );
              //    SetLength( wieloosobowe__statki_t, i + 1 );
              //
              //
              //    strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ], obiekty_wieloosobowe__statki_r__rozmiar_c );
              //
              //
              //    SetLength( wieloosobowe__statki_t[ i ].œruba_obrót_k¹t, wieloosobowe__statki_t[ i ].œruba_obrót_k¹t__d³ugoœæ );
              //
              //    for j := 0 to Length( wieloosobowe__statki_t[ i ].œruba_obrót_k¹t ) - 1 do
              //      strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].œruba_obrót_k¹t[ j ], SizeOf( real )  );
              //
              //
              //    SetLength( wieloosobowe__statki_t[ i ].artyleria_t, wieloosobowe__statki_t[ i ].artyleria_t__d³ugoœæ_tabeli );
              //
              //    for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t ) - 1 do
              //      begin
              //
              //        strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ], obiekty_wieloosobowe__dzia³o_r__rozmiar_c );
              //
              //        SetLength( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t, wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t__d³ugoœæ_tabeli );
              //
              //        for k := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
              //          strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );
              //
              //      end;
              //    //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t ) - 1 do
              //
              //
              //    SetLength( wieloosobowe__statki_t[ i ].dzia³a_t, wieloosobowe__statki_t[ i ].dzia³a_t__d³ugoœæ_tabeli );
              //
              //    for j := 0 to Length( wieloosobowe__statki_t[ i ].dzia³a_t ) - 1 do
              //      begin
              //
              //        strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].dzia³a_t[ j ], obiekty_wieloosobowe__dzia³o_r__rozmiar_c );
              //
              //        SetLength( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t, wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t__d³ugoœæ_tabeli );
              //
              //        for k := 0 to Length( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
              //          strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );
              //
              //      end;
              //    //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].dzia³a_t ) - 1 do
              //
              //
              //    SetLength( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t, wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t__d³ugoœæ_tabeli );
              //
              //    for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do
              //      begin
              //
              //        strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ], obiekty_wieloosobowe__dzia³o_r__rozmiar_c );
              //
              //        SetLength( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t, wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t__d³ugoœæ_tabeli );
              //
              //        for k := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
              //          strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );
              //
              //      end;
              //    //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do
              //
              //
              //
              //    SetLength( wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t, wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t__d³ugoœæ_tabeli );
              //
              //    for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t ) - 1 do
              //      begin
              //
              //        strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t[ j ], obiekty_wieloosobowe__dzia³o_r__rozmiar_c );
              //
              //
              //        SetLength( wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t, wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t__d³ugoœæ_tabeli );
              //
              //        for k := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
              //          strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );
              //
              //      end;
              //    //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t ) - 1 do
              //
              //
              //    SetLength( wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t, wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t__d³ugoœæ_tabeli );
              //
              //    for j := 0 to Length( wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t ) - 1 do
              //      begin
              //
              //        strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t[ j ], obiekty_wieloosobowe__dzia³o_r__rozmiar_c );
              //
              //
              //        SetLength( wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t, wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t__d³ugoœæ_tabeli );
              //
              //        for k := 0 to Length( wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
              //          strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );
              //
              //      end;
              //    //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t ) - 1 do
              //
              //
              //    SetLength( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t, wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t__d³ugoœæ_tabeli );
              //
              //    for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t ) - 1 do
              //      begin
              //
              //        strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ], obiekty_wieloosobowe__dzia³o_r__rozmiar_c );
              //
              //
              //        SetLength( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t, wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t__d³ugoœæ_tabeli );
              //
              //        for k := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
              //          strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );
              //
              //      end;
              //    //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t ) - 1 do
              //
              //  end;
              ////---//while strumieñ_pamiêci_l.Position < strumieñ_pamiêci_l.Size do
              {$endregion 'Zakomentowane - obs³ugiwane w taki sposób zg³asza b³êdy dostêpu - wieloosobowe__komenda__odbierz__rekord_statki_c.'}


              {$region 'wieloosobowe__komenda__odbierz__rekord_statki_c.'}
              Wieloosobowe_Statki_Rekord_Czyœæ();

              while strumieñ_pamiêci_l.Position < strumieñ_pamiêci_l.Size do
                begin

                  i := Length( wieloosobowe__statki_t );
                  SetLength( wieloosobowe__statki_t, i + 1 );


                  //strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ], obiekty_wieloosobowe__statki_r__rozmiar_c );

                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].id_grupa, SizeOf( integer )  );
                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].id_statek, SizeOf( integer )  );
                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].id_statek_schemat, SizeOf( integer )  );
                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].artyleria_t__d³ugoœæ_tabeli, SizeOf( integer )  );
                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].dzia³a_t__d³ugoœæ_tabeli, SizeOf( integer )  );
                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t__d³ugoœæ_tabeli, SizeOf( integer )  );
                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].artyleria_wygl¹d_t__d³ugoœæ_tabeli, SizeOf( integer )  );
                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].dzia³a_wygl¹d_t__d³ugoœæ_tabeli, SizeOf( integer )  );
                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_wygl¹d_t__d³ugoœæ_tabeli, SizeOf( integer )  );
                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].œruba_obrót_k¹t__d³ugoœæ, SizeOf( integer )  );

                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].falowanie_bok_skrêt, SizeOf( real )  );
                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].prêdkoœæ_procent, SizeOf( real )  );
                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].prêdkoœæ_zadana_procent, SizeOf( real )  );
                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].punkty_¿ycia, SizeOf( real )  );
                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].punkty_¿ycia_maksymalne, SizeOf( real )  );
                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].punkty_¿ycia_procent_zosta³o, SizeOf( real )  );
                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].skrêt_procent, SizeOf( real )  );
                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].skrêt_zadany_procent, SizeOf( real )  );
                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].ster_k¹t, SizeOf( real )  );
                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].toniêcie__przechylenie__lewo_prawo, SizeOf( real )  );
                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].toniêcie__przechylenie__przód_ty³, SizeOf( real )  );

                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].czy_wszystkie_lufy, SizeOf( boolean )  );
                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].obracaj_dzia³a, SizeOf( boolean )  );
                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].podnoœ_lufy, SizeOf( boolean )  );
                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].przeliczone, SizeOf( boolean )  );

                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].gracz__nazwa, SizeOf( TWieloosobowe_String )  );

                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].cel_wspó³rzêdne, SizeOf( TWieloosobowe__Wektor_4 )  );
                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].kierunek, SizeOf( TWieloosobowe__Wektor_4 )  );
                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].pozycja, SizeOf( TWieloosobowe__Wektor_4 )  );

                  strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].amunicja_rodzaj, SizeOf( TAmunicja_Rodzaj )  );


                  SetLength( wieloosobowe__statki_t[ i ].œruba_obrót_k¹t, wieloosobowe__statki_t[ i ].œruba_obrót_k¹t__d³ugoœæ );

                  for j := 0 to Length( wieloosobowe__statki_t[ i ].œruba_obrót_k¹t ) - 1 do
                    strumieñ_pamiêci_l.Read(  wieloosobowe__statki_t[ i ].œruba_obrót_k¹t[ j ], SizeOf( real )  );


                  SetLength( wieloosobowe__statki_t[ i ].artyleria_t, wieloosobowe__statki_t[ i ].artyleria_t__d³ugoœæ_tabeli );

                  for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t ) - 1 do
                    begin

                      //strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ], obiekty_wieloosobowe__dzia³o_r__rozmiar_c );

                      strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].czy_lot_parabol¹, SizeOf( boolean )  );
                      strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obrót_k¹t, SizeOf( real )  );
                      strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].celownik_linia__podniesienie_k¹t, SizeOf( real )  );
                      strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].celownik_linia__szerokoœæ, SizeOf( single )  );
                      strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].celownik_linia__wzór, SizeOf( word )  );
                      strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].amunicja_iloœæ, SizeOf( integer )  );
                      strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t__d³ugoœæ_tabeli, SizeOf( integer )  );
                      strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].celownik_linia__kolor, SizeOf( TWieloosobowe__Wektor_4 )  );

                      SetLength( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t, wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t__d³ugoœæ_tabeli );

                      for k := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
                        begin

                          //strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );

                          strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_k¹t, SizeOf( real )  );
                          strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z, SizeOf( real )  );
                          strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].strza³_gotowoœæ, SizeOf( boolean )  );
                          strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__kolor, SizeOf( TWieloosobowe__Wektor_4 )  );
                          strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__pozycja, SizeOf( TWieloosobowe__Wektor_4 )  );

                        end;
                      //---//for k := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do

                    end;
                  //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].artyleria_t ) - 1 do


                  SetLength( wieloosobowe__statki_t[ i ].dzia³a_t, wieloosobowe__statki_t[ i ].dzia³a_t__d³ugoœæ_tabeli );

                  for j := 0 to Length( wieloosobowe__statki_t[ i ].dzia³a_t ) - 1 do
                    begin

                      //strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].dzia³a_t[ j ], obiekty_wieloosobowe__dzia³o_r__rozmiar_c );

                      strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obrót_k¹t, SizeOf( real )  );
                      strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].celownik_linia__podniesienie_k¹t, SizeOf( real )  );
                      strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].celownik_linia__szerokoœæ, SizeOf( single )  );
                      strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].celownik_linia__wzór, SizeOf( word )  );
                      strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].amunicja_iloœæ, SizeOf( integer )  );
                      strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t__d³ugoœæ_tabeli, SizeOf( integer )  );
                      strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].celownik_linia__kolor, SizeOf( TWieloosobowe__Wektor_4 )  );

                      SetLength( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t, wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t__d³ugoœæ_tabeli );

                      for k := 0 to Length( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
                        begin

                          //strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );

                          strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_k¹t, SizeOf( real )  );
                          strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z, SizeOf( real )  );
                          strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].strza³_gotowoœæ, SizeOf( boolean )  );
                          strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__kolor, SizeOf( TWieloosobowe__Wektor_4 )  );
                          strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__pozycja, SizeOf( TWieloosobowe__Wektor_4 )  );

                        end;
                      //---//for k := 0 to Length( wieloosobowe__statki_t[ i ].dzia³a_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do

                    end;
                  //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].dzia³a_t ) - 1 do


                  SetLength( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t, wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t__d³ugoœæ_tabeli );

                  for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do
                    begin

                      //strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ], obiekty_wieloosobowe__dzia³o_r__rozmiar_c );

                      strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obrót_k¹t, SizeOf( real )  );
                      strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia__podniesienie_k¹t, SizeOf( real )  );
                      strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia__szerokoœæ, SizeOf( single )  );
                      strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia__wzór, SizeOf( word )  );
                      strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].amunicja_iloœæ, SizeOf( integer )  );
                      strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t__d³ugoœæ_tabeli, SizeOf( integer )  );
                      strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].celownik_linia__kolor, SizeOf( TWieloosobowe__Wektor_4 )  );

                      SetLength( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t, wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t__d³ugoœæ_tabeli );

                      for k := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do
                        begin

                          //strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ], obiekty_wieloosobowe__lufa_r__rozmiar_c );

                          strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_podniesienie_k¹t, SizeOf( real )  );
                          strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].lufa_pozycja_z, SizeOf( real )  );
                          strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].strza³_gotowoœæ, SizeOf( boolean )  );
                          strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__kolor, SizeOf( TWieloosobowe__Wektor_4 )  );
                          strumieñ_pamiêci_l.Read( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t[ k ].prze³adowanie_wskaŸnik__pozycja, SizeOf( TWieloosobowe__Wektor_4 )  );

                        end;
                      //---//for k := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t[ j ].obiekty_wieloosobowe_lufa_r_t ) - 1 do

                    end;
                  //---//for j := 0 to Length( wieloosobowe__statki_t[ i ].torpedy_wyrzutnie_t ) - 1 do


                  wieloosobowe__statki_t[ i ].radar_id_statki_w_zasiêgu := Strumieñ_Napis_Odczytaj( strumieñ_pamiêci_l );
                  wieloosobowe__statki_t[ i ].radio_id_statki_w_zasiêgu := Strumieñ_Napis_Odczytaj( strumieñ_pamiêci_l );

                end;
              //---//while strumieñ_pamiêci_l.Position < strumieñ_pamiêci_l.Size do
              {$endregion 'wieloosobowe__komenda__odbierz__rekord_statki_c.'}

            end
          else//if komenda_l = wieloosobowe__komenda__odbierz__rekord_statki_c then
          if komenda_l = wieloosobowe__komenda__odbierz__statki_definicje_c then
            begin

              SetLength( statki_lista_t, 0 );

              if czy_klient_g then
                begin

                  // Tylko klient odczytuje dane o statkach.

                  while strumieñ_pamiêci_l.Position < strumieñ_pamiêci_l.Size do
                    begin

                      i := Length( statki_lista_t );
                      SetLength( statki_lista_t, i + 1 );

                      statki_lista_t[ i ].id := Strumieñ_Napis_Odczytaj( strumieñ_pamiêci_l );
                      statki_lista_t[ i ].nazwa := Strumieñ_Napis_Odczytaj( strumieñ_pamiêci_l );
                      statki_lista_t[ i ].opis := Strumieñ_Napis_Odczytaj( strumieñ_pamiêci_l );
                      statki_lista_t[ i ].plik_nazwa := Strumieñ_Napis_Odczytaj( strumieñ_pamiêci_l );
                      statki_lista_t[ i ].treœæ := Strumieñ_Napis_Odczytaj( strumieñ_pamiêci_l );

                    end;
                  //---//while strumieñ_pamiêci_l.Position < strumieñ_pamiêci_l.Size do


                  j := Statek_ComboBox.ItemIndex;
                  Statek_ComboBox.Items.Clear();

                  for i := 0 to Length( statki_lista_t ) - 1 do
                    if Trim( statki_lista_t[ i ].nazwa ) <> '' then
                      Statek_ComboBox.Items.Add( statki_lista_t[ i ].nazwa )
                    else//if Trim( statki_lista_t[ i ].nazwa ) <> '' then
                      Statek_ComboBox.Items.Add( statki_lista_t[ i ].plik_nazwa );


                  Statki_Zwolnij();

                  Statek_ComboBox.ItemIndex := j;

                  if    ( Statek_ComboBox.ItemIndex < 0 )
                    and (  Statek_ComboBox.Items.Count >= 1  ) then
                    Statek_ComboBox.ItemIndex := 0;

                  Statek_ComboBoxChange( nil );

                  Statek__Utwórz_BitBtnClick( nil ); //??? jakiœ statek chyba musi byæ utworzony bo zg³asza b³êdy do sprawdzenia.

                end;
              //---//if czy_klient_g then

            end
          else//if komenda_l = wieloosobowe__komenda__odbierz__statki_definicje_c then
          if komenda_l = wieloosobowe__komenda__pauza_c then
            begin

              if czy_klient_g then
                begin

                  // Tylko klient odczytuje komunikat o pauzie.

                  Pauza(  Strumieñ_Napis_Odczytaj( strumieñ_pamiêci_l ) = 'Tak'  );

                end;
              //---//if czy_klient_g then

            end
          else//if komenda_l = wieloosobowe__komenda__pauza_c then
          if komenda_l = wieloosobowe__komenda__serwer_wy³¹cza_siê_c then
            begin

              Result := wieloosobowe__komenda__serwer_wy³¹cza_siê_c;
              strumieñ_pamiêci_l.Read(  zts, SizeOf ( wieloosobowe__komenda__serwer_wy³¹cza_siê_c )  );

            end
          else//if komenda_l = wieloosobowe__komenda__serwer_wy³¹cza_siê_c then
          if komenda_l = wieloosobowe__komenda__statek__klawisze_obs³uga_c then
            begin

              if czy_serwer_g then
                begin

                  // Tylko serwer odbiera informacje o obs³udze klawiszy od klientów.

                  strumieñ_pamiêci_l.Read( wieloosobowe__statek_klawisze_obs³uga_r_l, obiekty_wieloosobowe__statek_klawisze_obs³uga_r__rozmiar_c );

                  // T³umaczy konfiguracjê klawiatury klienta na konfiguracjê klawiatury serwera.
                  j := 1;

                  if Trim( wieloosobowe__statek_klawisze_obs³uga_r_l.polecenie_nazwa ) <> '' then
                    begin

                      for i := 0 to Length( klawiatura_konfiguracja_r_t ) - 1 do
                        if wieloosobowe__statek_klawisze_obs³uga_r_l.polecenie_nazwa = klawiatura_konfiguracja_r_t[ i ].polecenie_nazwa then
                          begin

                            j := 0;


                            if klawiatura_konfiguracja_r_t[ i ].czy_mysz then
                              begin

                                wieloosobowe__statek_klawisze_obs³uga_r_l.klawisz := 0;
                                wieloosobowe__statek_klawisze_obs³uga_r_l.mysz_przycisk := klawiatura_konfiguracja_r_t[ i ].klawisz;

                              end
                            else//if klawiatura_konfiguracja_r_t[ i ].czy_mysz then
                              begin

                                wieloosobowe__statek_klawisze_obs³uga_r_l.klawisz := klawiatura_konfiguracja_r_t[ i ].klawisz;
                                wieloosobowe__statek_klawisze_obs³uga_r_l.mysz_przycisk := -1;

                              end;
                            //---//if klawiatura_konfiguracja_r_t[ i ].czy_mysz then


                            wieloosobowe__statek_klawisze_obs³uga_r_l.shift := [];

                            if klawiatura_konfiguracja_r_t[ i ].plus_alt then
                              wieloosobowe__statek_klawisze_obs³uga_r_l.shift := wieloosobowe__statek_klawisze_obs³uga_r_l.shift + [ ssAlt ];

                            if klawiatura_konfiguracja_r_t[ i ].plus_ctrl then
                              wieloosobowe__statek_klawisze_obs³uga_r_l.shift := wieloosobowe__statek_klawisze_obs³uga_r_l.shift + [ ssCtrl ];

                            if klawiatura_konfiguracja_r_t[ i ].plus_shift then
                              wieloosobowe__statek_klawisze_obs³uga_r_l.shift := wieloosobowe__statek_klawisze_obs³uga_r_l.shift + [ ssShift ];

                            Break;

                          end;
                      //---//for i := 0 to Length( klawiatura_konfiguracja_r_t ) - 1 do

                    end;
                  //---//if Trim( wieloosobowe__statek_klawisze_obs³uga_r_l.polecenie_nazwa ) <> '' then
                  //---// T³umaczy konfiguracjê klawiatury klienta na konfiguracjê klawiatury serwera.


                  if j = 0 then // Je¿eli kombinacja klawiszy jest nierozpoznana nic nie zmienia.
                    Statek_Klawisze_Obs³uga
                      (
                        wieloosobowe__statek_klawisze_obs³uga_r_l.id_statek, wieloosobowe__statek_klawisze_obs³uga_r_l.klawisz, wieloosobowe__statek_klawisze_obs³uga_r_l.mysz_przycisk, wieloosobowe__statek_klawisze_obs³uga_r_l.shift,
                        Amunicja_Rodzaj_Zbiór_Zwróæ( false, wieloosobowe__statek_klawisze_obs³uga_r_l.ar_artyleria, wieloosobowe__statek_klawisze_obs³uga_r_l.ar_pocisk, wieloosobowe__statek_klawisze_obs³uga_r_l.ar_torpeda, wieloosobowe__statek_klawisze_obs³uga_r_l.ar_wszystkie ),
                        true
                      );

                  Statek_Klient_Cel_Ustaw( wieloosobowe__statek_klawisze_obs³uga_r_l.id_statek, wieloosobowe__statek_klawisze_obs³uga_r_l.cel_wspó³rzêdne );

                end;
              //---//if czy_serwer_g then

            end
          else//if komenda_l = wieloosobowe__komenda__statek__klawisze_obs³uga_c then
          if komenda_l = wieloosobowe__komenda__statek__przywróæ_do_gry_c then
            begin

              strumieñ_pamiêci_l.Read( wieloosobowe__statek_przywróæ_do_gry__id_statek_g, SizeOf( wieloosobowe__statek_przywróæ_do_gry__id_statek_g )  );
              Statek_Przywróæ_Do_Gry( wieloosobowe__statek_przywróæ_do_gry__id_statek_g );
              wieloosobowe__statek_przywróæ_do_gry__id_statek_g := -99;

            end
          else//if komenda_l = wieloosobowe__komenda__statek__przywróæ_do_gry_c then
          if komenda_l = wieloosobowe__komenda__udp__klient_po³¹czony_nadal_c then
            begin

              if czy_serwer_g then
                begin

                  // Tylko serwer odczytuje aktywnoœæ pod³¹czenia klientów.

                  if czy_udp_l then
                    begin

                      // Sprawdza czy klient UDP przys³a³ dane zgodne z klientem TCP i czy znacznik czasu wysy³ki nie jest za stary, zapamiêtuje peer port klienta  UDP.

                      zts := Strumieñ_Napis_Odczytaj( strumieñ_pamiêci_l );

                      i := Pos( ';', zts );
                      j := -99;

                      if i > 1 then
                        try
                          j := StrToInt(  Copy( zts, 1, i - 1 )  ); // TCP peer_port.
                        except
                        end;
                        //---//try

                      if j <> -99 then
                        begin

                          Delete( zts, 1, i );

                          zt_tcp_klient_dane := tcp_klienci_lista_g.ZnajdŸ_Peer_Port( j );

                          if zt_tcp_klient_dane <> nil then
                            begin

                              i := Pos( ';', zts );
                              j := -1;

                              if i > 1 then
                                try
                                  j := StrToInt(  Copy( zts, 1, i - 1 )  ); // Identyfikator gracza.
                                except
                                end;
                                //---//try


                              if    ( j <> -1 )
                                and ( zt_tcp_klient_dane.identyfikator = j ) then
                                begin

                                  Delete( zts, 1, i );


                                  i := Pos( ';', zts );
                                  ztdu := -1;

                                  if i > 1 then
                                    try
                                      ztdu := StrToFloat(  Copy( zts, 1, i - 1 )  ); // Znacznik czasu.
                                    except
                                    end;
                                    //---//try

                                  if SecondsBetween( Now(), ztdu ) <= udp_klient_po³¹czenie_potwierdzanie_sekund_c * 2 then
                                    begin

                                      zt_tcp_klient_dane.peer_port_udp := id_socket_handle_f.PeerPort;
                                      zt_tcp_klient_dane.data_czas__udp_kontakt := Now();
                                      udp_klienci_lista_g.Dodaj( id_socket_handle_f.PeerIP, id_socket_handle_f.PeerPort, zt_tcp_klient_dane.identyfikator );

                                      //udp_klienci_lista_g.Usuñ_Przeterminowanych();
                                      //udp_data_czas_sprawdzanie_po³¹czeñ_ostatnie_g := Now();

                                    end;
                                  //---//if SecondsBetween( Now(), ztdu ) <= udp_klient_po³¹czenie_potwierdzanie_sekund_c * 2 then

                                end;
                              //---//if    ( j <> -1 ) (...)

                            end;
                          //---//if zt_tcp_klient_dane <> nil then

                        end;
                      //---//if j <> -99 then

                    end;
                  //---//if czy_udp_l then

                end;
              //---//if czy_serwer_g then

            end
          else//if komenda_l = wieloosobowe__komenda__udp__klient_po³¹czony_nadal_c then
          if komenda_l = wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_r_c then
            begin

              strumieñ_pamiêci_l.Read( komunikacja_rekord_testowy_r, komunikacja_rekord_testowy_r__rozmiar_c );
              Komunikacja_Rekord_Testowy_Obs³uga();

            end
          else//if komenda_l = wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_r_c then
          if komenda_l = wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_2_r_c then
            begin

              strumieñ_pamiêci_l.Read(  komunikacja_rekord_testowy_2_r_l.liczba_ca³kowita, SizeOf( integer )  );
              strumieñ_pamiêci_l.Read(  komunikacja_rekord_testowy_2_r_l.liczba_rzeczywista, SizeOf( real )  );
              strumieñ_pamiêci_l.Read(  komunikacja_rekord_testowy_2_r_l.data_czas, SizeOf( TDateTime )  );

              //strumieñ_pamiêci_l.Read( komunikacja_rekord_testowy_2_r_l, komunikacja_rekord_testowy_2_r__rozmiar_c ); // Tak nie dzia³a.

              if komunikacja_rekord_testowy_2_r_l.liczba_ca³kowita > 0 then
                begin

                  SetLength( komunikacja_rekord_testowy_2_r_l.napis, komunikacja_rekord_testowy_2_r_l.liczba_ca³kowita );

                  strumieñ_pamiêci_l.ReadBuffer(
                      Pointer( komunikacja_rekord_testowy_2_r_l.napis )^,
                      char_rozmiar_c * komunikacja_rekord_testowy_2_r_l.liczba_ca³kowita
                    );

                end;
              //---//if komunikacja_rekord_testowy_2_r_l.liczba_ca³kowita > 0 then

              Wieloosobowe__Log_Wypisz(   'RT o ' + IntToStr( komunikacja_rekord_testowy_2_r_l.liczba_ca³kowita ) + ' ' + ': ' + komunikacja_rekord_testowy_2_r_l.napis + '.'  ); //???

            end;
          //else//if komenda_l = wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_2_r_c then
          //  ;


          FreeAndNil( strumieñ_pamiêci_l );


          if komenda_l = wieloosobowe__komenda__odbierz__rekord_amunicja_c then
            Wieloosobowe_Amunicja_Parametry_Ustaw()
          else//if komenda_l = wieloosobowe__komenda__odbierz__rekord_amunicja_c then
          if komenda_l = wieloosobowe__komenda__odbierz__rekord_statki_c then
            Wieloosobowe_Statki_Parametry_Ustaw();
          {$endregion 'Przetwarza odczytane dane.'}

        end
      else//if    ( strumieñ_rozmiar > 0 ) (...)
        begin

          if komenda_l = wieloosobowe__komenda__odbierz__rekord_amunicja_c then
            begin

              // Je¿eli nie ma ju¿ amunicji na scenie to przychodzi pusta informacja (komenda i pusty strumieñ wielkoœæ równa 0)
              // Klienci usun¹ u siebie pozosta³¹ widoczn¹ amunicjê.

              SetLength( wieloosobowe__amunicja_t, 0 );
              Wieloosobowe_Amunicja_Parametry_Ustaw();

            end;
          //---//if komenda_l = wieloosobowe__komenda__odbierz__rekord_amunicja_c then

        end;
      //---//
      //---//if    ( strumieñ_rozmiar > 0 ) (...)

    end
  else//if   ( komenda_l = wieloosobowe__komenda__odbierz__rekord_amunicja_c ) (...)
    Result := komenda_l;

end;//---//Funkcja Wieloosobowe__Odczytaj().

//Funkcja Wieloosobowe__Trafienia_Efekt_Utwórz().
procedure TStatki_Form.Wieloosobowe__Trafienia_Efekt_Utwórz( obiekty_wieloosobowe__efekt_r_f : TObiekty_Wieloosobowe__Efekt_r );
var
  i : integer;
  zt_gl_base_scene_object : TGLBaseSceneObject;
begin

  if obiekty_wieloosobowe__efekt_r_f.id_statek = -1 then // Scena.
    zt_gl_base_scene_object := Gra_Obiekty_GLDummyCube
  else//if obiekty_wieloosobowe__efekt_r_f.id_statek = -1 then
    begin

      zt_gl_base_scene_object := nil;

      for i := 0 to Length( statki_t ) - 1 do
        if    ( statki_t[ i ] <> nil )
          and ( statki_t[ i ].id_statek = obiekty_wieloosobowe__efekt_r_f.id_statek ) then
          begin

            zt_gl_base_scene_object := statki_t[ i ];
            Break;

          end;
        //---//if    ( statki_t[ i ] <> nil ) (...)

    end;
  //---//if obiekty_wieloosobowe__efekt_r_f.id_statek = -1 then


  if wieloosobowe_amunicja_efekt_g <> nil then
    begin

      wieloosobowe_amunicja_efekt_g.amunicja_rodzaj := obiekty_wieloosobowe__efekt_r_f.amunicja_rodzaj;

    end;
  //---//if wieloosobowe_amunicja_efekt_g <> nil then


  Trafienia_Efekt_Utwórz_Jeden( zt_gl_base_scene_object, obiekty_wieloosobowe__efekt_r_f.efekt_rodzaj, obiekty_wieloosobowe__efekt_r_f.pozycja.X, obiekty_wieloosobowe__efekt_r_f.pozycja.Y, obiekty_wieloosobowe__efekt_r_f.pozycja.Z, wieloosobowe_amunicja_efekt_g, obiekty_wieloosobowe__efekt_r_f.czas_trwania, obiekty_wieloosobowe__efekt_r_f.czas_trwania_efekt_dodatkowy );

end;//---//Funkcja Wieloosobowe__Trafienia_Efekt_Utwórz().

//Funkcja Wieloosobowe__Trafienia_Efekt_Utwórz().
procedure TStatki_Form.Wieloosobowe__Trafienia_Efekt_Utwórz( obiekty_wieloosobowe__efekt_t_f : array of TObiekty_Wieloosobowe__Efekt_r );
var
  i,
  j
    : integer;
  zt_gl_base_scene_object : TGLBaseSceneObject;
begin

  for i := 0 to Length( wieloosobowe__efekt_t ) - 1 do
    begin

      if obiekty_wieloosobowe__efekt_t_f[ i ].id_statek = -1 then // Scena.
        zt_gl_base_scene_object := Gra_Obiekty_GLDummyCube
      else//if obiekty_wieloosobowe__efekt_t_f[ i ].id_statek = -1 then
        begin

          zt_gl_base_scene_object := nil;

          for j := 0 to Length( statki_t ) - 1 do
            if    ( statki_t[ j ] <> nil )
              and ( statki_t[ j ].id_statek = obiekty_wieloosobowe__efekt_t_f[ i ].id_statek ) then
              begin

                zt_gl_base_scene_object := statki_t[ j ];
                Break;

              end;
            //---//if    ( statki_t[ j ] <> nil ) (...)

        end;
      //---//if obiekty_wieloosobowe__efekt_t_f[ i ].id_statek = -1 then


      if wieloosobowe_amunicja_efekt_g <> nil then
        begin

          wieloosobowe_amunicja_efekt_g.amunicja_rodzaj := obiekty_wieloosobowe__efekt_t_f[ i ].amunicja_rodzaj;

        end;
      //---//if wieloosobowe_amunicja_efekt_g <> nil then


      Trafienia_Efekt_Utwórz_Jeden( zt_gl_base_scene_object, obiekty_wieloosobowe__efekt_t_f[ i ].efekt_rodzaj, obiekty_wieloosobowe__efekt_t_f[ i ].pozycja.X, obiekty_wieloosobowe__efekt_t_f[ i ].pozycja.Y, obiekty_wieloosobowe__efekt_t_f[ i ].pozycja.Z, wieloosobowe_amunicja_efekt_g, obiekty_wieloosobowe__efekt_t_f[ i ].czas_trwania, obiekty_wieloosobowe__efekt_t_f[ i ].czas_trwania_efekt_dodatkowy );

    end;
  //---//for i := 0 to Length( wieloosobowe__efekt_t ) - 1 do

end;//---//Funkcja Wieloosobowe__Trafienia_Efekt_Utwórz().

//Funkcja Wieloosobowe__Log_Wypisz().
procedure TStatki_Form.Wieloosobowe__Log_Wypisz( const napis_f : string; const wyró¿nij_f : boolean = false );
var
  wieloosobowe_powiadomienie_l : TWieloosobowe_Powiadomienie;
begin

  wieloosobowe_powiadomienie_l := TWieloosobowe_Powiadomienie.Create();
  wieloosobowe_powiadomienie_l.powiadomienie_treœæ := napis_f;
  wieloosobowe_powiadomienie_l.wyró¿nij := wyró¿nij_f;
  wieloosobowe_powiadomienie_l.Notify();

  // Bez Free().

end;//---//Funkcja Wieloosobowe__Log_Wypisz().

//Funkcja Gracz_Identyfikator().
function TStatki_Form.Gracz_Identyfikator() : integer;
begin

  //
  // Funkcja zwraca identyfikator gracza.
  //
  // Zwraca identyfikator gracza lub -9999 gdy brak identyfikatora.
  //

  try
    Result := StrToInt( Wieloosobowe_Identyfikator_Edit.Text );
  except
    Result := -9999;
  end;
  //---//try

end;//---//Funkcja Gracz_Identyfikator().

//Funkcja Gracze_Lista_Odœwie¿().
procedure TStatki_Form.Gracze_Lista_Odœwie¿();
var
  i,
  j,
  kolumna_kopia,
  wiersz_kopia
    : integer;
  zts : string;
  zt_pokój_rozmów__wyœlij_do__odbiorca_rodzaj : TPokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj;
begin

  kolumna_kopia := Gracze_Lista_StringGrid.Col;
  wiersz_kopia := Gracze_Lista_StringGrid.Row;

  if Gracze_Lista_StringGrid.ColCount <> 13 then
    Gracze_Lista_StringGrid.ColCount := 13;

  if tcp_klienci_lista_g.klienci_lista_list.Count > 0 then
    Gracze_Lista_StringGrid.RowCount := tcp_klienci_lista_g.klienci_lista_list.Count + 1
  else//if tcp_klienci_lista_g.klienci_lista_list.Count > 0 then
    Gracze_Lista_StringGrid.RowCount := 2; // Pusta lista.


  if Gracze_Lista_StringGrid.Cells[ 0, 0 ] = '' then
    begin

      Gracze_Lista_StringGrid.Cells[ 0, 0 ] := 'L. p.';
      Gracze_Lista_StringGrid.Cells[ 1, 0 ] := 'Id';
      Gracze_Lista_StringGrid.Cells[ 2, 0 ] := 'Nazwa';
      Gracze_Lista_StringGrid.Cells[ 3, 0 ] := 'Statek';
      Gracze_Lista_StringGrid.Cells[ 4, 0 ] := 'Grupa';
      Gracze_Lista_StringGrid.Cells[ 5, 0 ] := 'Gotowy';
      Gracze_Lista_StringGrid.Cells[ 6, 0 ] := 'Peer port tcp';
      Gracze_Lista_StringGrid.Cells[ 7, 0 ] := 'Peer port udp';
      Gracze_Lista_StringGrid.Cells[ 8, 0 ] := 'Czas pod³¹czenia';
      Gracze_Lista_StringGrid.Cells[ 9, 0 ] := 'Czas pod³¹czenia ostatniego';
      Gracze_Lista_StringGrid.Cells[ 10, 0 ] := 'Czas d³¹czenia';
      Gracze_Lista_StringGrid.Cells[ 11, 0 ] := 'Czas kontaktu udp ostatniego';
      Gracze_Lista_StringGrid.Cells[ 12, 0 ] := 'Od³¹czony';

    end;
  //---//if Gracze_Lista_StringGrid.Cells[ 0, 0 ] = '' then


  // Czyœci wpisy.
  for i := 0 to Gracze_Lista_StringGrid.ColCount - 1 do
    for j := 1 to Gracze_Lista_StringGrid.RowCount - 1 do
      begin

        Gracze_Lista_StringGrid.Cells[ i, j ] := '';
        Gracze_Lista_StringGrid.Cells[ i, j ] := '';
        Gracze_Lista_StringGrid.Cells[ i, j ] := '';
        Gracze_Lista_StringGrid.Cells[ i, j ] := '';
        Gracze_Lista_StringGrid.Cells[ i, j ] := '';
        Gracze_Lista_StringGrid.Cells[ i, j ] := '';
        Gracze_Lista_StringGrid.Cells[ i, j ] := '';
        Gracze_Lista_StringGrid.Cells[ i, j ] := '';
        Gracze_Lista_StringGrid.Cells[ i, j ] := '';
        Gracze_Lista_StringGrid.Cells[ i, j ] := '';

      end;
    //---//for j := 0 to Gracze_Lista_StringGrid.RowCount - 1 do


  for i := 0 to tcp_klienci_lista_g.klienci_lista_list.Count - 1 do
    begin

      Gracze_Lista_StringGrid.Cells[ 0, i + 1 ] := IntToStr( i + 1 );
      Gracze_Lista_StringGrid.Cells[ 1, i + 1 ] := IntToStr( TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator );
      Gracze_Lista_StringGrid.Cells[ 2, i + 1 ] := TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).nazwa;

      j := TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).id_statek_schemat;
      Gracze_Lista_StringGrid.Cells[ 3, i + 1 ] := Trim(  FormatFloat( '### ### ##0', j )  );
        if    ( j >= 0 )
          and (  j <= Length( statki_lista_t ) - 1 ) then
          Gracze_Lista_StringGrid.Cells[ 3, i + 1 ] := Gracze_Lista_StringGrid.Cells[ 3, i + 1 ] + ' - ' + statki_lista_t[ j ].nazwa;

      Gracze_Lista_StringGrid.Cells[ 4, i + 1 ] := Trim(  FormatFloat( '### ### ##0', TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).id_grupa )  );

      if TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).gotowy then
        Gracze_Lista_StringGrid.Cells[ 5, i + 1 ] := 'tak'
      else//if TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).gotowy then
        Gracze_Lista_StringGrid.Cells[ 5, i + 1 ] := 'nie';

      Gracze_Lista_StringGrid.Cells[ 6, i + 1 ] := Trim(  FormatFloat( '### ### ##0', TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).peer_port_tcp )  );
      Gracze_Lista_StringGrid.Cells[ 7, i + 1 ] := Trim(  FormatFloat( '### ### ##0', TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).peer_port_udp )  );
      Gracze_Lista_StringGrid.Cells[ 8, i + 1 ] := DateTimeToStr( TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).data_czas__pod³¹czenia );
      Gracze_Lista_StringGrid.Cells[ 9, i + 1 ] := DateTimeToStr( TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).data_czas__pod³¹czenia_ostatniego );

      if TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).data_czas__d³¹czenia <> 0 then
        Gracze_Lista_StringGrid.Cells[ 10, i + 1 ] := DateTimeToStr( TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).data_czas__d³¹czenia );

      if TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).data_czas__udp_kontakt <> 0 then
        Gracze_Lista_StringGrid.Cells[ 11, i + 1 ] := DateTimeToStr( TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).data_czas__udp_kontakt );

      if TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).od³¹czony then
        Gracze_Lista_StringGrid.Cells[ 12, i + 1 ] := 'tak'
      else//if TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).od³¹czony then
        Gracze_Lista_StringGrid.Cells[ 12, i + 1 ] := 'nie';

    end;
  //---//for i := 0 to tcp_klienci_lista_g.klienci_lista_list.Count - 1 do


  if tcp_klienci_lista_g.klienci_lista_list.Count <= 0 then
    Gracze_Lista_StringGrid.Cells[ 1, 1 ] := '<brak>';


  if Gracze_Lista_StringGrid.ColCount - 1 >= kolumna_kopia then
    Gracze_Lista_StringGrid.Col := kolumna_kopia;

  if Gracze_Lista_StringGrid.RowCount - 1 >= wiersz_kopia then
    Gracze_Lista_StringGrid.Row := wiersz_kopia;


  {$region 'Dodaje odbiorców wiadomoœci dla pokoju rozmów.'}
  j := Pokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj_ComboBox.ItemIndex;

  for i := 0 to Pokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj_ComboBox.Items.Count - 1 do
    TPokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj(Pokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj_ComboBox.Items.Objects[ i ]).Free();

  Pokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj_ComboBox.Clear();


  zt_pokój_rozmów__wyœlij_do__odbiorca_rodzaj := TPokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj.Create();
  zt_pokój_rozmów__wyœlij_do__odbiorca_rodzaj.id_odbiorca := 0;
  zt_pokój_rozmów__wyœlij_do__odbiorca_rodzaj.odbiorca_rodzaj := pror_Wszyscy;
  Pokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj_ComboBox.Items.AddObject( '<wszyscy>', zt_pokój_rozmów__wyœlij_do__odbiorca_rodzaj );


  for i := Gracz_Grupa_SpinEdit.MinValue to Gracz_Grupa_SpinEdit.MaxValue do
    begin

      zt_pokój_rozmów__wyœlij_do__odbiorca_rodzaj := TPokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj.Create();
      zt_pokój_rozmów__wyœlij_do__odbiorca_rodzaj.id_odbiorca := i;
      zt_pokój_rozmów__wyœlij_do__odbiorca_rodzaj.odbiorca_rodzaj := pror_Grupa_Jedna;

      zts := 'grupa ' + Trim(  FormatFloat( '0', i )  );

      if Gracz_Grupa_SpinEdit.Value = i then
        zts := zts + ' sojusznicy';

      Pokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj_ComboBox.Items.AddObject( zts, zt_pokój_rozmów__wyœlij_do__odbiorca_rodzaj );

    end;
  //---//for i := Gracz_Grupa_SpinEdit.MinValue to Gracz_Grupa_SpinEdit.MaxValue do


  for i := 0 to tcp_klienci_lista_g.klienci_lista_list.Count - 1 do
    //if TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator >= -1 then // Do SI te¿ mo¿na wysy³aæ komunikaty. //???
    if Gracz_Identyfikator() <> TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator then // Samemu do siebie nie mo¿na wysy³aæ wiadomoœci.
      begin

        zt_pokój_rozmów__wyœlij_do__odbiorca_rodzaj := TPokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj.Create();
        zt_pokój_rozmów__wyœlij_do__odbiorca_rodzaj.id_odbiorca := TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator;
        zt_pokój_rozmów__wyœlij_do__odbiorca_rodzaj.odbiorca_rodzaj := pror_Gracz_Jeden;

        zts := 'gracz ' + TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).nazwa + ' (' +Trim(  FormatFloat( '00', TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator )  ) + ')';

        Pokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj_ComboBox.Items.AddObject( zts, zt_pokój_rozmów__wyœlij_do__odbiorca_rodzaj );

      end;
    //---//if Gracz_Identyfikator() <> TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator then


  if j < 0 then
    j := 0;

  if    ( j >= 0 )
    and ( j <= Pokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj_ComboBox.Items.Count - 1 ) then
    Pokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj_ComboBox.ItemIndex := j;
  {$endregion 'Dodaje odbiorców wiadomoœci dla pokoju rozmów.'}

end;//---//Funkcja Gracze_Lista_Odœwie¿().

//Funkcja Gracze_Lista_Roz³¹cz().
procedure TStatki_Form.Gracze_Lista_Roz³¹cz( const peer_port_f : integer );
var
  i : integer;
  lista : TList;
begin

  //
  // Funkcja od³¹cza klientów.
  //
  // Parametry:
  //   peer_port_f:
  //     = -99 - od³¹czy wszystkich klientów.
  //     <> -99 - od³¹czy wskazanego klienta.
  //

  lista := IdTCPServer1.Contexts.LockList();

  try
    for i := 0 to lista.Count - 1 do
      if   ( peer_port_f = -99 )
        or ( TIdContext(lista[ i ]).Connection.Socket.Binding.PeerPort = peer_port_f ) then
        TIdContext(lista[ i ]).Connection.Disconnect(); // Nie wywo³uje IdTCPClient1.OnDisconnected().
  finally
    IdTCPServer1.Contexts.UnlockList();
  end;
  //---//try

end;//---//Funkcja Gracze_Lista_Roz³¹cz().

//Funkcja Gra_Statystyki_R_Identyfikator_ZnajdŸ().
function TStatki_Form.Gra_Statystyki_R_Identyfikator_ZnajdŸ( const identyfikator_f : integer ) : integer;
var
  i : integer;
begin

  //
  // Funkcja wyszukuje numer indeksu tabeli odpowiadaj¹cy identyfikatorowi gracza.
  //
  // Zwraca numer indeksu tabeli odpowiadaj¹cy identyfikatorowi gracza lub -99 gdy nic nie znajdzie.
  //
  // Parametry:
  //   identyfikator_f równa siê id_statek
  //

  Result := -99;

  for i := 0 to Length( gra_statystyki_r_t ) - 1 do
    if gra_statystyki_r_t[ i ].identyfikator = identyfikator_f then
      begin

        Result := i;
        Exit;

      end;
    //---//if gra_statystyki_r_t[ i ].identyfikator = identyfikator_f then

end;//---//Funkcja Gra_Statystyki_R_Identyfikator_ZnajdŸ().

//Funkcja Gra_Statystyki_Wypisz().
procedure TStatki_Form.Gra_Statystyki_Wypisz();
var
  i,
  j
    : integer;
  zts : string;
const
 odstêp_c_l : string = '   ';
begin

  //
  // Funkcja wypisuje statystyki gry.
  //

  Log_Memo.Lines.Add( 'Statystyki gry' );


  for i := 0 to Length( gra_statystyki_r_t ) - 1 do
    begin

      zts := '';

      for j := 0 to tcp_klienci_lista_g.klienci_lista_list.Count - 1 do
        if TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ j ]).identyfikator = gra_statystyki_r_t[ i ].identyfikator then
          begin

            zts := TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ j ]).nazwa;

            if    ( TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ j ]).id_statek_schemat >= 0 )
              and (  TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ j ]).id_statek_schemat <= Length( statki_lista_t ) - 1  ) then
              begin

                zts := zts + ', ' + statki_lista_t[ TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ j ]).id_statek_schemat ].nazwa;

              end;
            //---//if    ( TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ j ]).id_statek_schemat >= 0 ) (...)

            Break;

          end;
        //---//if TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ j ]).identyfikator = gra_statystyki_r_t[ i ].identyfikator then


      if Trim( zts ) <> '' then
        zts := ', ' + zts;

      Log_Memo.Lines.Add(    'identyfikator ' + Trim(  FormatFloat( '### ### ##0', gra_statystyki_r_t[ i ].identyfikator )  ) + zts   );
      //Log_Memo.Lines.Add(    odstêp_c_l + 'amunicja wystrzelona iloœæ ' + Trim(  FormatFloat( '### ### ##0', gra_statystyki_r_t[ i ].amunicja_wystrzelona_iloœæ )  )   );
      //Log_Memo.Lines.Add(    odstêp_c_l + 'amunicja wystrzelona obra¿enia zadawane ' + Trim(  FormatFloat( '### ### ##0.00', gra_statystyki_r_t[ i ].amunicja_wystrzelona_obra¿enia_zadawane )  )   );
      //Log_Memo.Lines.Add(    odstêp_c_l + 'obra¿enia otrzymane ' + Trim(  FormatFloat( '### ### ##0.00', gra_statystyki_r_t[ i ].obra¿enia_otrzymane )  )   );
      //Log_Memo.Lines.Add(    odstêp_c_l + 'obra¿enia zadane amunicja ' + Trim(  FormatFloat( '### ### ##0.00', gra_statystyki_r_t[ i ].obra¿enia_zadane_amunicja )  )   );
      //Log_Memo.Lines.Add(    odstêp_c_l + 'obra¿enia zadane amunicja w tym sojusznikom ' + Trim(  FormatFloat( '### ### ##0.00', gra_statystyki_r_t[ i ].obra¿enia_zadane_amunicja_sojusznikom )  )   );
      //Log_Memo.Lines.Add(    odstêp_c_l + 'obra¿enia zadane taranowanie ' + Trim(  FormatFloat( '### ### ##0.00', gra_statystyki_r_t[ i ].obra¿enia_zadane_taranowanie )  )   );
      //Log_Memo.Lines.Add(    odstêp_c_l + 'obra¿enia zadane taranowanie w tym sojusznikom ' + Trim(  FormatFloat( '### ### ##0.00', gra_statystyki_r_t[ i ].obra¿enia_zadane_taranowanie_sojusznikom )  )   );
      //Log_Memo.Lines.Add(    odstêp_c_l + 'taranowania iloœæ ' + Trim(  FormatFloat( '### ### ##0', gra_statystyki_r_t[ i ].taranowania_iloœæ )  )   );
      //Log_Memo.Lines.Add(    odstêp_c_l + 'taranowania iloœæ sojuszników ' + Trim(  FormatFloat( '### ### ##0', gra_statystyki_r_t[ i ].taranowania_iloœæ_sojuszników )  )   );
      //Log_Memo.Lines.Add(    odstêp_c_l + 'trafienia ' + Trim(  FormatFloat( '### ### ##0', gra_statystyki_r_t[ i ].trafienia )  )   );
      //Log_Memo.Lines.Add(    odstêp_c_l + 'zatoniêcia ' + Trim(  FormatFloat( '### ### ##0', gra_statystyki_r_t[ i ].zatoniêcia )  )   );
      //Log_Memo.Lines.Add(    odstêp_c_l + 'zatopienia ' + Trim(  FormatFloat( '### ### ##0', gra_statystyki_r_t[ i ].zatopienia )  )   );
      //Log_Memo.Lines.Add(    odstêp_c_l + 'zatopienia w tym sojuszników ' + Trim(  FormatFloat( '### ### ##0', gra_statystyki_r_t[ i ].zatopienia_sojuszników )  )   );

      Log_Memo.Lines.Add(    odstêp_c_l + Trim(  FormatFloat( '### ### ##0', gra_statystyki_r_t[ i ].amunicja_wystrzelona_iloœæ )  ) + ' amunicja wystrzelona iloœæ'   );
      Log_Memo.Lines.Add(    odstêp_c_l + Trim(  FormatFloat( '### ### ##0.00', gra_statystyki_r_t[ i ].amunicja_wystrzelona_obra¿enia_zadawane )  ) + ' amunicja wystrzelona obra¿enia zadawane'   );
      Log_Memo.Lines.Add(    odstêp_c_l + Trim(  FormatFloat( '### ### ##0.00', gra_statystyki_r_t[ i ].obra¿enia_otrzymane )  ) + ' obra¿enia otrzymane'   );
      Log_Memo.Lines.Add(    odstêp_c_l + Trim(  FormatFloat( '### ### ##0.00', gra_statystyki_r_t[ i ].obra¿enia_zadane_amunicja )  ) + ' obra¿enia zadane amunicja'   );
      Log_Memo.Lines.Add(    odstêp_c_l + Trim(  FormatFloat( '### ### ##0.00', gra_statystyki_r_t[ i ].obra¿enia_zadane_amunicja_sojusznikom )  ) + ' obra¿enia zadane amunicja w tym sojusznikom'   );
      Log_Memo.Lines.Add(    odstêp_c_l + Trim(  FormatFloat( '### ### ##0.00', gra_statystyki_r_t[ i ].obra¿enia_zadane_taranowanie )  ) + ' obra¿enia zadane taranowanie'   );
      Log_Memo.Lines.Add(    odstêp_c_l + Trim(  FormatFloat( '### ### ##0.00', gra_statystyki_r_t[ i ].obra¿enia_zadane_taranowanie_sojusznikom )  ) + ' obra¿enia zadane taranowanie w tym sojusznikom'   );
      Log_Memo.Lines.Add(    odstêp_c_l + Trim(  FormatFloat( '### ### ##0', gra_statystyki_r_t[ i ].taranowania_iloœæ )  ) + ' taranowania iloœæ'   );
      Log_Memo.Lines.Add(    odstêp_c_l + Trim(  FormatFloat( '### ### ##0', gra_statystyki_r_t[ i ].taranowania_iloœæ_sojuszników )  ) + ' taranowania iloœæ sojuszników'   );
      Log_Memo.Lines.Add(    odstêp_c_l + Trim(  FormatFloat( '### ### ##0', gra_statystyki_r_t[ i ].trafienia )  ) + ' trafienia'   );
      Log_Memo.Lines.Add(    odstêp_c_l + Trim(  FormatFloat( '### ### ##0', gra_statystyki_r_t[ i ].zatoniêcia )  ) + ' zatoniêcia'   );
      Log_Memo.Lines.Add(    odstêp_c_l + Trim(  FormatFloat( '### ### ##0', gra_statystyki_r_t[ i ].zatopienia )  ) + ' zatopienia'   );
      Log_Memo.Lines.Add(    odstêp_c_l + Trim(  FormatFloat( '### ### ##0', gra_statystyki_r_t[ i ].zatopienia_sojuszników )  ) + ' zatopienia w tym sojuszników'   );

      if gra_statystyki_r_t[ i ].amunicja_wystrzelona_iloœæ <> 0 then
        zts := Trim(  FormatFloat( '### ### ##0.00', gra_statystyki_r_t[ i ].trafienia * 100 / gra_statystyki_r_t[ i ].amunicja_wystrzelona_iloœæ )  )
      else//if gra_statystyki_r_t[ i ].amunicja_wystrzelona_iloœæ <> 0 then
        zts := '<n/d>';

      Log_Memo.Lines.Add( odstêp_c_l + zts + ' % celnoœæ' );

    end;
  //---//for i := 0 to Length( gra_statystyki_r_t ) - 1 do

end;//---//Funkcja Gra_Statystyki_Wypisz().

//Funkcja Informacja_Dodatkowa_Dodaj().
procedure TStatki_Form.Informacja_Dodatkowa_Dodaj( const napis_f : string; const wyœwietlanie_czas_sekund_f : smallint = 0 );
begin

  if   ( informacje_dodatkowe_list = nil )
    or (  not Assigned( informacje_dodatkowe_list )  ) then
    Exit;


  if wyœwietlanie_czas_sekund_f <= 0 then
    informacje_dodatkowe_list.Add(  TInformacje_Dodatkowe.Create( napis_f )  )
  else//if wyœwietlanie_czas_sekund_f <= 0 then
    informacje_dodatkowe_list.Add(  TInformacje_Dodatkowe.Create( napis_f, wyœwietlanie_czas_sekund_f )  );

  Informacje_Dodatkowe_TimerTimer( nil );

end;//---//Funkcja Informacja_Dodatkowa_Dodaj().

//Funkcja Interfejs_Aktywnoœæ_Ustaw_Klient().
procedure TStatki_Form.Interfejs_Aktywnoœæ_Ustaw_Klient( const aktywne_f : boolean );
begin

  Gra_Wspó³czynnik_Prêdkoœci_SpinEdit.Enabled := aktywne_f;
  L¹d_GroupBox.Enabled := aktywne_f;
  Morze_Wzburzenie_SpinEdit.Enabled := aktywne_f;
  Statek__Odœwie¿_Wskazany_BitBtn.Enabled := aktywne_f;
  Statek__Wczytaj_Listê_BitBtn.Enabled := aktywne_f;
  Statki_Pozycje_Pocz¹tkowe_GroupBox.Enabled := aktywne_f;

  if not aktywne_f then
    begin

      Gra_Wspó³czynnik_Prêdkoœci_SpinEdit.Value := 100;
      Morze_Wzburzenie_SpinEdit.Value := 100;

    end;
  //---//if not aktywne_f then

end;//---//Funkcja Interfejs_Aktywnoœæ_Ustaw_Klient().

//Funkcja Interfejs_Parametry_Wed³ug_Statku_Ustaw().
procedure TStatki_Form.Interfejs_Parametry_Wed³ug_Statku_Ustaw();
begin

  //
  // Funkcja ustawia podpowiedzi w elementach interfejsu na podstawie danych wczytanego statku.
  //

  if statek_gracza = nil then
    Exit;



  Radar_Zasiêg_GLDisk.OuterRadius := statek_gracza.radar_zasiêg;
  Radio_Zasiêg_GLDisk.OuterRadius := statek_gracza.radio_zasiêg;
  Sonar_Zasiêg_GLDisk.OuterRadius := statek_gracza.sonar_zasiêg;

  Radar_Dane_Z_Sonaru_CheckBox.Enabled := statek_gracza.sonar_zasiêg > 0;
  Radar_Dane_Z_Sonaru_CheckBox.Checked := Radar_Dane_Z_Sonaru_CheckBox.Enabled;

  if statek_gracza.radar_zasiêg > statek_gracza.radio_zasiêg then
    Radar_GLCamera.TagFloat := statek_gracza.radar_zasiêg
  else//if statek_gracza.radar_zasiêg > statek_gracza.radio_zasiêg then
    Radar_GLCamera.TagFloat := statek_gracza.radio_zasiêg;

  Radar_PN_Linia_GLLines.Nodes[ 1 ].Z := -Radar_GLCamera.TagFloat * 2;

  Radar_GLCamera.TagFloat := Radar_GLCamera.TagFloat + Radar_GLCamera.TagFloat * 2;

  if Radar_GLCamera.TagFloat < 2 then
    Radar_GLCamera.TagFloat := 2;

  Radar_GLCamera.Position.Y := Radar_GLCamera.TagFloat;


  Kamera_Odleg³oœæ_Maksymalna_SpinEdit.MaxValue := statek_gracza.kamera_odleg³oœæ_maksymalna;
  Kamera_Odleg³oœæ_Maksymalna_SpinEdit.Value := Kamera_Odleg³oœæ_Maksymalna_SpinEdit.MaxValue;

  Radar_Skala_SpinEdit.Hint :=
    'Skala radaru. ' + #13 +
    'Zasiêg radaru: ' + Trim(  FormatFloat( '### ### ##0', statek_gracza.radar_zasiêg )  ) +
    ', radia: ' + Trim(  FormatFloat( '### ### ##0', statek_gracza.radio_zasiêg )  ) +
    ', sonaru: ' + Trim(  FormatFloat( '### ### ##0', statek_gracza.sonar_zasiêg )  ) + '.';


  ar_Artyleria_CheckBox.Tag := integer(ar_Artyleria_CheckBox.Checked);
  ar_Pocisk_CheckBox.Tag := integer(ar_Pocisk_CheckBox.Checked);
  ar_Torpeda_CheckBox.Tag := integer(ar_Torpeda_CheckBox.Checked);

  ar_Artyleria_CheckBox.Checked := false;
  ar_Pocisk_CheckBox.Checked := false;
  ar_Torpeda_CheckBox.Checked := false;


  ar_Artyleria_CheckBox.Enabled := Length( statek_gracza.artyleria_t ) > 0;
  ar_Pocisk_CheckBox.Enabled := Length( statek_gracza.dzia³a_t ) > 0;
  ar_Torpeda_CheckBox.Enabled := Length( statek_gracza.torpedy_wyrzutnie_t ) > 0;


  if ar_Artyleria_CheckBox.Enabled then
    ar_Artyleria_CheckBox.Checked := boolean(ar_Artyleria_CheckBox.Tag);

  if ar_Pocisk_CheckBox.Enabled then
    ar_Pocisk_CheckBox.Checked := boolean(ar_Pocisk_CheckBox.Tag);

  if ar_Torpeda_CheckBox.Enabled then
    ar_Torpeda_CheckBox.Checked := boolean(ar_Torpeda_CheckBox.Tag);

end;//---//Funkcja Interfejs_Parametry_Wed³ug_Statku_Ustaw().

//Funkcja Klawisz_Konfiguracja_Zwolnij().
procedure TStatki_Form.Klawisz_Konfiguracja_Zwolnij();
var
  i : integer;
begin

  for i := Klawiatura_Konfiguracja_ScrollBox.ControlCount - 1 downto 0 do // Tylko wizualne. // Zwalnia elementy okna, które s¹ podrzêdne dla Element_Nadrzedny (tu ScrollBox1).
    Klawiatura_Konfiguracja_ScrollBox.Controls[ i ].Free();

end;//---//Funkcja Klawisz_Konfiguracja_Zwolnij().

//Funkcja Log_Wypisz().
procedure TStatki_Form.Log_Wypisz( const napis_f : string; const prze³¹cz_zak³adkê_f : boolean = true );
begin

  //
  // Funkcja wpisuje napis do pola logu.
  //
  // Parametry:
  //   napis_f
  //   prze³¹cz_zak³adkê_f:
  //     false - nie prze³¹cza zak³adki.
  //     true - prze³¹cza zak³adkê.
  //
  // Gdy wpisuje logi to serwer TCP blokuje siê i Log_Memo staje siê niewidoczne - lepiej u¿ywaæ Wieloosobowe__Log_Wypisz().
  //

  if Trim( napis_f ) = '' then
    Exit;

  Log_Memo.Lines.Add( '___' );
  Log_Memo.Lines.Add( napis_f );
  //Log_Memo.Lines.Add( '---' );

  if prze³¹cz_zak³adkê_f then
    PageControl1.ActivePage := Log_TabSheet;

end;//---//Funkcja Log_Wypisz().

//Funkcja Pokój_Rozmów__Wyœwietl_Wiadomoœæ().
procedure TStatki_Form.Pokój_Rozmów__Wyœwietl_Wiadomoœæ( pokój_rozmów_r_f : TPokój_Rozmów_r );
var
  pokój_rozmów_powiadomienie_l : TPokój_Rozmów_Powiadomienie;
begin

  pokój_rozmów_powiadomienie_l := TPokój_Rozmów_Powiadomienie.Create();
  pokój_rozmów_powiadomienie_l.pokój_rozmów_r := pokój_rozmów_r_f;
  pokój_rozmów_powiadomienie_l.Notify();

  // Bez Free().

end;//---//Funkcja Pokój_Rozmów__Wyœwietl_Wiadomoœæ().

//Funkcja Radar_Koryguj_Wielkoœæ_Obiektów().
function TStatki_Form.Radar_Koryguj_Wielkoœæ_Obiektów() : real;
begin

  //
  // Funkcja ustala wartoœæ wspó³czynnika wielkoœci obiektów na radarze zale¿nie od ustawionej skali radaru.
  //
  // Zwraca wartoœæ wspó³czynnika wielkoœci obiektów na radarze.
  //

  Result := Radar_Czu³oœæ_SpinEdit.Tag * 0.01 * Radar_Czu³oœæ_SpinEdit.Value * 0.1

end;//---//Funkcja Radar_Koryguj_Wielkoœæ_Obiektów().

//Funkcja Radar_L¹d_Rysuj().
procedure TStatki_Form.Radar_L¹d_Rysuj();
var
  i : integer;
  zt_gl_sphere : TGLSphere;
begin

  if   ( l¹d_list = nil )
    or (  not Assigned( l¹d_list )  ) then
    Exit;


  for i := 0 to l¹d_list.Count - 1 do
    begin

      if   ( statek_gracza = nil )
        or (
                 ( statek_gracza <> nil )
             and ( statek_gracza.DistanceTo( TGLCustomSceneObject(l¹d_list[ i ]) ) <= statek_gracza.radio_zasiêg )
           ) then
        begin

          zt_gl_sphere := TGLSphere.Create( Self );
          zt_gl_sphere.Parent := Radar_Obiekty_GLDummyCube;
          zt_gl_sphere.Pickable := false;
          zt_gl_sphere.AbsolutePosition := VectorMake( TGLCustomSceneObject(l¹d_list[ i ]).AbsolutePosition.X, TGLCustomSceneObject(l¹d_list[ i ]).AbsolutePosition.Y, TGLCustomSceneObject(l¹d_list[ i ]).AbsolutePosition.Z );
          zt_gl_sphere.Radius := Radar_Koryguj_Wielkoœæ_Obiektów();
          zt_gl_sphere.Material.FrontProperties.Ambient.Color := clrDarkBrown;
          zt_gl_sphere.Material.FrontProperties.Diffuse.Color := clrVeryDarkBrown;
          zt_gl_sphere.Material.FrontProperties.Emission.Color := clrTransparent;

        end;
      //---//if   ( statek_gracza = nil ) (...)

    end;
  //---//for i := 0 to l¹d_list.Count - 1 do

end;//---//Funkcja Radar_L¹d_Rysuj().

//Funkcja Radar_Statki_Rysuj().
procedure TStatki_Form.Radar_Statki_Rysuj();
var
  i : integer;
  œlad_rysuj : boolean;
  zt_gl_capsule : TGLCapsule;
  zt_gl_dummy_cube : TGLDummyCube;
  zt_gl_frustrum : TGLFrustrum;
  zt_gl_sphere : TGLSphere;
  zt_amunicja_wystrzelona_list : TList;
begin//Funkcja Statki_Ruch().

  Radar_Timer.Tag := Radar_Timer.Tag + 1;

  if Radar_Timer.Tag >= 5 then
    begin

      Radar_Timer.Tag := 0;
      œlad_rysuj := true;

    end
  else//if Radar_Timer.Tag >= 5 then
    œlad_rysuj := false;


  // Rysuje statki.
  for i := 0 to Length( statki_t ) - 1 do
    begin

      if statki_t[ i ] <> nil then
        begin

          if   ( statek_gracza = nil )
            or (
                     ( statek_gracza <> nil )
                 and (
                          ( statek_gracza.id_statek = statki_t[ i ].id_statek )
                       or (
                                ( statek_gracza.DistanceTo( statki_t[ i ] ) <= statek_gracza.radar_zasiêg )
                            //and (
                            //         ( statki_t[ i ] <> £ódŸ podwodna ) // £ódŸ_podwodna.
                            //      or (
                            //               ( statki_t[ i ] = £ódŸ podwodna )
                            //           and ( statki_t[ i ] not pod wod¹ )
                            //         )
                            //    )
                          )
                       or (  Radio_Dane_Wymieñ( statek_gracza, statki_t[ i ].id_statek )  )
                     )
               ) then
            begin

              if statek_gracza <> statki_t[ i ] then
                begin

                  zt_gl_dummy_cube := TGLDummyCube.Create( Self );
                  zt_gl_dummy_cube.Parent := Radar_Obiekty_GLDummyCube;
                  zt_gl_dummy_cube.Pickable := false;
                  zt_gl_dummy_cube.AbsolutePosition := VectorMake( statki_t[ i ].AbsolutePosition.X, statki_t[ i ].AbsolutePosition.Y, statki_t[ i ].AbsolutePosition.Z );
                  zt_gl_dummy_cube.AbsoluteDirection := statki_t[ i ].AbsoluteDirection;


                  zt_gl_frustrum := TGLFrustrum.Create( Self );
                  zt_gl_frustrum.Parent := zt_gl_dummy_cube;
                  zt_gl_frustrum.Pickable := false;
                  zt_gl_frustrum.PitchAngle := Radar_Statek_GLFrustrum.PitchAngle;
                  zt_gl_frustrum.RollAngle := Radar_Statek_GLFrustrum.RollAngle;
                  zt_gl_frustrum.Height := Radar_Statek_GLFrustrum.Height;
                  zt_gl_frustrum.Scale := Radar_Statek_GLFrustrum.Scale;

                  if statek_gracza <> nil then
                    if statek_gracza.id_grupa = statki_t[ i ].id_grupa then
                      zt_gl_frustrum.Material.FrontProperties.Diffuse.Color := clrSpringGreen
                    else//if statek_gracza.id_grupa = statki_t[ i ].id_grupa then
                      zt_gl_frustrum.Material.FrontProperties.Diffuse.Color := clrOrangeRed;

                end;
              //---//if statek_gracza <> statki_t[ i ] then


              if œlad_rysuj then
                begin

                  zt_gl_sphere := TGLSphere.Create( Self );
                  zt_gl_sphere.Parent := Radar_Œlady_GLDummyCube;
                  zt_gl_sphere.Pickable := false;
                  zt_gl_sphere.AbsolutePosition := VectorMake( statki_t[ i ].AbsolutePosition.X, 0, statki_t[ i ].AbsolutePosition.Z );
                  zt_gl_sphere.Radius := Radar_Koryguj_Wielkoœæ_Obiektów();
                  zt_gl_sphere.Material.FrontProperties.Ambient.Color := clrTransparent;
                  zt_gl_sphere.Material.FrontProperties.Diffuse.Color := clrSilver;
                  zt_gl_sphere.Material.FrontProperties.Emission.Color := clrTransparent;
                  //zt_gl_sphere.Material.BlendingMode := bmModulate;
                  zt_gl_sphere.Material.PolygonMode := GLState.pmPoints;
                  zt_gl_sphere.Slices := 4;
                  zt_gl_sphere.Stacks := 4;
                  zt_gl_sphere.Tag := Czas_Teraz();
                  zt_gl_sphere.TagFloat := integer(ar_Brak);
                  zt_gl_sphere.MoveLast();

                end;
              //---//if œlad_rysuj then

            end;
          //---//if   ( statek_gracza = nil ) (...)

        end;
      //---//if statki_t[ i ] <> nil then

    end;
  //---//for i := 0 to Length( statki_t ) - 1 do
  //---// Rysuje statki


  // Rysuje celownik gracza.
  if    ( statek_gracza <> nil )
    and ( statek_gracza.DistanceTo( Celowniczy_GLDummyCube ) <= statek_gracza.radar_zasiêg ) then
    begin

      zt_gl_sphere := TGLSphere.Create( Self );
      zt_gl_sphere.Parent := Radar_Obiekty_GLDummyCube;
      zt_gl_sphere.Pickable := false;
      zt_gl_sphere.AbsolutePosition := VectorMake( Celowniczy_GLDummyCube.AbsolutePosition.X, Celowniczy_GLDummyCube.AbsolutePosition.Y, Celowniczy_GLDummyCube.AbsolutePosition.Z );
      zt_gl_sphere.Radius := Radar_Koryguj_Wielkoœæ_Obiektów();
      zt_gl_sphere.Material.FrontProperties.Ambient.Color := clrYellowGreen;
      zt_gl_sphere.Material.FrontProperties.Diffuse.Color := clrYellow;
      zt_gl_sphere.Material.FrontProperties.Emission.Color := clrTransparent;

    end;
  //---//if   ( statek_gracza = nil ) (...)


  // Rysuje amunicjê.
  if    ( Radar_Dane_Z_Sonaru_CheckBox.Enabled )
    and ( Radar_Dane_Z_Sonaru_CheckBox.Checked ) then
    begin

      if czy_klient_g then
        zt_amunicja_wystrzelona_list := wieloosobowe_amunicja_wystrzelona_list
      else//if czy_klient_g then
        zt_amunicja_wystrzelona_list := amunicja_wystrzelona_list;


      for i := 0 to zt_amunicja_wystrzelona_list.Count - 1 do
        begin

          if    ( zt_amunicja_wystrzelona_list[ i ] <> nil )
            and ( TAmunicja(zt_amunicja_wystrzelona_list[ i ]).amunicja_rodzaj = ar_Torpeda ) then
            begin

              if   ( statek_gracza = nil )
                or (
                         ( statek_gracza <> nil )
                     and (
                              (
                                    ( czy_klient_g )
                                and (  ( statek_gracza.DistanceTo( TAmunicja(zt_amunicja_wystrzelona_list[ i ]).korpus_ustawienie_pocz¹tkowe_dummy ) <= statek_gracza.sonar_zasiêg )  )
                              )
                           or (
                                    ( not czy_klient_g )
                                and (  ( statek_gracza.DistanceTo( TAmunicja(zt_amunicja_wystrzelona_list[ i ]) ) <= statek_gracza.sonar_zasiêg )  )
                              )
                           //or (  Radio_Dane_Wymieñ( statek_gracza, TAmunicja(zt_amunicja_wystrzelona_list[ i ]).id_statek )  )
                         )
                   ) then
                begin

                  zt_gl_dummy_cube := TGLDummyCube.Create( Self );
                  zt_gl_dummy_cube.Parent := Radar_Obiekty_GLDummyCube;
                  zt_gl_dummy_cube.Pickable := false;

                  if czy_klient_g then
                    begin

                      //zt_gl_dummy_cube.AbsolutePosition := VectorMake( TAmunicja(zt_amunicja_wystrzelona_list[ i ]).korpus_ustawienie_pocz¹tkowe_dummy.AbsolutePosition.X, TAmunicja(zt_amunicja_wystrzelona_list[ i ]).korpus_ustawienie_pocz¹tkowe_dummy.AbsolutePosition.Y, TAmunicja(zt_amunicja_wystrzelona_list[ i ]).korpus_ustawienie_pocz¹tkowe_dummy.AbsolutePosition.Z );
                      zt_gl_dummy_cube.AbsolutePosition := VectorMake( TAmunicja(zt_amunicja_wystrzelona_list[ i ]).korpus_ustawienie_pocz¹tkowe_dummy.AbsolutePosition.X, 0, TAmunicja(zt_amunicja_wystrzelona_list[ i ]).korpus_ustawienie_pocz¹tkowe_dummy.AbsolutePosition.Z );
                      zt_gl_dummy_cube.AbsoluteDirection := TAmunicja(zt_amunicja_wystrzelona_list[ i ]).korpus_ustawienie_pocz¹tkowe_dummy.AbsoluteDirection;

                    end
                  else//if czy_klient_g then
                    begin

                      //zt_gl_dummy_cube.AbsolutePosition := VectorMake( TAmunicja(zt_amunicja_wystrzelona_list[ i ]).AbsolutePosition.X, TAmunicja(zt_amunicja_wystrzelona_list[ i ]).AbsolutePosition.Y, TAmunicja(zt_amunicja_wystrzelona_list[ i ]).AbsolutePosition.Z );
                      zt_gl_dummy_cube.AbsolutePosition := VectorMake( TAmunicja(zt_amunicja_wystrzelona_list[ i ]).AbsolutePosition.X, 0, TAmunicja(zt_amunicja_wystrzelona_list[ i ]).AbsolutePosition.Z );
                      zt_gl_dummy_cube.AbsoluteDirection := TAmunicja(zt_amunicja_wystrzelona_list[ i ]).AbsoluteDirection;

                    end;
                  //---//if czy_klient_g then


                  zt_gl_capsule := TGLCapsule.Create( Self );
                  zt_gl_capsule.Parent := zt_gl_dummy_cube;
                  zt_gl_capsule.Pickable := false;
                  zt_gl_capsule.PitchAngle := Radar_Statek_GLFrustrum.PitchAngle;
                  zt_gl_capsule.RollAngle := Radar_Statek_GLFrustrum.RollAngle;
                  zt_gl_capsule.Radius := Radar_Koryguj_Wielkoœæ_Obiektów();
                  zt_gl_capsule.Material.FrontProperties.Diffuse.Color := clrPlum;


                  if œlad_rysuj then
                    begin

                      zt_gl_sphere := TGLSphere.Create( Self );
                      zt_gl_sphere.Parent := Radar_Œlady_GLDummyCube;
                      zt_gl_sphere.Pickable := false;

                      if czy_klient_g then
                        begin

                          zt_gl_sphere.AbsolutePosition := VectorMake( TAmunicja(zt_amunicja_wystrzelona_list[ i ]).korpus_ustawienie_pocz¹tkowe_dummy.AbsolutePosition.X, 0, TAmunicja(zt_amunicja_wystrzelona_list[ i ]).korpus_ustawienie_pocz¹tkowe_dummy.AbsolutePosition.Z );

                        end
                      else//if czy_klient_g then
                        begin

                          zt_gl_sphere.AbsolutePosition := VectorMake( TAmunicja(zt_amunicja_wystrzelona_list[ i ]).AbsolutePosition.X, 0, TAmunicja(zt_amunicja_wystrzelona_list[ i ]).AbsolutePosition.Z );

                        end;
                      //---//if czy_klient_g then

                      zt_gl_sphere.Radius := Radar_Koryguj_Wielkoœæ_Obiektów();
                      zt_gl_sphere.Material.FrontProperties.Ambient.Color := clrTransparent;
                      zt_gl_sphere.Material.FrontProperties.Diffuse.Color := clrWhite;
                      zt_gl_sphere.Material.FrontProperties.Emission.Color := clrTransparent;
                      //zt_gl_sphere.Material.BlendingMode := bmModulate;
                      zt_gl_sphere.Material.PolygonMode := GLState.pmPoints;
                      zt_gl_sphere.Slices := 4;
                      zt_gl_sphere.Stacks := 4;
                      zt_gl_sphere.Tag := Czas_Teraz();
                      zt_gl_sphere.TagFloat := integer(ar_Torpeda);
                      zt_gl_sphere.MoveLast();

                    end;
                  //---//if œlad_rysuj then

                end;
              //---//if   ( statek_gracza = nil ) (...)

            end;
          //---//if    ( zt_amunicja_wystrzelona_list[ i ] <> nil ) (...)

        end;
      //---//for i := 0 to zt_amunicja_wystrzelona_list.Count - 1 do

    end;
  //---//if    ( Radar_Dane_Z_Sonaru_CheckBox.Enabled ) (...)
  //---// Rysuje amunicjê.

end;//---//Funkcja Radar_Statki_Rysuj().

//Funkcja Radar_Wyczyœæ().
procedure TStatki_Form.Radar_Wyczyœæ( const czyœæ_wszystko_f : boolean = false );
var
  i : integer;
begin

  //
  // Funkcja czyœci wykres radaru.
  //
  // Parametry:
  //   czyœæ_wszystko_f:
  //     false - œlad ruchu statków jest czyszczony wzglêdem czasu trwania.
  //     true - czyœci wszystko.
  //


  for i := Radar_Œlady_GLDummyCube.Count - 1 downto 0 do
    if   ( czyœæ_wszystko_f )
      or (
               ( Radar_Œlady_GLDummyCube.Children[ i ].TagFloat <> integer(ar_Torpeda) ) // Œlady statków.
           and (  Czas_Miêdzy_W_Sekundach( Radar_Œlady_GLDummyCube.Children[ i ].Tag ) * gra_wspó³czynnik_prêdkoœci_g > Radar_Rysowanie_Œladów__Statków_Sekundy_SpinEdit.Value  )
         )
      or (
               ( Radar_Œlady_GLDummyCube.Children[ i ].TagFloat = integer(ar_Torpeda) ) // Œlady torped.
           and (  Czas_Miêdzy_W_Sekundach( Radar_Œlady_GLDummyCube.Children[ i ].Tag ) * gra_wspó³czynnik_prêdkoœci_g > Radar_Rysowanie_Œladów__Amunicji_Sekundy_SpinEdit.Value  )
         ) then
      Radar_Œlady_GLDummyCube.Children[ i ].Free()
    else//if   ( czyœæ_wszystko_f ) (...)
      TGLSphere(Radar_Œlady_GLDummyCube.Children[ i ]).Radius := Radar_Koryguj_Wielkoœæ_Obiektów(); // Aktualizuje rozmiar gdy zmieni siê skalê radaru.


  for i := Radar_Obiekty_GLDummyCube.Count - 1 downto 0 do
    begin

      Radar_Obiekty_GLDummyCube.Children[ i ].Free();

    end;
  //---//for i := Radar_Obiekty_GLDummyCube.Count - 1 downto 0 do

end;//---//Funkcja Radar_Wyczyœæ().

//Funkcja Radio_Statki_W_Zasiêgu().
procedure TStatki_Form.Radio_Statki_W_Zasiêgu();
var
  i,
  j
    : integer;
begin

  //
  // Funkcja ustawia statkom jakie id statki maj¹ w zasiêgu radaru i radia.
  //

  if czy_klient_g then
    Exit;


  //if    ( czy_gra_lokalna_g )
  //  and ( not Radar_Dane_Z_Radia_CheckBox.Checked ) then
  if not Radar_Dane_Z_Radia_CheckBox.Checked then // Gdy radio wy³¹czone to nie wysy³a danych do innych statków.
    begin

      if statek_gracza <> nil then
        begin

          statek_gracza.radar_id_statki_w_zasiêgu := '-99, -99';
          statek_gracza.radio_id_statki_w_zasiêgu := '-99, -99';

        end;
      //---//if statek_gracza <> nil then


      Exit;

    end;
  //---//if not Radar_Dane_Z_Radia_CheckBox.Checked then



  for i := 0 to Length( statki_t ) - 1 do
    begin

      if statki_t[ i ] <> nil then
        begin

          statki_t[ i ].radar_id_statki_w_zasiêgu := '-99';
          statki_t[ i ].radio_id_statki_w_zasiêgu := '-99';


          for j := 0 to Length( statki_t ) - 1 do
            begin

              if statki_t[ j ] <> nil then
                begin

                  // Jakie statki ma w zasiêgu radaru statek.
                  //if    ( statki_t[ i ].id_statek <> statki_t[ j ].id_statek ) // Siebie te¿ ma na liœcie aby potem ³atwiej by³o wyœwietlaæ.
                  if      ( statki_t[ i ].DistanceTo( statki_t[ j ] ) <= statki_t[ i ].radar_zasiêg ) then
                    //and (
                    //         ( statki_t[ i ] <> £ódŸ podwodna ) // £ódŸ_podwodna.
                    //      or (
                    //               ( statki_t[ i ] = £ódŸ podwodna )
                    //           and ( statki_t[ i ] not pod wod¹ )
                    //         )
                    //    )
                    begin

                      statki_t[ i ].radar_id_statki_w_zasiêgu := statki_t[ i ].radar_id_statki_w_zasiêgu +
                        ', ' + IntToStr( statki_t[ j ].id_statek );

                    end;
                  //---//if    ( statki_t[ i ].id_statek <> statki_t[ j ].id_statek ) (...)


                  // Jakie statki z w³asnej grupy ma w zasiêgu radia statek.
                  //if    ( statki_t[ i ].id_statek <> statki_t[ j ].id_statek ) // Siebie te¿ ma na liœcie aby potem ³atwiej by³o wyœwietlaæ.
                  if    ( statki_t[ i ].id_grupa = statki_t[ j ].id_grupa )
                    and ( statki_t[ i ].DistanceTo( statki_t[ j ] ) <= statki_t[ i ].radio_zasiêg ) then
                    begin

                      statki_t[ i ].radio_id_statki_w_zasiêgu := statki_t[ i ].radio_id_statki_w_zasiêgu +
                        ', ' + IntToStr( statki_t[ j ].id_statek );

                    end;
                  //---//if    ( statki_t[ i ].id_statek <> statki_t[ j ].id_statek ) (...)

                end;
              //---//if statki_t[ j ] <> nil then

            end;
          //---//for j := 0 to Length( statki_t ) - 1 do


          statki_t[ i ].radar_id_statki_w_zasiêgu := statki_t[ i ].radar_id_statki_w_zasiêgu +
            ', -99';

          statki_t[ i ].radio_id_statki_w_zasiêgu := statki_t[ i ].radio_id_statki_w_zasiêgu +
            ', -99';

        end;
      //---//if statki_t[ i ] <> nil then

    end;
  //---//for i := 0 to Length( statki_t ) - 1 do

end;//---//Funkcja Radio_Statki_W_Zasiêgu().

//Funkcja Radio_Dane_Wymieñ().
function TStatki_Form.Radio_Dane_Wymieñ( const zt_statek_f : TStatek; id_statek_f : integer ) : boolean;
var
  i,
  j
    : integer;
begin

  //
  // Funkcja sprawdza czy informacje o danym statku mog¹ zostaæ przekazane przez radio.
  //
  // Zwraca prawdê gdy informacje o danym statku mog¹ zostaæ przekazane przez radio.
  //
  // Parametry:
  //   zt_statek_f - statek pytaj¹cy o informacje.
  //   id_statek_f - id sprawdzanego statku.
  //

  Result := false;

  if   ( not Radar_Dane_Z_Radia_CheckBox.Checked )
    or ( zt_statek_f = nil ) then
    Exit;


  for i := 0 to Length( statki_t ) - 1 do
    begin

      if    ( statki_t[ i ] <> nil )
        and ( statki_t[ i ].id_grupa = zt_statek_f.id_grupa ) // Informacje wymieniaj¹ tylko statki z tej samej grupy.
        and (   Pos(  ', ' + IntToStr( statki_t[ i ].id_statek ) + ',',  zt_statek_f.radio_id_statki_w_zasiêgu  ) > 0   ) // Statki s¹ w zasiêgu radiowym.
        and (   Pos(  ', ' + IntToStr( id_statek_f ) + ',',  statki_t[ i ].radar_id_statki_w_zasiêgu  ) > 0   ) // Statek ma w zasiêgu radaru sprawdzany statek.
        then
        begin

          Result := true;
          Exit;

        end;
      //---//if statki_t[ i ] <> nil then

    end;
  //---//for i := 0 to Length( statki_t ) - 1 do

end;//---//Funkcja Radio_Dane_Wymieñ().

//Funkcja Komunikacja_Rekord_Testowy_Obs³uga().
procedure TStatki_Form.Komunikacja_Rekord_Testowy_Obs³uga( const tylko_wyœwietl_f : boolean = true );
var
  i : integer;
begin

  //
  // Funkcja wyœwietla zawartoœæ testowego rekordu komunikacji
  // i ewentualnie podstawia dane do testowego rekordu komunikacji.
  //
  // Parametry:
  //   tylko_wyœwietl_f:
  //     false - podstawi dane.
  //     true - tylko wyœwietli.
  //


  if not tylko_wyœwietl_f then
    begin

      komunikacja_rekord_testowy_r.liczba_ca³kowita := Random( 99 );
      komunikacja_rekord_testowy_r.liczba_rzeczywista := Random( 999 ) + Random( 9999 ) * 0.0001;
      komunikacja_rekord_testowy_r.data_czas := Now();
      komunikacja_rekord_testowy_r.napis_krótki := '¹¥êÊŒÆñó³';

      for i := 1 to 10 do
        komunikacja_rekord_testowy_r.napis_krótki := komunikacja_rekord_testowy_r.napis_krótki +
          Char(  Random( 188 ) + 32  ); // Od 32 do 220.

    end;
  //---//if not tylko_wyœwietl_f then


  Log_Memo.Lines.Add(  '*' + IntToStr( komunikacja_rekord_testowy_r.liczba_ca³kowita ) + '*liczba ca³kowita'  );
  Log_Memo.Lines.Add(  '*' + FloatToStr( komunikacja_rekord_testowy_r.liczba_rzeczywista ) + '*liczba rzeczywista'  );
  Log_Memo.Lines.Add(  '*' + DateTimeToStr( komunikacja_rekord_testowy_r.data_czas ) + '*data czas'  );
  Log_Memo.Lines.Add( '*' + komunikacja_rekord_testowy_r.napis_krótki + '*napis krótki' );
  Log_Memo.Lines.Add(    'OpóŸnienie: ' + Trim(   FormatFloat(  '### ### ##0', SecondsBetween( Now(), komunikacja_rekord_testowy_r.data_czas )  )   ) + ' [s].'    );

end;//---//Funkcja Komunikacja_Rekord_Testowy_Obs³uga().

//---//      ***      Funkcje      ***      //---//


//FormShow().
procedure TStatki_Form.FormShow( Sender: TObject );
begin

  // Wywo³anie w obrêbie dzia³ania tego zdarzenia Application.MessageBox, ShowMessage wyœwietla b³¹d 'Argument out of range' ale nie przerywa wykonywania reszty kodu.

  czas_bezwzglêdny_g := 0;
  czas_bezwzglêdny_skok_milisekundy_g := 50;
  Czas_Bezwzglêdny_Timer.Interval := czas_bezwzglêdny_skok_milisekundy_g;

  czy_kamera_od_najnowszego_pocisku := true;
  czy_pauza_g := false;

  czy_gra_lokalna_g := false;
  czy_serwer_g := false;
  czy_klient_g := false;
  czy_wy³¹czanie_serwera_g := false;
  //czy_wysy³anie_trwa_g := false;
  klient_pierwsze_ustawienie_kamery_g := false;
  pokój_rozmów__zmiana_szerokoœci__aktywnoœæ_g := false;

  pokój_rozmów__zmiana_szerokoœci__szerokoœæ_pocz¹tkowa_g := 0;
  pokój_rozmów__zmiana_szerokoœci__wysokoœæ_pocz¹tkowa_g := 0;
  pokój_rozmów__zmiana_szerokoœci__x_pocz¹tkowy_g := 0;
  pokój_rozmów__zmiana_szerokoœci__y_pocz¹tkowy_g := 0;

  l¹d_definicja_g := '';

  l¹d_pozycja_pocz¹tkowa_parametry_t[ 1 ].korekta_obrót := 0;
  l¹d_pozycja_pocz¹tkowa_parametry_t[ 1 ].korekta_x := 0;
  l¹d_pozycja_pocz¹tkowa_parametry_t[ 1 ].korekta_z := 0;
  l¹d_pozycja_pocz¹tkowa_parametry_t[ 1 ].odstêp_x := 7;
  l¹d_pozycja_pocz¹tkowa_parametry_t[ 1 ].z := 10;
  l¹d_pozycja_pocz¹tkowa_parametry_t[ 2 ].korekta_obrót := 180;
  l¹d_pozycja_pocz¹tkowa_parametry_t[ 2 ].korekta_x := 0;
  l¹d_pozycja_pocz¹tkowa_parametry_t[ 2 ].korekta_z := 0;
  l¹d_pozycja_pocz¹tkowa_parametry_t[ 2 ].odstêp_x := 7;
  l¹d_pozycja_pocz¹tkowa_parametry_t[ 2 ].z := -10;

  gra_pozycja_pocz¹tkowa_parametry_t[ 1 ] := l¹d_pozycja_pocz¹tkowa_parametry_t[ 1 ];
  gra_pozycja_pocz¹tkowa_parametry_t[ 2 ] := l¹d_pozycja_pocz¹tkowa_parametry_t[ 2 ];

  statki_pozycja_pocz¹tkowa_parametry_t[ 1 ] := l¹d_pozycja_pocz¹tkowa_parametry_t[ 1 ];
  statki_pozycja_pocz¹tkowa_parametry_t[ 2 ] := l¹d_pozycja_pocz¹tkowa_parametry_t[ 2 ];

  kamera_indeks_amunicji := 0;
  kamera_szybkoœæ_ruchu_g := 1;
  wieloosobowe__statek_przywróæ_do_gry__id_statek_g := -99;
  //moment_wciœniêcia_klawisza := Now();
  pokój_rozmów_ostatnia_wiadomoœæ_wys³ana_data_czas := 0;

  projektowy_tryb__statek := nil;
  wieloosobowe_amunicja_efekt_g := nil;
  statek_gracza := nil; // Nie zmienia statki_t[ 0 ].

  Randomize();

  Gra_GLSceneViewer.Align := alClient;
  Radar_GLSceneViewer.Align := alClient;
  Klawiatura_Konfiguracja_ScrollBox.Align := alClient;

  //mouse_look_active_przed_pauz¹ := Gra_GLUserInterface.MouseLookActive;

  {$IFDEF DEBUG}
  PageControl1.ActivePage := Pozosta³e_TabSheet; //Gra_TabSheet Wieloosobowe_TabSheet Ustawienia_TabSheet Pozosta³e_TabSheet Klawiatura_Konfiguracja_TabSheet
  {$ELSE DEBUG}
  //???
  PageControl1.ActivePage := Wieloosobowe_TabSheet;
  Button1.Visible := false;
  {$ENDIF}

  // Nie wykrywa mi kolizji z Plane wiêc ta bry³a s³u¿y do wykrywania trafieñ w wodê.
  Woda_Kolizje_GLCube.Position.Y := Woda_GLPlane.Position.Y - Woda_Kolizje_GLCube.CubeHeight * 0.5;
  Woda_Kolizje_GLCube.CubeDepth := Woda_GLPlane.Height;
  Woda_Kolizje_GLCube.CubeWidth := Woda_GLPlane.Width;

  Dno_GLPlane.Height := Woda_GLPlane.Height;
  Dno_GLPlane.Width := Woda_GLPlane.Width;

  Dno_Kolizje_GLCube.Position.Y := Dno_GLPlane.Position.Y - Dno_Kolizje_GLCube.CubeHeight * 0.5;
  Dno_Kolizje_GLCube.CubeDepth := Woda_GLPlane.Height;
  Dno_Kolizje_GLCube.CubeWidth := Woda_GLPlane.Width;

  Radar_T³o_GLPlane.Height := Woda_GLPlane.Height;
  Radar_T³o_GLPlane.Width := Woda_GLPlane.Width;

  Gracz_Nazwa_Edit.MaxLength := SizeOf( TWieloosobowe_String ) - 1;
  Pokój_Rozmów_Wiadomoœæ_Edit.MaxLength := SizeOf( TWieloosobowe_String ) - 1;

  Kamera_Odleg³oœæ_Maksymalna_SpinEdit.Value := 0;

  Gra_GLCamera.Tag := integer(kt_Brak);

  Ustawienia_ScrollBox.VertScrollBar.Position := 0;
  Ustawienia_ScrollBox.HorzScrollBar.Position := 0;

  Klawiatura_Konfiguracja__Domyœlna_ButtonClick( Sender );

  amunicja_wystrzelona_list := TList.Create();
  wieloosobowe_amunicja_wystrzelona_list := TList.Create();

  informacje_dodatkowe_list := TList.Create();
  l¹d_list := TList.Create();
  trafienia_efekt_list := TList.Create();

  tcp_klienci_lista_g := TTCP_Klienci_Lista.Create();
  udp_klienci_lista_g := TUDP_Klienci_Lista.Create();

  pokój_rozmów_ostatnia_wiadomoœci_wys³ane_treœæ_string_list := TStringList.Create();

  Wczytaj_Schemat( katalog_schematy_lista__l¹dy_c, -1, l¹dy_lista_t );
  Wczytaj_Schemat( katalog_schematy_lista__statki_c, -1, statki_lista_t );
  Wczytaj_Schemat( katalog_schematy_lista__statki_pozycje_pocz¹tkowe_c, -1, statki_pozycje_pocz¹tkowe_lista_t );

  Ustawienia_Plik();

  if    ( L¹d_ComboBox.ItemIndex < 0 )
    and (  L¹d_ComboBox.Items.Count >= 1  ) then
    L¹d_ComboBox.ItemIndex := 0; // Nie wywo³a L¹d_ComboBoxChange().

  if    ( Statek_ComboBox.ItemIndex < 0 )
    and (  Statek_ComboBox.Items.Count >= 1  ) then
    Statek_ComboBox.ItemIndex := 0;


  Gra_Wspó³czynnik_Prêdkoœci_SpinEditChange( Sender );
  Celownik_Wielkoœæ_EditChange( Sender );
  Kamera_Szybkoœæ_Ruchu_EditChange( Sender );
  Mysz_Czu³oœæ_EditChange( Sender );
  Amunicja__Zanurzenie_G³êbokoœæ_Zadana_EditChange( Sender );
  Amunicja__Zanurzenie_G³êbokoœæ_Zadana_EditChange( Amunicja__Zanurzenie_G³êbokoœæ_Zadana__Skok_O_Edit );


  Czas_Bezwzglêdny_Timer.Enabled := true;
  Informacje_Dodatkowe_Timer.Enabled := true;
  Radar_Timer.Enabled := true;



  Statek__Utwórz_BitBtnClick( nil );


  Gracze_Lista_Odœwie¿();


  Klawiatura_Konfiguracja__Wczytaj_ButtonClick( Klawiatura_Konfiguracja__Przyciski_Panel );

  Pokój_Rozmów__Na_Ekranie_CheckBoxClick( Sender );


  Radar_0_GLSphere.Visible := false;
  Radar_L_GLCapsule.Visible := false;


  //tcp_klienci_lista_g.Dodaj_Aktualizuj( serwer_peer_port_c, -99 ); // Serwer ma peer_port_f i identyfikator_f = -1.
  //Elementy_Gry_Przygotuj();

  // test //???
//  Wieloosobowe__Pod³¹cz_BitBtnClick( Sender );
//  Gracz_Grupa_SpinEdit.Value := 1;
//  SI__Grupa_SpinEdit.Value := 1;
//  Gracz_Nazwa_Edit.Text := 'G1';
//  SI__Nazwa_Edit.Text := 'B1';
//  SI__Statek_ComboBox.ItemIndex := 2;
//  SI__Dodaj_BitBtnClick( Sender );
//
//  SI__Grupa_SpinEdit.Value := 2;
//  SI__Nazwa_Edit.Text := 'Ba1';
//  SI__Dodaj_BitBtnClick( Sender );
//  SI__Nazwa_Edit.Text := 'Ba2';
//  SI__Dodaj_BitBtnClick( Sender );
//  SI__Nazwa_Edit.Text := 'Ba3';
//  SI__Dodaj_BitBtnClick( Sender );
//
//  Gracz_Gotowoœæ_BitBtnClick( Gracz_Gotowoœæ_Tak_BitBtn );
//  Gra_Rozpocznij_BitBtnClick( Sender );

  //statek_gracza := TStatek.Create( Gra_Obiekty_GLDummyCube, Statki_Form.Gra_GLCollisionManager, 1, '', prymitywy_lista_t );
  //statek_gracza.id_statek := 1;
  //statek_gracza.Position.SetPoint( 20, 0, -8 );

  //statek_gracza.TurnAngle := -45;
  //statek_gracza.prêdkoœæ_procent := 90;
  //statek_gracza.prêdkoœæ_zadana_procent := 90;
  //
  //statki_t[ 1 ].prêdkoœæ_procent := 60;
  //statki_t[ 1 ].prêdkoœæ_zadana_procent := 60;
  //statki_t[ 1 ].TurnAngle := -30;
  //statki_t[ 1 ].Position.X := statki_t[ 1 ].Position.X - 3.5;

//  SetLength( statki_t, 1 );
//  statki_t[ 0 ] := TStatek.Create( Gra_Obiekty_GLDummyCube, Statki_Form.Gra_GLCollisionManager, 0, '', prymitywy_lista_t );
//  statki_t[ 0 ].id_statek := 1;
//  statek_gracza := statki_t[ 0 ];
//  //statek_gracza := nil; // Nie zmienia statki_t[ 0 ].


//  SetLength( statki_t, 2 );
//  statki_t[ 1 ] := TStatek.Create( Gra_Obiekty_GLDummyCube, Statki_Form.Gra_GLCollisionManager, 1, '', prymitywy_lista_t );
//  statki_t[ 1 ].id_statek := 2;
//  statki_t[ 1 ].Elementy_Gracza_Widocznoœæ( false );


  //Gra_GLCamera.TargetObject := statek_gracza;
  //GLNavigator1

  //Gra_GLSceneViewerClick( Sender );

  Gra_GLSceneViewer.Tag := 0;
  Gra_GLSceneViewerMouseDown( Sender, System.UITypes.TMouseButton.mbLeft, [ System.Classes.ssHorizontal ], 0, 0 ); // Ze wzglêdu na Gra_GLSceneViewer.Tag i ssHorizontal nie strzeli.

  //Kamera_Prze³¹cz( 1 = 10 ); //???
  // Z prawej strony w lewo.
//  Gra_GLCamera.Position.X := 2;
//  Gra_GLCamera.Position.Y := 2;
//  Gra_GLCamera.Position.Z := 4;
//  Gra_GLCamera.Direction.SetVector( -1, 0, 0 );

  // Z lewej strony w prawo.
//  Gra_GLCamera.Position.X := -3;
//  Gra_GLCamera.Position.Y := 2;
//  Gra_GLCamera.Position.Z := 0;
//  Gra_GLCamera.Direction.SetVector( 1, 0, 0 );

  // Z ty³u w przód.
//  Gra_GLCamera.Position.X := 4;
//  Gra_GLCamera.Position.Y := 1;
//  Gra_GLCamera.Position.Z := 6;
//  Gra_GLCamera.Direction.SetVector( 0, 0, -1 );

  // Z góry w dó³.
//  Gra_GLCamera.Position.X := 0;
//  Gra_GLCamera.Position.Y := 3;
//  Gra_GLCamera.Position.Z := 0;
//  Gra_GLCamera.Direction.SetVector( 0, -1, 0 );
//  Gra_GLCamera.RollAngle := 180;

//  GLLines1.AddNode( 0, 1, 0 ); // Bia³a.
//  GLLines1.AddNode( 0, 1, -2 );
//
//  GLLines2.AddNode( 0, 1.05, 0 ); // Zielona.
//  GLLines2.AddNode( 0, 1.05, 2 );
//
//  GLLines3.AddNode( 0, 1.1, 0 ); // Niebieska.
//  GLLines3.AddNode( 0, 1.1, 2 );

  GLLines1.AddNode( -1, 1, 0 ); // Bia³a.
  GLLines1.AddNode( -1, 1, 2 );

  GLLines2.AddNode( -1.05, 1, 0 ); // Zielona.
  GLLines2.AddNode( -1.05, 1, 2 );

  GLLines3.AddNode( -1.1, 1, 0 ); // Niebieska.
  GLLines3.AddNode( -1.1, 1, 2 );

  celowanie_tryb_g := ct_Punkt;

  Celowniczy_GLDummyCube.Position.SetPoint( -4, 0, -1 ); //???
  //statek_gracza.celownicza_linia.Nodes[ 1 ].AsAffineVector := Celowniczy_GLDummyCube.Position.AsAffineVector; //???

  Statki_Form.WindowState := wsMaximized; //???
  //Pokój_Rozmów_Memo.ReadOnly := false; //???

  //Wieloosobowe_Identyfikator_Edit.ReadOnly := false; //???

  // Dla 50 / 1 animacja jest w miarê p³ynna (wysy³ka albo odbiór).
  Serwer_Wysy³a_Timer.Interval := 50;
  Klient_IdTCP_Czyta_Timer.Interval := 100;
  Klient_IdUDP_Czyta_Timer.Interval := 1;

  //???
  //Serwer_Wysy³a_Timer.Interval := 600000;
  //Klient_IdTCP_Czyta_Timer.Interval := 3000;


//  Radar_Wielkoœæ_ButtonClick( Radar_Powiêksz_Button );
//  Radar_Wielkoœæ_ButtonClick( Radar_Powiêksz_Button );
//  Radar_Wielkoœæ_ButtonClick( Radar_Powiêksz_Button );
//  Radar_Wielkoœæ_ButtonClick( Radar_Powiêksz_Button );

end;//---//FormShow().

//FormClose().
procedure TStatki_Form.FormClose( Sender: TObject; var Action: TCloseAction );
var
  i : integer;
begin

  Informacje_Dodatkowe_Timer.Enabled := false;


  Pauza( true );

  Radar_Wyczyœæ( true );


  Gra_Zakoñcz_BitBtnClick( Sender );
  Wieloosobowe__Od³¹cz_BitBtnClick( Sender );


  Elementy_Gry_Zwolnij();


  SetLength( klawiatura_konfiguracja_r_t, 0 );
  Klawisz_Konfiguracja_Zwolnij();


  SetLength( gra_statystyki_r_t, 0 );
  SetLength( l¹dy_lista_t, 0 );
  SetLength( prymitywy_lista_t, 0 );
  SetLength( statki_lista_t, 0 );
  SetLength( statki_pozycje_pocz¹tkowe_lista_t, 0 );


  FreeAndNil( wieloosobowe_amunicja_efekt_g );

  FreeAndNil( amunicja_wystrzelona_list );
  FreeAndNil( wieloosobowe_amunicja_wystrzelona_list );

  FreeAndNil( l¹d_list );
  FreeAndNil( trafienia_efekt_list );

  FreeAndNil( tcp_klienci_lista_g );
  FreeAndNil( udp_klienci_lista_g );


  pokój_rozmów_ostatnia_wiadomoœci_wys³ane_treœæ_string_list.Clear();
  FreeAndNil( pokój_rozmów_ostatnia_wiadomoœci_wys³ane_treœæ_string_list );


  for i := informacje_dodatkowe_list.Count - 1 downto 0 do
    begin

      TInformacje_Dodatkowe(informacje_dodatkowe_list[ i ]).Free();
      informacje_dodatkowe_list.Delete( i );

    end;
  //---//for i := informacje_dodatkowe_list.Count - 1 downto 0 do

  FreeAndNil( informacje_dodatkowe_list );


  for i := 0 to Pokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj_ComboBox.Items.Count - 1 do
    TPokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj(Pokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj_ComboBox.Items.Objects[ i ]).Free();

  Pokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj_ComboBox.Clear();

end;//---//FormClose().

//FormResize().
procedure TStatki_Form.FormResize( Sender: TObject );
var
  zti : integer;
begin

  Radar_Panel.Height := Round( Gra_GLSceneViewer.Height * Radar_Panel.Tag * 0.01 );
  Radar_Panel.Top := Gra_GLSceneViewer.Height - Radar_Panel.Height;

  Radar_Panel.Width := Radar_Panel.Height;


  if Pokój_Rozmów_GroupBox.Parent = Statki_Form then
    begin

      if Radar_Panel.Visible then
        zti := Radar_Panel.Height
      else//if Radar_Panel.Visible then
        zti := 0;

      Pokój_Rozmów_GroupBox.Top := Gra_GLSceneViewer.Height - zti - Pokój_Rozmów_GroupBox.Height - 10;

    end;
  //---//if Pokój_Rozmów_GroupBox.Parent = Statki_Form then

end;//---//FormResize().

//Gra_GLSceneViewerExit().
procedure TStatki_Form.Gra_GLSceneViewerExit( Sender: TObject );
begin

  Gra_GLSceneViewer.Tag := 0;

end;//---//Gra_GLSceneViewerExit().

//Gra_GLSceneViewerClick().
procedure TStatki_Form.Gra_GLSceneViewerClick(Sender: TObject);
begin

  //if not Gra_GLSceneViewer.Focused then
  //  Gra_GLSceneViewer.SetFocus();

end;//---//Gra_GLSceneViewerClick().

//Gra_GLSceneViewerMouseDown().
procedure TStatki_Form.Gra_GLSceneViewerMouseDown( Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer );
var
  zt_statek : TStatek;
  Selected : TGLSceneObject;
begin

  if not Gra_GLSceneViewer.Focused then
    Gra_GLSceneViewer.SetFocus();

  if Gra_GLSceneViewer.Tag = 0 then
    begin

      // Aby pierwsze klikniêcie mysz¹ nie wywo³ywa³o akcji obs³ugi klawiszy (gdy zmienia siê skupienie).

      Gra_GLSceneViewer.Tag := 1;
      Exit;

    end;
  //---//if Gra_GLSceneViewer.Tag = 0 then


  //if not czy_pauza_g then
    begin

      //// Pauza nie jest ca³kowicie aktywna (nie wszystkie klawisze s¹ obs³ugiwane podczas pauzy).
      // Mo¿e lepiej aby pauza by³a aktywna.

      if statek_gracza <> nil then
        Statek_Klawisze_Obs³uga( statek_gracza.id_statek, 0, Word(Button), Shift, Amunicja_Rodzaj_Zbiór_Zwróæ() );


      Klawisze_Obs³uga_Zachowanie_Ci¹g³e( 0.15, Shift, Word(Button) ); // Na wypadek gdyby przypisano np. ruch kamery pod przycisk myszy.

    end;
  //---//if not czy_pauza_g then


  if czy_pauza_g then
    Napis_Odœwie¿();


  if not Projektowy_Tryb_CheckBox.Checked then
    Exit;


  Selected := nil;

  if ( Gra_GLSceneViewer.Buffer.GetPickedObject( x, y ) is TGLSceneObject ) then
    Selected := ( Gra_GLSceneViewer.Buffer.GetPickedObject( x, y ) as TGLSceneObject );

  if Selected <> nil then
    begin

      zt_statek := Statek_ZnajdŸ( Selected.Owner );


      if zt_statek <> nil then
        begin

          projektowy_tryb__statek := zt_statek;
          Log_Wypisz(  'Tryb projektowy - id_statek: ' + IntToStr( projektowy_tryb__statek.id_statek ) + '.'  );

        end
      else//if zt_statek <> nil then
        Log_Wypisz( 'Tryb projektowy - nie odnaleziono statku.' );

    end;
  //---//if Selected <> nil then

end;//---//Gra_GLSceneViewerMouseDown().

//Gra_GLSceneViewerMouseWheel().
procedure TStatki_Form.Gra_GLSceneViewerMouseWheel( Sender: TObject; Shift: TShiftState; WheelDelta: Integer; MousePos: TPoint; var Handled: Boolean );
var
  zti,
  luneta_zasiêg_l
    : integer;
  ztr : real;
const
  kamera_ogniskowa_domyœlna_l_c : single = 50;
begin

  if Gra_GLCamera.Parent = Gra_GLScene.Objects then
    begin

      // Kamera za statkiem.

      if WheelDelta >= 0 then
        //Gra_GLCamera.Position.Z := Gra_GLCamera.Position.Z
        Gra_GLCamera.Move( 1 )
      else//if WheelDelta >= 0 then
        //Gra_GLCamera.Position.Z := Gra_GLCamera.Position.Z;
        Gra_GLCamera.Move( -1 );

    end
  else//if Gra_GLCamera.Parent = Gra_GLScene.Objects then
    begin

      // Kamera na statku.

      // Okreœla rz¹d wielkoœci aktualnej wartoœci przybli¿enia (jak szybko zmienia siê przybli¿enie lunety).
      zti := Round( Gra_GLCamera.FocalLength );

      if WheelDelta < 0 then
        dec( zti );

      zti := Length(  IntToStr( zti )  ) - 1;
      zti := Round(  Power( 10, zti )  );
      //---// Okreœla rz¹d wielkoœci aktualnej wartoœci przybli¿enia (jak szybko zmienia siê przybli¿enie lunety).


      if statek_gracza <> nil then
        luneta_zasiêg_l := statek_gracza.luneta_zasiêg
      else//if statek_gracza <> nil then
        luneta_zasiêg_l := 600;


      if WheelDelta >= 0 then
        begin

          // Przybli¿anie.

          if Gra_GLCamera.FocalLength < luneta_zasiêg_l then
            Gra_GLCamera.FocalLength := Gra_GLCamera.FocalLength + zti
          else//if Gra_GLCamera.FocalLength < luneta_zasiêg_l then
            Gra_GLCamera.FocalLength := luneta_zasiêg_l;


          if Gra_GLCamera.FocalLength > luneta_zasiêg_l then
            Gra_GLCamera.FocalLength := luneta_zasiêg_l;

        end
      else//if WheelDelta >= 0 then
        begin

          // Oddalanie.

          if Gra_GLCamera.FocalLength > kamera_ogniskowa_domyœlna_l_c then
            Gra_GLCamera.FocalLength := Gra_GLCamera.FocalLength - zti
          else//if Gra_GLCamera.FocalLength > kamera_ogniskowa_domyœlna_l_c then
            Gra_GLCamera.FocalLength := kamera_ogniskowa_domyœlna_l_c;


          if Gra_GLCamera.FocalLength < kamera_ogniskowa_domyœlna_l_c then
            Gra_GLCamera.FocalLength := kamera_ogniskowa_domyœlna_l_c;

        end;
      //---//if WheelDelta >= 0 then


      // Modyfikuje czu³oœæ myszy zale¿nie od procentu przybli¿enia lunety (100% przybli¿enia – najwolniejszy ruch).
      zti := Round( luneta_zasiêg_l - kamera_ogniskowa_domyœlna_l_c ); // Zakres zmiany ogniskowej kamery.
      ztr := mysz_czu³oœæ_g - mysz_czu³oœæ_luneta_g; // Zakres zmiany prêdkoœci myszy.

      if zti = 0 then
        zti := 1; // Aby nie by³o dzielenie przez zero.

      Gra_GLUserInterface.MouseSpeed :=
          mysz_czu³oœæ_g
        - ztr
        * (  ( Gra_GLCamera.FocalLength - kamera_ogniskowa_domyœlna_l_c ) * 100 / zti  ) // Aktualny procent przybli¿enia lunety.
        * 0.01;

      if Gra_GLUserInterface.MouseSpeed < mysz_czu³oœæ_luneta_g then
        Gra_GLUserInterface.MouseSpeed := mysz_czu³oœæ_luneta_g;
      //---// Modyfikuje czu³oœæ myszy zale¿nie od procentu przybli¿enia lunety (100% przybli¿enia – najwolniejszy ruch).

    end;
  //---//if Gra_GLCamera.Parent = Gra_GLScene.Objects then

end;//---//Gra_GLSceneViewerMouseWheel().

//Gra_GLSceneViewerMouseMove().
procedure TStatki_Form.Gra_GLSceneViewerMouseMove( Sender: TObject; Shift: TShiftState; X, Y: Integer );
begin

  if    ( czy_pauza_g )
    and ( Gra_GLSceneViewer.Focused ) then
    begin

      Gra_GLUserInterface.MouseLook();
      Gra_GLUserInterface.MouseUpdate();
      Gra_GLSceneViewer.Invalidate();

    end;
  //---//if    ( czy_pauza_g ) (...)

end;//---//Gra_GLSceneViewerMouseMove().

//Gra_GLSceneViewerKeyDown().
procedure TStatki_Form.Gra_GLSceneViewerKeyDown( Sender: TObject; var Key: Word; Shift: TShiftState );

  //Funkcja Klawisz_Wciœniêto_SprawdŸ_l() w Gra_GLSceneViewerKeyDown().
  function Klawisz_Wciœniêto_SprawdŸ_l( const klawiatura_konfiguracja_r_f : TKlawiatura_Konfiguracja_r ) : boolean;
  begin

    Result := Klawisz_Wciœniêto_SprawdŸ( klawiatura_konfiguracja_r_f, Key, -1, Shift );

  end;//---//Funkcja Klawisz_Wciœniêto_SprawdŸ_l() w Gra_GLSceneViewerKeyDown().

var
  klawisz_l : word;
begin//Gra_GLSceneViewerKeyDown().

  //if Key = VK_ESCAPE then
  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__zamknij_program ) then
    begin

      Gra_GLCadencer.Enabled := false;
      Close();

    end;
  //---//if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__zamknij_program ) then


  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__mouse_look_active ) then
    begin

      Gra_GLUserInterface.MouseLookActive := not Gra_GLUserInterface.MouseLookActive;


      if    ( Gra_GLUserInterface.MouseLookActive )
        and ( Celownik_Widocznoœæ_Mouse_Look_Active_CheckBox.Checked )
        and ( not Celownik_Widocznoœæ_CheckBox.Checked ) then
        begin

          Celownik_Widocznoœæ_Mouse_Look_Active_CheckBox.Tag := 1;
          Celownik_Widocznoœæ_CheckBox.Checked := true;

        end
      else//if    ( Gra_GLUserInterface.MouseLookActive ) (...)
      if    ( not Gra_GLUserInterface.MouseLookActive )
        and ( Celownik_Widocznoœæ_Mouse_Look_Active_CheckBox.Checked )
        and ( Celownik_Widocznoœæ_CheckBox.Checked )
        and ( Celownik_Widocznoœæ_Mouse_Look_Active_CheckBox.Tag = 1 ) then
        begin

          Celownik_Widocznoœæ_Mouse_Look_Active_CheckBox.Tag := 0;
          Celownik_Widocznoœæ_CheckBox.Checked := false;

        end;
      //---//if    ( not Gra_GLUserInterface.MouseLookActive ) (...)

    end;
  //---//if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__mouse_look_active ) then


  if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__opcje ) then
    begin

      if PageControl1.Width > 1 then
        begin

          if not Pe³ny_Ekran_CheckBox.Checked then
            PageControl1.Width := 1
          else//if not Pe³ny_Ekran_CheckBox.Checked then
            begin

              PageControl1.Width := 0;
              Opcje_Pionowy_Splitter.Visible := not Pe³ny_Ekran_CheckBox.Checked;

            end;
          //---//if not Pe³ny_Ekran_CheckBox.Checked then

        end
      else//if PageControl1.Width > 1 then
        begin

          if not Opcje_Pionowy_Splitter.Visible then
            Opcje_Pionowy_Splitter.Visible := true;


          PageControl1.Width := Round( Self.Width * 0.2 );

          if PageControl1.Width < 350 then
            PageControl1.Width := Round( Self.Width * 0.35 );

        end;
      //---//if PageControl1.Width > 1 then

    end;
  //---//if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__opcje ) then


  //if Key = Ord( 'P' ) then
  if    (  Klawisz_Wciœniêto_SprawdŸ_l( klawisz__pauza )  )
    and ( not czy_klient_g ) then
    begin

      Pauza( not czy_pauza_g );

      if czy_pauza_g then
        Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__pauza_c, -99, 'Tak' )
      else//if czy_pauza_g then
        Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__pauza_c, -99, 'Nie' );

    end;
  //---//if    (  Klawisz_Wciœniêto_SprawdŸ_l( klawisz__pauza )  ) (...)


//  if    (  Key = Ord( 'S' )  )
//    and ( ssAlt in Shift ) then
//    Wieloosobowe__Tryb_RadioGroup.Visible := not Wieloosobowe__Tryb_RadioGroup.Visible;


  //if not czy_pauza_g then
    begin

      //// Pauza nie jest ca³kowicie aktywna (nie wszystkie klawisze s¹ obs³ugiwane podczas pauzy).
      // Mo¿e lepiej aby pauza by³a aktywna.


      if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__amunicja__zanurzenie_g³êbokoœæ_zadana__plus ) then
        begin

          klawisz_l := VK_UP;
          Edit_Jako_Spin_KeyDown( Amunicja__Zanurzenie_G³êbokoœæ_Zadana_Edit, klawisz_l, [] );

        end;
      //---//if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__amunicja__zanurzenie_g³êbokoœæ_zadana__plus ) then

      if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__amunicja__zanurzenie_g³êbokoœæ_zadana__minus ) then
        begin

          klawisz_l := VK_DOWN;
          Edit_Jako_Spin_KeyDown( Amunicja__Zanurzenie_G³êbokoœæ_Zadana_Edit, klawisz_l, [] );

        end;
      //---//if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__amunicja__zanurzenie_g³êbokoœæ_zadana__minus ) then


      if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__celowanie_tryb ) then
        if Celowanie_Tryb_RadioGroup.ItemIndex = 0 then
          Celowanie_Tryb_RadioGroup.ItemIndex := 1
        else//if Celowanie_Tryb_RadioGroup.ItemIndex = 0 then
          Celowanie_Tryb_RadioGroup.ItemIndex := 0;

      if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__celownik_widocznoœæ ) then
        Celownik_Widocznoœæ_CheckBox.Checked := not Celownik_Widocznoœæ_CheckBox.Checked;

      if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__celownik_widocznoœæ_mouse_look_active ) then
        begin

          Celownik_Widocznoœæ_Mouse_Look_Active_CheckBox.Checked := not Celownik_Widocznoœæ_Mouse_Look_Active_CheckBox.Checked;

          if Celownik_Widocznoœæ_Mouse_Look_Active_CheckBox.Checked then
            Informacja_Dodatkowa_Dodaj( 'Wyœwietlaj celownik w trybie obracania kamery mysz¹.', 3 )
          else//if Celownik_Widocznoœæ_Mouse_Look_Active_CheckBox.Checked then
            Informacja_Dodatkowa_Dodaj( 'Nie wyœwietlaj celownika w trybie obracania kamery mysz¹.', 3 );

        end;
      //---//if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__celownik_widocznoœæ_mouse_look_active ) then


      if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__dalmierz ) then
        Dalmierz_CheckBox.Checked := not Dalmierz_CheckBox.Checked;


      if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__kamera__Amunicja ) then
        Kamera_Prze³¹cz( kt_Amunicja );

      if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__kamera__Artyleria ) then
        Kamera_Prze³¹cz( kt_Artyleria );

      if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__kamera__Statek ) then
        Kamera_Prze³¹cz( kt_Statek );

      if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__kamera__Swobodna ) then
        Kamera_Prze³¹cz( kt_Swobodna );

      if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__kamera__Za_Statkiem ) then
        Kamera_Prze³¹cz( kt_Za_Statkiem );


      if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__obrót_k¹t_zablokowany_wskaŸnik ) then
        Obrót_K¹t_Zablokowany_WskaŸnik_CheckBox.Checked := not Obrót_K¹t_Zablokowany_WskaŸnik_CheckBox.Checked;

      if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__obrót_k¹t_zablokowany_strza³_wskaŸnik ) then
        Obrót_K¹t_Zablokowany_Strza³_WskaŸnik_CheckBox.Checked := not Obrót_K¹t_Zablokowany_Strza³_WskaŸnik_CheckBox.Checked;


      if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__pe³ny_ekran ) then
        Pe³ny_Ekran_CheckBox.Checked := not Pe³ny_Ekran_CheckBox.Checked;


      if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__pokój_rozmów__na_ekranie ) then
        Pokój_Rozmów__Na_Ekranie_CheckBox.Checked := not Pokój_Rozmów__Na_Ekranie_CheckBox.Checked;

      if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__pokój_rozmów__informacja_dodatkowa ) then
        Pokój_Rozmów__Informacja_Dodatkowa_CheckBox.Checked := not Pokój_Rozmów__Informacja_Dodatkowa_CheckBox.Checked;


      if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__punkty_¿ycia_wskaŸnik__gracz ) then
        Punkty_¯ycia_WskaŸnik__Gracz_CheckBox.Checked := not Punkty_¯ycia_WskaŸnik__Gracz_CheckBox.Checked;

      if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__punkty_¿ycia_wskaŸnik__przeciwnik ) then
        Punkty_¯ycia_WskaŸnik__Przeciwnik_CheckBox.Checked := not Punkty_¯ycia_WskaŸnik__Przeciwnik_CheckBox.Checked;

      if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__punkty_¿ycia_wskaŸnik__sojusznik ) then
        Punkty_¯ycia_WskaŸnik__Sojusznik_CheckBox.Checked := not Punkty_¯ycia_WskaŸnik__Sojusznik_CheckBox.Checked;


      if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__projektowy_tryb__w³¹cz_wy³¹cz ) then
        Projektowy_Tryb_CheckBox.Checked := not Projektowy_Tryb_CheckBox.Checked;


      if    (  Klawisz_Wciœniêto_SprawdŸ_l( klawisz__strzelaj_z__artyleria )  )
        and ( ar_Artyleria_CheckBox.Enabled ) then
        ar_Artyleria_CheckBox.Checked := not ar_Artyleria_CheckBox.Checked;

      if    (  Klawisz_Wciœniêto_SprawdŸ_l( klawisz__strzelaj_z__pocisk )  )
        and ( ar_Pocisk_CheckBox.Enabled ) then
        ar_Pocisk_CheckBox.Checked := not ar_Pocisk_CheckBox.Checked;

      if    (  Klawisz_Wciœniêto_SprawdŸ_l( klawisz__strzelaj_z__torpeda )  )
        and ( ar_Torpeda_CheckBox.Enabled ) then
        ar_Torpeda_CheckBox.Checked := not ar_Torpeda_CheckBox.Checked;

      if    (  Klawisz_Wciœniêto_SprawdŸ_l( klawisz__strzelaj_z__wszystkie )  )
        and ( ar_Wszystkie_CheckBox.Enabled ) then
        ar_Wszystkie_CheckBox.Checked := not ar_Wszystkie_CheckBox.Checked;


      if not czy_klient_g then
        begin

          if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__gra_wspó³czynnik_prêdkoœci__plus ) then
            Gra_Wspó³czynnik_Prêdkoœci_SpinEdit.Value := Gra_Wspó³czynnik_Prêdkoœci_SpinEdit.Value + Gra_Wspó³czynnik_Prêdkoœci_SpinEdit.Increment;

          if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__gra_wspó³czynnik_prêdkoœci__normalna ) then
            Gra_Wspó³czynnik_Prêdkoœci_SpinEdit.Value := 100;

          if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__gra_wspó³czynnik_prêdkoœci__minus ) then
            Gra_Wspó³czynnik_Prêdkoœci_SpinEdit.Value := Gra_Wspó³czynnik_Prêdkoœci_SpinEdit.Value - Gra_Wspó³czynnik_Prêdkoœci_SpinEdit.Increment;


          if    (  Klawisz_Wciœniêto_SprawdŸ_l( klawisz__l¹d_odœwie¿_wskazany )  )
            and ( L¹d_GroupBox.Enabled ) then
            L¹d__Odœwie¿_Wskazany_BitBtnClick( Sender );


          if    (  Klawisz_Wciœniêto_SprawdŸ_l( klawisz__statek__utwórz )  )
            and ( Statek_GroupBox.Enabled ) then
            Statek__Utwórz_BitBtnClick( Sender );

        end;
      //---//if not czy_klient_g then



      if statek_gracza <> nil then
        Statek_Klawisze_Obs³uga( statek_gracza.id_statek, Key, -1, Shift, Amunicja_Rodzaj_Zbiór_Zwróæ() );

    end;
  //else//if not czy_pauza_g then


  {$region 'Przesuwanie statków (w trybie projektowym).'}
  if Projektowy_Tryb_CheckBox.Checked then
    begin

      if projektowy_tryb__statek <> nil then
        begin

          if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__projektowy_tryb__statek__prêdkoœæ_zadana_0_100 ) then
            begin

              if projektowy_tryb__statek.prêdkoœæ_procent <> 0 then
                begin

                  projektowy_tryb__statek.prêdkoœæ_procent := 0;

                end
              else//if projektowy_tryb__statek.prêdkoœæ_procent <> 0 then
                begin

                  projektowy_tryb__statek.prêdkoœæ_procent := 100;

                end;
              //---//if projektowy_tryb__statek.prêdkoœæ_procent <> 0 then

              projektowy_tryb__statek.prêdkoœæ_zadana_procent := projektowy_tryb__statek.prêdkoœæ_procent;

            end;
          //---//if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__projektowy_tryb__statek__prêdkoœæ_zadana_0_100 ) then


          if Klawisz_Wciœniêto_SprawdŸ_l( klawisz__projektowy_tryb__statek___resetuj_obrót ) then
            projektowy_tryb__statek.ResetRotations();

        end;
      //---//if projektowy_tryb__statek <> nil then

    end;
  //---//if Projektowy_Tryb_CheckBox.Checked then
  {$endregion 'Przesuwanie statków (w trybie projektowym).'}


  if czy_pauza_g then
    begin

      if Gra_GLSceneViewer.Focused then
        begin

          Klawisze_Obs³uga_Zachowanie_Ci¹g³e( 0.15 ); // Aby w trakcie pauzy równie¿ wykonywane by³y zachowania klawiszy.

        end;
      //---//if Gra_GLSceneViewer.Focused then


      Napis_Odœwie¿();

    end;
  //---//if czy_pauza_g then

end;//---//Gra_GLSceneViewerKeyDown().

//Gra_GLCadencerProgress().
procedure TStatki_Form.Gra_GLCadencerProgress( Sender: TObject; const deltaTime, newTime: Double );
begin

  Klawisze_Obs³uga_Zachowanie_Ci¹g³e( deltaTime * 5 );


  if Gra_GLSceneViewer.Focused then
    begin

      Gra_GLUserInterface.MouseLook();
      Gra_GLUserInterface.MouseUpdate();
      Gra_GLSceneViewer.Invalidate();

    end;
  //---//if Gra_GLSceneViewer.Focused then


  if not czy_klient_g then //???
    Gra_GLCollisionManager.CheckCollisions(); //???


  Statki_Ruch( deltaTime );

  Lufy_Prze³adowanie( deltaTime );


  Trafienia_Efekt_Czas_Trwania_SprawdŸ();


  Napis_Odœwie¿();


  Celownicza_Kula_Zmieñ_Pozycjê();


  Kamera_Odleg³oœæ_Kontroluj_Ustaw( deltaTime );

  //statek_gracza.artyleria_t[ 0 ].Podniesienie_Zadane_Zmieñ(); //???
  //statek_gracza.artyleria_t[ 0 ].Podniesienie_Kierunek_Zmieñ( Celowanie_Precyzja_Podniesienie_SpinEdit.Value ); //???

//  GLLines1.Nodes[ 1 ].X := -Gra_GLCamera.AbsoluteDirection.X;
//  GLLines1.Nodes[ 1 ].Z := -Gra_GLCamera.AbsoluteDirection.Z;

  //GLLines3.Nodes[ 1 ].X := statek_gracza.AbsoluteDirection.X;
  //GLLines3.Nodes[ 1 ].Z := statek_gracza.AbsoluteDirection.Z;


  GLLines1.Nodes[ 1 ].Y := 1 + Gra_GLCamera.AbsoluteDirection.Y;
//  GLLines1.Nodes[ 1 ].Z := -Gra_GLCamera.AbsoluteDirection.Z;

  //GLLines3.Nodes[ 1 ].AsAffineVector := Celownicza_GLSphere.Position.AsAffineVector;


//  Wieloosobowe_Statki_Parametry_Odczytaj();
//  Wieloosobowe_Statki_Parametry_Ustaw();


  //Wieloosobowe_Amunicja_Parametry_Odczytaj();
  //Wieloosobowe_Amunicja_Parametry_Ustaw();



  //GLCylinder1.AbsoluteDirection := Gra_GLCamera.AbsoluteDirection;
  //GLCylinder1.Up := Gra_GLCamera.Up;

  //GLArrowLine_¯ó³ta.Direction := statki_t[ 0 ].torpedy_wyrzutnie_t[ 0 ].lufy_t[ 0 ].Direction;
  //if    (  Length( statki_t ) > 0  )
  //  and (  Length( statki_t[ 0 ].torpedy_wyrzutnie_t ) > 0  ) then
  //  GLArrowLine_Zielona.Direction.AsVector := statki_t[ 0 ].torpedy_wyrzutnie_t[ 0 ].lufy_t[ 0 ].AbsoluteDirection;
  //
  //if amunicja_wystrzelona_list.Count > 0 then
  //  GLArrowLine_¯ó³ta.Direction.AsVector := TAmunicja(amunicja_wystrzelona_list[ 0 ]).korpus_ustawienie_pocz¹tkowe_dummy.AbsoluteDirection;

//X_Lewo_GLCube.AbsoluteDirection := VectorSubtract( Gra_GLCamera.AbsoluteDirection, X_Lewo_GLCube.AbsolutePosition );

end;//---//Gra_GLCadencerProgress().

//Gra_GLCollisionManagerCollision().
procedure TStatki_Form.Gra_GLCollisionManagerCollision( Sender: TObject; object1, object2: TGLBaseSceneObject );

  //Funkcja Oznacz_Kolizjê() w Gra_GLCollisionManagerCollision().
  function Oznacz_Kolizjê( object_1_f, object_2_f : TGLBaseSceneObject ) : boolean;

    //Funkcja Kolizja_Statek_Statek_Przelicz() Oznacz_Kolizjê() w Gra_GLCollisionManagerCollision().
    procedure Kolizja_Statek_Statek_Przelicz( statek_1_f, statek_2_f : TStatek; gl_base_scene_object_1_f, gl_base_scene_object_2_f : TGLBaseSceneObject );
    var
      zti_l : integer;
      ztr_l,
      ztr_kopia,
      k¹t_miêdzy_statkami_l,
      k¹t_œredni_miêdzy_statkami_l,
      k¹t_wspó³czynnik_l, // Zale¿nie od k¹ta miêdzy statkami modyfikuje obliczenia; 1 - silne uderzenie, 0.01 - lekkie uderzenie (statki œlizgaj¹ siê po sobie i obracaj¹).
      punkty_¿ycia_kopia_l_l
        : real;
      zt_vector_1,
      zt_vector_2
        : GLVectorGeometry.TVector;
    begin

      //
      // Funkcja przelicza skutki zderzenia dwóch statków.
      //
      // Parametry:
      //   statek_1_f
      //   statek_2_f
      //   gl_base_scene_object_1_f - element pierwszego statku, który uczestniczy w kolizji.
      //   gl_base_scene_object_2_f - element drugiego statku, który uczestniczy w kolizji.
      //

      {$region 'Wylicza k¹t miêdzy statkami i wspó³czynnik k¹ta.'}
      if statek_1_f.prêdkoœæ_aktualna < 0 then
        zt_vector_1 := GLVectorGeometry.VectorNegate( statek_1_f.AbsoluteDirection )
      else//if statek_1_f.prêdkoœæ_aktualna < 0 then
        zt_vector_1 := statek_1_f.AbsoluteDirection;

      if statek_2_f.prêdkoœæ_aktualna < 0 then
        zt_vector_2 := GLVectorGeometry.VectorNegate( statek_2_f.AbsoluteDirection )
      else//if statek_1_f.prêdkoœæ_aktualna < 0 then
        zt_vector_2 := statek_2_f.AbsoluteDirection;


      k¹t_miêdzy_statkami_l := //180 - // Je¿eli chce siê sprawdziæ drug¹ czêœæ k¹ta.
        RadToDeg( // uses Math.
            AngleBetweenVectors( // uses GLVectorGeometry.
               zt_vector_1,
               zt_vector_2,
               GLVectorGeometry.VectorMake( 0, 0, 0 )
             )
          );

      //Statki_Form.Caption := FloatToStr( k¹t_miêdzy_statkami_l );

      if    ( k¹t_miêdzy_statkami_l > 45 )
        and ( k¹t_miêdzy_statkami_l < 135 ) then
        k¹t_wspó³czynnik_l := 1 // Uderzenie z boku.
      else//if    ( k¹t_miêdzy_statkami_l > 45 ) (...)
        begin

          // Uderzenie z przodu lub z ty³u.

          if   (
                     ( statek_1_f.prêdkoœæ_aktualna = 0 ) // Jeden statek p³ynie, a drugi stoi.
                 and ( statek_2_f.prêdkoœæ_aktualna <> 0 )
               )
            or (
                     ( statek_1_f.prêdkoœæ_aktualna <> 0 ) // Jeden statek p³ynie, a drugi stoi.
                 and ( statek_2_f.prêdkoœæ_aktualna = 0 )
               )
            or (
                     ( k¹t_miêdzy_statkami_l > 150 ) // P³yn¹ w przeciwnych kierunkach.
                 and (  Sign( statek_1_f.prêdkoœæ_aktualna ) = Sign( statek_2_f.prêdkoœæ_aktualna )  )
               )
            or (
                     ( k¹t_miêdzy_statkami_l < 30 ) // Jeden ze statków cofa a drugi nie.
                 and (  Sign( statek_1_f.prêdkoœæ_aktualna ) <> Sign( statek_2_f.prêdkoœæ_aktualna )  )
               ) then
            k¹t_wspó³czynnik_l := 1
          else//if Sign( statek_1_f.prêdkoœæ_aktualna ) <> Sign( statek_1_f.prêdkoœæ_aktualna ) then
            k¹t_wspó³czynnik_l := 0.01

        end;
      //---//if    ( k¹t_miêdzy_statkami_l > 45 ) (...)

      //Statki_Form.Caption := FloatToStr( k¹t_wspó³czynnik_l );
      {$endregion 'Wylicza k¹t miêdzy statkami i wspó³czynnik k¹ta.'}


      {$region 'Oznacza kolizjê, wyœwietla efekt, nalicza obra¿enia.'}
      if    (
                 (  Abs( statek_1_f.prêdkoœæ_procent ) > kolizja_oznaczanie_prêdkoœæ_procent_c  )
              or (  Abs( statek_2_f.prêdkoœæ_procent ) > kolizja_oznaczanie_prêdkoœæ_procent_c  )
            )
        and (   not Statki_Kolizja_Oznaczenie_SprawdŸ(  statek_1_f.kolizja_oznaczenie_string_list, IntToStr( statek_2_f.id_statek )  )   )
        and (   not Statki_Kolizja_Oznaczenie_SprawdŸ(  statek_2_f.kolizja_oznaczenie_string_list, IntToStr( statek_1_f.id_statek )  )   ) then
        begin

          //TGLCube(gl_base_scene_object_1_f).Material.FrontProperties.Emission.SetColor( 0, 1, 0 ); // Test. //???
          //TGLCube(gl_base_scene_object_2_f).Material.FrontProperties.Emission.SetColor( 0, 1, 0 ); // Test. //???
          //Statki_Form.Caption := Statki_Form.Caption + '*';


          statek_1_f.kolizja_oznaczenie_string_list.Add(  IntToStr( statek_2_f.id_statek ) + '|' + IntToStr( Czas_Teraz() )  );
          statek_2_f.kolizja_oznaczenie_string_list.Add(  IntToStr( statek_1_f.id_statek ) + '|' + IntToStr( Czas_Teraz() )  );

          Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_L¹d, gl_base_scene_object_1_f.AbsolutePosition.X, gl_base_scene_object_1_f.AbsolutePosition.Y, gl_base_scene_object_1_f.AbsolutePosition.Z, nil, -1, -1 );
          Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_L¹d, gl_base_scene_object_2_f.AbsolutePosition.X, gl_base_scene_object_2_f.AbsolutePosition.Y, gl_base_scene_object_2_f.AbsolutePosition.Z, nil, -1, -1 );


          // Obra¿enia dla statku drugiego (zadaje statek pierwszy).
          //if gl_base_scene_object_1_f.Tag <> 1 then
          //  statek_2_f.Punkty_¯ycia_Zmieñ( -statek_2_f.punkty_¿ycia_maksymalne * 0.1 )
          //else
          //if Abs( statek_1_f.prêdkoœæ_procent ) > kolizja_oznaczanie_prêdkoœæ_procent_c * 2 then
          if    (  gl_base_scene_object_1_f.Tag = 1  ) // Czy uderzono dziobem (czêœci¹ taranuj¹c¹ - wzmocnion¹).
            and (  Abs( statek_1_f.prêdkoœæ_procent ) > kolizja_oznaczanie_prêdkoœæ_procent_c * 2  ) then
            ztr_l :=
                -statek_2_f.punkty_¿ycia_maksymalne * 0.1 // 10% z punktów ¿ycia.
              * Abs( statek_1_f.prêdkoœæ_procent ) * 0.5 * 0.1 // 10% z po³owy prêdkoœci.
          else//if    (  gl_base_scene_object_1_f.Tag = 1  ) (...)
            ztr_l := -statek_2_f.punkty_¿ycia_maksymalne * 0.1 * k¹t_wspó³czynnik_l;

          punkty_¿ycia_kopia_l_l := statek_2_f.punkty_¿ycia;
          ztr_kopia := ztr_l;

          statek_2_f.Punkty_¯ycia_Zmieñ( ztr_l );

          zti_l := Gra_Statystyki_R_Identyfikator_ZnajdŸ( statek_1_f.id_statek );

          if zti_l >= 0 then
            begin

              gra_statystyki_r_t[ zti_l ].taranowania_iloœæ := gra_statystyki_r_t[ zti_l ].taranowania_iloœæ + 1;
              gra_statystyki_r_t[ zti_l ].obra¿enia_zadane_taranowanie := gra_statystyki_r_t[ zti_l ].obra¿enia_zadane_taranowanie - ztr_l; // Wartoœæ jest ujemna.

              if statek_1_f.id_grupa = statek_2_f.id_grupa then
                begin

                  gra_statystyki_r_t[ zti_l ].taranowania_iloœæ_sojuszników := gra_statystyki_r_t[ zti_l ].taranowania_iloœæ_sojuszników + 1;
                  gra_statystyki_r_t[ zti_l ].obra¿enia_zadane_taranowanie_sojusznikom := gra_statystyki_r_t[ zti_l ].obra¿enia_zadane_taranowanie_sojusznikom - ztr_l; // Wartoœæ jest ujemna.

                end;
              //---//if statek_1_f.id_grupa = statek_2_f.id_grupa then

              if    ( punkty_¿ycia_kopia_l_l > 0 )
                and ( statek_2_f.punkty_¿ycia <= 0 ) then
                begin

                  gra_statystyki_r_t[ zti_l ].zatopienia := gra_statystyki_r_t[ zti_l ].zatopienia + 1;

                  if statek_1_f.id_grupa = statek_2_f.id_grupa then
                    gra_statystyki_r_t[ zti_l ].zatopienia_sojuszników := gra_statystyki_r_t[ zti_l ].zatopienia_sojuszników + 1;

                end;
              //---//if    ( punkty_¿ycia_kopia_l_l > 0 ) (...)

            end;
          //---//if zti_l >= 0 then


          // Obra¿enia dla statku pierwszego (zadaje statek drugi).
          if    (  gl_base_scene_object_2_f.Tag = 1  ) // Czy uderzono dziobem (czêœci¹ taranuj¹c¹ - wzmocnion¹).
            and (  Abs( statek_2_f.prêdkoœæ_procent ) > kolizja_oznaczanie_prêdkoœæ_procent_c * 2  ) then
            ztr_l :=
                -statek_1_f.punkty_¿ycia_maksymalne * 0.1 // 10% z punktów ¿ycia.
              * Abs( statek_2_f.prêdkoœæ_procent ) * 0.5 * 0.1 // 10% z po³owy prêdkoœci.
          else//if    (  gl_base_scene_object_2_f.Tag = 1  ) (...)
            ztr_l := -statek_1_f.punkty_¿ycia_maksymalne * 0.1 * k¹t_wspó³czynnik_l;

          punkty_¿ycia_kopia_l_l := statek_1_f.punkty_¿ycia;

          statek_1_f.Punkty_¯ycia_Zmieñ( ztr_l );

          // Wpisuje obra¿anie otrzymane przez statek pierwszy.
          if zti_l >= 0 then
            gra_statystyki_r_t[ zti_l ].obra¿enia_otrzymane := gra_statystyki_r_t[ zti_l ].obra¿enia_otrzymane - ztr_l; // Wartoœæ jest ujemna.


          zti_l := Gra_Statystyki_R_Identyfikator_ZnajdŸ( statek_2_f.id_statek );

          if zti_l >= 0 then
            begin

              gra_statystyki_r_t[ zti_l ].taranowania_iloœæ := gra_statystyki_r_t[ zti_l ].taranowania_iloœæ + 1;
              gra_statystyki_r_t[ zti_l ].obra¿enia_zadane_taranowanie := gra_statystyki_r_t[ zti_l ].obra¿enia_zadane_taranowanie - ztr_l; // Wartoœæ jest ujemna.

              if statek_1_f.id_grupa = statek_2_f.id_grupa then
                begin

                  gra_statystyki_r_t[ zti_l ].taranowania_iloœæ_sojuszników := gra_statystyki_r_t[ zti_l ].taranowania_iloœæ_sojuszników + 1;
                  gra_statystyki_r_t[ zti_l ].obra¿enia_zadane_taranowanie_sojusznikom := gra_statystyki_r_t[ zti_l ].obra¿enia_zadane_taranowanie_sojusznikom - ztr_l; // Wartoœæ jest ujemna.

                end;
              //---//if statek_1_f.id_grupa = statek_2_f.id_grupa then

              if    ( punkty_¿ycia_kopia_l_l > 0 )
                and ( statek_1_f.punkty_¿ycia <= 0 ) then
                begin

                  gra_statystyki_r_t[ zti_l ].zatopienia := gra_statystyki_r_t[ zti_l ].zatopienia + 1;

                  if statek_1_f.id_grupa = statek_2_f.id_grupa then
                    gra_statystyki_r_t[ zti_l ].zatopienia_sojuszników := gra_statystyki_r_t[ zti_l ].zatopienia_sojuszników + 1;

                end;
              //---//if    ( punkty_¿ycia_kopia_l_l > 0 ) (...)


              // Wpisuje obra¿anie otrzymane przez statek drugi.
              gra_statystyki_r_t[ zti_l ].obra¿enia_otrzymane := gra_statystyki_r_t[ zti_l ].obra¿enia_otrzymane - ztr_kopia; // Wartoœæ jest ujemna.

            end;
          //---//if zti_l >= 0 then

        end;
      //---//if    (  Abs( statek_1_f.prêdkoœæ_procent ) > kolizja_oznaczanie_prêdkoœæ_procent_c  ) (...)
      {$endregion 'Oznacza kolizjê, wyœwietla efekt, nalicza obra¿enia.'}


      // Wytraca prêdkoœæ podczas kolizji.
      if Abs( statek_1_f.prêdkoœæ_aktualna ) > 0 then
        begin

          if k¹t_wspó³czynnik_l = 1 then // Przy ma³ym k¹cie kolizji nie zwalniaj¹.
            statek_1_f.prêdkoœæ__kolizja_zwalnianie := 1.2;

        end;
      //---//if Abs( statek_1_f.prêdkoœæ_aktualna ) > 0 then


      // Przesuwanie statku, który zosta³ uderzony.
      // Je¿eli statki najd¹ na siebie to mo¿e wyst¹piæ efekt ci¹gniêcia (statek, który próbuje siê wycofaæ z kolizji zamiast siê oddalaæ naci¹ga na siebie drugi statek). //???
      statek_2_f.Translate
        (
          statek_1_f.AbsoluteDirection.X * statek_1_f.prêdkoœæ_aktualna * kolizja_przesuwanie_si³a_c * k¹t_wspó³czynnik_l,
          statek_1_f.AbsoluteDirection.Y * statek_1_f.prêdkoœæ_aktualna * kolizja_przesuwanie_si³a_c * k¹t_wspó³czynnik_l,
          statek_1_f.AbsoluteDirection.Z * statek_1_f.prêdkoœæ_aktualna * kolizja_przesuwanie_si³a_c * k¹t_wspó³czynnik_l
        );



      {$region 'Obraca statki do wspólnego kierunku (taki sam k¹t obrotu).'}
      k¹t_œredni_miêdzy_statkami_l := ( statek_1_f.TurnAngle + statek_2_f.TurnAngle ) * 0.5; // Œrednia k¹tów (œrodek miedzy k¹tami).

      // Je¿eli miêdzy k¹tami statków jest k¹t 180 / -180 to zmienia kierunek obrotu.
      if    (  Abs( statek_1_f.TurnAngle ) > 90  )
        and (  Abs( statek_2_f.TurnAngle ) > 90  )
        and (  Sign( statek_1_f.TurnAngle ) <> Sign( statek_2_f.TurnAngle )  ) then
        ztr_l := -1
      else//if    (  Abs( statek_1_f.TurnAngle ) > 90  ) (...)
        ztr_l := 1;


      // Obraca statek pierwszy.
      if statek_2_f.TurnAngle <> k¹t_œredni_miêdzy_statkami_l then
        begin

          if statek_2_f.TurnAngle > k¹t_œredni_miêdzy_statkami_l then
            statek_2_f.TurnAngle := statek_2_f.TurnAngle - statek_2_f.skrêt_prêdkoœæ * gra_wspó³czynnik_prêdkoœci_g * ztr_l // 0.3
          else//if statek_2_f.TurnAngle > k¹t_wspó³czynnik_l then
            statek_2_f.TurnAngle := statek_2_f.TurnAngle + statek_2_f.skrêt_prêdkoœæ * gra_wspó³czynnik_prêdkoœci_g * ztr_l;

        end;
      //---//if statek_2_f.TurnAngle <> k¹t_œredni_miêdzy_statkami_l then

      // Obraca statek drugi.
      if statek_1_f.TurnAngle <> k¹t_œredni_miêdzy_statkami_l then
        begin

          if statek_1_f.TurnAngle > k¹t_œredni_miêdzy_statkami_l then
            statek_1_f.TurnAngle := statek_1_f.TurnAngle - statek_1_f.skrêt_prêdkoœæ * gra_wspó³czynnik_prêdkoœci_g * ztr_l
          else//if statek_1_f.TurnAngle > k¹t_wspó³czynnik_l then
            statek_1_f.TurnAngle := statek_1_f.TurnAngle + statek_1_f.skrêt_prêdkoœæ * gra_wspó³czynnik_prêdkoœci_g * ztr_l;

        end;
      //---//if statek_2_f.TurnAngle <> k¹t_œredni_miêdzy_statkami_l then
      {$endregion 'Obraca statki do wspólnego kierunku (taki sam k¹t obrotu).'}

    end;//---//Funkcja Kolizja_Statek_Statek_Przelicz() Oznacz_Kolizjê() w Gra_GLCollisionManagerCollision().

  var
    zti : integer;
    ztr,
    punkty_¿ycia_kopia_l
      : real;
    zt_statek,
    zt_statek_2
      : TStatek;
  begin//Funkcja Oznacz_Kolizjê() w Gra_GLCollisionManagerCollision().

    // Zwraca prawdê gdy wykryto kolizjê.

    Result := false;


    {$region 'Amunicja.'}
    // Amunicja trafia w amunicjê.
    if    ( not Result )
      and ( object_1_f.Owner is TAmunicja )
      and ( object_2_f.Owner is TAmunicja )
      and ( object_1_f.Owner <> object_2_f.Owner ) // Aby nie oznacza³o kolizji elementów jednej amunicji z sama sob¹.
      and ( //???
               ( TAmunicja(object_1_f.Owner).czy_uzbrojona )
            or ( TAmunicja(object_2_f.Owner).czy_uzbrojona )
          )
      and ( not TAmunicja(object_1_f.Owner).czy_usun¹æ_amunicja )
      and ( not TAmunicja(object_2_f.Owner).czy_usun¹æ_amunicja ) then
      begin

        Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_Woda, object_1_f.AbsolutePosition.X, object_1_f.AbsolutePosition.Y, object_1_f.AbsolutePosition.Z, TAmunicja(object_1_f.Owner), -1, -1 );

        TAmunicja(object_1_f.Owner).czy_usun¹æ_amunicja := true;
        TAmunicja(object_2_f.Owner).czy_usun¹æ_amunicja := true;

      end;
    //---//if    ( not Result ) (...)


    // Amunicja trafia w wodê.
    if    ( not Result )
      and ( object_1_f.Owner is TAmunicja )
      and (  not ( object_2_f.Owner is TAmunicja )  )
      and ( object_2_f.Name = Woda_Kolizje_GLCube.Name )
      and ( TAmunicja(object_1_f.Owner ).czy_poza_luf¹ ) //???
      and ( not TAmunicja(object_1_f.Owner ).czy_efekt_wpadniêcia_do_wody )
      and ( not TAmunicja(object_1_f.Owner ).czy_pod_wod¹ )
      //and ( TAmunicja(object_1_f.Owner ).amunicja_rodzaj <> ar_Torpeda )
      and ( not TAmunicja(object_1_f.Owner).czy_usun¹æ_amunicja ) then
      begin

        Result := true;

        TAmunicja(object_1_f.Owner).czy_efekt_wpadniêcia_do_wody := true;

        Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_Woda, object_1_f.AbsolutePosition.X, object_1_f.AbsolutePosition.Y, object_1_f.AbsolutePosition.Z, TAmunicja(object_1_f.Owner), -1, -1 );

      end;
    //---//if    ( not Result ) (...)


    // Amunicja trafia w l¹d.
    if    ( not Result )
      and ( object_1_f.Owner is TAmunicja )
      and (  not ( object_2_f.Owner is TAmunicja )  )
      and ( TAmunicja(object_1_f.Owner ).czy_poza_luf¹ )
      and (
               ( object_2_f.Name = Dno_Kolizje_GLCube.Name )
            or (  Pos( 'L¹d__', object_2_f.Name ) = 1  )
          )
      and ( not TAmunicja(object_1_f.Owner).czy_usun¹æ_amunicja ) then
      begin

        Result := true;

        Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_L¹d, object_1_f.AbsolutePosition.X, object_1_f.AbsolutePosition.Y, object_1_f.AbsolutePosition.Z, TAmunicja(object_1_f.Owner), -1, -1 );

        TAmunicja(object_1_f.Owner).czy_usun¹æ_amunicja := true;

      end;
    //---//if    ( not Result ) (...)


    // Amunicja trafia w statek.
    if    ( not Result )
      and ( object_1_f.Owner is TAmunicja )
      and (  not ( object_2_f.Owner is TAmunicja )  )
      and ( TAmunicja(object_1_f.Owner).czy_poza_luf¹ )
      and ( not TAmunicja(object_1_f.Owner).czy_usun¹æ_amunicja )
      and ( object_2_f.Name <> Woda_Kolizje_GLCube.Name ) then
      begin

        Result := true;

        //Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, object_1_f.AbsolutePosition.X, object_1_f.AbsolutePosition.Y, object_1_f.AbsolutePosition.Z );

        zt_statek := Statek_ZnajdŸ( object_2_f.Owner );

        if    ( zt_statek <> nil )
          and ( zt_statek.statki_rozstawianie_status = srs_Brak ) then // Aby nie wykrywa³ kolizji ze statkami, które s¹ w trakcie rozstawiania.
          begin

            //if not zt_statek.czy_usun¹æ_statek then //???
              begin

                Trafienia_Efekt_Utwórz_Jeden( zt_statek, er_Trafienie_Statek, zt_statek.AbsoluteToLocal( object_1_f.AbsolutePosition ).X, zt_statek.AbsoluteToLocal( object_1_f.AbsolutePosition ).Y, zt_statek.AbsoluteToLocal( object_1_f.AbsolutePosition ).Z, TAmunicja(object_1_f.Owner), -1, -1 );

                if TAmunicja(object_1_f.Owner ).czy_uzbrojona then
                  begin

                    punkty_¿ycia_kopia_l := zt_statek.punkty_¿ycia;
                    ztr := -TAmunicja(object_1_f.Owner).obra¿enia_zadawane * TAmunicja(object_1_f.Owner).obra¿enia_zadawane_wspó³czynnik_zmodyfikowany; //???

                    zt_statek.Punkty_¯ycia_Zmieñ( ztr );


                    zti := Gra_Statystyki_R_Identyfikator_ZnajdŸ( TAmunicja(object_1_f.Owner).id_statek );

                    if zti >= 0 then
                      begin

                        gra_statystyki_r_t[ zti ].trafienia := gra_statystyki_r_t[ zti ].trafienia + 1;
                        gra_statystyki_r_t[ zti ].obra¿enia_zadane_amunicja := gra_statystyki_r_t[ zti ].obra¿enia_zadane_amunicja - ztr; // Wartoœæ jest ujemna.

                        if    ( TAmunicja(object_1_f.Owner).statek <> nil )
                          and ( TAmunicja(object_1_f.Owner).statek.id_grupa = zt_statek.id_grupa ) then
                          gra_statystyki_r_t[ zti ].obra¿enia_zadane_amunicja_sojusznikom := gra_statystyki_r_t[ zti ].obra¿enia_zadane_amunicja_sojusznikom - ztr; // Wartoœæ jest ujemna.

                        if    ( punkty_¿ycia_kopia_l > 0 )
                          and ( zt_statek.punkty_¿ycia <= 0 ) then
                          begin

                            gra_statystyki_r_t[ zti ].zatopienia := gra_statystyki_r_t[ zti ].zatopienia + 1;

                            if    ( TAmunicja(object_1_f.Owner).statek <> nil )
                              and ( TAmunicja(object_1_f.Owner).statek.id_grupa = zt_statek.id_grupa ) then
                              gra_statystyki_r_t[ zti ].zatopienia_sojuszników := gra_statystyki_r_t[ zti ].zatopienia_sojuszników + 1;

                          end;
                        //---//if    ( punkty_¿ycia_kopia_l > 0 ) (...)

                      end;
                    //---//if zti >= 0 then

                  end;
                //---//if TAmunicja(object_1_f.Owner ).czy_uzbrojona then

              end;
            //---//if not zt_statek.czy_usun¹æ_statek then

          end
        else//if    ( zt_statek <> nil ) (...)
          Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_Woda, object_1_f.AbsolutePosition.X, object_1_f.AbsolutePosition.Y, object_1_f.AbsolutePosition.Z, TAmunicja(object_1_f.Owner), -1, -1 );

        TAmunicja(object_1_f.Owner).czy_usun¹æ_amunicja := true;

      end;
    //---//if    ( not Result ) (...)
    {$endregion 'Amunicja.'}


    {$region 'Statek.'}
    // Statek dotyka l¹d.
    if    ( not Result )
      and (  not ( object_1_f.Owner is TAmunicja )  )
      and (  not ( object_2_f.Owner is TAmunicja )  )
      and ( object_1_f.Name <> Woda_Kolizje_GLCube.Name )
      and ( object_2_f.Name <> Woda_Kolizje_GLCube.Name )
      and (  Pos( 'L¹d__', object_1_f.Name ) <= 0  )
      and (
               ( object_2_f.Name = Dno_Kolizje_GLCube.Name )
            or (  Pos( 'L¹d__', object_2_f.Name ) = 1  )
          ) then
      begin

        zt_statek := Statek_ZnajdŸ( object_1_f.Owner );

        if zt_statek <> nil then // Czy jednym z obiektów kolizji jest statek.
          begin

            if zt_statek.statki_rozstawianie_status = srs_Rozstawianie_Kolizja_SprawdŸ then // Aby nie wykrywa³ kolizji ze statkami, które s¹ w trakcie rozstawiania.
              begin

                Result := true;
                zt_statek.statki_rozstawianie_status := srs_Rozstawianie_Kolizja_Wykryta;

              end
            else//if zt_statek.statki_rozstawianie_status = srs_Rozstawianie_Kolizja_SprawdŸ then
              begin

                if    (  Abs( zt_statek.prêdkoœæ_procent ) > kolizja_oznaczanie_prêdkoœæ_procent_c  )
                  and (  not Statki_Kolizja_Oznaczenie_SprawdŸ( zt_statek.kolizja_oznaczenie_string_list, object_2_f.Name )  ) then
                  begin

                    Result := true;

                    zt_statek.kolizja_oznaczenie_string_list.Add(  object_2_f.Name + '|' + IntToStr( Czas_Teraz() )  );

                    Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_L¹d, object_1_f.AbsolutePosition.X, object_1_f.AbsolutePosition.Y, object_1_f.AbsolutePosition.Z, nil, -1, -1 );


                    if Abs( zt_statek.prêdkoœæ_procent ) > kolizja_oznaczanie_prêdkoœæ_procent_c * 2 then
                      //zt_statek.Punkty_¯ycia_Zmieñ( -zt_statek.punkty_¿ycia_maksymalne * 0.1 * object_2_f.TagFloat ); // Koryguje iloœæ obra¿eñ o wp³yw kolizji l¹du. //???
                      //zt_statek.Punkty_¯ycia_Zmieñ( -zt_statek.punkty_¿ycia_maksymalne * 0.1 );
                      zt_statek.Punkty_¯ycia_Zmieñ
                        (
                            -zt_statek.punkty_¿ycia_maksymalne * 0.1 // 10% z punktów ¿ycia.
                          * object_2_f.TagFloat // Koryguje iloœæ obra¿eñ o wp³yw kolizji l¹du.
                          * Abs( zt_statek.prêdkoœæ_procent ) * 0.5 * 0.1 // 10% z po³owy prêdkoœci.
                        )

                  end;
                //---//if    (  Abs( zt_statek.prêdkoœæ_procent ) > kolizja_oznaczanie_prêdkoœæ_procent_c  ) (...)


                if Abs( zt_statek.prêdkoœæ_aktualna ) > 0 then
                  zt_statek.prêdkoœæ__kolizja_zwalnianie := object_2_f.TagFloat;

              end;
            //---//if zt_statek.statki_rozstawianie_status = srs_Rozstawianie_Kolizja_SprawdŸ then

          end;
        //---//if zt_statek <> nil then

      end;
    //---//if    ( not Result ) (...)


    // Statek dotyka inny statek.
    if    ( not Result )
      and (  not ( object_1_f.Owner is TAmunicja )  )
      and (  not ( object_2_f.Owner is TAmunicja )  )
      and ( object_1_f.Name <> Woda_Kolizje_GLCube.Name )
      and ( object_2_f.Name <> Woda_Kolizje_GLCube.Name )
      and (  Pos( 'L¹d__', object_1_f.Name ) <= 0  )
      and (  Pos( 'L¹d__', object_2_f.Name ) <= 0  ) then
      begin

        zt_statek := Statek_ZnajdŸ( object_1_f.Owner );

        if zt_statek <> nil then // Czy jednym z obiektów kolizji jest statek.
          begin

            zt_statek_2 := Statek_ZnajdŸ( object_2_f.Owner );

            if    ( zt_statek_2 <> nil )
              and ( zt_statek <> zt_statek_2 ) then // Czy drugim z obiektów kolizji jest statek.
              begin

                Result := true;


                if    ( zt_statek.statki_rozstawianie_status = srs_Brak ) // Aby nie wykrywa³ kolizji ze statkami, które s¹ w trakcie rozstawiania.
                  and ( zt_statek_2.statki_rozstawianie_status = srs_Brak ) then
                  Kolizja_Statek_Statek_Przelicz( zt_statek, zt_statek_2, object_1_f, object_2_f )
                  //Kolizja_Statek_Statek_Przelicz( zt_statek_2, zt_statek, object_2_f, object_1_f );
                else//if    ( zt_statek.statki_rozstawianie_status = srs_Brak ) (...)
                  begin

                    if zt_statek.statki_rozstawianie_status = srs_Rozstawianie_Kolizja_SprawdŸ then
                      zt_statek.statki_rozstawianie_status := srs_Rozstawianie_Kolizja_Wykryta;

                    if zt_statek_2.statki_rozstawianie_status = srs_Rozstawianie_Kolizja_SprawdŸ then
                      zt_statek_2.statki_rozstawianie_status := srs_Rozstawianie_Kolizja_Wykryta;

                  end;
                //---//if    ( zt_statek.statki_rozstawianie_status = srs_Brak ) (...)

              end;
            //---//if zt_statek_2 <> nil then

          end;
        //---//if zt_statek <> nil then

      end;
    //---//if    ( not Result ) (...)
    {$endregion 'Statek.'}

//    if    ( object_1_f <> nil )
//      and ( object_2_f <> nil )
//      and ( object_1_f is TAmunicja )
//      and (  not ( object_2_f is TAmunicja )  ) then
//      begin
//
//        TAmunicja(object_1_f).korpus.Material.FrontProperties.Emission.Color := clrBlue;
//        Statki_Form.Caption := Caption + '*';
//
//      end;
//    //---//


//      if not VectorEquals( TGLTorus(object_f).Material.FrontProperties.Emission.Color, clrBlue ) then // uses GLVectorGeometry.
//        TAmunicja(object_f).korpus.Material.FrontProperties.Emission.Color := clrBlue
//      else//if not VectorEquals( TGLTorus(object_f).Material.FrontProperties.Emission.Color, clrBlue ) then
//        TAmunicja(object_f).korpus.Material.FrontProperties.Emission.Color := clrGreen;

    // magiczne pociski ³añcuch.
    //if    ( object_f <> nil )
    //  and ( object_f is TGLTorus )
    //  and ( Pocisk_Magiczny_GLTorus.Tag = 1 ) then
    //  if not VectorEquals( TGLTorus(object_f).Material.FrontProperties.Emission.Color, clrBlue ) then // uses GLVectorGeometry.
    //    TGLTorus(object_f).Material.FrontProperties.Emission.Color := clrBlue
    //  else//if not VectorEquals( TGLTorus(object_f).Material.FrontProperties.Emission.Color, clrBlue ) then
    //    TGLTorus(object_f).Material.FrontProperties.Emission.Color := clrGreen;

    // magiczne pociski ³añcuch.
    //if    ( object_f <> nil )
    //  and ( object_f is TPocisk_Magiczny ) then
    //  if not VectorEquals( TPocisk_Magiczny(object_f).Material.FrontProperties.Emission.Color, clrRed ) then // uses GLVectorGeometry.
    //    TPocisk_Magiczny(object_f).Material.FrontProperties.Emission.Color := clrRed
    //  else//if not VectorEquals( TGLTorus(object_f).Material.FrontProperties.Emission.Color, clrRed ) then
    //    TPocisk_Magiczny(object_f).Material.FrontProperties.Emission.Color := clrYellowGreen;


  end;//---//Funkcja Oznacz_Kolizjê() w Gra_GLCollisionManagerCollision().

begin//Gra_GLCollisionManagerCollision().

  if    ( object1 <> nil )
    and ( object2 <> nil )
    and ( object1.Owner <> nil )
    and ( object2.Owner <> nil ) then
    begin

      if not Oznacz_Kolizjê( object1, object2 ) then
        Oznacz_Kolizjê( object2, object1 );

//      if    ( object1.Owner is TAmunicja )
//        and (  not ( object2.Owner is TAmunicja )  ) then
//        Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, object1.AbsolutePosition.X, object1.AbsolutePosition.Y, object1.AbsolutePosition.Z )
//      else//if    ( object1.Owner is TAmunicja ) (...)
//      if    ( object2.Owner is TAmunicja )
//        and (  not ( object1.Owner is TAmunicja )  ) then
//        Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, object2.AbsolutePosition.X, object2.AbsolutePosition.Y, object2.AbsolutePosition.Z );

    end;
  //---//if    ( object1 <> nil ) (...)

  //Oznacz_Kolizjê( object1, object2 );
  //Oznacz_Kolizjê( object2, object1 );

end;//---//Gra_GLCollisionManagerCollision().

procedure TStatki_Form.GLCollisionManager2Collision(Sender: TObject; object1, object2: TGLBaseSceneObject);
begin

//    if    ( object1 <> nil )
//      and ( object2 <> nil ) then
//      begin
//
//        //Statki_Form.Caption := Caption + '*';
//        //Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, object1.AbsolutePosition.X, object1.AbsolutePosition.Y, object1.AbsolutePosition.Z );
//        Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, object2.AbsolutePosition.X, object2.AbsolutePosition.Y, object2.AbsolutePosition.Z );
//
//      end;
//    //---//
//Exit;
//    if    ( object1 <> nil )
//      and ( object2 <> nil )
//          (
//               (
//                    ( object1.Owner <> nil )
//                and ( object1.Owner is TAmunicja )
//
//                and ( object2.Owner <> nil )
//                and (  not ( object2.Owner is TAmunicja )  )
//               )
//            or (
//                    ( object2.Owner <> nil )
//                and ( object2.Owner is TAmunicja )
//
//                and ( object1.Owner <> nil )
//                and (  not ( object1.Owner is TAmunicja )  )
//               )
//          ) then
    if    ( object1 <> nil )
      and ( object2 <> nil )
      and ( object1.Owner <> nil )
      and ( object2.Owner <> nil ) then
      begin

        //TAmunicja(object1).korpus.Material.FrontProperties.Emission.Color := clrBlue;
        //Statki_Form.Caption := Caption + '*';
        //Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, 0, 2, 0 );
        //Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, object1.AbsolutePosition.X, object1.AbsolutePosition.Y, object1.AbsolutePosition.Z );


        if    ( object1.Owner is TAmunicja )
          and (  not ( object2.Owner is TAmunicja )  )then
          Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_Woda, object1.AbsolutePosition.X, object1.AbsolutePosition.Y, object1.AbsolutePosition.Z, TAmunicja(object2.Owner), -1, -1 )
        else
        if    ( object2.Owner is TAmunicja )
          and (  not ( object1.Owner is TAmunicja )  )then
          Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_Woda, object2.AbsolutePosition.X, object2.AbsolutePosition.Y, object2.AbsolutePosition.Z, TAmunicja(object1.Owner), -1, -1 );

      end;
    //---//

end;

//Czas_Bezwzglêdny_TimerTimer().
procedure TStatki_Form.Czas_Bezwzglêdny_TimerTimer( Sender: TObject );
begin

  inc( czas_bezwzglêdny_g );

end;//---//Czas_Bezwzglêdny_TimerTimer().

//PageControl1Change().
procedure TStatki_Form.PageControl1Change( Sender: TObject );
var
  zti : integer;
begin

  if PageControl1.ActivePage = Klawiatura_Konfiguracja_TabSheet then
    begin

      // Przy zmianie zak³adki na Klawiatura_Konfiguracja_TabSheet zapamiêtuje aktualny rozmiar i zwiêksza szerokoœæ.

      if Self.Width >= 1050 then
        zti := 1000
      else//if Self.Width >= 1050 then
      if Self.Width >= 400 then
        zti := Self.Width - 50;

      if    ( Klawiatura_Konfiguracja__Rozmiar_Zak³adki_Poszerz_CheckBox.Checked )
        and ( PageControl1.Width < zti ) then
        begin

          Klawiatura_Konfiguracja__Rozmiar_Zak³adki_Poszerz_CheckBox.Tag := PageControl1.Width;

          PageControl1.Width := zti;

        end;
      //---//if    ( Klawiatura_Konfiguracja__Rozmiar_Zak³adki_Poszerz_CheckBox.Checked ) (...)

    end
  else//if PageControl1.ActivePage = Klawiatura_Konfiguracja_TabSheet then
    begin

      // Przy zmianie zak³adki na inna ni¿ Klawiatura_Konfiguracja_TabSheet przywraca poprzedni¹ szerokoœæ.

      if    ( Klawiatura_Konfiguracja__Rozmiar_Zak³adki_Poszerz_CheckBox.Checked )
        and ( Klawiatura_Konfiguracja__Rozmiar_Zak³adki_Poszerz_CheckBox.Tag > 0 ) then
        PageControl1.Width := Klawiatura_Konfiguracja__Rozmiar_Zak³adki_Poszerz_CheckBox.Tag;


      Klawiatura_Konfiguracja__Rozmiar_Zak³adki_Poszerz_CheckBox.Tag := 0;

    end;
  //---//if PageControl1.ActivePage = Klawiatura_Konfiguracja_TabSheet then

end;//---//PageControl1Change().

//L¹d__Wczytaj_Listê_BitBtnClick().
procedure TStatki_Form.L¹d__Wczytaj_Listê_BitBtnClick( Sender: TObject );
begin
  
  L¹d_Opis_Memo.Text := 'Opis mapy.';
  Wczytaj_Schemat( katalog_schematy_lista__l¹dy_c, -1, l¹dy_lista_t );
 
end;//---//L¹d__Wczytaj_Listê_BitBtnClick().

//L¹d__Odœwie¿_Wskazany_BitBtnClick().
procedure TStatki_Form.L¹d__Odœwie¿_Wskazany_BitBtnClick( Sender: TObject );
begin

  if   ( L¹d_ComboBox.Items.Count < 0 )
    or ( L¹d_ComboBox.ItemIndex < 0 )
    or (  L¹d_ComboBox.ItemIndex > Length( l¹dy_lista_t ) - 1  ) then
    Exit;


  Wczytaj_Schemat( katalog_schematy_lista__l¹dy_c, L¹d_ComboBox.ItemIndex, l¹dy_lista_t );

  L¹d_ComboBoxChange( Sender );
  
end;//---//L¹d__Odœwie¿_Wskazany_BitBtnClick().

//L¹d__Utwórz_BitBtnClick().
procedure TStatki_Form.L¹d__Utwórz_BitBtnClick( Sender: TObject );
begin

  L¹d_Zwolnij();
  L¹d_Utwórz( L¹d_ComboBox.ItemIndex );
      
end;//---//L¹d__Utwórz_BitBtnClick().

//L¹d_ComboBoxChange().
procedure TStatki_Form.L¹d_ComboBoxChange( Sender: TObject );
begin

  if   ( L¹d_ComboBox.Items.Count < 0 )
    or ( L¹d_ComboBox.ItemIndex < 0 )
    or (  L¹d_ComboBox.ItemIndex > Length( l¹dy_lista_t ) - 1  ) then
    Exit;


  L¹d_Opis_Memo.Text := StringReplace( l¹dy_lista_t[ L¹d_ComboBox.ItemIndex ].opis, '#13#10', #13#10, [ rfReplaceAll ] );

  
  L¹d_Zwolnij();
  L¹d_Utwórz( L¹d_ComboBox.ItemIndex );

end;//---//L¹d_ComboBoxChange().

//Statek__Wczytaj_Listê_BitBtnClick().
procedure TStatki_Form.Statek__Wczytaj_Listê_BitBtnClick( Sender: TObject );
begin

  Statek_Opis_Memo.Text := 'Opis statku.';
  Wczytaj_Schemat( katalog_schematy_lista__statki_c, -1, statki_lista_t );
 
end;//---//Statek__Wczytaj_Listê_BitBtnClick().

//Statek__Odœwie¿_Wskazany_BitBtnClick().
procedure TStatki_Form.Statek__Odœwie¿_Wskazany_BitBtnClick( Sender: TObject );
begin

  if   ( Statek_ComboBox.Items.Count < 0 )
    or ( Statek_ComboBox.ItemIndex < 0 )
    or (  Statek_ComboBox.ItemIndex > Length( statki_lista_t ) - 1  ) then
    Exit;


  Wczytaj_Schemat( katalog_schematy_lista__statki_c, Statek_ComboBox.ItemIndex, statki_lista_t );
  
  Statek_ComboBoxChange( Sender );

end;//---//Statek__Odœwie¿_Wskazany_BitBtnClick().

//Statek__Utwórz_BitBtnClick().
procedure TStatki_Form.Statek__Utwórz_BitBtnClick( Sender: TObject );
begin

  if Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked then
    Statek__Odœwie¿_Wskazany_BitBtnClick( Sender );


  Statki_Zwolnij( true, false );

  if Length( statki_t ) < 1  then
    SetLength( statki_t, 1 );

  statki_t[ 0 ] := TStatek.Create(  Gra_Obiekty_GLDummyCube, Statki_Form.Gra_GLCollisionManager, 0, Statek_Odczytaj_Schemat( Statek_ComboBox.ItemIndex ), prymitywy_lista_t  );
  statki_t[ 0 ].id_grupa := 1; // Aby po odnowieniu statku (je¿eli nie trwa gra) poprawnie wczyta³o i ustawi³o statek.
  statki_t[ 0 ].id_statek_schemat := Statek_ComboBox.ItemIndex; // Aby po odnowieniu statku (je¿eli nie trwa gra) poprawnie wczyta³o i ustawi³o statek.
  statek_gracza := statki_t[ 0 ];


  Interfejs_Parametry_Wed³ug_Statku_Ustaw();

  if    (  not ( Gra_GLCamera.Parent is TStatek )  )
    and ( not Statek__Komunikat_B³êdu_Pomiñ_CheckBox.Checked ) then
    Kamera_Prze³¹cz( kt_Statek ); // Ustawi kamerê na statku gracza.


  Elementy_Gracza_Dostosuj_CheckBoxClick( Sender );


  if    ( czy_klient_g )
    and ( statek_gracza <> nil ) then
    statek_gracza.Elementy_Gracza_Widocznoœæ( Gracz_Grupa_SpinEdit.Value, false ); // Aby po zakoñczeniu gry u klienta nie by³o widaæ linii celowniczych.

end;//---//Statek__Utwórz_BitBtnClick().

//Statek__Opis_BitBtnClick().
procedure TStatki_Form.Statek__Opis_BitBtnClick( Sender: TObject );
begin

  if statek_gracza <> nil then
    ShowMessage(  statek_gracza.Parametry_Odczytaj( true )  )
  else//if statek_gracza <> nil then
    Application.MessageBox( 'Nale¿y utworzyæ statek.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );

end;//---//Statek__Opis_BitBtnClick().

//Statek_ComboBoxChange().
procedure TStatki_Form.Statek_ComboBoxChange( Sender: TObject );
begin

  if   ( Statek_ComboBox.Items.Count < 0 )
    or ( Statek_ComboBox.ItemIndex < 0 )
    or (  Statek_ComboBox.ItemIndex > Length( statki_lista_t ) - 1  ) then
    Exit;


  Statek_Opis_Memo.Text := StringReplace( statki_lista_t[ Statek_ComboBox.ItemIndex ].opis, '#13#10', #13#10, [ rfReplaceAll ] );

end;//---//Statek_ComboBoxChange().

//Statek_ComboBoxKeyDown().
procedure TStatki_Form.Statek_ComboBoxKeyDown( Sender: TObject; var Key: Word; Shift: TShiftState );
begin

  // Enter.
  if Key = 13 then
    begin

      Key := 0;
      Statek__Utwórz_BitBtnClick( nil );

    end;
  //---//if Key = 13 then

end;//---//Statek_ComboBoxKeyDown().

//Statki_Pozycje_Pocz¹tkowe__Wczytaj_Listê_BitBtnClick().
procedure TStatki_Form.Statki_Pozycje_Pocz¹tkowe__Wczytaj_Listê_BitBtnClick( Sender: TObject );
begin

  Statki_Pozycje_Pocz¹tkowe_Opis_Memo.Text := 'Opis pozycji pocz¹tkowej statków.';
  Wczytaj_Schemat( katalog_schematy_lista__statki_pozycje_pocz¹tkowe_c, -1, statki_pozycje_pocz¹tkowe_lista_t );

end;//---//Statki_Pozycje_Pocz¹tkowe__Wczytaj_Listê_BitBtnClick().

//Statki_Pozycje_Pocz¹tkowe__Odœwie¿_Wskazany_BitBtnClick().
procedure TStatki_Form.Statki_Pozycje_Pocz¹tkowe__Odœwie¿_Wskazany_BitBtnClick( Sender: TObject );
begin

  if   ( Statki_Pozycje_Pocz¹tkowe_ComboBox.Items.Count < 0 )
    or ( Statki_Pozycje_Pocz¹tkowe_ComboBox.ItemIndex < 0 )
    or (  Statki_Pozycje_Pocz¹tkowe_ComboBox.ItemIndex > Length( statki_pozycje_pocz¹tkowe_lista_t ) - 1  ) then
    Exit;


  Wczytaj_Schemat( katalog_schematy_lista__statki_pozycje_pocz¹tkowe_c, Statki_Pozycje_Pocz¹tkowe_ComboBox.ItemIndex, statki_pozycje_pocz¹tkowe_lista_t );

  Statki_Pozycje_Pocz¹tkowe_ComboBoxChange( Sender );

end;//---//Statki_Pozycje_Pocz¹tkowe__Odœwie¿_Wskazany_BitBtnClick().

//Statki_Pozycje_Pocz¹tkowe__Brak_BitBtnClick().
procedure TStatki_Form.Statki_Pozycje_Pocz¹tkowe__Brak_BitBtnClick( Sender: TObject );
begin

  Statki_Pozycje_Pocz¹tkowe_ComboBox.ItemIndex := -1;
  Statki_Pozycje_Pocz¹tkowe_Opis_Memo.Text := 'Opis pozycji pocz¹tkowej statków.';

  Statki_Pozycje_Pocz¹tkowe_ComboBoxChange( Sender ); // Aby podstawi³ wartoœci domyœlne.

end;//---//Statki_Pozycje_Pocz¹tkowe__Brak_BitBtnClick().

//Statki_Pozycje_Pocz¹tkowe_ComboBoxChange().
procedure TStatki_Form.Statki_Pozycje_Pocz¹tkowe_ComboBoxChange( Sender: TObject );
var
  i,
  j
    : integer;
  zt_xml_document : TXMLDocument; //uses XMLDoc
begin//Statki_Pozycje_Pocz¹tkowe_ComboBoxChange().

  statki_pozycja_pocz¹tkowa_parametry_t[ 1 ].korekta_obrót := 0;
  statki_pozycja_pocz¹tkowa_parametry_t[ 1 ].korekta_x := 0;
  statki_pozycja_pocz¹tkowa_parametry_t[ 1 ].korekta_z := 0;
  statki_pozycja_pocz¹tkowa_parametry_t[ 1 ].odstêp_x := 7;
  statki_pozycja_pocz¹tkowa_parametry_t[ 1 ].z := 10;
  statki_pozycja_pocz¹tkowa_parametry_t[ 2 ].korekta_obrót := 180;
  statki_pozycja_pocz¹tkowa_parametry_t[ 2 ].korekta_x := 0;
  statki_pozycja_pocz¹tkowa_parametry_t[ 2 ].korekta_z := 0;
  statki_pozycja_pocz¹tkowa_parametry_t[ 2 ].odstêp_x := 7;
  statki_pozycja_pocz¹tkowa_parametry_t[ 2 ].z := -10;


  if   ( Statki_Pozycje_Pocz¹tkowe_ComboBox.Items.Count < 0 )
    or ( Statki_Pozycje_Pocz¹tkowe_ComboBox.ItemIndex < 0 )
    or (  Statki_Pozycje_Pocz¹tkowe_ComboBox.ItemIndex > Length( statki_pozycje_pocz¹tkowe_lista_t ) - 1  ) then
    begin

      Statki_Pozycje_Pocz¹tkowe_Opis_Memo.Text := '';
      Exit;

    end;
  //---//if   ( Statki_Pozycje_Pocz¹tkowe_ComboBox.Items.Count < 0 ) (...)


  Statki_Pozycje_Pocz¹tkowe_Opis_Memo.Text := StringReplace( statki_pozycje_pocz¹tkowe_lista_t[ Statki_Pozycje_Pocz¹tkowe_ComboBox.ItemIndex ].opis, '#13#10', #13#10, [ rfReplaceAll ] );


  zt_xml_document := TXMLDocument.Create( Application );

  zt_xml_document.Options := zt_xml_document.Options + [ doNodeAutoIndent ]; // Domyœlnie ma: doNodeAutoCreate, doAttrNull, doAutoPrefix, doNamespaceDecl.

  try
    // Serwer zg³asza b³¹d podczas odczytu danych o l¹dzie od klienta
    //   MSXML is not installed
    //   Assertion failure GLContext.pas
    // W L¹d_Zwolnij() chyba te¿ takie coœ siê dzieje (inne b³êdy) ale z podobnego powodu.
    //
    // Uda³o siê unikn¹æ b³êdów tak:
    //   w zdarzeniu odczytania danych o l¹dzie tylko w³¹czyæ Timer;
    //   w Timer.OnTimet wy³¹czyæ Timer i wywo³aæ zwalnianie i wczytywanie l¹du.
    //
    zt_xml_document.LoadFromXML( statki_pozycje_pocz¹tkowe_lista_t[ Statki_Pozycje_Pocz¹tkowe_ComboBox.ItemIndex ].treœæ );
  except
    on E : Exception do
      Application.MessageBox(  PChar('Nieprawid³owa definicja pozycji pocz¹tkowej statków.' + #13 + E.Message + ' ' + IntToStr( E.HelpContext )), 'B³¹d', MB_OK + MB_ICONEXCLAMATION  );
      //Log_Wypisz(  'Nieprawid³owa definicja pozycji pocz¹tkowej statków.' + #13 + #10 + E.Message + ' ' + IntToStr( E.HelpContext )  );
  end;
  //---//try

  {$region 'Odczyt danych xml.'}
  if zt_xml_document.Active then
    begin

      for i := 0 to zt_xml_document.DocumentElement.ChildNodes.Count - 1 do
        begin

          if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'grupa_1' then
            begin

              for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do
                begin

                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'korekta_obrót' then
                    statki_pozycja_pocz¹tkowa_parametry_t[ 1 ].korekta_obrót := Round(  Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null )  )
                  else
                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'korekta_x' then
                    statki_pozycja_pocz¹tkowa_parametry_t[ 1 ].korekta_x := Round(  Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null )  )
                  else
                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'korekta_z' then
                    statki_pozycja_pocz¹tkowa_parametry_t[ 1 ].korekta_z := Round(  Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null )  )
                  else
                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'odstêp_x' then
                    statki_pozycja_pocz¹tkowa_parametry_t[ 1 ].odstêp_x := Round(  Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null )  )
                  else
                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'z' then
                    statki_pozycja_pocz¹tkowa_parametry_t[ 1 ].z := Round(  Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null )  );

                end;
              //---//for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do

            end
          else//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'grupa_1' then
          if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'grupa_2' then
            begin

              for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do
                begin

                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'korekta_obrót' then
                    statki_pozycja_pocz¹tkowa_parametry_t[ 2 ].korekta_obrót := Round(  Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null )  )
                  else
                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'korekta_x' then
                    statki_pozycja_pocz¹tkowa_parametry_t[ 2 ].korekta_x := Round(  Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null )  )
                  else
                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'korekta_z' then
                    statki_pozycja_pocz¹tkowa_parametry_t[ 2 ].korekta_z := Round(  Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null )  )
                  else
                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'odstêp_x' then
                    statki_pozycja_pocz¹tkowa_parametry_t[ 2 ].odstêp_x := Round(  Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null )  )
                  else
                  if zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].LocalName = 'z' then
                    statki_pozycja_pocz¹tkowa_parametry_t[ 2 ].z := Round(  Odczytaj_Liczbê_Z_Napisu( zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes[ j ].Text, null )  );

                end;
              //---//for j := 0 to zt_xml_document.DocumentElement.ChildNodes[ i ].ChildNodes.Count - 1 do

            end;
          //---//if zt_xml_document.DocumentElement.ChildNodes[ i ].LocalName = 'grupa_2' then

        end;
      //---//for i := 0 to zt_xml_document.DocumentElement.ChildNodes.Count - 1 do

    end;
  //---//if zt_xml_document.Active then
  {$endregion 'Odczyt danych xml.'}


  zt_xml_document.Free();


  {$region 'Przyk³ad xml.'}
{
<statki_pozycja_pocz¹tkowa>
  <nazwa>Pozycje pocz¹tkowa 01</nazwa>
  <opis><![CDATA[Opis pozycje pocz¹tkowa 01.#13#10Nowa linia.]]></opis>

  <grupa_1>
    <korekta_obrót>123</korekta_obrót> <!-- Pocz¹tkowy obrót statku (+) lewo (-) prawo. -->
    <korekta_x>123</korekta_x> <!-- Przesuniêcie pozycji wszystkich statków w grupie (-) lewo (+) prawo. -->
    <korekta_z>123</korekta_z> <!-- Przesuniêcie pozycji ka¿dego statku w grupie osobno o wielokrotnoœæ wartoœci (-) przód (+) ty³. -->
    <odstêp_x>123</odstêp_x> <!-- Odstêp miêdzy statkami po bokach. -->
    <z>123</z> <!-- Odstêp od œrodka planszy (-) przód (+) ty³. -->
  </grupa_1>

  <grupa_2>
    <korekta_obrót>123</korekta_obrót>
    <korekta_x>123</korekta_x>
    <korekta_z>-123</korekta_z>
    <odstêp_x>123</odstêp_x>
    <z>-123</z>
  </grupa_2>
</statki_pozycja_pocz¹tkowa>
}
  {$endregion 'Przyk³ad xml.'}

end;//---//Statki_Pozycje_Pocz¹tkowe_ComboBoxChange().

//Gra_Rozpocznij_BitBtnClick().
procedure TStatki_Form.Gra_Rozpocznij_BitBtnClick( Sender: TObject );
var
  i : integer;
  zt_id_socket_handle : TIdSocketHandle;
begin

  if czy_klient_g then
    Exit
  else//if czy_klient_g then
  if   ( czy_gra_lokalna_g )
    or ( czy_serwer_g ) then
    begin

      for i := 0 to tcp_klienci_lista_g.klienci_lista_list.Count - 1 do //??? Potem odkomentowaæ.
        begin

          if not TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).gotowy then
            begin

              if Application.MessageBox( 'Nie wszyscy gracze s¹ gotowi. Czy kontynuowaæ?', 'Potwierdzenie', MB_YESNO + MB_DEFBUTTON2 + MB_ICONQUESTION ) = IDNO then
                Exit
              else//if Application.MessageBox( 'Nie wszyscy gracze s¹ gotowi. Czy kontynuowaæ?', 'Potwierdzenie', MB_YESNO + MB_DEFBUTTON2 + MB_ICONQUESTION ) = IDNO then
                Break; // Dalej nie sprawdza gotowoœci graczy.

            end;
          //---//if not TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).gotowy then

        end;
      //---//for i := 0 to tcp_klienci_lista_g.klienci_lista_list.Count - 1 do


      SetLength( gra_statystyki_r_t, 0 );
      SetLength( gra_statystyki_r_t, tcp_klienci_lista_g.klienci_lista_list.Count );

      for i := 0 to tcp_klienci_lista_g.klienci_lista_list.Count - 1 do
        begin

          gra_statystyki_r_t[ i ].identyfikator := TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator;
          gra_statystyki_r_t[ i ].amunicja_wystrzelona_iloœæ := 0;
          gra_statystyki_r_t[ i ].amunicja_wystrzelona_obra¿enia_zadawane := 0;
          gra_statystyki_r_t[ i ].obra¿enia_otrzymane := 0;
          gra_statystyki_r_t[ i ].obra¿enia_zadane_amunicja := 0;
          gra_statystyki_r_t[ i ].obra¿enia_zadane_amunicja_sojusznikom := 0;
          gra_statystyki_r_t[ i ].obra¿enia_zadane_taranowanie := 0;
          gra_statystyki_r_t[ i ].obra¿enia_zadane_taranowanie_sojusznikom := 0;
          gra_statystyki_r_t[ i ].taranowania_iloœæ := 0;
          gra_statystyki_r_t[ i ].taranowania_iloœæ_sojuszników := 0;
          gra_statystyki_r_t[ i ].trafienia := 0;
          gra_statystyki_r_t[ i ].zatoniêcia := 0;
          gra_statystyki_r_t[ i ].zatopienia := 0;
          gra_statystyki_r_t[ i ].zatopienia_sojuszników := 0;

        end;
      //---//for i := 0 to tcp_klienci_lista_g.klienci_lista_list.Count - 1 do


      Radar_Wyczyœæ( true );


      if czy_serwer_g then
        begin

          if not IdUDPServer1.Active then
            begin

              IdUDPServer1.DefaultPort := Serwer_Port_SpinEdit.Value;

              IdUDPServer1.Bindings.Clear();

              zt_id_socket_handle := IdUDPServer1.Bindings.Add();
              zt_id_socket_handle.IP := '0.0.0.0';
              zt_id_socket_handle.Port := Serwer_Port_SpinEdit.Value;


              IdUDPServer1.Active := true;

            end;
          //---//if not IdUDPServer1.Active then


          udp_data_czas_sprawdzanie_po³¹czeñ_ostatnie_g := Now();

          Serwer_Wysy³a_Timer.Enabled := true;


          Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__gra__rozpocznij_c, -99, '' );

          Wieloosobowe__Strumieñ_Wyœlij(  wieloosobowe__komenda__gra__morze_wzburzenie_c, -99, IntToStr( Morze_Wzburzenie_SpinEdit.Value )  );
          Wieloosobowe__Strumieñ_Wyœlij(  wieloosobowe__komenda__gra__wspó³czynnik_prêdkoœci_c, -99, IntToStr( Gra_Wspó³czynnik_Prêdkoœci_SpinEdit.Value )  );


          for i := 0 to Length( prymitywy_lista_t ) - 1 do
            Wieloosobowe__Strumieñ_Wyœlij(  wieloosobowe__komenda__odbierz__prymitywy_definicja_c, -99, IntToStr( i )  );


          Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__odbierz__l¹d_definicja_c, -99, '' );

        end;
      //---//if czy_serwer_g then

    end;
  //---//if   ( czy_gra_lokalna_g ) (...)


  // Gra lokalna.

  Gra_Rozpocznij_BitBtn.Enabled := false;
  Gra_Zakoñcz_BitBtn.Enabled := true;

  Gracz_Gotowoœæ_Tak_BitBtn.Enabled := false;
  Gracz_Gotowoœæ_Nie_BitBtn.Enabled := false;

  Statki_Zaprezentuj_Button.Enabled := false;
  Statki_Zaprezentuj__Zwolnij_BitBtn.Enabled := false;


  Elementy_Gry_Zwolnij();
  Elementy_Gry_Przygotuj();

  if not ( Gra_GLCamera.Parent is TStatek ) then
    Kamera_Prze³¹cz( kt_Statek ); // Ustawi kamerê na statku gracza.

end;//---//Gra_Rozpocznij_BitBtnClick().

//Gra_Zakoñcz_BitBtnClick().
procedure TStatki_Form.Gra_Zakoñcz_BitBtnClick( Sender: TObject );
begin

  Serwer_Wysy³a_Timer.Enabled := false;


  if   ( czy_serwer_g )
    or ( czy_gra_lokalna_g ) then
    begin

      Gra_Rozpocznij_BitBtn.Enabled := true;
      Gra_Zakoñcz_BitBtn.Enabled := false;

      Gracz_Gotowoœæ_BitBtnClick( Gracz_Gotowoœæ_Nie_BitBtn );

      //Gracz_Gotowoœæ_Tak_BitBtn.Enabled := true;
      //Gracz_Gotowoœæ_Nie_BitBtn.Enabled := true;

      Statki_Zaprezentuj_Button.Enabled := true;
      Statki_Zaprezentuj__Zwolnij_BitBtn.Enabled := true;


      if czy_serwer_g then
        begin

          Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__gra__zakoñcz_c, -99, '' );
          Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__gra__statystyki_wyœlij_c, -99, '' );

          Sleep( Klient_IdTCP_Czyta_Timer.Interval * 3 ); // Tak jest ustawiony zegar czytania klientów. //???

        end;
      //---//if czy_serwer_g then


      Gra_Statystyki_Wypisz();

    end;
  //---//if   ( czy_serwer_g ) (...)


  if IdUDPServer1.Active then
    IdUDPServer1.Active := false;

  IdUDPServer1.Bindings.Clear(); //???

  udp_klienci_lista_g.Usuñ_Wszystkich();


  Elementy_Gry_Zwolnij();

  L¹d_Utwórz( L¹d_ComboBox.ItemIndex ); // Wczytuje pozycje pocz¹tkowe statków.

  Statek__Utwórz_BitBtnClick( Sender );

  if not ( Gra_GLCamera.Parent is TStatek ) then
    Kamera_Prze³¹cz( kt_Statek ); // Ustawi kamerê na statku gracza.

end;//---//Gra_Zakoñcz_BitBtnClick().

//Gra_Wspó³czynnik_Prêdkoœci_SpinEditChange().
procedure TStatki_Form.Gra_Wspó³czynnik_Prêdkoœci_SpinEditChange( Sender: TObject );
var
  ztr : real;
begin

  ztr := Gra_Wspó³czynnik_Prêdkoœci_SpinEdit.Value / 100;

  if ztr <= 0 then
    ztr := 1;

  gra_wspó³czynnik_prêdkoœci_g := ztr;

  Gra_Wspó³czynnik_Prêdkoœci_Etykieta_Label.Caption := 'Prêdkoœæ gry ' + FloatToStr( gra_wspó³czynnik_prêdkoœci_g );

  Informacja_Dodatkowa_Dodaj( Gra_Wspó³czynnik_Prêdkoœci_Etykieta_Label.Caption );


  if gra_wspó³czynnik_prêdkoœci_g <> 0 then
    Radar_Timer.Interval := Round( 1000 / gra_wspó³czynnik_prêdkoœci_g );


  if czy_serwer_g then
    Wieloosobowe__Strumieñ_Wyœlij(  wieloosobowe__komenda__gra__wspó³czynnik_prêdkoœci_c, -99, IntToStr( Gra_Wspó³czynnik_Prêdkoœci_SpinEdit.Value )  );

end;//---//Gra_Wspó³czynnik_Prêdkoœci_SpinEditChange().

//Wieloosobowe__Tryb_RadioGroupClick().
procedure TStatki_Form.Wieloosobowe__Tryb_RadioGroupClick( Sender: TObject );
begin

  if Wieloosobowe__Tryb_RadioGroup.ItemIndex = 0 then // Brak.
    begin

      Wieloosobowe_Identyfikator_Edit.Text := '';
      Wieloosobowe_Identyfikator_Gra_Label.Caption := '<brak>';

    end;
  //---//if Wieloosobowe__Tryb_RadioGroup.ItemIndex = 0 then

end;//---//Wieloosobowe__Tryb_RadioGroupClick().

//Wieloosobowe__Pod³¹cz_BitBtnClick().
procedure TStatki_Form.Wieloosobowe__Pod³¹cz_BitBtnClick( Sender: TObject );
begin

  case Wieloosobowe__Tryb_RadioGroup.ItemIndex of
    0 : // Gra lokalna.
      begin

        czy_gra_lokalna_g := true;

      end;
    1 : // Klient.
      begin

        czy_serwer_g := false;
        czy_klient_g := true;
        czy_gra_lokalna_g := false;

      end;
    //---// 1
    2 : // Serwer.
      begin

        czy_serwer_g := true;
        czy_klient_g := false;
        czy_gra_lokalna_g := false;
        //czy_wysy³anie_trwa_g := false;

      end;
    //---// 2

    else//case Wieloosobowe__Tryb_RadioGroup.ItemIndex of
      begin

        czy_serwer_g := false;
        czy_klient_g := false;
        czy_gra_lokalna_g := false;
        //czy_wysy³anie_trwa_g := false;

      end;
    //---//
  end;
  //---//case Wieloosobowe__Tryb_RadioGroup.ItemIndex of


  Wieloosobowe__Tryb_RadioGroup.Enabled := false;
  Wieloosobowe__Pod³¹cz_BitBtn.Enabled := false;

  Gra_Rozpocznij_BitBtn.Enabled := true;

  Gracz_Gotowoœæ_Nie_BitBtn.Enabled := false;
  Gracz_Gotowoœæ_Tak_BitBtn.Enabled := true;


  if not czy_gra_lokalna_g then
    begin

      IdTCPClient1.Host := Serwer_Adres_IP_Edit.Text;
      IdTCPClient1.Port := Serwer_Port_SpinEdit.Value;
      IdTCPClient1.ReadTimeout := 5; //???
      IdTCPServer1.DefaultPort := Serwer_Port_SpinEdit.Value;

    end;
  //---//if not czy_gra_lokalna_g then


  if   ( czy_serwer_g )
    or ( czy_gra_lokalna_g ) then
    begin

      if czy_serwer_g then
        begin

          czy_wy³¹czanie_serwera_g := false;

          IdTCPServer1.Active := true;

        end;
      //---//if czy_serwer_g then


      tcp_klienci_lista_g.Dodaj_Aktualizuj( serwer_peer_port_c, -99 ); // Serwer ma peer_port_f i identyfikator_f = -1.
      Wieloosobowe_Identyfikator_Edit.Text := IntToStr( serwer_peer_port_c );
      Wieloosobowe_Identyfikator_Gra_Label.Caption := Wieloosobowe_Identyfikator_Edit.Text;

      Gracze_Lista_Odœwie¿();


      Gra_Zakoñcz_BitBtn.Enabled := false;
      SI_GroupBox.Enabled := true;

    end;
  //---//if   ( czy_serwer_g ) (...)


  if czy_klient_g then
    begin

      Gra_Rozpocznij_BitBtn.Enabled := false;
      Gra_Zakoñcz_BitBtn.Enabled := false;
      Gracze_Lista_Roz³¹cz_Gracza_BitBtn.Enabled := false;

      Interfejs_Aktywnoœæ_Ustaw_Klient( false );


      // Nawi¹zanie po³¹czenia.
      if not IdTCPClient1.Connected then
        begin

          try
            IdTCPClient1.Connect();
          except
            on E : Exception do
              begin
                Application.MessageBox(
                    PChar('Nie mo¿na nawi¹zaæ po³aczenia z serwerem: ' + IdTCPClient1.Host + #13 +
                    E.Message + ' ' + IntToStr( E.HelpContext ) + '.'), 'B³¹d',
                    MB_OK + MB_ICONEXCLAMATION
                  );
              end;
            //---//on E : Exception do
          end;
          //---//try


          if IdTCPClient1.Connected then
            begin

              //???Self.Caption := 'TCP UDP test ' + IntToStr( IdTCPClient1.Socket.Binding.Port );

              if Wieloosobowe_Identyfikator_Edit.Text = '' then
                Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__identyfikator__nadaj_c, -99, '' )
              else//if Wieloosobowe_Identyfikator_Edit.Text = '' then
                Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__identyfikator__przypomnij_c, -99, Wieloosobowe_Identyfikator_Edit.Text );


              Klient_IdTCP_Czyta_Timer.Enabled := true;

            end
          else//if not IdTCPClient1.Connected then
            begin

              Application.MessageBox( 'Nie uda³o siê po³¹czyæ z serwerem.', 'B³¹d', MB_OK + MB_ICONEXCLAMATION );
              Wieloosobowe__Od³¹cz_BitBtnClick( Sender );

            end;
          //---//if IdTCPClient1.Connected then

        end;
      //---//if not IdTCPClient1.Connected then

    end;
  //---//if czy_klient_g then

end;//---//Wieloosobowe__Pod³¹cz_BitBtnClick().

//Wieloosobowe__Od³¹cz_BitBtnClick().
procedure TStatki_Form.Wieloosobowe__Od³¹cz_BitBtnClick( Sender: TObject );
begin

  Gra_Zakoñcz_BitBtnClick( Sender );

  Klient_IdTCP_Czyta_Timer.Enabled := false;
  Klient_IdUDP_Czyta_Timer.Enabled := false;
  Klient_Wysy³a_Timer.Enabled := false;

  Gra_Rozpocznij_BitBtn.Enabled := true;
  Gra_Zakoñcz_BitBtn.Enabled := true;

  Gracz_Gotowoœæ_BitBtnClick( Gracz_Gotowoœæ_Nie_BitBtn );

  Gracz_Gotowoœæ_Nie_BitBtn.Enabled := false;
  Gracz_Gotowoœæ_Tak_BitBtn.Enabled := false;

  SI_GroupBox.Enabled := false;


  if IdUDPClient1.Connected then
    IdUDPClient1.Disconnect();

  if IdUDPServer1.Active then
    IdUDPServer1.Active := false;


  if IdTCPClient1.Connected then
    IdTCPClient1.Disconnect();

  if IdTCPServer1.Active then
    begin

      czy_wy³¹czanie_serwera_g := true;
      Wieloosobowe__Tekst_Wyœlij( wieloosobowe__komenda__serwer_wy³¹cza_siê_c );

      Sleep( Klient_IdTCP_Czyta_Timer.Interval * 3 ); // Tak jest ustawiony zegar czytania klientów. //???

      //IdTCPServer1.Bindings.Clear();

      //tcp_klienci_lista_g.Usuñ_Wszystkich();
      udp_klienci_lista_g.Usuñ_Wszystkich();


      IdTCPServer1.Active := false;
      //czy_wysy³anie_trwa_g := false;

      //Wieloosobowe_Identyfikator_Edit.Text := '';
      //Wieloosobowe_Identyfikator_Gra_Label.Caption := '<brak>';

    end;
  //---//if IdTCPServer1.Active then


  tcp_klienci_lista_g.Usuñ_Wszystkich(); // Czyœci równie¿ listê u klienta.
  //udp_klienci_lista_g.Usuñ_Wszystkich(); // Czyœci równie¿ listê u klienta.

  Wieloosobowe_Identyfikator_Edit.Text := ''; // Czyœci równie¿ u klienta.
  Wieloosobowe_Identyfikator_Gra_Label.Caption := '<brak>';


  if czy_klient_g then
    begin

      Statki_Zaprezentuj_Button.Enabled := true;
      Statki_Zaprezentuj__Zwolnij_BitBtn.Enabled := true;

      Interfejs_Aktywnoœæ_Ustaw_Klient( true );

    end;
  //---//if czy_klient_g then


  czy_gra_lokalna_g := false;
  czy_serwer_g := false;
  czy_klient_g := false;


  Wieloosobowe__Tryb_RadioGroup.Enabled := true;
  Wieloosobowe__Pod³¹cz_BitBtn.Enabled := true;
  Gracze_Lista_Roz³¹cz_Gracza_BitBtn.Enabled := true;

  Gracze_Lista_Odœwie¿();

end;//---//Wieloosobowe__Od³¹cz_BitBtnClick().

//IdTCPServer1Connect().
procedure TStatki_Form.IdTCPServer1Connect( AContext: TIdContext );
begin

  if czy_wy³¹czanie_serwera_g then
    Exit;


  if 1 = 2 then
    begin

        Wieloosobowe__Log_Wypisz(
            'Po³¹czenie od: ' + AContext.Connection.Socket.Binding.PeerIP +
            ':' + IntToStr( AContext.Connection.Socket.Binding.PeerPort ) +
            ' (iloœæ: ' + IntToStr( IdTCPServer1.Contexts.LockList.Count ) + ')'
          );
        //Wieloosobowe__Log_Wypisz( 'Otrzymany tekst: ' + AContext.Connection.AllData );


      IdTCPServer1.Contexts.UnlockList(); // Mo¿e to ma byæ tylko je¿eli wczeœniej tutaj odnosi siê do IdTCPServer1.Contexts (chyba tak).

    end;
  //---//if 1 = 2 then

end;//---//IdTCPServer1Connect().

//IdTCPServer1Disconnect().
procedure TStatki_Form.IdTCPServer1Disconnect( AContext: TIdContext );
var
  zt_tcp_klient_dane : TTCP_Klient_Dane;
begin

  if czy_wy³¹czanie_serwera_g then
    Exit;


  if 1 = 2 then
    begin

      Wieloosobowe__Log_Wypisz(
          'Od³¹czy³ siê: ' + AContext.Connection.Socket.Binding.PeerIP +
          ':' + IntToStr( AContext.Connection.Socket.Binding.PeerPort ) +
          ' (iloœæ: ' + IntToStr( IdTCPServer1.Contexts.LockList.Count - 1 ) + ')'
        );

      IdTCPServer1.Contexts.UnlockList(); // Mo¿e to ma byæ tylko je¿eli wczeœniej tutaj odnosi siê do IdTCPServer1.Contexts (chyba tak).

    end;
  //---//if 1 = 2 then


  zt_tcp_klient_dane := tcp_klienci_lista_g.ZnajdŸ_Peer_Port( AContext.Connection.Socket.Binding.PeerPort );

  if zt_tcp_klient_dane <> nil then
    udp_klienci_lista_g.Usuñ_Peer_Port( zt_tcp_klient_dane.peer_port_udp );


  tcp_klienci_lista_g.Usuñ_Peer_Port( AContext.Connection.Socket.Binding.PeerPort ); //??? roz³¹czenie z powodu sieci
  //tcp_klienci_lista_g.Od³¹czony_Peer_Port( AContext.Connection.Socket.Binding.PeerPort );


  Gracze_Lista_Odœwie¿();


  Serwer_Klient_Od³¹czenie_Timer.Enabled := true;

end;//---//IdTCPServer1Disconnect().

//IdTCPServer1Execute().
procedure TStatki_Form.IdTCPServer1Execute( AContext: TIdContext );
begin

  // Bez tego zdarzenia podczas aktywowania serwera zg³asza b³¹d, ¿e brakuje tego zdarzenia.

  if czy_wy³¹czanie_serwera_g then
    Exit;

  //Wieloosobowe__Log_Wypisz( 'IdTCPServer1Execute' );


  Log_Wypisz(  Wieloosobowe__Odczytaj( AContext.Connection.IOHandler, '', AContext, nil )  );

end;//---//IdTCPServer1Execute().

//IdUDPServer1UDPRead().
procedure TStatki_Form.IdUDPServer1UDPRead( AThread: TIdUDPListenerThread; const AData: TIdBytes; ABinding: TIdSocketHandle );
begin

  if czy_wy³¹czanie_serwera_g then
    Exit;

  //Wieloosobowe__Log_Wypisz( 'IdUDPServer1UDPRead' );


  //komenda_l := IdGlobal.BytesToString( AData, IdGlobal.IndyTextEncoding_UTF8 );
  Wieloosobowe__Odczytaj(  nil, IdGlobal.BytesToString( AData, IdGlobal.IndyTextEncoding_UTF8 ), nil, ABinding  );

end;//---//IdUDPServer1UDPRead().

//Serwer_Wysy³a_TimerTimer().
procedure TStatki_Form.Serwer_Wysy³a_TimerTimer( Sender: TObject );
begin

  //if czy_wysy³anie_trwa_g then //???
  //  Exit;


  //Wieloosobowe__Log_Wypisz( 'Serwer_Wysy³a_TimerTimer' );

  //czy_wysy³anie_trwa_g := true;

  //Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__odbierz__rekord_amunicja_c, -99, '' );
  //Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__odbierz__rekord_statki_c, -99, '' );

  Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__odbierz__rekord_amunicja_c, -99, '', true );
  Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__odbierz__rekord_statki_c, -99, '', true );
  //Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__odbierz__rekord_efekt_c, -99, '', true ); // Efekt wysy³any jako tabela.

  //czy_wysy³anie_trwa_g := false;


  if SecondsBetween( Now(), udp_data_czas_sprawdzanie_po³¹czeñ_ostatnie_g ) > udp_klient_po³¹czenie_potwierdzanie_sekund_c * 2 then
    begin

      udp_klienci_lista_g.Usuñ_Przeterminowanych();
      udp_data_czas_sprawdzanie_po³¹czeñ_ostatnie_g := Now();

    end;
  //---//if SecondsBetween( Now(), udp_data_czas_sprawdzanie_po³¹czeñ_ostatnie_g ) > udp_klient_po³¹czenie_potwierdzanie_sekund_c * 2 then

end;//---//Serwer_Wysy³a_TimerTimer().

//Klient_IdTCP_Czyta_TimerTimer().
procedure TStatki_Form.Klient_IdTCP_Czyta_TimerTimer( Sender: TObject );
var
  komenda_l : string;
begin

  if IdTCPClient1.Connected then
    try

      //check for a message from the server
      if IdTCPClient1.IOHandler.InputBufferIsEmpty then
        begin

          IdTCPClient1.IOHandler.CheckForDataOnSource( 10 );
          IdTCPClient1.IOHandler.CheckForDisconnect();

          if IdTCPClient1.IOHandler.InputBufferIsEmpty then
            Exit;

        end;
      //---//if IdTCPClient1.IOHandler.InputBufferIsEmpty then


      komenda_l := Wieloosobowe__Odczytaj( IdTCPClient1.IOHandler, '', nil, nil );


      //if Trim( komenda_l ) <> '' then
      //  Wieloosobowe__Log_Wypisz( 'Serwer TCP: ' + komenda_l );
      //Log_Wypisz( komenda_l );


      if    (  Pos( wieloosobowe__komenda__serwer_wy³¹cza_siê_c, komenda_l ) > 0  ) // Ze wzglêdu na to, ¿e w tym przyk³adzie serwer wysy³a jeszcze informacjê do kogo wysy³a tekst. //???
        and ( not czy_serwer_g ) then
        begin

          Wieloosobowe__Od³¹cz_BitBtnClick( Sender );
          Wieloosobowe_Identyfikator_Edit.Text := '';
          Wieloosobowe_Identyfikator_Gra_Label.Caption := '<brak>';

        end
      else//if    (  Pos( wieloosobowe__komenda__serwer_wy³¹cza_siê_c, komenda_l ) > 0  ) (...)
        Log_Wypisz( komenda_l );

    except
      on E : Exception do
        begin

          //Application.MessageBox(  PChar(E.Message + ' ' + IntToStr( E.HelpContext )), 'B³¹d', MB_OK + MB_ICONEXCLAMATION  );
          Log_Memo.Lines.Add( E.Message + ' ' + IntToStr( E.HelpContext ) );

        end;
      //---//on E : Exception do
    end;
    //---//try


  if not IdTCPClient1.Connected then
    Klient_IdTCP_Czyta_Timer.Enabled := false;

end;//---//Klient_IdTCP_Czyta_TimerTimer().

//Klient_IdUDP_Czyta_TimerTimer().
procedure TStatki_Form.Klient_IdUDP_Czyta_TimerTimer( Sender: TObject );
var
  komenda_l : string;
begin

  if IdUDPClient1.Connected then
    begin

      komenda_l := IdUDPClient1.ReceiveString( -1, IdGlobal.IndyTextEncoding_UTF8 );

      if Trim( komenda_l ) <> '' then
        komenda_l := Wieloosobowe__Odczytaj( nil, komenda_l, nil, nil );

      //if Trim( komenda_l ) <> '' then
      //  Wieloosobowe__Log_Wypisz( 'Serwer UDP: ' + komenda_l );


      // Klient przypomina, ¿e jest nadal po³¹czony.
      //if    ( udp_klienci_lista_g.klienci_lista_list.Count = 1 )
      //  and (  SecondsBetween( Now(), TUDP_Klient_Dane(udp_klienci_lista_g.klienci_lista_list[ 0 ]).data_czas_kontakt_ostatni ) > udp_klient_po³¹czenie_potwierdzanie_sekund_c  ) then
      if SecondsBetween( Now(), udp_data_czas_sprawdzanie_po³¹czeñ_ostatnie_g ) > udp_klient_po³¹czenie_potwierdzanie_sekund_c then
        begin

          Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__udp__klient_po³¹czony_nadal_c, -99, '', true );

          udp_data_czas_sprawdzanie_po³¹czeñ_ostatnie_g := Now();
          //TUDP_Klient_Dane(udp_klienci_lista_g.klienci_lista_list[ 0 ]).data_czas_kontakt_ostatni := Now();

        end;
      //---//if SecondsBetween( Now(), udp_data_czas_sprawdzanie_po³¹czeñ_ostatnie_g ) > udp_klient_po³¹czenie_potwierdzanie_sekund_c then

    end;
  //---//if IdUDPClient1.Connected then


  if   ( not IdTCPClient1.Connected )
    or ( not IdUDPClient1.Connected ) then
    begin

      Klient_IdUDP_Czyta_Timer.Enabled := false;
      Klient_Wysy³a_Timer.Enabled := false;

    end;
  //---//if   ( not IdTCPClient1.Connected ) (...)

end;//---//Klient_IdUDP_Czyta_TimerTimer().

//Klient_Wysy³a_TimerTimer().
procedure TStatki_Form.Klient_Wysy³a_TimerTimer( Sender: TObject );
begin

  if statek_gracza <> nil then
    begin

      if czy_klient_g then
        begin

          // Wysy³a informacjê o tym gdzie celuje gracz.

          wieloosobowe__statek_klawisze_obs³uga_r.id_statek := statek_gracza.id_statek; //??? na pocz¹tku gry
          wieloosobowe__statek_klawisze_obs³uga_r.klawisz := 0;
          wieloosobowe__statek_klawisze_obs³uga_r.shift := [];
          wieloosobowe__statek_klawisze_obs³uga_r.mysz_przycisk := -1;
          wieloosobowe__statek_klawisze_obs³uga_r.cel_wspó³rzêdne := statek_gracza.celownicza_linia.Nodes[ 1 ].AsVector;
          wieloosobowe__statek_klawisze_obs³uga_r.ar_artyleria := ar_Artyleria_CheckBox.Checked;
          wieloosobowe__statek_klawisze_obs³uga_r.ar_pocisk := ar_Pocisk_CheckBox.Checked;
          wieloosobowe__statek_klawisze_obs³uga_r.ar_torpeda := ar_Torpeda_CheckBox.Checked;
          wieloosobowe__statek_klawisze_obs³uga_r.ar_wszystkie := ar_Wszystkie_CheckBox.Checked;
          wieloosobowe__statek_klawisze_obs³uga_r.polecenie_nazwa := '';

          Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__statek__klawisze_obs³uga_c, -99, '' );

        end;
      //---//if czy_klient_g then

    end;
  //---//if statek_gracza <> nil then

end;//---//Klient_Wysy³a_TimerTimer().

//Serwer_Klient_Od³¹czenie_TimerTimer().
procedure TStatki_Form.Serwer_Klient_Od³¹czenie_TimerTimer( Sender: TObject );
begin

  // Je¿eli wysy³a informacjê od razu w zdarzeniu IdTCPServer1Disconnect() to serwer zg³asza b³¹d 'Connection Closed Gracefully'.

  Serwer_Klient_Od³¹czenie_Timer.Enabled := false;

  Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__gracz_lista_odœwie¿_c, -99, '' );

end;//---//Serwer_Klient_Od³¹czenie_TimerTimer().

//Pe³ny_Ekran_CheckBoxClick().
procedure TStatki_Form.Pe³ny_Ekran_CheckBoxClick( Sender: TObject );
begin

  if Pe³ny_Ekran_CheckBox.Checked then
    begin

      Pe³ny_Ekran_CheckBox.Tag := integer(wsMaximized);

      Self.BorderStyle := bsNone;
      Self.WindowState := wsMaximized;
      Self.Left := 0;
      Self.Top := 0;
      Self.Height := Screen.Height;
      Self.Width := Screen.Width;

      Self.BringToFront();
      //Radar_Panel.BringToFront();


      if PageControl1.Width = 1 then
        begin

          PageControl1.Width := 0;
          Opcje_Pionowy_Splitter.Visible := false;

        end;
      //---//if PageControl1.Width = 1 then

    end
  else//if Pe³ny_Ekran_CheckBox.Checked then
    begin

      Self.WindowState := System.UITypes.TWindowState(Pe³ny_Ekran_CheckBox.Tag);
      Self.BorderStyle := bsSizeable;


      if PageControl1.Width = 0 then
        begin

          Opcje_Pionowy_Splitter.Visible := true;
          PageControl1.Width := 1;

        end;
      //---//if PageControl1.Width = 0 then

    end;
  //---//if Pe³ny_Ekran_CheckBox.Checked then

end;//---//Pe³ny_Ekran_CheckBoxClick().

//Pokój_Rozmów__Na_Ekranie_CheckBoxClick().
procedure TStatki_Form.Pokój_Rozmów__Na_Ekranie_CheckBoxClick( Sender: TObject );
begin

  if Pokój_Rozmów__Na_Ekranie_CheckBox.Checked then
    begin

      // Na ekranie.

      Pokój_Rozmów_GroupBox.Align := alNone;
      Pokój_Rozmów_GroupBox.Parent := Statki_Form;
      Pokój_Rozmów_GroupBox.Anchors := [ akLeft, akBottom ];
      Pokój_Rozmów_GroupBox.Left := 0;

      Pokój_Rozmów__Ukryj_Button.Caption := 'x';
      Pokój_Rozmów__Ukryj_Button.Hint := 'Ukryj.';

      Pokój_Rozmów_GroupBox.Width := Pokój_Rozmów_GroupBox.Tag;

      FormResize( Sender );

      Pokój_Rozmów_Wiadomoœæ_Edit.SetFocus();

    end
  else//if Pokój_Rozmów__Na_Ekranie_CheckBox.Checked then
    begin

      // W zak³adkach.

      Pokój_Rozmów_GroupBox.Tag := Pokój_Rozmów_GroupBox.Width;

      Pokój_Rozmów_GroupBox.Parent := Gra_ScrollBox;
      Pokój_Rozmów_GroupBox.Align := alBottom;
      Pokój_Rozmów_GroupBox.Align := alTop;

      Pokój_Rozmów__Ukryj_Button.Caption := 'e';
      Pokój_Rozmów__Ukryj_Button.Hint := 'Wyœwietlaj pokój rozmów na ekranie gry.';

      //Gra_GLSceneViewer.SetFocus();
      Gra_GLSceneViewerMouseDown( Sender, System.UITypes.TMouseButton.mbLeft, [ System.Classes.ssHorizontal ], 0, 0 ); // Ze wzglêdu na Gra_GLSceneViewer.Tag i ssHorizontal nie strzeli.

    end;
  //---//if Pokój_Rozmów__Na_Ekranie_CheckBox.Checked then

end;//---//Pokój_Rozmów__Na_Ekranie_CheckBoxClick().

//Pokój_Rozmów__Wyœlij_Wiadomoœæ_ButtonClick().
procedure TStatki_Form.Pokój_Rozmów__Wyœlij_Wiadomoœæ_ButtonClick( Sender: TObject );
var
  i : integer;
begin

  if Trim( Pokój_Rozmów_Wiadomoœæ_Edit.Text ) <> '' then
    begin

      //if SecondsBetween( Now(), pokój_rozmów_ostatnia_wiadomoœæ_wys³ana_data_czas ) >= 1 then
      if MilliSecondsBetween( Now(), pokój_rozmów_ostatnia_wiadomoœæ_wys³ana_data_czas ) >= 500 then
        begin

          pokój_rozmów_ostatnia_wiadomoœæ_wys³ana_data_czas := Now();

          //Wieloosobowe__Tekst_Wyœlij( Pokój_Rozmów_Wiadomoœæ_Edit.Text );

          pokój_rozmów_r.id_nadawca := Gracz_Identyfikator();

          if pokój_rozmów_r.id_nadawca = -9999 then
            begin

              Application.MessageBox( 'Niepoprawny identyfikator nadawcy.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
              //Exit; //???

            end;
          //---//if pokój_rozmów_r.id_nadawca = -9999 then

          if   ( Pokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj_ComboBox.ItemIndex < 0 )
            or (  Pokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj_ComboBox.ItemIndex > Pokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj_ComboBox.Items.Count - 1 )
            or (  not Assigned( Pokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj_ComboBox.Items.Objects[ Pokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj_ComboBox.ItemIndex ] )  ) then
            begin

              Application.MessageBox( 'Nale¿y wskazaæ adresata wiadomoœci.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
              Exit;

            end;
          //---//if   ( Pokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj_ComboBox.ItemIndex < 0 ) (...)


          pokój_rozmów_r.id_odbiorca := TPokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj(Pokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj_ComboBox.Items.Objects[ Pokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj_ComboBox.ItemIndex ]).id_odbiorca;
          pokój_rozmów_r.data_czas_wys³ania := Now();
          pokój_rozmów_r.odbiorca_rodzaj := TPokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj(Pokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj_ComboBox.Items.Objects[ Pokój_Rozmów__Wyœlij_Do__Odbiorca_Rodzaj_ComboBox.ItemIndex ]).odbiorca_rodzaj; //pror_Wszyscy
          pokój_rozmów_r.wiadomoœæ := Pokój_Rozmów_Wiadomoœæ_Edit.Text;


          if czy_serwer_g then
            begin

              if pokój_rozmów_r.odbiorca_rodzaj = pror_Wszyscy then
                Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c, -99, '' )
              else//if pokój_rozmów_r.odbiorca_rodzaj = pror_Wszyscy then
                begin

                  for i := 0 to tcp_klienci_lista_g.klienci_lista_list.Count - 1 do
                    if    ( pokój_rozmów_r.id_nadawca <> TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator ) // Nie wysy³a wiadomoœci do siebie.
                      and (
                               (
                                     ( pokój_rozmów_r.odbiorca_rodzaj = pror_Gracz_Jeden )
                                 and ( pokój_rozmów_r.id_odbiorca = TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator )
                               )
                            or (
                                     ( pokój_rozmów_r.odbiorca_rodzaj = pror_Grupa_Jedna )
                                 and ( pokój_rozmów_r.id_odbiorca = TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).id_grupa )
                               )
                          ) then
                        begin

                          Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c, TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).peer_port_tcp, '' );

                          if pokój_rozmów_r.odbiorca_rodzaj = pror_Gracz_Jeden then
                            Break;

                        end;
                      //---//if    ( pokój_rozmów_r.id_nadawca <> TTCP_Klient_Dane(tcp_klienci_lista_g.klienci_lista_list[ i ]).identyfikator ) (...)

                end;
              //---//if pokój_rozmów_r.odbiorca_rodzaj = pror_Wszyscy then

              Pokój_Rozmów__Wyœwietl_Wiadomoœæ( pokój_rozmów_r );

            end
          else//if czy_serwer_g then
            if czy_klient_g then
              Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c, -99, '' );


          if   ( pokój_rozmów_ostatnia_wiadomoœci_wys³ane_treœæ_string_list.Count <= 0 )
            or (
                     ( pokój_rozmów_ostatnia_wiadomoœci_wys³ane_treœæ_string_list.Count > 0 )
                 and ( pokój_rozmów_ostatnia_wiadomoœci_wys³ane_treœæ_string_list[ pokój_rozmów_ostatnia_wiadomoœci_wys³ane_treœæ_string_list.Count - 1 ] <> Pokój_Rozmów_Wiadomoœæ_Edit.Text )
               ) then
            pokój_rozmów_ostatnia_wiadomoœci_wys³ane_treœæ_string_list.Add( Pokój_Rozmów_Wiadomoœæ_Edit.Text );

          while pokój_rozmów_ostatnia_wiadomoœci_wys³ane_treœæ_string_list.Count > 10 do
            pokój_rozmów_ostatnia_wiadomoœci_wys³ane_treœæ_string_list.Delete( 0 );


          Pokój_Rozmów_Wiadomoœæ_Edit.Text := '';
          Pokój_Rozmów_Wiadomoœæ_Edit.Tag := pokój_rozmów_ostatnia_wiadomoœci_wys³ane_treœæ_string_list.Count;


          pokój_rozmów_ostatnia_wiadomoœæ_wys³ana_data_czas := Now();

        end;
      //---//if MilliSecondsBetween( Now(), pokój_rozmów_ostatnia_wiadomoœæ_wys³ana_data_czas ) >= 500 then

    end
  else//if Trim( Pokój_Rozmów_Wiadomoœæ_Edit.Text ) <> '' then
    if    ( Sender <> nil )
      and ( TComponent(Sender).Name = Pokój_Rozmów__Wyœlij_Wiadomoœæ_Button.Name ) then
    else//if    ( Sender <> nil ) (...)
      if Pokój_Rozmów__Na_Ekranie_CheckBox.Checked then
        Pokój_Rozmów__Na_Ekranie_CheckBox.Checked := false;

end;//---//Pokój_Rozmów__Wyœlij_Wiadomoœæ_ButtonClick().

//Pokój_Rozmów_Wiadomoœæ_EditKeyDown().
procedure TStatki_Form.Pokój_Rozmów_Wiadomoœæ_EditKeyDown( Sender: TObject; var Key: Word; Shift: TShiftState );
var
  zti : integer;
begin

  // Enter.
  if Key = 13 then
    begin

      Key := 0;
      Pokój_Rozmów__Wyœlij_Wiadomoœæ_ButtonClick( Sender );

    end;
  //---//if Key = 13 then

  // Kursor góra.
  if    ( Key = VK_UP ) // 38.
    and ( Sender <> nil )
    and ( TComponent(Sender).Name = Pokój_Rozmów_Wiadomoœæ_Edit.Name ) then
    begin

      if Pokój_Rozmów_Wiadomoœæ_Edit.Tag > 0 then
        Pokój_Rozmów_Wiadomoœæ_Edit.Tag := Pokój_Rozmów_Wiadomoœæ_Edit.Tag - 1;

      if    ( pokój_rozmów_ostatnia_wiadomoœci_wys³ane_treœæ_string_list.Count > Pokój_Rozmów_Wiadomoœæ_Edit.Tag )
        and (  Trim( pokój_rozmów_ostatnia_wiadomoœci_wys³ane_treœæ_string_list[ Pokój_Rozmów_Wiadomoœæ_Edit.Tag ] ) <> ''  ) then
        begin

          Key := 0;

          zti := Pokój_Rozmów_Wiadomoœæ_Edit.SelStart;
          Pokój_Rozmów_Wiadomoœæ_Edit.Text := pokój_rozmów_ostatnia_wiadomoœci_wys³ane_treœæ_string_list[ Pokój_Rozmów_Wiadomoœæ_Edit.Tag ];
          Pokój_Rozmów_Wiadomoœæ_Edit.SelStart := zti;

        end;
      //---//if    ( pokój_rozmów_ostatnia_wiadomoœci_wys³ane_treœæ_string_list.Count > Pokój_Rozmów_Wiadomoœæ_Edit.Tag ) (...)

    end;
  //---//if    ( Key = VK_UP ) (...)

  // Kursor dó³.
  if    ( Key = VK_DOWN ) // 40.
    and ( Sender <> nil )
    and ( TComponent(Sender).Name = Pokój_Rozmów_Wiadomoœæ_Edit.Name ) then
    begin

      Key := 0;

      if Pokój_Rozmów_Wiadomoœæ_Edit.Tag <= pokój_rozmów_ostatnia_wiadomoœci_wys³ane_treœæ_string_list.Count - 1 then
        Pokój_Rozmów_Wiadomoœæ_Edit.Tag := Pokój_Rozmów_Wiadomoœæ_Edit.Tag + 1;

      if Pokój_Rozmów_Wiadomoœæ_Edit.Tag = pokój_rozmów_ostatnia_wiadomoœci_wys³ane_treœæ_string_list.Count then
        begin

          Pokój_Rozmów_Wiadomoœæ_Edit.Text := '';

        end
      else//if Pokój_Rozmów_Wiadomoœæ_Edit.Tag < pokój_rozmów_ostatnia_wiadomoœci_wys³ane_treœæ_string_list.Count then
        if    ( pokój_rozmów_ostatnia_wiadomoœci_wys³ane_treœæ_string_list.Count > Pokój_Rozmów_Wiadomoœæ_Edit.Tag )
          and (  Trim( pokój_rozmów_ostatnia_wiadomoœci_wys³ane_treœæ_string_list[ Pokój_Rozmów_Wiadomoœæ_Edit.Tag ] ) <> ''  ) then
          begin

            zti := Pokój_Rozmów_Wiadomoœæ_Edit.SelStart;
            Pokój_Rozmów_Wiadomoœæ_Edit.Text := pokój_rozmów_ostatnia_wiadomoœci_wys³ane_treœæ_string_list[ Pokój_Rozmów_Wiadomoœæ_Edit.Tag ];
            Pokój_Rozmów_Wiadomoœæ_Edit.SelStart := zti;

          end;
        //---//if    ( pokój_rozmów_ostatnia_wiadomoœci_wys³ane_treœæ_string_list.Count > Pokój_Rozmów_Wiadomoœæ_Edit.Tag ) (...)

    end;
  //---//if    ( Key = VK_DOWN ) (...)

end;//---//Pokój_Rozmów_Wiadomoœæ_EditKeyDown().

//Pokój_Rozmów__Ukryj_ButtonClick().
procedure TStatki_Form.Pokój_Rozmów__Ukryj_ButtonClick( Sender: TObject );
begin

  Pokój_Rozmów__Na_Ekranie_CheckBox.Checked := not Pokój_Rozmów__Na_Ekranie_CheckBox.Checked;

end;//---//Pokój_Rozmów__Ukryj_ButtonClick().

//Pokój_Rozmów_Przyciski_PanelMouseDown().
procedure TStatki_Form.Pokój_Rozmów_Przyciski_PanelMouseDown( Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer );
begin

  pokój_rozmów__zmiana_szerokoœci__szerokoœæ_pocz¹tkowa_g := Pokój_Rozmów_GroupBox.Width;
  pokój_rozmów__zmiana_szerokoœci__wysokoœæ_pocz¹tkowa_g := Pokój_Rozmów_GroupBox.Height;
  pokój_rozmów__zmiana_szerokoœci__x_pocz¹tkowy_g := X;
  pokój_rozmów__zmiana_szerokoœci__y_pocz¹tkowy_g := Y;

  pokój_rozmów__zmiana_szerokoœci__aktywnoœæ_g := true;

end;//---//Pokój_Rozmów_Przyciski_PanelMouseDown().

//Pokój_Rozmów_Przyciski_PanelMouseMove().
procedure TStatki_Form.Pokój_Rozmów_Przyciski_PanelMouseMove( Sender: TObject; Shift: TShiftState; X, Y: Integer );
var
  zti : integer;
begin

  if pokój_rozmów__zmiana_szerokoœci__aktywnoœæ_g then
    begin

      if Pokój_Rozmów__Na_Ekranie_CheckBox.Checked then
        begin

          zti := pokój_rozmów__zmiana_szerokoœci__szerokoœæ_pocz¹tkowa_g + X - pokój_rozmów__zmiana_szerokoœci__x_pocz¹tkowy_g;

          if zti >= 25 then
            Pokój_Rozmów_GroupBox.Width := zti;

        end;
      //---//if Pokój_Rozmów__Na_Ekranie_CheckBox.Checked then


      zti := pokój_rozmów__zmiana_szerokoœci__wysokoœæ_pocz¹tkowa_g + Y - pokój_rozmów__zmiana_szerokoœci__y_pocz¹tkowy_g;

      if zti >= 50 then
        Pokój_Rozmów_GroupBox.Height := zti;

    end;
  //---//if pokój_rozmów__zmiana_szerokoœci__aktywnoœæ_g then

end;//---//Pokój_Rozmów_Przyciski_PanelMouseMove().

//Pokój_Rozmów_Przyciski_PanelMouseUp().
procedure TStatki_Form.Pokój_Rozmów_Przyciski_PanelMouseUp( Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer );
begin

  pokój_rozmów__zmiana_szerokoœci__aktywnoœæ_g := false;

  FormResize( Sender );

end;//---//Pokój_Rozmów_Przyciski_PanelMouseUp().

//Gracz_Gotowoœæ_BitBtnClick().
procedure TStatki_Form.Gracz_Gotowoœæ_BitBtnClick( Sender: TObject );
var
  zt_tcp_klient_dane : TTCP_Klient_Dane;
begin

  if    ( Sender <> nil )
    and ( TComponent(Sender).Name = Gracz_Gotowoœæ_Nie_BitBtn.Name ) then
    begin

      Gracz_Gotowoœæ_Nie_BitBtn.Enabled := false;
      Gracz_Gotowoœæ_Tak_BitBtn.Enabled := true;

      Gracz_Grupa_SpinEdit.Enabled := true;
      Gracz_Nazwa_Edit.Enabled := true;
      Statek_GroupBox.Enabled := true;


      if czy_klient_g then
        Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__gracz_gotowoœæ_c, -99, 'Nie' )
      else//if czy_klient_g then
        begin

          // Serwer.

          L¹d_GroupBox.Enabled := true;
          SI__Dodaj_BitBtn.Enabled := true;
          Statki_Pozycje_Pocz¹tkowe_GroupBox.Enabled := true;


          zt_tcp_klient_dane := tcp_klienci_lista_g.ZnajdŸ_Peer_Port( serwer_peer_port_c );

          if zt_tcp_klient_dane <> nil then
            zt_tcp_klient_dane.gotowy := false;

          Gracze_Lista_Odœwie¿();

          Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__gracz_lista_odœwie¿_c, -99, '' );

        end;
      //---//if czy_klient_g then

    end
  else//if    ( Sender <> nil ) (...)
    begin

      if Trim( Gracz_Nazwa_Edit.Text ) = '' then
        begin

          Application.MessageBox( 'Nazwa gracza nie mo¿e byæ pusta.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
          Exit;

        end;
      //---//if Trim( Gracz_Nazwa_Edit.Text ) = '' then

      if   ( Statek_ComboBox.ItemIndex < 0 )
        or (  Trim( Statek_ComboBox.Text ) = ''  ) then
        begin

          Application.MessageBox( 'Nale¿y wybraæ statek.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
          Exit;

        end;
      //---//if   ( Statek_ComboBox.ItemIndex < 0 ) (...)


      if czy_klient_g then
        Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__gracz_gotowoœæ_c, -99, 'Tak' )
      else//if czy_klient_g then
        begin

          // Serwer.

          if not tcp_klienci_lista_g.Nazwa_Niepowtarzalna( serwer_peer_port_c, Gracz_Nazwa_Edit.Text ) then
            begin

              Application.MessageBox( 'Nazwa gracza powinna byæ niepowtarzalna.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
              Exit;

            end;
          //---//if not tcp_klienci_lista_g.Nazwa_Niepowtarzalna( serwer_peer_port_c, Gracz_Nazwa_Edit.Text ) then


          Gracz_Gotowoœæ_Nie_BitBtn.Enabled := true;
          Gracz_Gotowoœæ_Tak_BitBtn.Enabled := false;

          Gracz_Grupa_SpinEdit.Enabled := false;
          Gracz_Nazwa_Edit.Enabled := false;
          L¹d_GroupBox.Enabled := false;
          SI__Dodaj_BitBtn.Enabled := false;
          Statek_GroupBox.Enabled := false;
          Statki_Pozycje_Pocz¹tkowe_GroupBox.Enabled := false;


          zt_tcp_klient_dane := tcp_klienci_lista_g.ZnajdŸ_Peer_Port( serwer_peer_port_c );

          if zt_tcp_klient_dane <> nil then
            begin

              zt_tcp_klient_dane.id_grupa := Gracz_Grupa_SpinEdit.Value;
              zt_tcp_klient_dane.id_statek_schemat := Statek_ComboBox.ItemIndex;
              zt_tcp_klient_dane.gotowy := true;
              zt_tcp_klient_dane.nazwa := Gracz_Nazwa_Edit.Text;

            end;
          //---//if zt_tcp_klient_dane <> nil then


          Gracze_Lista_Odœwie¿();

          Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__gracz_lista_odœwie¿_c, -99, '' );

        end;
      //---//if czy_klient_g then

    end;
  //---//if    ( Sender <> nil ) (...)

end;//---//Gracz_Gotowoœæ_BitBtnClick().

//Gracze_Lista_Odœwie¿_BitBtnClick().
procedure TStatki_Form.Gracze_Lista_Odœwie¿_BitBtnClick( Sender: TObject );
begin

  if   ( czy_serwer_g )
    or ( czy_gra_lokalna_g ) then
    Gracze_Lista_Odœwie¿()
  else//if   ( czy_serwer_g ) (...)
  if czy_klient_g then
    Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__gracz_lista_odœwie¿_c, -99, '' );

end;//---//Gracze_Lista_Odœwie¿_BitBtnClick().

//Gracze_Lista_Roz³¹cz_Gracza_BitBtnClick().
procedure TStatki_Form.Gracze_Lista_Roz³¹cz_Gracza_BitBtnClick( Sender: TObject );
var
  zti : integer;
  zt_tcp_klient_dane : TTCP_Klient_Dane;
begin

  if    ( not czy_gra_lokalna_g )
    and ( not czy_serwer_g ) then
    Exit;


  if Gracze_Lista_StringGrid.RowCount <= 1 then
    begin

      Application.MessageBox( 'Nale¿y wskazaæ gracza.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
      Exit;

    end;
  //---//if Gracze_Lista_StringGrid.RowCount <= 1 then

  if Gracze_Lista_StringGrid.ColCount <= 3 then
    begin

      Application.MessageBox( 'Nieprawid³owa lista graczy.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
      Exit;

    end;
  //---//if Gracze_Lista_StringGrid.ColCount <= 3 then


  try
    zti := StrToInt( Gracze_Lista_StringGrid.Cells[ 1, Gracze_Lista_StringGrid.Row ] );
  except
    Application.MessageBox( 'Nie uda³o siê odczytaæ identyfikatora gracza.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
    Exit;
  end;
  //---//try

  if zti = Gracz_Identyfikator() then
    begin

      Application.MessageBox( 'Nie mo¿na roz³¹czyæ samego siebie.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
      Exit;

    end;
  //---//if zti = Gracz_Identyfikator() then


  zt_tcp_klient_dane := tcp_klienci_lista_g.ZnajdŸ_Identyfikator( zti );

  if zt_tcp_klient_dane = nil then
    Application.MessageBox( 'Nie uda³o siê odnaleŸæ gracza o zadanym identyfikatorze.', 'Informacja', MB_OK + MB_ICONEXCLAMATION )
  else//if zt_tcp_klient_dane = nil then
    begin

      if zt_tcp_klient_dane.peer_port_tcp = serwer_peer_port_c then
        begin

          Application.MessageBox( 'Nie mo¿na roz³¹czyæ serwera.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
          Exit;

        end;
      //---//if zt_tcp_klient_dane.peer_port_tcp = serwer_peer_port_c then


      if zt_tcp_klient_dane.peer_port_tcp = si_peer_port_c then
        begin

          // Usuwa SI z listy.

          tcp_klienci_lista_g.Usuñ_Identyfikator( zt_tcp_klient_dane.identyfikator );

          Gracze_Lista_Odœwie¿();

          Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__gracz_lista_odœwie¿_c, -99, '' );

        end
      else//if zt_tcp_klient_dane.peer_port_tcp = si_peer_port_c then
        Gracze_Lista_Roz³¹cz( zt_tcp_klient_dane.peer_port_tcp );

    end;
  //---//if zt_tcp_klient_dane = nil then

end;//---//Gracze_Lista_Roz³¹cz_Gracza_BitBtnClick().

//SI__Dodaj_BitBtnClick().
procedure TStatki_Form.SI__Dodaj_BitBtnClick( Sender: TObject );
var
  zt_tcp_klient_dane : TTCP_Klient_Dane;
begin

  if    ( not czy_gra_lokalna_g )
    and ( not czy_serwer_g ) then
    Exit;


  if Trim( SI__Nazwa_Edit.Text ) = '' then
    begin

      Application.MessageBox( 'Nazwa gracza nie mo¿e byæ pusta.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
      Exit;

    end;
  //---//if Trim( SI__Nazwa_Edit.Text ) = '' then

  if   ( SI__Statek_ComboBox.ItemIndex < 0 )
    or (  Trim( SI__Statek_ComboBox.Text ) = ''  ) then
    begin

      Application.MessageBox( 'Nale¿y wybraæ statek.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
      Exit;

    end;
  //---//if   ( SI__Statek_ComboBox.ItemIndex < 0 ) (...)

  if not tcp_klienci_lista_g.Nazwa_Niepowtarzalna( SI__Nazwa_Edit.Text ) then
    begin

      Application.MessageBox( 'Nazwa gracza powinna byæ niepowtarzalna.', 'Informacja', MB_OK + MB_ICONEXCLAMATION );
      Exit;

    end;
  //---//if not tcp_klienci_lista_g.Nazwa_Niepowtarzalna( si_peer_port_c, SI__Nazwa_Edit.Text ) then



  zt_tcp_klient_dane := tcp_klienci_lista_g.Dodaj_Aktualizuj( si_peer_port_c, -99 ); // Serwer ma peer_port_f i identyfikator_f = -1.

  if zt_tcp_klient_dane <> nil then
    begin

      zt_tcp_klient_dane.id_grupa := SI__Grupa_SpinEdit.Value;
      zt_tcp_klient_dane.id_statek_schemat := SI__Statek_ComboBox.ItemIndex;
      zt_tcp_klient_dane.gotowy := true;
      zt_tcp_klient_dane.nazwa := SI__Nazwa_Edit.Text;

    end;
  //---//if zt_tcp_klient_dane <> nil then


  Gracze_Lista_Odœwie¿();

  Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__gracz_lista_odœwie¿_c, -99, '' );

end;//---//SI__Dodaj_BitBtnClick().

//Edit_Jako_Spin_KeyDown().
procedure TStatki_Form.Edit_Jako_Spin_KeyDown( Sender: TObject; var Key: Word; Shift: TShiftState );
var
  kursor_pozycja : integer;
  ztr,
  pole_wartoœæ
    : real;
  zts : string;
begin

  // Zwiêksza lub zmniejsza wartoœæ liczbow¹ w polu tekstowym.
  //
  // Podstawowy SpinEdit pozwala tylko na liczby ca³kowite a nie chcê dodawaæ komponentów, których mo¿e nie byæ w podstawowych wersjach IDE.

  if   ( Sender = nil )
    or (
             ( Sender <> nil )
         and (  not ( Sender is TEdit )  )
       )
    or (
             ( Key <> VK_UP ) // Strza³ka w górê.
         and ( Key <> VK_DOWN ) // Strza³ka w dó³.
       ) then
    Exit;


  zts := TEdit(Sender).Text;
  zts := StringReplace( zts, ' ', '', [ rfReplaceAll ] );
  zts := StringReplace( zts, '.', ',', [ rfReplaceAll ] );

  try
    pole_wartoœæ := StrToFloat( zts );
  except
    Exit;
  end;
  //---//try


  kursor_pozycja := TEdit(Sender).SelStart; // Indeksowane od 0, zts od 1.


  if Pos( ',', zts ) < kursor_pozycja + 1 then
    ztr := 0.1
  else//if Pos( ',', zts ) < TEdit(Sender).SelStart then
    ztr := 1;


  if    ( Sender <> nil )
    and ( TComponent(Sender).Name = Amunicja__Zanurzenie_G³êbokoœæ_Zadana_Edit.Name ) then
    begin

      zts := Amunicja__Zanurzenie_G³êbokoœæ_Zadana__Skok_O_Edit.Text;
      zts := StringReplace( zts, ' ', '', [ rfReplaceAll ] );
      zts := StringReplace( zts, '.', ',', [ rfReplaceAll ] );

      try
        if StrToFloat( zts ) > 0 then
          ztr := StrToFloat( zts );
      except
      end;
      //---//try

    end;
  //---//if    ( Sender <> nil ) (...)


  // Strza³ka w dó³.
  if Key = VK_DOWN then
    ztr := -ztr;

  Key := 0;

  pole_wartoœæ := pole_wartoœæ + ztr;


  zts := FloatToStr( pole_wartoœæ );
  zts := StringReplace( zts, ',', '.', [ rfReplaceAll ] );
  TEdit(Sender).Text := zts;


  TEdit(Sender).SelStart := kursor_pozycja;

end;//---//Edit_Jako_Spin_KeyDown().

//ScrollBoxMouseWheel().
procedure TStatki_Form.ScrollBoxMouseWheel( Sender: TObject; Shift: TShiftState; WheelDelta: Integer; MousePos: TPoint; var Handled: Boolean );
begin

  if   ( Sender = nil )
    or (
             ( Sender <> nil )
         and (  not ( Sender is TScrollBox )  )
       ) then
    Exit;


  if WheelDelta < 0 then
    TScrollBox(Sender).VertScrollBar.Position := TScrollBox(Sender).VertScrollBar.Position + TScrollBox(Sender).VertScrollBar.Increment
  else//if WheelDelta < 0 then
    TScrollBox(Sender).VertScrollBar.Position := TScrollBox(Sender).VertScrollBar.Position - TScrollBox(Sender).VertScrollBar.Increment;

end;//---//ScrollBoxMouseWheel().

//Ustawienia_Zapisz_ButtonClick().
procedure TStatki_Form.Ustawienia_Zapisz_ButtonClick( Sender: TObject );
begin

  if Application.MessageBox( 'Czy zapisaæ ustawienia?', 'Potwierdzenie', MB_YESNO + MB_DEFBUTTON2 + MB_ICONQUESTION ) <> IDYES then
    Exit;

  Ustawienia_Plik( true );

end;//---//Ustawienia_Zapisz_ButtonClick().

//Ustawienia_Wczytaj_ButtonClick().
procedure TStatki_Form.Ustawienia_Wczytaj_ButtonClick( Sender: TObject );
begin

  Ustawienia_Plik();

end;//---//Ustawienia_Wczytaj_ButtonClick().

//Amunicja__Zanurzenie_G³êbokoœæ_Zadana_EditChange().
procedure TStatki_Form.Amunicja__Zanurzenie_G³êbokoœæ_Zadana_EditChange( Sender: TObject );
var
  zts : string;
begin

  // Podstawowy SpinEdit pozwala tylko na liczby ca³kowite a nie chcê dodawaæ komponentów, których mo¿e nie byæ w podstawowych wersjach IDE.

  if    ( Sender <> nil )
    and ( TComponent(Sender).Name = Amunicja__Zanurzenie_G³êbokoœæ_Zadana__Skok_O_Edit.Name ) then
    begin

      zts := Amunicja__Zanurzenie_G³êbokoœæ_Zadana__Skok_O_Edit.Text;
      zts := StringReplace( zts, ' ', '', [ rfReplaceAll ] );
      zts := StringReplace( zts, '.', ',', [ rfReplaceAll ] );

      try
        Amunicja__Zanurzenie_G³êbokoœæ_Zadana__Skok_O_Label.Caption := Trim(   FormatFloat(  '### ### ##0.000000', StrToFloat( zts )  )   );
      except
      end;
      //---//try


    end
  else//if    ( Sender <> nil ) (...)
    begin

      zts := Amunicja__Zanurzenie_G³êbokoœæ_Zadana_Edit.Text;
      zts := StringReplace( zts, ' ', '', [ rfReplaceAll ] );
      zts := StringReplace( zts, '.', ',', [ rfReplaceAll ] );

      try
        Amunicja__Zanurzenie_G³êbokoœæ_Zadana_Label.Caption := Trim(   FormatFloat(  '### ### ##0.000000', StrToFloat( zts )  )   );
      except
      end;
      //---//try

    end;
  //---//if    ( Sender <> nil ) (...)


  Informacja_Dodatkowa_Dodaj( 'Torpeda g³êbokoœæ zadana: ' + Amunicja__Zanurzenie_G³êbokoœæ_Zadana_Label.Caption + '.', informacja_dodatkowa__wyœwietlanie_czas_sekund__krótki_c );

end;//---//Amunicja__Zanurzenie_G³êbokoœæ_Zadana_EditChange().

//Celowanie_Tryb_RadioGroupClick().
procedure TStatki_Form.Celowanie_Tryb_RadioGroupClick( Sender: TObject );
begin

  if Celowanie_Tryb_RadioGroup.ItemIndex = 0 then // równoleg³y.
    celowanie_tryb_g := ct_Linia // Namierzanie równoleg³e do linii celowania.
  else//if Celowanie_Tryb_RadioGroup.ItemIndex = 0 then
    celowanie_tryb_g := ct_Punkt; // Namierzanie zbie¿ne do punktu celowania.

end;//---//Celowanie_Tryb_RadioGroupClick().

//Celownik_Widocznoœæ_CheckBoxClick().
procedure TStatki_Form.Celownik_Widocznoœæ_CheckBoxClick( Sender: TObject );
begin

  Celowniczy_GLDummyCube.Visible := Celownik_Widocznoœæ_CheckBox.Checked;

end;//---//Celownik_Widocznoœæ_CheckBoxClick().

//Celownik_Wielkoœæ_EditChange().
procedure TStatki_Form.Celownik_Wielkoœæ_EditChange( Sender: TObject );
var
  zts : string;
begin

  // Podstawowy SpinEdit pozwala tylko na liczby ca³kowite a nie chcê dodawaæ komponentów, których mo¿e nie byæ w podstawowych wersjach IDE.

  zts := Celownik_Wielkoœæ_Edit.Text;
  zts := StringReplace( zts, ' ', '', [ rfReplaceAll ] );
  zts := StringReplace( zts, '.', ',', [ rfReplaceAll ] );

  try
    Celowniczy_GLDummyCube.CubeSize := Abs(  StrToFloat( zts )  );
  except
  end;
  //---//try

  Celownik_Wielkoœæ_Label.Caption := Trim(  FormatFloat( '### ### ##0.000000', Celowniczy_GLDummyCube.CubeSize )  );

end;//---//Celownik_Wielkoœæ_EditChange().

//Kamera_Szybkoœæ_Ruchu_EditChange().
procedure TStatki_Form.Kamera_Szybkoœæ_Ruchu_EditChange( Sender: TObject );
var
  zts : string;
begin

  // Podstawowy SpinEdit pozwala tylko na liczby ca³kowite a nie chcê dodawaæ komponentów, których mo¿e nie byæ w podstawowych wersjach IDE.

  zts := Kamera_Szybkoœæ_Ruchu_Edit.Text;
  zts := StringReplace( zts, ' ', '', [ rfReplaceAll ] );
  zts := StringReplace( zts, '.', ',', [ rfReplaceAll ] );

  try
    kamera_szybkoœæ_ruchu_g := StrToFloat( zts );
  except
  end;
  //---//try

  Kamera_Szybkoœæ_Ruchu_Label.Caption := Trim(  FormatFloat( '### ### ##0.000000', kamera_szybkoœæ_ruchu_g )  );

end;//---//Kamera_Szybkoœæ_Ruchu_EditChange().

//Morze_Wzburzenie_SpinEditChange().
procedure TStatki_Form.Morze_Wzburzenie_SpinEditChange( Sender: TObject );
begin

  Informacja_Dodatkowa_Dodaj(   Morze_Wzburzenie_Etykieta_Label.Caption + ' ' + Trim(  FormatFloat( '### ### ##0', Morze_Wzburzenie_SpinEdit.Value )  )   );

  if czy_serwer_g then
    Wieloosobowe__Strumieñ_Wyœlij(  wieloosobowe__komenda__gra__morze_wzburzenie_c, -99, IntToStr( Morze_Wzburzenie_SpinEdit.Value )  );

end;//---//Morze_Wzburzenie_SpinEditChange().

//Mysz_Czu³oœæ_EditChange().
procedure TStatki_Form.Mysz_Czu³oœæ_EditChange( Sender: TObject );
var
  zts : string;
begin

  // Podstawowy SpinEdit pozwala tylko na liczby ca³kowite a nie chcê dodawaæ komponentów, których mo¿e nie byæ w podstawowych wersjach IDE.

  zts := Mysz_Czu³oœæ_Edit.Text;
  zts := StringReplace( zts, ' ', '', [ rfReplaceAll ] );
  zts := StringReplace( zts, '.', ',', [ rfReplaceAll ] );

  try
    Gra_GLUserInterface.MouseSpeed := StrToFloat( zts );
  except
  end;
  //---//try

  mysz_czu³oœæ_g := Gra_GLUserInterface.MouseSpeed;


  zts := Mysz_Czu³oœæ_Luneta_Edit.Text;
  zts := StringReplace( zts, ' ', '', [ rfReplaceAll ] );
  zts := StringReplace( zts, '.', ',', [ rfReplaceAll ] );

  try
    mysz_czu³oœæ_luneta_g := StrToFloat( zts );
  except
  end;
  //---//try

  Mysz_Czu³oœæ_Label.Caption := Trim(  FormatFloat( '### ### ##0.000000', Gra_GLUserInterface.MouseSpeed )  );
  Mysz_Czu³oœæ_Luneta_Label.Caption := Trim(  FormatFloat( '### ### ##0.000000', mysz_czu³oœæ_luneta_g )  );

end;//---//Mysz_Czu³oœæ_EditChange().

//Elementy_Gracza_Dostosuj_CheckBoxClick().
procedure TStatki_Form.Elementy_Gracza_Dostosuj_CheckBoxClick( Sender: TObject );
var
  i : integer;
begin

  if statek_gracza <> nil then
    statek_gracza.Elementy_Gracza_Dostosuj( -99, Punkty_¯ycia_WskaŸnik__Gracz_CheckBox.Checked, false, false, Obrót_K¹t_Zablokowany_WskaŸnik_CheckBox.Checked, Obrót_K¹t_Zablokowany_Strza³_WskaŸnik_CheckBox.Checked );


  for i := 0 to Length( statki_t ) - 1 do
    if    ( statki_t[ i ] <> statek_gracza )
      and ( statki_t[ i ] <> nil ) then
      statki_t[ i ].Elementy_Gracza_Dostosuj( Gracz_Grupa_SpinEdit.Value, false, Punkty_¯ycia_WskaŸnik__Przeciwnik_CheckBox.Checked, Punkty_¯ycia_WskaŸnik__Sojusznik_CheckBox.Checked, false, false );

end;//---//Elementy_Gracza_Dostosuj_CheckBoxClick().

//Radar_Widocznoœæ_CheckBoxClick().
procedure TStatki_Form.Radar_Widocznoœæ_CheckBoxClick( Sender: TObject );
begin

  Radar_Panel.Visible := Radar_Widocznoœæ_CheckBox.Checked;

  FormResize( Sender );

end;//---//Radar_Widocznoœæ_CheckBoxClick().

//Projektowy_Tryb_CheckBoxClick().
procedure TStatki_Form.Projektowy_Tryb_CheckBoxClick( Sender: TObject );
begin

  Gra_Obiekty_GLDummyCube.Pickable := Projektowy_Tryb_CheckBox.Checked;


  if Projektowy_Tryb_CheckBox.Checked then
    projektowy_tryb__statek := statek_gracza;

end;//---//Projektowy_Tryb_CheckBoxClick().

//Informacje_Dodatkowe_TimerTimer().
procedure TStatki_Form.Informacje_Dodatkowe_TimerTimer( Sender: TObject );
var
  i : integer;
begin

  for i := informacje_dodatkowe_list.Count - 1 downto 0 do
    begin

      if SecondsBetween( Now(), TInformacje_Dodatkowe(informacje_dodatkowe_list[ i ]).utworzenie_data_czas ) > TInformacje_Dodatkowe(informacje_dodatkowe_list[ i ]).wyœwietlanie_czas_sekund then
        begin

          TInformacje_Dodatkowe(informacje_dodatkowe_list[ i ]).Free();
          informacje_dodatkowe_list.Delete( i );

        end;
      //---//if SecondsBetween( Now(), TInformacje_Dodatkowe(informacje_dodatkowe_list[ i ]).utworzenie_data_czas ) > TInformacje_Dodatkowe(informacje_dodatkowe_list[ i ]).wyœwietlanie_czas_sekund then

    end;
  //---//for i := informacje_dodatkowe_list.Count - 1 downto 0 do


  Informacje_Dodatkowe_GLHUDText.Text := '';


  for i := 0 to informacje_dodatkowe_list.Count - 1 do
    begin

      Informacje_Dodatkowe_GLHUDText.Text := Informacje_Dodatkowe_GLHUDText.Text + #13 + #10
        + TInformacje_Dodatkowe(informacje_dodatkowe_list[ i ]).napis;

    end;
  //---//for i := 0 to informacje_dodatkowe_list.Count - 1 do

end;//---//Informacje_Dodatkowe_TimerTimer().

//Radar_GLSceneViewerMouseMove().
procedure TStatki_Form.Radar_GLSceneViewerMouseMove( Sender: TObject; Shift: TShiftState; X, Y: Integer );
begin

  wspó³rzêdne_œwiata_z_radaru_affine_vector_g := Radar_GLSceneViewer.Buffer.PixelRayToWorld( x, y );
  wspó³rzêdne_œwiata_z_radaru_affine_vector_g.Y := 0;

end;//---//Radar_GLSceneViewerMouseMove().

//Radar_Wielkoœæ_ButtonClick().
procedure TStatki_Form.Radar_Wielkoœæ_ButtonClick( Sender: TObject );
begin

  if    ( Sender <> nil )
    and ( TComponent(Sender).Name = Radar_Pomniejsz_Button.Name ) then
    Radar_Panel.Tag := Radar_Panel.Tag - 10
  else//if    ( Sender <> nil ) (...)
    Radar_Panel.Tag := Radar_Panel.Tag + 10;


  if Radar_Panel.Tag < 5 then
    Radar_Panel.Tag := 5
  else//if Radar_Panel.Tag < 5 then
    if Radar_Panel.Tag > 95 then
      Radar_Panel.Tag := 95;


  FormResize( Sender );

end;//---//Radar_Wielkoœæ_ButtonClick().

//Radar_TimerTimer().
procedure TStatki_Form.Radar_TimerTimer( Sender: TObject );
var
  ztr : real;
begin

  // Komponent dok³adnie nie pilnuje zakresów.
  if Radar_Skala_SpinEdit.Value < Radar_Skala_SpinEdit.MinValue then
    Radar_Skala_SpinEdit.Value := Radar_Skala_SpinEdit.MinValue;


  if Radar_Zmieniaj_Czu³oœæ_Wraz_Ze_Skal¹_CheckBox.Checked then
    Radar_Czu³oœæ_SpinEdit.Tag := Radar_Skala_SpinEdit.Value;


  // Dostosowuje wielkoœæ statku gracza na radarze.
  Radar_Statek_GLFrustrum.Scale.X := 3.0 * Radar_Koryguj_Wielkoœæ_Obiektów();
  Radar_Statek_GLFrustrum.Scale.Y := 6.0 * Radar_Koryguj_Wielkoœæ_Obiektów();


  Radio_Statki_W_Zasiêgu();


  Radar_Wyczyœæ();

  Radar_L¹d_Rysuj();
  Radar_Statki_Rysuj();


  if statek_gracza <> nil then
    begin

      Radar_GLCamera.Position.Y := Radar_GLCamera.TagFloat * Radar_Skala_SpinEdit.Value * 0.01;


      Radio_Zasiêg_GLDisk.Visible := Radar_Dane_Z_Radia_CheckBox.Checked;
      Sonar_Zasiêg_GLDisk.Visible := Radar_Dane_Z_Sonaru_CheckBox.Checked;

      Radar_Statek_GLDummyCube.AbsoluteDirection := statek_gracza.AbsoluteDirection;
      Radar_Statek_GLDummyCube.AbsolutePosition := statek_gracza.AbsolutePosition;

      Radar_PN_Linia_GLLines.AbsolutePosition := Radar_Statek_GLDummyCube.AbsolutePosition;


      Radar_Kamera_Kierunek_GLDisk.Visible := Radar_Kamera_Kierunek_Wyœwietlaj_CheckBox.Checked;

      Radar_Kamera_Kierunek_GLDummyCube.AbsoluteDirection := Gra_GLCamera.AbsoluteDirection;
      Radar_Kamera_Kierunek_GLDummyCube.Direction.Y := 0;
      Radar_Kamera_Kierunek_GLDummyCube.AbsoluteUp := VectorMake( 0, 1, 0 );

      Radar_Kamera_Kierunek_GLDisk.OuterRadius := 20.0 * Radar_Koryguj_Wielkoœæ_Obiektów();
      Radar_PN_Linia_GLLines.Scale.X := 40.0 * Radar_Koryguj_Wielkoœæ_Obiektów();

    end;
  //---//if statek_gracza <> nil then

end;//---//Radar_TimerTimer().

//Statki_Zaprezentuj_ButtonClick().
procedure TStatki_Form.Statki_Zaprezentuj_ButtonClick( Sender: TObject );
var
  i,
  zti
    : integer;
begin

  //Statki_Zwolnij(  false, Length( statki_t ) > 0  );
  Statki_Zwolnij( false, true );


  for i := 0 to Statek_ComboBox.Items.Count - 1 do
    begin

      zti := Length( statki_t );
      SetLength( statki_t, zti + 1 );
      statki_t[ zti ] := TStatek.Create(  Gra_Obiekty_GLDummyCube, Statki_Form.Gra_GLCollisionManager, zti, Statek_Odczytaj_Schemat( i ), prymitywy_lista_t  );
      statki_t[ zti ].id_grupa := 1; // Aby po odnowieniu statku (je¿eli nie trwa gra) poprawnie wczyta³o i ustawi³o statek.
      statki_t[ zti ].id_statek_schemat := i;
      statki_t[ zti ].obracaj_dzia³a := false;
      statki_t[ zti ].podnoœ_lufy := false;
      statki_t[ zti ].gracz__nazwa.Text := Statek_ComboBox.Items[ i ];
      statki_t[ zti ].Elementy_Gracza_Widocznoœæ( statki_t[ zti ].id_grupa, false );

      if i = 0 then
        statki_t[ zti ].Position.SetPoint( Statki_Zaprezentuj__Pozycja_Pocz¹tkowa__X_SpinEdit.Value, Statki_Zaprezentuj__Pozycja_Pocz¹tkowa__Y_SpinEdit.Value, Statki_Zaprezentuj__Pozycja_Pocz¹tkowa__Z_SpinEdit.Value )
      else//if i = 0 then
        if not Statki_Zaprezentuj__Kolumna_CheckBox.Checked then
          statki_t[ zti ].Position.SetPoint( statki_t[ zti - 1 ].Position.X + Statki_Zaprezentuj__Odstêpy_Miêdzy_Statkami_SpinEdit.Value, statki_t[ zti - 1 ].Position.Y, statki_t[ zti - 1 ].Position.Z )
        else//if not Statki_Zaprezentuj__Kolumna_CheckBox.Checked then
          statki_t[ zti ].Position.SetPoint( statki_t[ zti - 1 ].Position.X, statki_t[ zti - 1 ].Position.Y, statki_t[ zti - 1 ].Position.Z + Statki_Zaprezentuj__Odstêpy_Miêdzy_Statkami_SpinEdit.Value );

    end;
  //---//for i := 0 to Statek_ComboBox.Items.Count - 1 do

end;//---//Statki_Zaprezentuj_ButtonClick().

//Statki_Zaprezentuj__Zwolnij_BitBtnClick().
procedure TStatki_Form.Statki_Zaprezentuj__Zwolnij_BitBtnClick( Sender: TObject );
begin

  Statki_Zwolnij( false, true );

end;//---//Statki_Zaprezentuj__Zwolnij_BitBtnClick().

//Statki_ZaprezentujKeyDown().
procedure TStatki_Form.Statki_ZaprezentujKeyDown( Sender: TObject; var Key: Word; Shift: TShiftState );
begin

  // Enter.
  if Key = 13 then
    begin

      Key := 0;
      Statki_Zaprezentuj_ButtonClick( Sender );

    end;
  //---//if Key = 13 then

end;//---//Statki_ZaprezentujKeyDown().

//Statystyki_Wypisz_ButtonClick().
procedure TStatki_Form.Statystyki_Wypisz_ButtonClick( Sender: TObject );
begin

  if czy_klient_g then
    Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__gra__statystyki_wyœlij_c, -99, '' )
  else//if czy_klient_g then
    Gra_Statystyki_Wypisz();

  PageControl1.ActivePage := Log_TabSheet;

end;//---//Statystyki_Wypisz_ButtonClick().

//Klawiatura_Konfiguracja_Domyœlna_ButtonClick().
procedure TStatki_Form.Klawiatura_Konfiguracja__Domyœlna_ButtonClick( Sender: TObject );

  //Funkcja Klawisz_Plus_Alt_Ctrl_Shift_Zeruj_1() w Klawiatura_Konfiguracja_Domyœlna_ButtonClick().
  procedure Klawisz_Plus_Alt_Ctrl_Shift_Zeruj_1( pointer_f : Pointer );
  var
    klawiatura_konfiguracja_r_w : ^TKlawiatura_Konfiguracja_r;
  begin

    Exit;

    klawiatura_konfiguracja_r_w := pointer_f;

    klawiatura_konfiguracja_r_w.plus_alt := false;
    klawiatura_konfiguracja_r_w.plus_ctrl := false;
    klawiatura_konfiguracja_r_w.plus_shift := false;

  end;//---Funkcja Klawisz_Plus_Alt_Ctrl_Shift_Zeruj_1() w Klawiatura_Konfiguracja_Domyœlna_ButtonClick().

  //Funkcja Klawisz_Plus_Alt_Ctrl_Shift_Zeruj() w Klawiatura_Konfiguracja_Domyœlna_ButtonClick().
  procedure Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( out klawiatura_konfiguracja_r_f : TKlawiatura_Konfiguracja_r; const klawisz_f : Word; const polecenie_nazwa_f : string; out indeks_f : integer; const shift_f : TShiftState = []; const czy_mysz_f : boolean = false );
  var
    klawiatura_konfiguracja_r_w : ^TKlawiatura_Konfiguracja_r;
  begin

    inc( indeks_f );
    SetLength( klawiatura_konfiguracja_r_t, indeks_f + 1 );
    klawiatura_konfiguracja_r_f.klawisz := klawisz_f;
    klawiatura_konfiguracja_r_t[ indeks_f ] := @klawiatura_konfiguracja_r_f;
    klawiatura_konfiguracja_r_t[ indeks_f ].czy_mysz := czy_mysz_f;
    klawiatura_konfiguracja_r_t[ indeks_f ].polecenie_nazwa := polecenie_nazwa_f;
    klawiatura_konfiguracja_r_t[ indeks_f ].plus_alt := ssAlt in shift_f;
    klawiatura_konfiguracja_r_t[ indeks_f ].plus_ctrl := ssCtrl in shift_f;
    klawiatura_konfiguracja_r_t[ indeks_f ].plus_shift := ssShift in shift_f;
    TKlawisz_Konfiguracja.Create( Klawiatura_Konfiguracja_ScrollBox, klawiatura_konfiguracja_r_t[ indeks_f ] );

  end;//---Funkcja Klawisz_Plus_Alt_Ctrl_Shift_Zeruj() w Klawiatura_Konfiguracja_Domyœlna_ButtonClick().

var
  zti,
  przesuniêcie_w_pionie_kopia
    : integer;
begin//Klawiatura_Konfiguracja_Domyœlna_ButtonClick().

  przesuniêcie_w_pionie_kopia := Klawiatura_Konfiguracja_ScrollBox.VertScrollBar.Position;


  Klawisz_Konfiguracja_Zwolnij();

  SetLength( klawiatura_konfiguracja_r_t, 0 );
  zti := -1;

  //Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__, 0, '', zti ); // .

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__amunicja__zanurzenie_g³êbokoœæ_zadana__minus, 0, 'Amunicja zanurzenie g³êbokoœæ zadana minus', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__amunicja__zanurzenie_g³êbokoœæ_zadana__plus, 0, 'Amunicja zanurzenie g³êbokoœæ zadana plus', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__celowanie_tryb, 0, 'Celowanie tryb', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__celownik_widocznoœæ, 0, 'Celownik widocznoœæ', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__celownik_widocznoœæ_mouse_look_active, 0, 'Celownik widocznoœæ obracanie mysz¹', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__dalmierz, 0, 'Dalmierz', zti ); // .

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__obracaj_dzia³a, 79, 'Broñ obracaj', zti ); // O.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__obrót_k¹t_zablokowany_wskaŸnik, 0, 'Broñ  obrót k¹t zablokowany wskaŸnik', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__obrót_k¹t_zablokowany_strza³_wskaŸnik, 0, 'Broñ  obrót k¹t zablokowany strza³ wskaŸnik', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__podnoœ_lufy, 76, 'Broñ podnoœ lufy', zti ); // L.

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__gra_wspó³czynnik_prêdkoœci__minus, 0, 'Gra prêdkoœci minus', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__gra_wspó³czynnik_prêdkoœci__normalna, 0, 'Gra prêdkoœci normalna', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__gra_wspó³czynnik_prêdkoœci__plus, 0, 'Gra prêdkoœci plus', zti ); // .

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__mouse_look_active, 32, 'Kamera obracanie mysz¹ prze³¹cz', zti ); // Space.

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__w_dó³_obrót, 90, 'Kamera obrót w dó³', zti ); // Z.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__w_górê_obrót, 67, 'Kamera obrót w górê', zti ); // C.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__w_lewo_obrót, 81, 'Kamera obrót w lewo', zti ); // Q.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__w_przawo_obrót, 69, 'Kamera obrót w prawo', zti ); // E.

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__w_dó³, 70, 'Kamera ruch w dó³', zti ); // F.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__w_górê, 82, 'Kamera ruch w górê', zti ); // R.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__w_lewo, 65, 'Kamera ruch w lewo', zti ); // A.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__w_przawo, 68, 'Kamera ruch w prawo', zti ); // D.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__do_przodu, 87, 'Kamera ruch w przód', zti ); // W.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__do_ty³u, 83, 'Kamera ruch w ty³', zti ); // S.

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__Artyleria, 0, 'Kamera ustaw artyleryjska (je¿eli artyleria jest dostêpna na statku)', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__Amunicja, 0, 'Kamera ustaw na amunicjê', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__Statek, 0, 'Kamera ustaw na statek', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__Swobodna, 0, 'Kamera ustaw swobodna', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__kamera__Za_Statkiem, 0, 'Kamera ustaw za statkiem', zti ); // .

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__l¹d_odœwie¿_wskazany, 0, 'L¹d odœwie¿ wskazan¹ mapê', zti ); // .

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__opcje, VK_F1, 'Opcje', zti ); // F1.

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__pauza, 80, 'Pauza', zti ); // P.

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__pe³ny_ekran, VK_RETURN, 'Pe³ny ekran', zti, [ ssAlt, ssCtrl ] ); // Atl + Enter.

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__pokój_rozmów__informacja_dodatkowa, 0, 'Pokój rozmów wyœwietlaj dialogi na ekranie gry', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__pokój_rozmów__na_ekranie, 13, 'Pokój rozmów wyœwietlaj na ekranie gry', zti ); // Enter.

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__prêdkoœæ_zadana_procent_zmieñ__1_plus, 0, 'Prêdkoœæ do przodu +1', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__prêdkoœæ_zadana_procent_zmieñ__25_plus, 104, 'Prêdkoœæ do przodu +25', zti ); // Num8.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__prêdkoœæ_zadana_procent_zmieñ__100_plus, 0, 'Prêdkoœæ do przodu +100', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__prêdkoœæ_zadana_procent_zmieñ__1_minus, 0, 'Prêdkoœæ do ty³u +1', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__prêdkoœæ_zadana_procent_zmieñ__25_minus, 98, 'Prêdkoœæ do ty³u +25', zti ); // Num 2.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__prêdkoœæ_zadana_procent_zmieñ__100_minus, 0, 'Prêdkoœæ do ty³u +100', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__prêdkoœæ_zadana_procent_zmieñ__zero, 101, 'Prêdkoœæ zero', zti ); // Num 5.

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__punkty_¿ycia_wskaŸnik__gracz, 0, 'Punkty ¿ycia wskaŸnik gracz', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__punkty_¿ycia_wskaŸnik__przeciwnik, 0, 'Punkty ¿ycia wskaŸnik przeciwnik', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__punkty_¿ycia_wskaŸnik__sojusznik, 0, 'Punkty ¿ycia wskaŸnik sojusznik', zti ); // .

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__radar_widocznoœæ, 0, 'Radar wyœwietlaj na ekranie', zti ); // .

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__statek__utwórz, 0, 'Statek utwórz (ponownie) wskazany', zti ); // .

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__skrêt_zadany_procent_zmieñ__1_lewo, 0, 'Ster lewo +1', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__skrêt_zadany_procent_zmieñ__25_lewo, 100, 'Ster lewo +25', zti ); // Num 4.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__skrêt_zadany_procent_zmieñ__100_lewo, 0, 'Ster lewo +100', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__skrêt_zadany_procent_zmieñ__1_prawo, 0, 'Ster prawo +1', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__skrêt_zadany_procent_zmieñ__25_prawo, 102, 'Ster prawo +25', zti ); // Num 6.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__skrêt_zadany_procent_zmieñ__100_prawo, 0, 'Ster prawo +100', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__skrêt_zadany_procent_zmieñ__zero, 96, 'Ster zero', zti ); // Num 0.

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strza³_1, 0, 'Strza³ pojedynczy', zti, [], true ); // LPM.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strza³_2, VK_NUMPAD7, 'Strza³ pojedynczy (alternatywna kombinacja klawiszy)', zti ); // Num 7.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strza³__wszystkie_wybrane_1, 1, 'Strza³ z wszystkich broni wybranych typów', zti, [], true ); // PPM.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strza³__wszystkie_wybrane_2, 0, 'Strza³ z wszystkich broni wybranych typów (alternatywna kombinacja klawiszy)', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strza³__wszystkie_lufy_1, 2, 'Strza³ z wszystkich luf wskazanej broni', zti, [], true ); // SPM.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strza³__wszystkie_lufy_2, VK_NUMPAD9, 'Strza³ z wszystkich luf wskazanej broni (alternatywna kombinacja klawiszy)', zti ); // Num 9.

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strza³__broñ_indeks_zmieniaj, 0, 'Strza³ przechodŸ na kolejn¹ broñ (tego samego rodzaju) po strzale', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strza³__broñ_indeks_nastêpny, 0, 'Strza³ przejdŸ na nastêpn¹ broñ (tego samego rodzaju)', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strza³__broñ_indeks_poprzedni, 0, 'Strza³ przejdŸ na poprzedni¹ broñ (tego samego rodzaju)', zti ); // .

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strzelaj_z__artyleria, VK_F7, 'Strzelaj z artylerii ustaw', zti ); // F7.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strzelaj_z__pocisk, VK_F6, 'Strzelaj z dzia³ ustaw', zti ); // F6.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strzelaj_z__torpeda, VK_F5, 'Strzelaj z torped ustaw', zti ); // F5.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__strzelaj_z__wszystkie, VK_F8, 'Strzelaj ze wszystkiego ustaw', zti ); // F8.

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__statek__przesuniêcie_w_lewo, VK_LEFT, 'Projektowy tryb statek przesuniêcie w lewo', zti ); // Kursor w lewo.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__statek__przesuniêcie_w_prawo, VK_RIGHT, 'Projektowy tryb statek przesuniêcie w prawo', zti ); // Kursor w prawo.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__statek__przesuniêcie_w_przód, VK_UP, 'Projektowy tryb statek przesuniêcie w przód', zti ); // Kursor w górê.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__statek__przesuniêcie_w_ty³, VK_DOWN, 'Projektowy tryb statek przesuniêcie w ty³', zti ); // Kursor w dó³.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__statek__obrót_lewo, VK_DELETE, 'Projektowy tryb statek obrót lewo', zti ); // Delete.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__statek__obrót_prawo, VK_NEXT, 'Projektowy tryb statek obrót prawo', zti ); // Page Down.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__statek__przechylenie_w_lewo, VK_INSERT, 'Projektowy tryb statek przechylenie w lewo', zti ); // Insert.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__statek__przechylenie_w_prawo, VK_PRIOR, 'Projektowy tryb statek przechylenie w prawo', zti ); // Page Up.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__statek__uniesienie_przodu, VK_HOME, 'Projektowy tryb statek uniesienie przodu', zti ); // Home.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__statek__uniesienie_ty³u, VK_END, 'Projektowy tryb statek uniesienie ty³u', zti ); // End.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__statek__prêdkoœæ_zadana_0_100, 191, 'Projektowy tryb statek prêdkoœæ prze³¹cz 0%, 100%', zti ); // /.
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__statek___resetuj_obrót, 0, 'Projektowy tryb statek resetuj obrót', zti ); // .
  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__projektowy_tryb__w³¹cz_wy³¹cz, 0, 'Projektowy tryb w³¹cz wy³¹cz', zti ); // .

  Klawisz_Plus_Alt_Ctrl_Shift_Zeruj( klawisz__zamknij_program, 27, 'Zamknij program', zti ); // Esc.


  Klawiatura_Konfiguracja_ScrollBox.VertScrollBar.Position := przesuniêcie_w_pionie_kopia;

end;//---//Klawiatura_Konfiguracja_Domyœlna_ButtonClick().

//Klawiatura_Konfiguracja__Wczytaj_ButtonClick().
procedure TStatki_Form.Klawiatura_Konfiguracja__Wczytaj_ButtonClick( Sender: TObject );
var
  i,
  j
    : integer;
  czy_b³¹d,
  komunikaty_pomiñ
    : boolean;
  zts_1,
  zts_2,
  komunikat_treœæ
    : string;
  plik_tekstowy : TextFile;
  zt_klawiatura_konfiguracja_r : TKlawiatura_Konfiguracja_r;
begin

  if    ( Sender <> nil )
    and ( TComponent(Sender).Name = Klawiatura_Konfiguracja__Przyciski_Panel.Name ) then
    begin

      // Pomija pytanie.

      komunikaty_pomiñ := true;

    end
  else//if    ( Sender <> nil ) (...)
    begin

      komunikaty_pomiñ := false;

      if Application.MessageBox( 'Czy wczytaæ konfiguracjê klawiszy?', 'Potwierdzenie', MB_YESNO + MB_DEFBUTTON2 + MB_ICONQUESTION ) = IDNO then
        Exit;

    end;
  //---//if    ( Sender <> nil ) (...)


  zts_1 := ExtractFilePath( Application.ExeName ) + 'Klawiatura konfiguracja ' + Trim(  FormatFloat( '000', Klawiatura_Konfiguracja__Konfiguracja_Numer_SpinEdit.Value )  ) + '.txt';

  if not FileExists( zts_1 ) then
    begin

      komunikat_treœæ := 'Nie odnaleziono pliku konfiguracji klawiszy (' + zts_1 + ').';

      if not komunikaty_pomiñ then
        Application.MessageBox( PChar(komunikat_treœæ), 'Informacja', MB_OK + MB_ICONEXCLAMATION )
      else//if not komunikaty_pomiñ then
        Log_Wypisz( komunikat_treœæ );

      Exit;

    end;
  //---//if not FileExists( zts_1 ) then


  komunikat_treœæ := '';


  AssignFile( plik_tekstowy, zts_1 );

  Reset( plik_tekstowy );

  while not Eof( plik_tekstowy ) do
    begin

      czy_b³¹d := false;


      Readln( plik_tekstowy, zts_1 ); // Czyta ca³¹ liniê.

      {$region 'Odczytuje wartoœci z tekstu.'}
      i := Pos( ';', zts_1 );

      if i > 0 then
        begin

          zts_2 := Copy( zts_1, 1, i - 1 );
          Delete( zts_1, 1, i );

          try
            i := StrToInt( zts_2 );
          except
            komunikat_treœæ := komunikat_treœæ + #13 + #10 + 'b³êdny kod klawisza (' + zts_2 + ')';
          end;
          //---//try

          if   ( i < 0 )
            or (  i > High( word )  ) then
            begin

              czy_b³¹d := true;
              komunikat_treœæ := komunikat_treœæ + #13 + #10 + 'b³êdny zakres kodu klawisza (' + zts_2 + ')';

            end
          else//if   ( i < 0 ) (...)
            zt_klawiatura_konfiguracja_r.klawisz := i;

        end
      else//if i > 0 then
        begin

          czy_b³¹d := true;
          komunikat_treœæ := komunikat_treœæ + #13 + #10 + 'brak kodu klawisza';

        end;
      //---//if i > 0 then


      i := Pos( ';', zts_1 );

      if i > 0 then
        begin

          zts_2 := Copy( zts_1, 1, i - 1 );
          Delete( zts_1, 1, i );
          zt_klawiatura_konfiguracja_r.czy_mysz := zts_2 = 'mysz';

        end
      else//if i > 0 then
        begin

          czy_b³¹d := true;
          komunikat_treœæ := komunikat_treœæ + #13 + #10 + 'brak rodzaju klawisza';

        end;
      //---//if i > 0 then


      i := Pos( ';', zts_1 );

      if i > 0 then
        begin

          zts_2 := Copy( zts_1, 1, i - 1 );
          Delete( zts_1, 1, i );
          zt_klawiatura_konfiguracja_r.plus_alt := zts_2 = 'alt';

        end
      else//if i > 0 then
        begin

          //czy_b³¹d := true;
          komunikat_treœæ := komunikat_treœæ + #13 + #10 + 'brak parametru - klawisz alt';

        end;
      //---//if i > 0 then


      i := Pos( ';', zts_1 );

      if i > 0 then
        begin

          zts_2 := Copy( zts_1, 1, i - 1 );
          Delete( zts_1, 1, i );
          zt_klawiatura_konfiguracja_r.plus_ctrl := zts_2 = 'ctrl';

        end
      else//if i > 0 then
        begin

          //czy_b³¹d := true;
          komunikat_treœæ := komunikat_treœæ + #13 + #10 + 'brak parametru - klawisz ctrl';

        end;
      //---//if i > 0 then


      i := Pos( ';', zts_1 );

      if i > 0 then
        begin

          zts_2 := Copy( zts_1, 1, i - 1 );
          Delete( zts_1, 1, i );
          zt_klawiatura_konfiguracja_r.plus_shift := zts_2 = 'shift';

        end
      else//if i > 0 then
        begin

          //czy_b³¹d := true;
          komunikat_treœæ := komunikat_treœæ + #13 + #10 + 'brak parametru - klawisz shift';

        end;
      //---//if i > 0 then


      i := Pos( ';', zts_1 );

      if i > 0 then
        begin

          zts_2 := Copy( zts_1, 1, i - 1 );
          Delete( zts_1, 1, i );
          zt_klawiatura_konfiguracja_r.polecenie_nazwa := zts_2;

        end
      else//if i > 0 then
        begin

          //czy_b³¹d := true;
          zt_klawiatura_konfiguracja_r.polecenie_nazwa := zts_1;
          komunikat_treœæ := komunikat_treœæ + #13 + #10 + 'brak nazwy funkcjonalnoœci';

        end;
      //---//if i > 0 then
      {$endregion 'Odczytuje wartoœci z tekstu.'}

      if not czy_b³¹d then
        begin

          zts_2 := '?';

          for i := 0 to Length( klawiatura_konfiguracja_r_t ) - 1 do
            if klawiatura_konfiguracja_r_t[ i ].polecenie_nazwa = zt_klawiatura_konfiguracja_r.polecenie_nazwa then
              begin

                klawiatura_konfiguracja_r_t[ i ].klawisz := zt_klawiatura_konfiguracja_r.klawisz;
                klawiatura_konfiguracja_r_t[ i ].czy_mysz := zt_klawiatura_konfiguracja_r.czy_mysz;
                klawiatura_konfiguracja_r_t[ i ].plus_alt := zt_klawiatura_konfiguracja_r.plus_alt;
                klawiatura_konfiguracja_r_t[ i ].plus_ctrl := zt_klawiatura_konfiguracja_r.plus_ctrl;
                klawiatura_konfiguracja_r_t[ i ].plus_shift := zt_klawiatura_konfiguracja_r.plus_shift;

                zts_2 := '';


                for j := 0 to Klawiatura_Konfiguracja_ScrollBox.ControlCount - 1 do
                  if    ( Klawiatura_Konfiguracja_ScrollBox.Controls[ j ] is TKlawisz_Konfiguracja )
                    and ( TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.polecenie_nazwa = klawiatura_konfiguracja_r_t[ i ].polecenie_nazwa ) then
                    begin

                      zt_klawiatura_konfiguracja_r.klawisz := TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.klawisz;

                      TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).Czy_Mysz_CheckBox.Checked := TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.czy_mysz;
                      TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).Plus_Alt_CheckBox.Checked := TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.plus_alt;
                      TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).Plus_Ctrl_CheckBox.Checked := TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.plus_ctrl;
                      TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).Plus_Shift_CheckBox.Checked := TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.plus_shift;

                      // Dodatkowe sprawdzenie (nie powinny zmieniæ siê te wartoœci).
                      if TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.mysz_niezdefiniowana then
                        TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.mysz_niezdefiniowana := false;

                      if TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.klawisz <> zt_klawiatura_konfiguracja_r.klawisz then
                        TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.klawisz := zt_klawiatura_konfiguracja_r.klawisz;
                      //---// Dodatkowe sprawdzenie (nie powinny zmieniæ siê te wartoœci).

                      TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).Nazwa_Klawisza();


                      TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).Polecenie_Nazwa_Label.Font.Color := clWindowText; // Ustawia domyœlny kolor.

                      Break;

                    end;
                  //---//if Klawiatura_Konfiguracja_ScrollBox.Controls[ j ] is TKlawisz_Konfiguracja then

                Break;

              end;
            //---//if klawiatura_konfiguracja_r_t[ i ].polecenie_nazwa = zt_klawiatura_konfiguracja_r.polecenie_nazwa then


          if zts_2 <> '' then
            komunikat_treœæ := komunikat_treœæ + #13 + #10 + 'wczytana konfiguracja klawiszy zawiera nieznane definicje funkcjonalnoœci (' + zt_klawiatura_konfiguracja_r.polecenie_nazwa + ')';

        end;
      //---//if not czy_b³¹d then

    end;
  //---//while not Eof( plik_tekstowy ) do

  CloseFile( plik_tekstowy );



  if komunikat_treœæ <> '' then
    begin

      komunikat_treœæ := 'Pojawi³y siê nastêpuj¹ce b³êdy podczas wczytywania konfiguracji klawiszy:' + #13 + #10 + komunikat_treœæ + '.';

      Log_Wypisz( komunikat_treœæ, false );

      if not komunikaty_pomiñ then
        ShowMessage( komunikat_treœæ );

    end;
  //---//if komunikat_treœæ <> '' then

end;//---//Klawiatura_Konfiguracja__Wczytaj_ButtonClick().

//Klawiatura_Konfiguracja__Zapisz_ButtonClick().
procedure TStatki_Form.Klawiatura_Konfiguracja__Zapisz_ButtonClick( Sender: TObject );
var
  i : integer;
  zts : string;
  plik_tekstowy : TextFile;
begin

  if Application.MessageBox( 'Czy zapisaæ konfiguracjê klawiszy?', 'Potwierdzenie', MB_YESNO + MB_DEFBUTTON2 + MB_ICONQUESTION ) = IDNO then
    Exit;


  zts := ExtractFilePath( Application.ExeName ) + 'Klawiatura konfiguracja ' + Trim(  FormatFloat( '000', Klawiatura_Konfiguracja__Konfiguracja_Numer_SpinEdit.Value )  ) + '.txt';

  AssignFile( plik_tekstowy, zts );

  Rewrite( plik_tekstowy ); // Czyœci. Nie odczyta zablokowanego pliku.


  for i := 0 to Length( klawiatura_konfiguracja_r_t ) - 1 do
    begin

      zts := IntToStr( klawiatura_konfiguracja_r_t[ i ].klawisz ) + ';';

      if klawiatura_konfiguracja_r_t[ i ].czy_mysz then
        zts := zts + 'mysz;'
      else//if klawiatura_konfiguracja_r_t[ i ].czy_mysz then
        zts := zts + 'klawisz;';

      if klawiatura_konfiguracja_r_t[ i ].plus_alt then
        zts := zts + 'alt;'
      else//if klawiatura_konfiguracja_r_t[ i ].plus_alt then
        zts := zts + ';';

      if klawiatura_konfiguracja_r_t[ i ].plus_ctrl then
        zts := zts + 'ctrl;'
      else//if klawiatura_konfiguracja_r_t[ i ].plus_ctrl then
        zts := zts + ';';

      if klawiatura_konfiguracja_r_t[ i ].plus_shift then
        zts := zts + 'shift;'
      else//if klawiatura_konfiguracja_r_t[ i ].plus_shift then
        zts := zts + ';';

      zts := zts + klawiatura_konfiguracja_r_t[ i ].polecenie_nazwa + ';';

      Writeln( plik_tekstowy, zts );

    end;
  //---//for i := 0 to Length( klawiatura_konfiguracja_r_t ) - 1 do


  CloseFile( plik_tekstowy ); // Dopiero po zamkniêciu zapisuje zmiany.

end;//---//Klawiatura_Konfiguracja__Zapisz_ButtonClick().

//Klawiatura_Konfiguracja__Niepowtarzalnoœæ_SprawdŸ_ButtonClick().
procedure TStatki_Form.Klawiatura_Konfiguracja__Niepowtarzalnoœæ_SprawdŸ_ButtonClick( Sender: TObject );
var
  i,
  j
    : integer;
  komunikat_treœæ : string;
  zt_klawiatura_konfiguracja_r : TKlawiatura_Konfiguracja_r;
begin

  komunikat_treœæ := '';


  for i := 0 to Klawiatura_Konfiguracja_ScrollBox.ControlCount - 1 do // Tylko wizualne.
    TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).Polecenie_Nazwa_Label.Font.Color := clWindowText; // Ustawia domyœlny kolor.


  for i := 0 to Klawiatura_Konfiguracja_ScrollBox.ControlCount - 1 do // Tylko wizualne.
    begin

      if TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).klawiatura_konfiguracja_r_w.mysz_niezdefiniowana then
        begin

          komunikat_treœæ := komunikat_treœæ + #13 + #10 + TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).klawiatura_konfiguracja_r_w.polecenie_nazwa
            + ' - niepe³na definicja';

          TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).Polecenie_Nazwa_Label.Font.Color := clMaroon;

        end;
      //---//if TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).klawiatura_konfiguracja_r_w.mysz_niezdefiniowana then


      zt_klawiatura_konfiguracja_r.klawisz := TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).klawiatura_konfiguracja_r_w.klawisz;
      zt_klawiatura_konfiguracja_r.czy_mysz := TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).klawiatura_konfiguracja_r_w.czy_mysz;
      zt_klawiatura_konfiguracja_r.plus_alt := TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).klawiatura_konfiguracja_r_w.plus_alt;
      zt_klawiatura_konfiguracja_r.plus_ctrl := TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).klawiatura_konfiguracja_r_w.plus_ctrl;
      zt_klawiatura_konfiguracja_r.plus_shift := TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).klawiatura_konfiguracja_r_w.plus_shift;


      if    ( zt_klawiatura_konfiguracja_r.klawisz = 0 )
        and ( not zt_klawiatura_konfiguracja_r.czy_mysz )
        and (
                 ( zt_klawiatura_konfiguracja_r.plus_alt )
              or ( zt_klawiatura_konfiguracja_r.plus_ctrl )
              or ( zt_klawiatura_konfiguracja_r.plus_shift )
            ) then
        begin

          komunikat_treœæ := komunikat_treœæ + #13 + #10 + TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).klawiatura_konfiguracja_r_w.polecenie_nazwa
            + ' - niepoprawna definicja';

          TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).Polecenie_Nazwa_Label.Font.Color := clMaroon;

        end;
      //---//if    ( zt_klawiatura_konfiguracja_r.klawisz = 0 ) (...)


      if    ( zt_klawiatura_konfiguracja_r.klawisz = 0 )
        and ( not zt_klawiatura_konfiguracja_r.czy_mysz ) then
        // Brak definicji (nie sprawdzane) [Niezdefiniowane].
      else//if    ( zt_klawiatura_konfiguracja_r.klawisz = 0 ) (...)
        for j := i + 1 to Klawiatura_Konfiguracja_ScrollBox.ControlCount - 1 do // Tylko wizualne.
          begin

            if    ( zt_klawiatura_konfiguracja_r.klawisz = TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.klawisz )
              and ( zt_klawiatura_konfiguracja_r.czy_mysz = TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.czy_mysz )
              and ( zt_klawiatura_konfiguracja_r.plus_alt = TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.plus_alt )
              and ( zt_klawiatura_konfiguracja_r.plus_ctrl = TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.plus_ctrl )
              and ( zt_klawiatura_konfiguracja_r.plus_shift = TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.plus_shift ) then
              begin

                komunikat_treœæ := komunikat_treœæ + #13 + #10 +
                    TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).klawiatura_konfiguracja_r_w.polecenie_nazwa
                  + ' i ' + TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.polecenie_nazwa
                  + ' - powielona definicja';

                TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ i ]).Polecenie_Nazwa_Label.Font.Color := clRed;
                TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).Polecenie_Nazwa_Label.Font.Color := clRed;

              end;
            //---//if    ( zt_klawiatura_konfiguracja_r.klawisz = TKlawisz_Konfiguracja(Klawiatura_Konfiguracja_ScrollBox.Controls[ j ]).klawiatura_konfiguracja_r_w.klawisz ) (...)

          end;
        //---//for j := i + 1 to Klawiatura_Konfiguracja_ScrollBox.ControlCount - 1 do

    end;
  //---//for i := 0 to Klawiatura_Konfiguracja_ScrollBox.ControlCount - 1 do


  if komunikat_treœæ <> '' then
    begin

      komunikat_treœæ := 'Wykryto nastêpuj¹ce niezgodnoœci konfiguracji klawiszy:' + #13 + #10 + komunikat_treœæ + '.';

      Log_Wypisz( komunikat_treœæ, false );

      ShowMessage( komunikat_treœæ );

    end
  else//if komunikat_treœæ <> '' then
    Application.MessageBox( 'Nie wykryto niezgodnoœci konfiguracji klawiszy.', 'Informacja', MB_OK + MB_ICONINFORMATION );

end;//---//Klawiatura_Konfiguracja__Niepowtarzalnoœæ_SprawdŸ_ButtonClick().

procedure TStatki_Form.Button1Click(Sender: TObject);
var
  i : integer;
  zt_id_socket_handle : TIdSocketHandle;
begin

  // Do testów.



  Exit;


  //if Length( statki_t ) < 2 then
    begin

      Wieloosobowe__Pod³¹cz_BitBtnClick( Sender );

      Gracz_Nazwa_Edit.Text := 's';
      Gracz_Gotowoœæ_BitBtnClick( Gracz_Gotowoœæ_Tak_BitBtn );

      SI__Nazwa_Edit.Text := '1';
      SI__Statek_ComboBox.ItemIndex := 1;
      SI__Dodaj_BitBtnClick( Sender );

      SI__Nazwa_Edit.Text := '2';
      SI__Statek_ComboBox.ItemIndex := 6;
      SI__Dodaj_BitBtnClick( Sender );

      Gra_Rozpocznij_BitBtnClick( Sender );

    end;
  //---//


//  statki_t[ 1 ].celownicza_linia.Nodes[ 1 ].X := statki_t[ 1 ].celownicza_linia.Nodes[ 1 ].X + 1;
//  statki_t[ 1 ].celownicza_linia.Nodes[ 1 ].Y := statki_t[ 1 ].celownicza_linia.Nodes[ 1 ].Y + 1;
//  statki_t[ 1 ].celownicza_linia.Nodes[ 1 ].Z := statki_t[ 1 ].celownicza_linia.Nodes[ 1 ].Z + 1;



//  Statki_Rozstaw( nil );

//  statki_t[ 0 ].Position.Z := -2;
//  statki_t[ 1 ].Position.Z := 5;
//
//  statki_t[ 2 ].Position.Z := 10;
//  statki_t[ 3 ].Position.Z := 17;


  //Wieloosobowe_Identyfikator_Edit.Text := '1';

  //Serwer_Wysy³a_TimerTimer( Sender );
  //Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_2_r_c, -99, '' );


  Exit;

  if statek_gracza <> nil then
    ShowMessage(  statek_gracza.Parametry_Odczytaj( 1 = 1 ) );


  if czy_serwer_g then
    begin

      if not IdUDPServer1.Active then
        begin

          //??? Sprawdziæ gotowoœc graczy.

          IdUDPServer1.DefaultPort := Serwer_Port_SpinEdit.Value;

          IdUDPServer1.Bindings.Clear();

          zt_id_socket_handle := IdUDPServer1.Bindings.Add();
          zt_id_socket_handle.IP := '0.0.0.0';
          zt_id_socket_handle.Port := Serwer_Port_SpinEdit.Value;


          IdUDPServer1.Active := true;

        end;
      //---//if czy_serwer_g then

      Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__odbierz__rekord_amunicja_c, -99, '', true );
      //Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__odbierz__rekord_statki_c, -99, '', true );

    end;
  //---//if czy_serwer_g then


  if czy_klient_g then
    begin

      if IdTCPClient1.Connected then
        Caption := 'P'
      else
        Caption := 'X';


      if not IdUDPClient1.Connected then
        begin

          Elementy_Gry_Zwolnij();


          IdUDPClient1.Host := Serwer_Adres_IP_Edit.Text;
          IdUDPClient1.Port := Serwer_Port_SpinEdit.Value;
          IdUDPClient1.ReceiveTimeout := 5; //???


          if not IdUDPClient1.Connected then
            IdUDPClient1.Connect();

        end;
      //---//

      Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__udp__klient_po³¹czony_nadal_c, -99, '', true );
      Klient_IdUDP_Czyta_TimerTimer( Sender );

    end;
  //---//

  //Gracze_Lista_Roz³¹cz( -99 );


  //Gracze_Lista_Odœwie¿();
  //Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__gracz_lista_odœwie¿_c, -99, '' );

  Exit;

  Statki_Form.Caption := 'na';



//  L¹d_Zwolnij();
//  L¹d_Odczytaj_Z_Pliku( 'l¹d 03.xml' );
//  L¹d_Utwórz();


//  Amunicja_Wystrzelona_Zwolnij_Wszystkie();
//
//  amunicja_wystrzelona_list.Clear();


//  if statek_gracza.prêdkoœæ_procent <> 0 then
//    begin
//
//      statek_gracza.prêdkoœæ_procent := 0;
//      statki_t[ 1 ].prêdkoœæ_procent := 0;
//
//    end
//  else//if statek_gracza.prêdkoœæ_procent <> 0 then
//    begin
//
//      statek_gracza.prêdkoœæ_procent := 90;
//      statki_t[ 1 ].prêdkoœæ_procent := 60;
//
//    end;
//  //---//if statek_gracza.prêdkoœæ_procent <> 0 then
//
//  statek_gracza.prêdkoœæ_zadana_procent := statek_gracza.prêdkoœæ_procent;
//  statki_t[ 1 ].prêdkoœæ_zadana_procent := statki_t[ 1 ].prêdkoœæ_procent;


//Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_L¹d, 0, 1, 0, nil, -1, -1 );
//Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_Statek, 0, 5, 0, nil, -1, -1 );
//Trafienia_Efekt_Utwórz_Jeden( Gra_Obiekty_GLDummyCube, er_Trafienie_Woda, 0, 10, 0, nil, -1, -1 );
//Trafienia_Efekt_Utwórz_Jeden( statki_t[ 0 ], 0, 1, 0 );
//Statek_Przywróæ_Do_Gry( statki_t[ 0 ] );
//   GLPlane1.MoveFirst();
//  Exit;
//Trafienia_Efekt_Zwolnij_Wszystkie();
//statki_t[ 1 ].czy_usun¹æ_statek := true;
//  Exit;
//
//  if statki_t[ 0 ] <> nil then
//    FreeAndNil( statki_t[ 0 ] )
//  else
//    statki_t[ 0 ] := TStatek.Create( Gra_Obiekty_GLDummyCube, Statki_Form.Gra_GLCollisionManager, 0, '', prymitywy_lista_t );
//
//  statek_gracza := statki_t[ 0 ];

//  for i := amunicja_wystrzelona_list.Count - 1 downto 0 do
//    begin
//
//      //TAmunicja(amunicja_wystrzelona_list[ i ]).Position
//      TAmunicja(amunicja_wystrzelona_list[ i ]).Free();
//      amunicja_wystrzelona_list.Delete( i );
//
//    end;
//  //---//for i := amunicja_wystrzelona_list.Count - 1 downto 0 do
//
//Exit;
//  //Statek_Przywróæ_Do_Gry( statek_gracza );
//  Statek_Przywróæ_Do_Gry( statki_t[ 1 ] );
//  Statek_Przywróæ_Do_Gry( statki_t[ 2 ] );
//  Statek_Przywróæ_Do_Gry( statki_t[ 3 ] );
//  Statek_Przywróæ_Do_Gry( statki_t[ 0 ] );
  //statek_gracza.SetAbsoluteDirection( 0, 1, 0 );

  Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__odbierz__l¹d_definicja_c, -99, '' );


  //Wieloosobowe__Tekst_Wyœlij(  DateTimeToStr( Now() )  );
  Wieloosobowe__Tekst_Wyœlij_UDP(  DateTimeToStr( Now() )  );

  //Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__odbierz__rekord_amunicja_c, -99, '', true );
  //Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__odbierz__rekord_statki_c, -99, '', true );
  Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__odbierz__rekord_efekt_c, -99, '', true );

  //Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__odbierz__rekord_komunikacja_rekord_testowy_r_c, -99, '' );
  //Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__statek__klawisze_obs³uga_c, -99, '' );
  //Wieloosobowe__Tekst_Wyœlij( wieloosobowe__komenda__serwer_wy³¹cza_siê_c, -99, '' );
  //Exit;

  pokój_rozmów_r.wiadomoœæ := DateTimeToStr( Now() );
  Wieloosobowe__Strumieñ_Wyœlij( wieloosobowe__komenda__odbierz__rekord_pokój_rozmów_r_c, -99, '' );
  Log_Memo.Lines.Add(  IntToStr( pokój_rozmów_r.id_odbiorca ) + ' ' + DateTimeToStr( Now() )   );

end;

end.

{

...

Edit1KeyDown

Nie wykrywa
  Tab
  PrtScr
  przyciski myszy


Ctrl, Shift, Alt, Win, - nie rozró¿nia strony
Tab, Win, Alt, Menu myszy * wywo³uja w³asne kacje

***

Gra_GLSceneViewerMouseDown
  Statek_Klawisze_Obs³uga()
  Klawisze_Obs³uga_Zachowanie_Ci¹g³e();
    if Projektowy_Tryb_CheckBox.Checked then


Gra_GLSceneViewerKeyDown
  if czy_pauza_g then Klawisze_Obs³uga_Zachowanie_Ci¹g³e()
  Statek_Klawisze_Obs³uga()
    Key : Word
    if Key = Ord( 'P' ) then
      VK_ESCAPE
      VK_SPACE
      Ord( 'P' )

Gra_GLCadencerProgress
  Klawisze_Obs³uga_Zachowanie_Ci¹g³e()

Wieloosobowe__Odczytaj
  Statek_Klawisze_Obs³uga()



TStatki_Form.Klawisze_Obs³uga_Zachowanie_Ci¹g³e( d : double );
  kamera ruch
//testy
  if   IsKeyDown( 'W' )
    or IsKeyDown( 'z' ) then
  moment_wciœniêcia_klawisza := Now();
  if Gra_GLSceneViewer.Focused then
  if Projektowy_Tryb_CheckBox.Checked then
  VK_LEFT

TStatki_Form.Statek_Klawisze_Obs³uga( const id_statek_f : integer; const klawisz_f : Word; const shift_f : TShiftState; const mysz_przycisk_f : SmallInt );
  if klawisz_f = Ord( 'O' ) then
  if klawisz_f = VK_NUMPAD8 then
  if ( ssShift in shift_f ) then
  mysz_przycisk_f

}
